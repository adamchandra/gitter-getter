                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T14:04:40.217Z
Здравствуйте

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T14:10:24.007Z
👋🏾

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T14:10:55.359Z
I wanted to call the library “

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T14:11:15.357Z
Ugh.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T14:11:26.666Z
`plugins.sbt` pulls in `"org.kohsuke" % "github-api" % "1.59"`  which has an alarming number of dependencies. Is it being used or is this an artifact from the original slamdata build?

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T14:11:36.754Z
матрёшка”, but even I can't type that easily.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T14:12:02.822Z
I think that's not necessary.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T14:12:38.169Z
I only noticed because I'm on the plane home and it was taking a while.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T14:15:43.792Z
I still have more of the stuff to support your use cases to commit, meant to get it in last night, but forgot my power cord at the conference. Stole one from my brother this morning, though.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T14:17:12.192Z
Are you talking about matryosha at LambdaConf?

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T14:17:38.027Z
```scala
scala> val матрёшка = 42
матрёшка: Int = 42
```

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T14:17:51.812Z
Heh, it would have worked too. 

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T14:18:00.706Z
Well, I’m going to submit a talk about it to the Typelevel summit. And I’m doing a recursion-schemes-in-haskell workshop.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T14:20:02.993Z
Ok cool. I'm going to get my stuff working with matryoshka and give it a shout-out next time I do that talk.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T14:21:58.093Z
I translated some of the stuff from your talk: https://gist.github.com/sellout/b29f1aec33bb841df109 (but again, it requires not-yet-committed changes).

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T14:22:35.129Z
oh sweet

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T14:25:09.528Z
I really appreciate your help and encouragement on this, by the way.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T14:25:20.333Z
As someone (forget who 😕) pointed out in my unsession, you can `.embed` with `Cofree[F, A]` if the `A` has a monoid. Which is what lets the `convertTo` line work, but haven’t committed that, so currently only the `cata` line above it works.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T14:25:43.759Z
oh right, ok

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T14:25:45.367Z
@tpolecat I really appreciate that I’m not the only one actually playing in this space!

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T14:26:01.247Z
Right!

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T14:55:23.940Z
@tpolecat If you clone sellout/matryoshka (rather than slamdata), the “doobied” branch should have everything you need.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T14:56:40.780Z
I’ll get a PR in soon.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T14:56:52.699Z
soon = in a few days :D

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T14:56:53.714Z
rock on, thanks! 

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T14:57:27.039Z
I was trying to figure out how to express this in terms of the slamdata head and wasn't seeing it.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T15:04:55.392Z
I'm not seeing the `.cata` syntax, and the type of `Recursive[Fix].cata` doesn't seem to be what I want. Trying to go `Fix[F] => Cofree[F, Unit]`.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T15:05:32.103Z
It wants `F[A] => A` which I can't provide for `ProfF`.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T15:05:51.456Z
I might be reading it wrong.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T15:06:31.856Z
Well, `Cofree((), _)` is `F[Cofree[F, Unit]] => Cofree[F, Unit]`, but wait …

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T15:06:52.279Z
You can actually go directly `Fix[F] => Cofree[F, Int]`

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T15:07:33.096Z
Yeah, I was just trying baby steps.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T15:07:49.428Z
Oh, sorry. Yeah.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T15:08:06.763Z
I think I'm reading it wrong. `A` is going to be the cofree.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T15:08:12.775Z
Right, exactly.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T15:09:59.404Z
The `.cata` syntax … oh, right … so, I still have to fix imports and stuff. Right now you need to explicitly `import matryoshka.Recursive.ops._`, because I haven’t done anything to organize the ops generated by Simulacrum.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T15:10:46.482Z
oh ok, i haven't used simulacrum before

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T15:11:11.673Z
That should be the only one you need, though … most of the other ops are manually created and the implicit conversions are directly in the matryoshka package.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T15:11:40.106Z
Eventually something like `import matryoshka.syntax._` will get you all the ops, like in Cats.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T15:11:53.168Z
right right

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T15:12:00.765Z
works. this is so badass

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T15:12:08.909Z
💃🏽

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T15:15:58.072Z
It does require a type arg, which may be unavoidable.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T15:16:17.364Z
```scala
p.cata[Cofree[ProfF, Unit]](Cofree((), _))
```

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T15:17:22.984Z
Actually we may be able to fix that with an unapply. I'll give it a try.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T15:20:47.488Z
`p.cata(Cofree[ProfF, Unit]((), _))` should work, too, right?

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T15:20:58.575Z
eliminates one `Cofree`.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T15:21:13.690Z
ah maybe

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T15:22:27.018Z
`p.convertTo[Cofree[?[_], Unit]]` _should_ work, but that might actually have trouble finding the right implicit?

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T15:25:25.674Z
Yeah that works. Type args on `Cofree` don't work.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T15:25:31.791Z
```scala
    val p0 = Recursive[Fix].cata[ProfF, Cofree[ProfF, Unit]](p)(Cofree((), _))
    val p1 = p.cata[Cofree[ProfF, Unit]](Cofree((), _))
    val p2 = p.convertTo[Cofree[?[_], Unit]]
```

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T15:26:22.930Z
So all of those are ok.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T15:28:04.053Z
Cool, so yeah, we need like cataU, etc. to handle things with a `[?[_], A]` shape automatically, right?

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T15:37:42.786Z
I tried it for a minute and it didn't look like it would work the way it's written because you need the `F` immediately, so maybe with the partially applied trick.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T15:43:51.912Z
If you want to open an issue and assign it to me I can put on my weeine hat and see what I can do.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T15:45:07.327Z
I think I'm too wrecked to cope with `Unapply` today though ;-)

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T15:45:21.221Z
Hahaha – yeah, understood.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T15:45:48.716Z
I’ll open an issue, but out of curiosity, _can_ you open an issue / assign it? Or do you have to be a member of the org to do so?

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T15:46:08.355Z
Seems like anyone should be able to open one. Just want to make sure I don’t have any settings that need changing.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T15:46:27.786Z
Oh, dunno. An `@` mention works.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T15:48:00.114Z
*sigh* … too many chat clients. I got all of my services into one, but now we have a new generation of proprietary protocols.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-09T01:01:08.751Z
If Scala Exercises ends up not being ready for prime time I'm happy to help you get set up with tut. Not much to it really.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-09T01:01:31.969Z
I think Scala Exercises or something like it might subsume tut at some point though. It's really promising.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-09T03:23:42.424Z
Yep, I'm planning to use tut for the docs. I have a backlog of changes to get merged first (including the stuff for Doobie).

                                                                                                                                                      Greg Pfeil @sellout@2016-03-09T21:10:46.555Z
@tpolecat The changes for Doobie are released in v0.4.0.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-09T21:42:12.949Z
Rock on, thanks! Did you publish it anywhere or should I just build locally?

                                                                                                                                                      Greg Pfeil @sellout@2016-03-09T21:42:32.654Z
It’s on sonatype … oh, I should add that to the README :D

                                                                                                                                                      Greg Pfeil @sellout@2016-03-09T21:43:03.154Z
"com.slamdata" %% "matryoshka-core" % "0.4.0"

                                                                                                                                                      Rob Norris @tpolecat@2016-03-09T21:43:08.836Z
\o/

                                                                                                                                                      Greg Pfeil @sellout@2016-03-13T15:48:02.308Z
If anyone *cough* @tpolecat *cough* wants to comment on the crazy Scala tricks in #13, that’d be great.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-13T18:17:32.663Z
this is some crazy computer shit right here

                                                                                                                                                      Rob Norris @tpolecat@2016-03-13T18:18:45.653Z
you're generalizing generalizations of things i don't understand to begin with, but i'll take a look

                                                                                                                                                      Greg Pfeil @sellout@2016-03-13T18:55:46.684Z
@tpolecat Yeah, but I'm guessing you're more familiar with how to convince Scala of things in general.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-13T19:08:29.449Z
Also, I need to add _tons_ of docs, so questions help, too :D

                                                                                                                                                      Rob Norris @tpolecat@2016-03-13T19:21:49.014Z
@sellout your `version.sbt` is sitting on the next version rather that `-SNAPSHOT` which makes it a little harder to `publish-local` … not a big deal but slightly unusual

                                                                                                                                                      Greg Pfeil @sellout@2016-03-13T19:23:01.669Z
@tpolecat Oh, we’re trying to do continuous delivery. Every merge into master is a new release. So we don’t bother to go back to SNAPSHOT in between. Did you just manually edit version.sbt for publish-local?

                                                                                                                                                      Rob Norris @tpolecat@2016-03-13T19:23:38.139Z
Ok, gotcha.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-13T19:23:46.852Z
Yeah I just manually change it.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-13T19:25:50.094Z
So, I’m open to better ways to manage what we’re doing. I didn’t really find anything on doing continuous delivery in Scala. Everything is very open to input 😄

                                                                                                                                                      Rob Norris @tpolecat@2016-03-13T19:29:04.387Z
I have never done continuous delivery so I have no idea. The verizon boys do continuous delivery but they do have snapshots so their CI system must roll the version.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-13T19:30:07.534Z
Stylistic question … we make pretty much everything available both with and without `ops`, which is easy with @typeclass. But how bad is it to make certain things kind of _only_ available in `ops` style?

                                                                                                                                                      Greg Pfeil @sellout@2016-03-13T19:31:46.685Z
E.g., there are methods `hylo` and `chrono`which are just specializations of `ghylo` (and specializing it makes inference better, eliminates some parameters, etc.). But it would be nice to only define `hylo` and `chrono` in `IdOps`, and not making them available via the package object. But will users hate me?

                                                                                                                                                      Greg Pfeil @sellout@2016-03-13T19:32:19.251Z
If you don’t use `ops` style, you could still call `ghylo` directly, it’s just noisier.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-13T19:33:47.192Z
I think there's some wiggle room for trivial variations that exist only in syntax.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-13T19:34:03.411Z
You might be able to find people who would object loudly but seems ok to me.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-13T19:34:21.006Z
Cool. I always like maintaining less code.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-13T19:37:42.161Z
Also I have to tell you I'm irritated at your  `cofreeShow[F[_], A: Show](implicit F: (Show ~> λ[α => Show[F[α]]]))` because it took me a really long time to figure out how to encode that in Scala and yours is better than mine.


                                                                                                                                                      Rob Norris @tpolecat@2016-03-13T19:37:48.613Z
;-)

                                                                                                                                                      Greg Pfeil @sellout@2016-03-13T19:39:41.777Z
Heh, I came up with that after the first time I spoke about recursion schemes (internally at SlamData), and I was trying to explain the structure to people unfamiliar with Cofree. Of course, it’s a bad Show instance, because you couldn’t write a Read instance to match it ;)

                                                                                                                                                      Greg Pfeil @sellout@2016-03-13T19:41:04.389Z
Oh, you mean the NaturalTransformation bit? I stole that from something in Scalaz. But I don’t recall what. I think it may have been some other instance on Cofree. But I use it all over Quasar now.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-13T19:42:19.579Z
Oh you know what, I think I was doing something more general.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-13T19:42:20.123Z
https://gist.github.com/tpolecat/0ef576a0150d95b4d9e6

                                                                                                                                                      Rob Norris @tpolecat@2016-03-13T19:43:42.873Z
Kinda squinting at it now. It made sense at the time.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-13T19:44:38.431Z
Ahaha, I have thought about something like `~~>`, but never made it. Makes total sense!

                                                                                                                                                      Rob Norris @tpolecat@2016-03-13T19:44:40.084Z
Nope, same thing you're doing. Oh well.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-13T19:48:48.121Z
Stylistically you might get some complaints about things like `(a(node ∘ (_ ∘ (_ ∘ (_._1)))) ⊛ b(node ∘ (_ ∘ (_ ∘ (_._2)))))((_, _))` because the bullet-like things are hard to distinguish and aren't in common use.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-13T19:49:11.816Z
Fine w/me though.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-13T19:49:28.498Z
I will fight to the death for my Unicode operators ;)

                                                                                                                                                      Rob Norris @tpolecat@2016-03-13T19:50:51.461Z
Rock on.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-13T19:56:43.238Z
The poor man's unapply seems good to me. It handles the [co]free shape which is the main use case. The normal unapply machinery has the hole in the wrong place so I think you would end up having to rewrite it anyway.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-13T20:44:36.024Z
Actually I'm going to give it another try. I think I see what I need to do.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-13T20:45:42.167Z
👍🏾 (want Slack reactions here so bad)

                                                                                                                                                      Rob Norris @tpolecat@2016-03-13T23:30:55.167Z
so ... close

                                                                                                                                                      Rob Norris @tpolecat@2016-03-14T04:18:16.086Z
@sellout ok i made a wip pr against your branch so you can see what i figured out. looks like it's possible

                                                                                                                                                      Greg Pfeil @sellout@2016-03-20T02:09:22.318Z
@tpolecat BTW, `Nu` is fixed now, so we have codata.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-20T02:31:36.235Z
:+1: 

                                                                                                                                                      Greg Pfeil @sellout@2016-03-20T02:38:37.180Z
#19 

                                                                                                                                                      Greg Pfeil @sellout@2016-03-22T02:09:08.695Z
@tpolecat unfolding to `Nu[ProfF]` would be an alternative to the case where you call the coalgebra directly – it’s lazy, so you can treat it like the corecursive structure, rather than having to explicitly apply the coalgebra at each step.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-22T02:33:55.107Z
@sellout not quite sure which step you're talking about. you mean the `unfoldCM`?

                                                                                                                                                      Rob Norris @tpolecat@2016-03-22T02:34:41.593Z
i really need to work on this presentation so i have time for you to correct it for me!

                                                                                                                                                      Greg Pfeil @sellout@2016-03-22T02:36:37.814Z
@tpolecat In your unsession at NEScala, you showed a case (and maybe it was just for example) where you called a function with the type `Int ⇒ ConnectionIO[ProfF[Int]]` directly, returning a single Prof where the students were just represented by their dbid.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-22T02:36:50.812Z
right, yes

                                                                                                                                                      Greg Pfeil @sellout@2016-03-22T02:37:07.954Z
Was that just for illustration?

                                                                                                                                                      Rob Norris @tpolecat@2016-03-22T02:37:46.113Z
No, it seemed like a good idea since I can then `.unfoldCM` with that to get the `ConnectionIO[Cofree[ProfF, Int]]`.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-22T02:37:58.384Z
So what does `Nu` do for me?

                                                                                                                                                      Greg Pfeil @sellout@2016-03-22T02:41:38.009Z
But I mean, was calling it directly for illustration? Passing it to `unfoldCM` ends up giving the recursive structure all at once (once you run that monad). When you might only care about a small slice of the results, right?

                                                                                                                                                      Rob Norris @tpolecat@2016-03-22T02:42:16.814Z
Yes, right. It materializes the whole structure from the root.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-22T02:43:28.651Z
So, yeah, I’m not positive about `Nu` in monads. I have to think about that.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-22T02:44:41.547Z
For your stuff, this requires a few other things … like you can define `type Cofree[F[_], A] = Mu[Ann[F, A, ?]]`.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-22T02:44:58.097Z
Mmmm. Ok.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-22T02:45:17.394Z
But, you can have an attributed stream (CoCofree?) like `Nu[Ann[F, A, ?]]`.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-22T02:46:59.928Z
Anyway, I’m just meandering now.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-22T02:47:19.157Z
But the idea of `Nu` is having a stream/codata of any data structure.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-22T02:48:25.557Z
So `type List[A] = Mu[ListF[A, ?]]` and `type Stream[A] = Nu[ListF[A, ?]]`

                                                                                                                                                      Rob Norris @tpolecat@2016-03-22T02:49:06.064Z
So when you do `unfoldCM` you have to traverse `F` which kind of forces things I think. I don't know what the effectful streamy type would look like.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-22T02:49:34.807Z
I need to sit down and play with `Mu` and `Nu` because I don't know anything about them. I get `Fix` and `Cofree` but just don't have any exposure to the others.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-22T02:49:50.245Z
Yeah, exactly. I wasn’t thinking of ConnectionIO when I first mentioned Nu, then you threw a wrench in the works, as always ;)

                                                                                                                                                      Rob Norris @tpolecat@2016-03-22T02:50:01.513Z
\o/

                                                                                                                                                      Rob Norris @tpolecat@2016-03-22T02:50:23.529Z
Although something I was interested in illustrating would be:

                                                                                                                                                      Rob Norris @tpolecat@2016-03-22T02:51:06.222Z
`case class Foo[A](data: Whatevs, parent: Option[A], children: List[A])` where you can walk the structure up and down forever.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-22T02:51:22.198Z
And I don't know if you can do that with `Fix`.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-22T02:52:53.380Z
I haven't tried it. Would be a cool trick if I could unfold the database structure into a doubly-linked tree.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-22T02:53:12.505Z
So maybe `Nu` could do that?

                                                                                                                                                      Greg Pfeil @sellout@2016-03-22T02:53:39.317Z
Yeah, that’s where you want things like Mu/Nu.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-22T02:53:59.672Z
Ok, cool.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-22T02:55:30.522Z
A “true” stream is the minimal argument for Nu, I think: `final case class StreamF[A, R](head: A, tail: R)`

                                                                                                                                                      Greg Pfeil @sellout@2016-03-22T02:56:21.485Z
`Fix[StreamF]` is going to get you in trouble instantly.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-22T02:57:14.627Z
So, `scalaz.Cofree` is trampolined which might be cheating. Is it supposed to be finite?

                                                                                                                                                      Rob Norris @tpolecat@2016-03-22T02:59:50.707Z
Like, `Cofree.unfoldC(1)(a => Option(a + 1))` terminates but you can peel off layers forever.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-22T03:00:19.831Z
Ok bedtime for 2yo, gotta run. Thanks for your help, this is a lot of fun.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-22T03:00:30.144Z
Right, I think trampolining gets you that, too. I’m not sure what the tradeoffs are. Cool. Thank _you_.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-28T17:28:36.192Z
Really need to convince myself that `type Free[F[_], A] = Nu[CoAnn[F, A, ?]]` is equivalent to the trampolined version.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-01T15:05:40.200Z
So, did some thinking about Cofree last night. Realized that the `Mu[Ann[F, A, ?]]` encoding simplifies a bunch of things for Matryoshka.  One of those things is that `unfoldC` (which I called `attributeAna` in Matryoshka) no longer needs its own operation. Instead of `1.attributeAna(a => Option(a + 1))`, you can do `1.ana(attribute(a => Option(a + 1)))`. I.e., the `attribute` function transforms the coalgebra from `Int => Option[Int]` into `Int => Ann[Option, Int, Int]`. And if you unfold into `Mu`, you end up with `Mu[Ann[Option, Int, ?]]`, which is Cofree.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-01T15:07:03.298Z
And other classes of things change in a similar way – meaning most (all?) of the operations outside of the generalized core can be brought into it.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-01T15:08:28.980Z
Also, it turns out that `Ann[F[_], A, B]` ≣ `EnvT[A, F[_], B]`, which is already in Matryoshka. (`EnvT[A, F[_], B]` is the comonad transformer for `(A, F[B])`.)

                                                                                                                                                      Greg Pfeil @sellout@2016-04-01T16:41:41.766Z
Oh man, this just made me realize why Kmett’s using open type families to encode `T[F] => F[T[F]]`. Now, how do I do that in Scala …

                                                                                                                                                      Greg Pfeil @sellout@2016-04-02T19:54:38.087Z
Apparently I’m now using Matryoshka to rebuild everything.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-02T19:55:10.985Z
@tpolecat I don’t think I need that unapply trick for `Cofree[?[_], A]`, etc. anymore.

                                                                                                                                                      Rob Norris @tpolecat@2016-04-02T20:15:25.089Z
@sellout oh that's good news. :+1: 

                                                                                                                                                      Greg Pfeil @sellout@2016-04-02T20:25:26.599Z
@tpolecat I’m just guessing at this point, but I changed the type classes from `trait Recursive[T[_[_]]]` to `trait Recursive[T]`, and instances from `implicit def recursive[A]: Recursive[Cofree[?[_], A]` to `implicit def recursive[F[_], A]: Recursive[Cofree[F, A]]`. But that looks like an improvement in terms of implicit search?

                                                                                                                                                      Greg Pfeil @sellout@2016-04-02T20:27:58.755Z
It’s a consequence of a change that lets you pretend that, say, `List[A]` is actually `Mu[ListF[A, ?]]`, getting all the folds/unfolds on traditionally-defined data structures.

                                                                                                                                                      Rob Norris @tpolecat@2016-04-02T21:10:57.084Z
Oh, cool. Yeah once you don't need higher-kinded unification you're in much better shape, inference-wise.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-04T03:04:41.427Z
@tpolecat Ok, cool. Still have 38 errors (hey, down from 511), but it looks like the new approach _does_ fix the implicit search.

                                                                                                                                                      Rob Norris @tpolecat@2016-04-04T03:06:09.434Z
Cool, I look forward to seeing it.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-04T14:22:46.236Z
So confused … I have two type classes that extend the same trait. One works just fine, the other can’t find a type that’s declared in the super trait.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-04T14:32:57.163Z
Oh, I think I figured it out.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-10T23:44:15.787Z
“Recursion: where functional programming hits bottom”

                                                                                                                                                      Rob Norris @tpolecat@2016-04-11T00:04:54.543Z
:+1: 

                                                                                                                                                      Greg Pfeil @sellout@2016-04-11T03:58:41.682Z
Submitted to SBTB.

                                                                                                                                                      jeremyrsmith @jeremyrsmith@2016-04-15T02:44:49.960Z
I subscribe to so many gitter channels now, and I kind of feel bad for all of them

                                                                                                                                                      Greg Pfeil @sellout@2016-04-15T02:45:41.325Z
Oh man – way too many. And sometimes I wish multiple projects would aggregate under one channel. Like, does scalacheck-shapeless need its own?

                                                                                                                                                      Rob Norris @tpolecat@2016-04-15T02:46:26.738Z
just submitted my fix+cofree+doobie talk to scala up north

                                                                                                                                                      jeremyrsmith @jeremyrsmith@2016-04-15T02:46:39.883Z
anyway, whatever books or blogs or videos or degree programs would be helpful, I want to have the background I need to understand this tool.  Because I know that it applies to several things I have solved in less elegant ways, but I don't know what the link is

                                                                                                                                                      Rob Norris @tpolecat@2016-04-15T02:46:52.585Z
so i may be spreading the gospel of fixpoint types to our adorable canadian friends

                                                                                                                                                      Greg Pfeil @sellout@2016-04-15T02:46:53.135Z
@tpolecat Is “Scala Up North” an actual thing?

                                                                                                                                                      Rob Norris @tpolecat@2016-04-15T02:46:57.460Z
yeah

                                                                                                                                                      Rob Norris @tpolecat@2016-04-15T02:47:10.729Z
http://scalaupnorth.com/

                                                                                                                                                      Greg Pfeil @sellout@2016-04-15T02:48:56.392Z
@jeremyrsmith It’s mostly papers, which aren’t the most direct way to get there. There are a couple blog posts. https://medium.com/@jaredtobin/practical-recursion-schemes-c10648ec1c29#.611hff5gp is a decent one, but in Haskell.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-15T02:49:13.112Z
However, Matryoshka takes a lot from Ed Kmett’s Haskell recursion schemes.

                                                                                                                                                      jeremyrsmith @jeremyrsmith@2016-04-15T02:50:18.411Z
Thanks, I'll check those out.  I am not a Haskell programmer, but even so it's often easier to understand than corresponding Scala

                                                                                                                                                      Greg Pfeil @sellout@2016-04-15T02:50:29.023Z
(Although, toward the end of that post, Jared advocates a few things I don’t agree with, which I’ll cover in my next talk, which will hopefully be a bit more practical).

                                                                                                                                                      Greg Pfeil @sellout@2016-04-15T02:51:32.857Z
I think I bit off a bit too much in that Typelevel talk – I also had other stuff involving Shapeless and Monocle that I ended up cutting, and I probably should have cut the Inject/Coproduct stuff and just focused on Matryoshka, too.

                                                                                                                                                      jeremyrsmith @jeremyrsmith@2016-04-15T02:51:55.235Z
trust me, it was a good talk.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-15T02:52:21.014Z
Thanks. I appreciate it 😄

                                                                                                                                                      Rob Norris @tpolecat@2016-04-15T02:52:26.449Z
Are we talking about Typelevel Summit? Did I meet you @jeremyrsmith?

                                                                                                                                                      jeremyrsmith @jeremyrsmith@2016-04-15T02:52:30.671Z
the talk informs people who understand, and piques the interest of people who don't

                                                                                                                                                      jeremyrsmith @jeremyrsmith@2016-04-15T02:52:39.047Z
that's the goal of a talk

                                                                                                                                                      jeremyrsmith @jeremyrsmith@2016-04-15T02:52:52.765Z
I didn't make typelevel @tpolecat but I watched it on YouTube

                                                                                                                                                      Rob Norris @tpolecat@2016-04-15T02:52:59.451Z
Aha ok.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-15T02:53:37.321Z
@jeremyrsmith True – I think what I need is better docs/tutorial to get people from the talk to writing code. Well, that’s a goal for the next month as I get ready to talk again.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-15T02:57:08.914Z
@tpolecat Hrmm, early August … I’ll already be in PA. Montreal is close enough and my parents can watch the kids …

                                                                                                                                                      Rob Norris @tpolecat@2016-04-15T02:57:54.330Z
Do it!

                                                                                                                                                      Greg Pfeil @sellout@2016-04-15T03:02:09.418Z
PRs welcome 😉 https://github.com/sellout/fix

                                                                                                                                                      Greg Pfeil @sellout@2016-04-15T03:09:24.696Z
@jeremyrsmith I’m also happy to answer more specific questions. The README has links to a couple papers, but that’s probably not the kind of answers you’re looking for.

                                                                                                                                                      Cody Allen @ceedubs@2016-04-19T20:03:45.280Z
my cat stepped on my keyboard and Gitter recommended that I join this room. Probably about the best case scenario for how that could have ended

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T04:45:36.111Z
Hey @sellout which repo/branch is the most likely to become reality at this point?

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T04:46:07.327Z
I'd like to try to adapt my examples and see how much it cleans up my talk. It needs some cleaning up.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T04:46:44.550Z
@tpolecat All except for the oldest one, parts of which have already been absorbed elsewhere.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T04:47:37.809Z
But if you just use attributeAnaM and I forget the other one, it should be a simple change once the `Base` stuff is in.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T04:48:25.965Z
@tpolecat I could use some help with that `Base` PR if you want ;)

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T04:50:45.116Z
Hm looks like it's compiling except for a scaladoc error. What do you need help with?

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T04:51:21.802Z
@tpolecat But the tests don’t compile, right?

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T04:52:37.341Z
Ok I was just looking at the travis output. I'll give it a try.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T04:53:50.759Z
The problem I _think_ I’m running into now is that I define the type class instances with the type `Recursive.Aux[T, F] with Corecursive.Aux[T, F]`, and so when something is looking for a `Recursive.Aux` implicit, it doesn’t find it … does that make sense?

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T04:55:55.628Z
Huh. That works fine with single-param typeclasses.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T04:57:06.217Z
So, part of it may be that the `.Aux` is a type alias to the `Recursive[T[F]]` type class (with a specific `Base` type member)?

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T04:57:25.594Z
And I might just be misinterpreting what @InTheNow had told me was happening.

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T04:58:44.669Z
Ah, yes. The tests don't quite compile.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T04:59:20.805Z
I would like to instantiate the type classes separately anyway, but I can’t because they need to provably have the same `Base`. And I don’t _think_ there’s a way to define a type family in Scala other than using an associated type.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:00:36.489Z
Like, instead of `@typeclass Recursive[T[F]] extends Base[T[F]]`, I’d rather do `@typeclass trait Recursive[T[F]](implicit B: Base[T[F]])` (which doesn’t work, of course).

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:05:18.502Z
Ok, yeah I have a similar problem in doobie. I'm using a superclass like you are.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:08:22.023Z
@tpolecat And you end up instantiating with `with`?

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:08:45.130Z
I haven't gotten that far. I was thinking I would. This is a new thing I'm messing with.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:09:07.802Z
Ah, ok. Well, it’s good to know there’s someone in the same boat :D

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:11:29.899Z
And there are still other things that haven’t been sorted out on that branch. Even after it works, it may live on its own branch for a while.

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:15:13.765Z
hm how do i get a repl? it wants to compile the tests

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:16:12.251Z
Oh, I haven’t tried. But I have another branch that moves the tests to their own subproject. Not that that helps you now.

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:17:11.622Z
i'll delete the tests. need to crank down the warnings and stuff too

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:17:27.289Z
do you not use the repl when you're coding?

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:18:06.595Z
Ok that worked.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:18:31.018Z
No, I know it’s something I _should_ be doing, but the couple times I tried I got pretty frustrated. I think there are like two compiler flags that need to be disabled for it, though.

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:20:40.644Z
well it's working with the tests deleted ;-)

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:21:02.224Z
I should try that will _all_ my tests.

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:22:09.283Z
so yeah i'm seeing what you're seeing

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:22:44.165Z
`Recursive.Aux[Fix[F], F]` works on its own but not `with ...`

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:24:16.813Z
So you need to define them together but do you ever want to have a handle on the combined instance?

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:25:03.549Z
Well, I tend to just use two constraints in that case.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:25:14.472Z
rather than one with a `with`

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:25:14.928Z
ok

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:25:26.965Z
I definitely need just one or the other, though.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:26:11.159Z
Oh, could that one be a lower-prio instance, and then have a `Recursive.Aux` instance that just refers to that instance?

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:26:23.054Z
I guess it doesn’t even need to be lower-prio.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:26:42.297Z
I should just spell out priority, because autocorrect ruins it otherwisee.

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:26:50.530Z
If you make `matryoshoka` non-implicit and add
```
  implicit def matryoshkaRA[F[_]]:   Recursive.Aux[Fix[F], F] = matryoshka[F]
  implicit def matryoshkaCA[F[_]]: Corecursive.Aux[Fix[F], F] = matryoshka[F]
```
then the instances are available implicitly.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:27:07.710Z
Yeah, exactly. Awesome.

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:36:23.723Z
So with this encoding I have to name the functor if I'm abstracting over recursion schemes?

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:36:45.594Z
i.e., I can't say `[T[_[_]]: Recursive]` .. I have to say `[T[_[_]], F[_]](implicit ev: Recursive.Aux[T[F], F])`

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:38:28.368Z
Yeah, but you probably want to say `[T, F[_]](implicit ev: Recursive.Aux[T, F])`

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:38:42.589Z
I.e., T shouldn’t be parameterized.

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:38:55.356Z
Ah ok.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:40:29.499Z
Because F is really naming the _base_ of the fixpoint. Which is `[T[F], F]` when T is Fix/Mu/Nu, but it’s `[Cofree[F, A], EnvT[A, F, ?]]`, `[List[A], ListF[A, ?]]`, etc.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:40:59.635Z
The benefit of this change is that you can treat arbitrary types as if they had been implemented in fixpoint style.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:42:07.666Z
And, I haven’t really seen the impact this has on user code yet – converting all the tests should give me some idea. I hope it’s not _too_ terrible.

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:45:26.015Z
Ok, that almost makes sense. I look forward to seeing some examples.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:46:06.456Z
I hope it works out, because one of the points in my upcoming talks is how you can take advantage of that to smooth the transition of existing code – 1. define a pattern functor that parallels your ADT, 2. define a {co}rec instance on it directly (`Recursive.Aux[Foo, FooF]`), then you can write algebras over `FooF`, and use them in folds over `Foo`.

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:47:48.673Z
Ohhhh. Wow, ok.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:47:58.365Z
Does that actually make sense?

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:48:32.688Z
Yes, I don't know how it could possibly work but I'm looking at `ListF` and I see what you're talking about.

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:49:11.431Z
So if you start out with a pattern functor by itself does it collapse into something simpler?

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:50:07.288Z
You mean if you don’t already have a directly-recursive structure? Yeah, in that case you don’t need your own Recursive instance, you just take advantage of the ones defined for Mu/Nu.

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:50:12.536Z
RIght.

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:50:15.477Z
ok ok

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:51:10.928Z
But the instances you define yourself are pretty simple – like the List/ListF one – it just maps each node to its corresponding node in the functor (and embed does the opposite).

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:52:29.214Z
Yeah it looks pretty mechanical.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:52:45.933Z
Probably Shapeless could do it for you ;)

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:59:20.621Z
If you could define the pattern functor as a typeclass then I'll bet it could.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T06:15:14.474Z
I like that, every 30 minutes, my computer alerts me to how little sleep I’m going to be getting.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-25T20:52:05.379Z
This type family stuff is still a PITA. Maybe I’ll have time to wrap it up in the near future.

                                                                                                                                                      Rob Norris @tpolecat@2016-04-26T05:06:44.504Z
This fixpoint stuff is solid gold for database programming. I have never heard of it being used this way before. It totally solves the id problem and the "only materialize part of the graph" problem.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-26T05:20:33.633Z
@tpolecat Yeah, your stuff is the only time I've seen it, and it seems so widely applicable.

                                                                                                                                                      JerrySwan @JerrySwan@2016-04-28T22:12:38.606Z
Hi. What imports do I need in order to compile the code in the README at https://github.com/slamdata/matryoshka?

                                                                                                                                                      Greg Pfeil @sellout@2016-04-28T22:14:48.757Z
`import matryoshka._, Recursive.ops._, TraverseT.ops._` should get you everything. It’s on my todo list to clean up imports, and also to start using tut, so I can’t just omit important details like how to import stuff.

                                                                                                                                                      Rob Norris @tpolecat@2016-04-28T22:17:37.173Z
:-)

                                                                                                                                                      JerrySwan @JerrySwan@2016-04-29T05:08:34.254Z
@sellout - that's not working for me. The following fails to compile:
```  
import matryoshka._
  import matryoshka.Recursive.ops._, matryoshka.FunctorT.ops._
  import scalaz._, Scalaz._
  
  sealed trait Expr[A]
  final case class Num[A](value: Long) extends Expr[A]
  final case class Mul[A](l: A, r: A)  extends Expr[A]
  
  val eval: Expr[Long] => Long = {
    case Num(x)    => x
    case Mul(x, y) => x * y
  }
  
  implicit object expFunctor extends Functor[Expr] {
    def map[A, B](fa: Expr[A])(f: A => B): Expr[B] = fa match {
      case Num(v)   => Num[B](v)
      case Mul(a,b) => Mul[B](f(a),f(b))
    }
   }
  
  def someExpr[T[_[_]]: Corecursive]: T[Expr] =
    Mul(Num(2).embed, Mul(Num(3).embed, Num(4).embed).embed).embed

  someExpr[Mu].cata(eval) // ⇒ 24
```
reporting: 
value embed is not a member of Num[A]

                                                                                                                                                      Greg Pfeil @sellout@2016-04-29T12:38:49.710Z
@JerrySwan You're right – in someExpr, the Num nodes need to have a type annotation – Num[T[Expr]](2)

                                                                                                                                                      Greg Pfeil @sellout@2016-04-29T12:38:55.556Z
Ugh

                                                                                                                                                      Greg Pfeil @sellout@2016-04-29T12:40:01.928Z
`Num[T[Expr]]`

                                                                                                                                                      Greg Pfeil @sellout@2016-04-29T12:41:26.667Z
Ok, I'll tut today, because that's embarrassing.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-29T12:42:41.995Z
Also, I'm trying to figure out if I can use covariance at all to eliminate the need for all the leaves to be annotated like that.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-29T15:33:28.841Z
@JerrySwan Also, the examples in the test folder (granted, all currently conflated under Spec) are things that actually get compiled. #16 pulls those test algebras, etc. into their own files, hopefully making them more digestible. I need to get that merged.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-29T15:34:07.364Z
I imagine there’ll be increasing work on Matryoshka as my next talk on the topic approaches ;)

                                                                                                                                                      Greg Pfeil @sellout@2016-04-30T19:46:35.415Z
So, matryoshka has stuff like `F[T[F]]` everywhere. However, we often want to operate on `G[Nothing]` (where `G <: F`), so technically that’s a subtype of `F[T[F]]`, but I can’t figure out where I can put variance annotations to make that work.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-30T19:47:33.130Z
In SlamData, we do smart constructors (well, prisms) to promote the `G` to `F`, but we still need explicit type annotations to get `T[F]` rather than `Nothing`.

                                                                                                                                                      Greg Pfeil @sellout@2016-05-13T02:50:12.068Z
**\[Greg Pfeil, SlamData Inc.\]** Random neat thing: `1.ana[Nu](constantly).ana[Nu](find(_ > 10)): Partial[Int]`

                                                                                                                                                      Greg Pfeil @sellout@2016-05-13T02:51:14.541Z
**\[Greg Pfeil, SlamData Inc.\]** `1.ana[Nu](constantly)` generates an infinite stream of `1`s. and `.ana[Nu](find(_ > 10))` returns the first item from that stream that’s greater than 10.

                                                                                                                                                      Greg Pfeil @sellout@2016-05-13T02:56:16.815Z
**\[Greg Pfeil, SlamData Inc.\]** It’ll run forever, but the type tells you that’s a possibility. But rather than having to either do `.take(100)` before `find`ing or just get back some forever-running future, you can peek ahead in chunks however large you want … `runFor(100)`, see if it got a result in that time, and if not, just run for more, or give up.

                                                                                                                                                      Greg Pfeil @sellout@2016-05-13T18:09:03.293Z
I changed it a bit, so `find` is now a transformation, which means you can equivalently write `1.ana[Nu](constantly ⋙ find(_ > 10))`.

                                                                                                                                                      Cody Allen @ceedubs@2016-05-13T18:15:16.881Z
yer a wizard @sellout 

                                                                                                                                                      Greg Pfeil @sellout@2016-05-20T16:22:56.493Z
**\[Greg Pfeil, SlamData Inc.\]** A problem I run into constantly in algebras – I have an algebra like `EJson[Bson] => PlannerError \/ Bson` \(`F[A] => M[A]`, a Kleisli algebra\), but when it fails, I want to return the structure that failed, a `T[EJson]`, but that forces me to turn the simple cata into a para – carrying the recursive structure along with me: `EJson[(T[EJson], Bson)] => PlannerError \/ Bson`. But that makes the whole thing a bit less general \(ran into a problem today where I’m actually folding from a `Free[EJson, _]`, and there’s really no way for me to reconstruct a `T[EJson]` that perhaps never even existed\).

                                                                                                                                                      Greg Pfeil @sellout@2016-05-20T16:25:49.512Z
**\[Greg Pfeil, SlamData Inc.\]** Also, I wonder if there’s a way to do something even more useful – like use an applicative to build a structure of `Free[EJson, PlannerError]`, with the errors in the holes that failed for whatever reason. Which maybe gives the caller something they can more usefully translate back to the end user \(e.g., positions in the query where the error happened\).

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T22:35:51.537Z
So I'm just getting into recursion schemes.  I know Erik Meijer often talks about using the *morphisms as a replacement for general recursion.  So as I'm using recursion schemes, I'm taking note for when I feel forced to use recursion.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T22:36:31.690Z
With Mu, I can turn Mu[ListF] into a scala.collection.List without a recursive call. . . that's pretty straight forward.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T22:37:08.713Z
but my attempt to turning Nu[ListF] into a scala.collection.Stream uses recursion.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T22:37:32.012Z
should I keep hunting?  Or can someone stop me from hunting for the impossible?

                                                                                                                                                      Greg Pfeil @sellout@2016-06-22T22:39:03.347Z
Yes. It’s not as straightforward as it could be (there’s a PR to fix that), but you can use `ListF.listIso` – `muListF.cata(ListF.listIso.get)` … or `reverseGet` … I always forget which is which :D

                                                                                                                                                      Greg Pfeil @sellout@2016-06-22T22:40:03.936Z
With the `Base` PR, if I ever figure it out, you’ll be able to just apply recursion schemes to scala Lists and Streams directly.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T22:40:24.474Z
actually, it's kind of a two-part question.  1) is it possible?  2) is it possible with Matryoshka?

                                                                                                                                                      Greg Pfeil @sellout@2016-06-22T22:42:22.571Z
So, you can see that `ListF.listIso.get` is “just” an Algebra. So if you’re building up a Mu[ListF] with a Coalgebra, you can do `x.hylo(ListF.listIso.get, myCoalgebra)` to build up the Mu[ListF] and convert it to a scala List in a single pass.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T22:43:15.451Z
okay, I think that pointer makes sense.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-22T22:43:23.095Z
Oh, so all my rambling is for naught, because you figured that part out. I missed that `Nu` was your problematic case.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T22:43:38.300Z
oh, good.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T22:43:42.370Z
yeah, I got it for Mu!

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T22:44:16.168Z
honestly, I'm completely okay with it not being possible for Nu.  It just puts an asterisk by Erik's claims.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T22:44:25.869Z
but perhaps all of Erik's claims need asterisks.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-22T22:44:43.605Z
Well, there are other things that aren’t in Matryoshka yet. Like good metamorphisms …

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T22:44:53.658Z
so many *morphisms.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T22:45:01.639Z
I saw the picture you put up.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-22T22:46:39.999Z
This paper, if you care to dig in: https://www.researchgate.net/publication/220131211_Metamorphisms_Streaming_representation-changers

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T22:46:53.736Z
Comonad.Reader posts from 2008-2009. . . somehow being 8 years behind doesn't feel that bad.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-22T22:48:00.048Z
But I don’t think there needs to be a * next to Erik’s claims (maybe there should be, I certainly haven’t proved otherwise). But you should be able to do the things you want to do with Streams without converting to Stream. Just might mean reimplementing stuff ;)

                                                                                                                                                      Greg Pfeil @sellout@2016-06-22T22:48:25.718Z
But I’ll think about trying to convert to Stream as well.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T22:49:53.946Z
for me, it's more the exercise of seeing the benefits of recursion schemes.  I agree that a raw Nu[StreamF] is effectively stream.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T22:50:49.523Z
cool, that paper makes very clear what a metamorphism is.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T22:59:31.786Z
@sellout maybe you can short-circuit some learning for me.  I'm still trying to figure out the relationship Mu has with Free.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T23:00:00.955Z
in particular, whether one can be defined in terms of the other.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T23:00:30.575Z
(even if it's not in the libraries we use day-to-day)

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T23:02:38.171Z
I think this is on the last pages of the bananas paper that I haven't gotten to yet.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T23:03:55.885Z
my hunch is that Free can be defined in terms of Mu, where the functor is the non-recursive algebra for Return | Bind

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T23:05:36.121Z
but I won't believe it til I see it all compiling.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-22T23:07:42.016Z
Yeah, look in matryoshka.instances.fixedpoint – Free is Mu[CoEnv] (and Cofree is Mu[EnvT])

                                                                                                                                                      Greg Pfeil @sellout@2016-06-22T23:09:05.117Z
Co/monad instances yet.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T23:09:24.413Z
cool.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-22T23:09:50.540Z
But I don't have … co/monad …

                                                                                                                                                      Greg Pfeil @sellout@2016-06-22T23:10:41.303Z
I'm hoping to discover some type class that when defined on a Functor provides Monad on the fixed point of that Functor.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-22T23:11:45.910Z
Like the current stuff for Bifunctor[F] => Functor[Mu[F]]

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T23:12:02.819Z
interesting.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T23:12:32.645Z
I think I should look at the tests; maybe it will give me some better idea for the usefulness.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T23:12:54.249Z
there's a point in learning this stuff where it really feels like the brunt of an "Evolution of a Haskeller" joke.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T23:13:05.032Z
like a needless complication.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T23:15:26.717Z
@sellout so Runar put in some work to make sure his Free didn't blow stack.  does Mu[CoEnv] have the same gaurantees of stack-safety?

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T23:16:15.071Z
(I'm speaking specifically to the matryoshka implementation of Mu and CoEnv with that question).

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T23:27:38.859Z
also, I think I see now that Mu just deals with the recursive-type part of Free.  Free as a concept is just a different concept.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T23:27:58.149Z
and probably similarly for Nu and Cofree.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-22T23:32:21.535Z
How do you mean it's a different concept? You should be able to get the Free Monad-ness from MuCoEnv.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T23:43:16.449Z
I can't figure out how to say it in text.  I'm just saying that the fact that Free can be written in terms of Mu is not really related to the fact it's a "left adjoint of a forgetful functor". . . more that it's a recursive type, and Mu factors out the recursiveness of any recursive type.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T23:43:33.145Z
hopefully that makes sense.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-23T00:03:37.451Z
okay, this is where my play got me:  https://gist.github.com/shajra/6d88a35b76a2c62a171bd41ac090aada

                                                                                                                                                      Sukant Hajra @shajra@2016-06-23T00:03:50.432Z
whoa. . . not sure if I wanted that all expanded out, Gitter.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-23T02:03:59.491Z
@shajra You’re right about the Mu representation not saying anything meaningful about the left adjointness. However … http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.307.5950

                                                                                                                                                      Greg Pfeil @sellout@2016-06-23T02:05:22.724Z
That paper has a generalization of recursion schemes (using adjunctions rather than monads/comonads) that does rely on that relationship (look at λ-coiteration, which is a generalization of the comonad-based futumorphism).

                                                                                                                                                      Greg Pfeil @sellout@2016-06-23T02:05:36.884Z
That’s one of the three big changes currently happening in Matryoshka. Heh.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-23T02:06:22.195Z
The others are the “Base” approach I mentioned earlier, and then higher-order recursion schemes that allow for mutually-recursive types.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-23T02:11:04.374Z
Higher-order is going to get in first, because I already have parts of it working and it’s useful for work.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-23T02:12:07.212Z
“Base” I would like to get in next because it cleans up a lot of stuff conceptually and makes it easier to use recursion schemes with “traditional” data types. And it’s also useful for work. But it has hit a snag that I suppose I will eventually have to deal with.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-23T02:12:34.377Z
Adjunctions seems fun, but I don’t have a particular need for it yet.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-23T02:34:23.586Z
@sellout glad I asked.  Good information.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-23T02:36:53.070Z
no joke:  "The  many  divergent  generalisations  of  catamorphisms  can  be bewildering  to  the  uninitiated..."

                                                                                                                                                      Greg Pfeil @sellout@2016-06-23T02:38:00.657Z
Oh, and you had also asked about trampolining – I haven’t done anything for it _yet_. I want to get a good test case that shows the improvement. But I _think_ I can trampoline Mu, and get it for free on all functors.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-23T02:38:49.367Z
@sellout I think Stephen Compall is making some good arguments against trampolining at _every_ step.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-23T02:39:17.161Z
@shajra Heh, yeah, I joke that if you understand the generalized Elgot hylomorphism, all the others just fall out of that ;)

                                                                                                                                                      Sukant Hajra @shajra@2016-06-23T02:39:41.112Z
is that true?

                                                                                                                                                      Greg Pfeil @sellout@2016-06-23T02:40:18.175Z
Yeah, pretty much.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-23T02:40:40.715Z
I mean, there’s also the Kleisli variants, but those work as you’d expect.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-23T02:41:17.164Z
okay, there's just so many:  http://comonad.com/reader/2009/recursion-schemes/

                                                                                                                                                      Sukant Hajra @shajra@2016-06-23T02:42:44.529Z
is this Elgot holymorphism generalization covered in the paper you linked?  If not, then is it in some other paper?

                                                                                                                                                      Greg Pfeil @sellout@2016-06-23T02:42:55.005Z
Yeah, actually the synchro and exo maybe don’t fall under that … at least not without adjunctions.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-23T02:43:12.048Z
I don’t think there’s anything that covers that explicitly.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-23T02:43:33.043Z
okay, I have a feeling this is all going to keep me busy if I let it.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-23T02:44:17.101Z
But, all folds are hylos with `project` for the unfold and all unfolds are hylos with `embed` for the fold.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-23T02:45:14.142Z
cool, I saw this usage of project and embed in various libraries, but didn't get to understanding it yet.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-23T02:45:30.030Z
And then cata/ana just use `Id` for the {co}monads, histo/futu use {co}free, para/apo use {co}product, etc.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-23T02:46:45.803Z
I made https://github.com/sellout/recursion-scheme-talk/blob/master/cheat%20sheet.pdf, which builds on that post of Kmett’s – you’ve probably seen it. That version is a bit out of date. I should commit an updated one.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-23T02:47:07.314Z
The left and right sides represent duals.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-23T02:47:28.208Z
cool, I can see cata/ana right off the bat.  I'll try to remember the other four relations for histo/futu/para/apo.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-23T02:47:47.432Z
yeah, I saw that.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-23T02:48:13.307Z
all this started when I decided to present the bananas paper because a meetup organizer twisted my arm.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-23T02:48:23.357Z
Hah!

                                                                                                                                                      Sukant Hajra @shajra@2016-06-23T02:48:45.695Z
then I saw how deep the hole went, jumped in, and realized I didn't have an escape plan.

                                                                                                                                                      Suhail Shergill @suhailshergill@2016-06-23T18:31:22.071Z
@sellout i recently became aware of this project. does it include the work from gibbons' conjugate hylomorphism paper? an attempt to have a toolbox to unify recursion schemes?

                                                                                                                                                      Suhail Shergill @suhailshergill@2016-06-23T18:31:24.720Z
http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/conjugate-hylos.pdf

                                                                                                                                                      Greg Pfeil @sellout@2016-06-23T19:28:46.338Z
@suhailshergill 😆 We were just discussing that yesterday, actually – you can probably find it in scrollback. But that requires the adjunction approach, which is a generalization of what’s currently in Matryoshka (comonadic folds). 

                                                                                                                                                      Greg Pfeil @sellout@2016-06-23T19:29:51.649Z
The current comonadic version does have some generalized hylomorphisms – {co}Elogot algebras, chronomorphisms, dynamorphisms, etc. – but not as rich as adjoint folds.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-23T20:17:35.053Z
I'm new to this stuff.  Does Haskell's recursion-scheme library have this generalization?  Or another library?

                                                                                                                                                      Greg Pfeil @sellout@2016-06-23T20:38:37.004Z
@shajra I don’t know of a library that uses adjoint folds. Both recursion-schemes (I’m certain) and comp-data (I think) use comonadic folds. Other libraries (fixplate, etc.) have a few hand-written folds, but not generalized ones (I think).

                                                                                                                                                      Suhail Shergill @suhailshergill@2016-06-24T00:28:07.752Z
@shajra not to my knowledge. i've been aware of that paper for a while now, and hoping someone will get to implementing it before i get the time to ;)

                                                                                                                                                      Suhail Shergill @suhailshergill@2016-06-24T00:29:11.339Z
@sellout is there work being done to switch to switch to adjoint folds?

                                                                                                                                                      Suhail Shergill @suhailshergill@2016-06-24T00:30:25.502Z
seems like it is
> That’s one of the three big changes currently happening in Matryoshka. Heh.

is there a specific branch i should look at?

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T00:31:13.894Z
@suhailshergill I don't know if that one has been pushed. I'll figure it out and let you know.

                                                                                                                                                      Suhail Shergill @suhailshergill@2016-06-24T00:31:39.831Z
rock on dude :) appreciate it

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T03:10:48.689Z
bananas paper question: in that paper, they define both the "banana" and "lens" operator in terms of mu, which they explicitly call the "least fixed point".  I was expecting them to introduce both mu and nu.  The paper makes no reference to "greatest fixed point" so something feels missing.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T03:14:49.278Z
actually, I think it makes sense.  it's just a normal "fix" function.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T03:15:32.336Z
to turn ((L -> A) -> (L -> A)) into just (L -> A)

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T03:56:01.870Z
okay, tried to implement the banana and lens function directly, and got a stack overflow

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T04:04:24.232Z
oh, probably because I defined fix wrong.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T04:09:02.052Z
yeah, needed the fancier z-combinator for a strict language.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T05:17:57.713Z
okay, I got rid of the stack overflow for making a finite stream with Mu, but making a "lens" function causes my infinite stream to unwravel all the way and blow stack.

                                                                                                                                                      Suhail Shergill @suhailshergill@2016-06-24T10:54:38.260Z
@shajra an alternate to z combinator is to simply use trampolining. see https://github.com/suhailshergill/predef/blob/master/src/main/scala/sss/predef/Fix.scala#L68

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T13:00:28.895Z
@suhailshergill thanks for the suggestion.  My real problem is too much strictness for my core curation.  But once I solve that, stack safety is good to have too.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T13:01:21.363Z
I had this working already.  I just wanted to make functions that reflected exactly the notation in the Bananas paper.

                                                                                                                                                      Suhail Shergill @suhailshergill@2016-06-24T13:01:47.143Z
right hence the stream evaluation. understood

                                                                                                                                                      Suhail Shergill @suhailshergill@2016-06-24T13:02:11.831Z
btw, what're you doing these days sukant? still awesome stuff at rackspace?

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T13:05:11.079Z
No, Rackspace was never the ideal place to do machine learning, so we left when they did a reorg that put us under a crazy Hadoop project that seemed flawed on construct.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T13:06:26.195Z
Two of us went to Helium to do some engineering in Haskell there, and I went to a local startup that's in a similar space as IBM Watson (which has pros and cons).

                                                                                                                                                      Suhail Shergill @suhailshergill@2016-06-24T13:46:39.086Z
:)

                                                                                                                                                      Suhail Shergill @suhailshergill@2016-06-24T13:47:26.134Z
if you're ever in toronto, we should grab a bite

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T15:34:04.791Z
@suhailshergill same for if you're in Austin

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T15:34:40.171Z
(or anyone!)  Also, if anyone wants to present at an Austin Scala or Haskell meetup, I can help set that up.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T15:55:53.940Z
I can see how working with recursion schemes and remove some boilerplate of recursion, but some claims of the benefits seem stronger than I can see.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T15:56:00.014Z
@suhailshergill Going to Scala Up North, by any chance?

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T15:56:16.413Z
@shajra Like which ones?

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T15:56:30.856Z
For instance, do recursion schemes enhance composability of abstraction?

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T15:57:23.843Z
@shajra I’m not sure exactly what you mean by that, but there are a lot of compositionality / fusion benefits.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T15:58:13.340Z
Although, it can be hard to clearly separate the benefits that come from pattern functors and those that come from recursion schemes.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T15:58:16.194Z
okay, that's what I'm hoping, but in the middle of seeing all the mechanics, I feel I might be losing perspective.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T15:58:23.868Z
right!  

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T15:58:52.118Z
what I'd like to see is something like a side-by-side comparison with respect to composition and fusion.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T15:59:21.016Z
@shajra I find that it lets me break things down into very small simple pieces. The complexity doesn’t _completely_ go away, but it’s moved away from the logic into the composition of the algebras.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T15:59:24.023Z
maybe with just ana/cata/hylo

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T15:59:43.020Z
right, I can see how it factors down into smaller parts.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T16:00:18.099Z
but that gets to another claim, which is reuse of algorithms with different functors.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T16:00:36.300Z
E.g., I can write a bunch of simple algebras, and one that requires some wild combination of annotation, state, whatever. Then, I can “lift” the simple algebras into that same shape when I compose them.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T16:01:04.178Z
Yeah, matryoshka has a small number of common algebras currently – that should grow, and should become a separate `package`.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T16:01:40.437Z
what's the function for "lifting"?

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T16:01:54.927Z
I think a type signature will help me see this more concretely.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T16:03:26.556Z
So, there are a couple. There is `generalizeAlgebra[W[_]]: Algebra[F, A] => GAlgebra[W, F, A]`, and `generalizeCoalgebra[M[_]]: Coalgebra[F, A] => GCoalgebra[M, F, A]` – then others for lifting to Elgot algebras and Kleisli variants.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T16:04:22.770Z
Hmm, it looks like we don’t yet have a release that takes advantage of `@group` in Scaladoc. That helps for seeing the generic algebras.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T16:05:11.601Z
It really needs some reorg.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T16:05:50.736Z
Ah, wait, we do – I was just on an old Scaladoc: https://oss.sonatype.org/service/local/repositories/releases/archive/com/slamdata/matryoshka-core_2.11/0.11.0/matryoshka-core_2.11-0.11.0-javadoc.jar/!/index.html#matryoshka.package

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T16:06:16.450Z
The bottom of that “Algebras & Coalgebras” section has a few generic algebras.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T16:07:02.653Z
oh right, all the "general algebra" stuff is new to me.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T16:08:26.809Z
Mostly I add stuff as I need to use it. At some point I’d like to go through and fill in all the gaps.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T16:11:03.649Z
got it, I think this makes it more clear.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T16:11:13.979Z
fortunately, functors compose.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T16:11:51.188Z
so I see what you mean by some of these benefits really coming from the fact we're working with functors (and less from the recursion scheme part)

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T16:13:50.669Z
Yeah, so functors let you use the same structure for a “bare” AST and an annotated one (see Brian McKenna’s post on bottom-up type annotation). But recursion schemes let you avoid building the annotated AST at all.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T16:14:46.794Z
I just realized, there's no Functor instances on Mu or Nu using the underlying functor.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T16:15:16.924Z
is that just an oversight?  Or is it not possible to make them (which at this point I wouldn't suspect is true)?

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T16:17:07.009Z
wait, I just realized that question doesn't typecheck (kinds mixed up)

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T16:17:29.022Z
I thought it was, but must be on a branch that has other in-progress stuff ;)

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T16:18:19.659Z
okay, it seems like we can get a functor instance, but Mu[F] is not the right kind `(* -> *)`

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T16:19:20.504Z
Ok … so my connection is bad and at least one message dropped …

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T16:19:24.675Z
this one: @shajra Ah, just not published yet – You get a `Functor[Mu[F[?, ?]]]` from a `Bifunctor[F]`, etc.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T16:20:20.378Z
`Functor[λ[α => Mu[F[α, ?]]]]`, that is.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T16:20:39.695Z
thanks, makes more sense now.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T16:21:53.846Z
That works for Traverse and its supers … trying to figure out if there’s an incantation where `Bimonadish[F] => Monad[λ[α => Mu[F[α, ?]]]]`.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T16:22:07.726Z
cool.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T16:24:03.972Z
I'm looking for a small example that makes the abstraction benefits of recursion schemes shine (in a presentation)

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T16:25:09.607Z
I need to read Brian's post.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T16:25:56.926Z
@shajra My “Efficient Nanopass Compilers” talk (https://github.com/sellout/recursion-scheme-talk) has an example of the same code with three different approaches.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T16:26:31.635Z
I should really fix the outline to use the proper syntax for Coproduct/Inject.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T16:28:16.909Z
cool, let me look at that too.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T16:30:45.056Z
I like that Org-mode with notes renders on Github the way it does.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T16:31:56.764Z
Yeah, me too. I’m still working on getting to the point where org-mode gives me both a polished presentation and a polished blog post. Getting there, though. Having epresent actually show speaker notes during the presentation would be great. Trying to add that.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T20:05:03.679Z
@sellout that talk was really helpful in seeing the benefit of this approach -- especially when using Coproduct.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T20:32:19.089Z
There are a lot of pieces that fit together really well – recursion schemes, coproducts, ABTs, invertible-syntax, etc.

                                                                                                                                                      Suhail Shergill @suhailshergill@2016-06-24T20:32:46.007Z
@sellout whoa. github's org mode renderer now shows inline images?

                                                                                                                                                      Suhail Shergill @suhailshergill@2016-06-24T20:35:49.537Z
@sellout unfortunately not. i'd planned to pitch my tagless final talk again, but then life intervened (have recently moved to a different role, and so that's been taking a lot of time)

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T20:56:02.800Z
Ah yeah, understandable. I’ll be talking about Matryoshka there.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T02:40:28.039Z
@sellout reading more of your presentation, and I'm a bit confused about how `(Let :+: F)[Fix[F]]` matches directly with a `Let(...)` pattern match.  are there custom extractors for Coproduct?

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T02:40:51.802Z
I know loosely about Coproduct, but haven't used it in a Scala project.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T02:55:59.638Z
so many implementations with the name ':+:'

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T02:56:05.778Z
one in Scalaz and one in Shapeless.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-25T02:56:23.560Z
@shajra I edited things for slide space, but also that section was just sloppy. The way we _really_ do it is just `Let[Fix[F]] => F[Fix[F]]`, then we have a function: `(G :<: H) => (G[A] => H[A]) => (H[A] => H[A])`

                                                                                                                                                      Greg Pfeil @sellout@2016-06-25T02:56:40.250Z
(where `Let :<: F`, of course)

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T02:56:50.828Z
awesome.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T02:57:07.852Z
part of me always distrusts the compiler in my head before distrusting the compiler in other people's head.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T02:57:13.476Z
not always a sound way to go.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-25T02:57:46.251Z
One of the selling points of Haskell is that it fits on slides better, but that doesn’t go over at a Scala conference ;)

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T02:57:52.402Z
right.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T02:58:09.001Z
at some point, I think the important part is really the type signatures.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-25T02:58:26.114Z
But I also need to start using Babel with my org-mode stuff to keep me honest.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T02:58:27.418Z
with a lot of ... for the implementation and a link to a source repo.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T02:58:43.116Z
right, I use tut for all my presentations for this reason.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T02:58:47.777Z
(when in Scala)

                                                                                                                                                      Greg Pfeil @sellout@2016-06-25T02:59:05.849Z
Even if I hide stuff in the slides, it’ll compile in the repo :)

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T02:59:25.823Z
but it has one side-effect, which is that you have to introduce stuff in dependency order, which is sometimes good for comprehension, sometimes a distraction.

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-06-25T07:14:47.345Z
Out of interest: What level of education do the users of this library have?

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T07:18:16.287Z
@mgttlinger I've definitely seen people of all kinds of backgrounds pick this stuff up.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T07:19:34.864Z
So I almost don't want to admit to my education, because while it's helpful, it also seems besides the point.

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-06-25T07:24:13.634Z
I think a background in theoretical computer science mostly helps in seeing a need for it.

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-06-25T07:34:31.629Z
For example I currently am in my master studies in computer science and started focusing on the theoretical part of the field. From talking to other students about topics in that direction, I get the sense I have acquired above average knowledge there, but I am still struggling at understanding the recursion schemes talk which was mentioned further up.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T14:11:03.131Z
I think what might help your perspective is to meet people in the same boat as you coming at this material without an academic background.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T14:16:08.396Z
My belief is that graduate school is sometimes a consequence of a personal motivation and ability to learn.  So it makes sense that people into recursion schemes may also have been interested in other things you can get from graduate school.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T14:16:38.011Z
But that thinking makes it more of a correlation than a cause.

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-06-25T14:22:56.994Z
That may be helpful.

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-06-25T14:24:27.811Z
So far I haven't even met people at the university which are really interested in that topic.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T14:27:36.381Z
The emphasis in various topics varies a lot from school to school.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T14:29:00.840Z
In that regard, there's more homogeneity with FP conferences, including the industry ones.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T14:30:54.514Z
I bet a lot of people found Free monads more from blogs and talks, for instance.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T14:32:45.533Z
Which leads a community that's academic-friendly, but not really academic (not publishing, for instance).

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-06-25T14:33:15.287Z
As traveling to conferences out of my own pocket as a student is difficult I mostly try to read literature on those topics ond follow conversations in chats like this.

                                                                                                                                                      Torsten Scholak @tscholak@2016-06-25T14:45:42.562Z
May I chime in?

                                                                                                                                                      Torsten Scholak @tscholak@2016-06-25T14:46:42.933Z
Are there any review articles or book (chapters) that could be recommended to a beginner?

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T14:59:10.688Z
@tscholak in recursion schemes, you mean?

                                                                                                                                                      Torsten Scholak @tscholak@2016-06-25T14:59:36.256Z
Yes

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T15:02:31.313Z
@sellout's talks seemed pretty good as an intro to me.

                                                                                                                                                      Torsten Scholak @tscholak@2016-06-25T15:05:26.116Z
Alright, I'll start there :) thanks.

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-06-25T15:21:34.086Z
In the example from the talk when the recursion is removed from `Expr`. By pulling the type of the nested expressions into a type parameter (I hope that are somewhat understandable terms for what happened) don't we loose type safety of the built language as we now can write expressions that wont compile (in the sense of the `eval` method being the compiler) like `Mul "nope" "notexp"` when we really want to only have other nested expressions?

                                                                                                                                                      Suhail Shergill @suhailshergill@2016-06-25T15:30:29.127Z
agreed
:point_up: [June 25, 2016 10:16 AM](https://gitter.im/slamdata/matryoshka?at=576e92288c9263ba30e5aac0)

                                                                                                                                                      Greg Pfeil @sellout@2016-06-25T16:01:23.850Z
@mgttlinger Part of the point is that we _don’t_ only want nested expressions. And isn’t “not compiling” the definition of type safety? You could have written `Mul “nope” “notexp”` with the traditional definition, but you’d just get a type error in a different place.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-25T16:05:52.333Z
The idea of “pattern functors” – the removal of recursion from a data type – is useful beyond just recursion schemes, and in fact is somewhat unnecessary for recursion schemes (impl. in Scala pending 😆). But it allows for composition of recursive structures. E.g., one of the things we do at SlamData is separate the data model from the rest of the AST, so we can say something like `eval: Data :+: Operations ~> Data`. And don’t have to define the Data bits in two places.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-25T16:06:53.157Z
Brian McKenna’s post: https://brianmckenna.org/blog/type_annotation_cofree is another example, using pattern functors to allow arbitrary annotation on the nodes of a tree (and his example gets even more compelling, IMO, if you add recursion schemes to the mix).

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-06-25T17:15:34.673Z
@sellout Well if it doesn't compile or crash at runtime depends on the implementation of the `eval`function I think. I am sure there are cool benefits from doing it that way but I still need to get used to this "level of abstraction" to see the pros and cons.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T17:43:50.921Z
@mgttlinger you're not alone.  I think the tests and examples of Matroyshka illustrate that the complexity can be most factored into library code.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T17:44:46.649Z
You /could/ complain about complexity in the types, but there's a counter-argument that parametricity kicks in, so you get more out of "following the types"

                                                                                                                                                      Greg Pfeil @sellout@2016-06-25T18:32:15.095Z
 I've been unhappy with the way a lot of tests look, because building up an example structure is _ugly_. But you tend not to do that in real code, just one or two layers at a time and the transformations handle the noisy bits.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-25T19:56:57.070Z
I don’t think you can write `eval` in a way that would crash at runtime (I mean, other than `sys.error` or something). It is type safe. In the cases where you do want a recursive type, you use `Mu[Expr]`, which is equivalent to the old `Expr`. But now you have other ways to use it, too. In the same way that `List[A]` isn’t less type safe than explicitly defining `IntList`, etc..

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-06-25T20:57:35.996Z
@sellout When you write eval to match on the `Expr` you could reach a point where you have no match defined for e.g. a `Add` between different types than `Expr`, but yeah that would be a rather naive implementation.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-25T20:58:30.281Z
@mgttlinger I don’t understand. Could you give an example?

                                                                                                                                                      Greg Pfeil @sellout@2016-06-25T21:00:31.716Z
`eval: Expr[Int] => Int` expects arguments of the form `Add(1, 3)` exhaustiveness checking should ensure that you’ve covered all the alternatives in `Expr`.

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-06-25T21:03:48.265Z
```scala
def eval(program: Expr[_]): Int = program match {
  case Mul[Expr[_]](a, b) => eval(a) * eval(b)
  case Add[Expr[_]](a, b) => eval(a) + eval(b)
  case Num(i) => i
}
```
This should fail at runtime when applied to something that is not entirely built from our `Expr` syntax, right?

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-06-25T21:04:37.176Z
I mean that implementation is obviously flawed but it looks correct at first glance.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-25T21:05:03.953Z
@mgttlinger Won’t that fail at compile time, complaining about erasure? Or at least not being exhaustive.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-25T21:06:11.405Z
I would say that the `_` makes it look flawed at first glance.

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-06-25T21:06:32.647Z
But those are just warnings, aren't they? But I get your point.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-25T21:07:31.440Z
Are those warnings? Exhaustiveness seems like it should be an error. But we treat all warnings as errors, so I don’t really know where the line is.

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-06-25T21:07:50.039Z
You don't prevent writing (syntactically) incorrect programms directly, but prevent them from being compiled/executed.

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-06-25T21:08:02.014Z
I'm not sure also.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-25T21:10:55.988Z
But you’d have the same problem with something like `sum(l: List[_]): Int = { case Cons[Int](h, t) =>  h + sum(t); case Nil => 0 }`, no? I.e., that seems more like a Scala bug, which I guess could be abused, but I’m going to deny that it’s an issue with the approach ;)

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-06-25T21:11:59.847Z
Unrelated question: Terms like `Mu` and `Nu` are used like they are common sense.  From what context do these greek letters come because I'm not familiar with those?

                                                                                                                                                      Greg Pfeil @sellout@2016-06-25T21:14:00.105Z
I’m not sure, either, other than they’re used in the papers and Haskell libs. `Fix` is clearer, IMO, but its semantics are bad.

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-06-25T21:18:14.476Z
Fixpoints are also something which I feel like I only have a basic understanding of which needs to be improved. My understanding of a fixpoint is that it is the set of inputs where every element is mapped onto itself by the morphism in question. Is that correct?

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T21:24:53.012Z
Reading the banana paper, it gets crazier than just mu/nu.  It's like like Erik and company got inspired by funny symbols he found LaTeX would typeset.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-25T21:24:53.145Z
@mgttlinger Yeah, so, the Y combinator is a value-level fixed-point operator, right? `Y f = f (Y f)`, and Mu/Nu/Fix are the same thing at the type level.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-25T21:25:24.935Z
@shajra Seriously. Glad we don’t have barbedWireMorphism as a result ;)

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T21:25:29.163Z
Be careful with a straight Y in a strict language.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-25T21:26:38.043Z
@shajra Indeed, but that’s just to illustrate the `x = f x`-ness, and the parallel to `Fix f = f (Fix f)`.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T21:27:01.274Z
Right, makes sense.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-26T04:16:45.332Z
I just reached a reminder that a `tail` function for Mu[ListF] is O(n).  Is this just the way it is, or is there a common remediation?

                                                                                                                                                      Sukant Hajra @shajra@2016-06-26T04:17:16.198Z
I mean, there's always just using a normal List if you need those asymptotics.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-26T04:59:03.693Z
I _think_ that’s just the way it is. But I also think it’s not as bad as it seems. E.g., traversing the list is still O(n). It’s just that the structure is effectively a suspended foldRight, so getting the tail requires traversing the structure. Also, in the middle of composed transformations, you usually don’t build up recursive structure.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-26T04:59:59.432Z
It’s a good reminder, though. I definitely see `.project` and think of it as a cheap operation, but it’s not necessarily. Same for `.embed` on Nu.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-26T05:05:31.553Z
Actually, nvm on the .embed bit.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-26T05:35:37.212Z
Yeah, it kind of flips for Nu.

                                                                                                                                                      Cody Allen @ceedubs@2016-06-29T01:53:18.895Z
As I start to play around with recursion schemes I feel like they are either going to allow me to move stack safety concerns to a central location or they are going to be completely incompatible with stack safety and all of my apps are going to be a ticking time bomb. I'm hoping it's the former but fearing the latter. Any good news here?

                                                                                                                                                      Greg Pfeil @sellout@2016-06-29T02:39:16.924Z
@ceedubs I’m hoping for the former, too 😉 I do think it’s likely, though that you can handle it exclusively in the fixed-point types. E.g., tramplining `Fix` seems trivial – just haven’t had a need to yet.

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-06-30T09:15:20.840Z
Any recommendations for introductory material on fixpoint theory?

                                                                                                                                                      Lars Hupel @larsrh@2016-09-07T11:05:05.903Z
Would something like an ANF transformation for syntax trees (see [here](http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/blog/2016/09/05/normal-forms.lhs/)) expressible with Matryoshka?

                                                                                                                                                      Greg Pfeil @sellout@2016-09-09T17:50:31.120Z
**\[Jean-Remi Desjardins, SlamData Inc.\]** Wow!
looking at `ShowT` and somewhat surprised, there must be something I am missing:
```
@typeclass trait ShowT[T[_[_]]] {
  def show[F[_]: Functor](tf: T[F])(implicit del: Delay[Show, F]): Cord =
    Cord(shows(tf))

  def shows[F[_]: Functor](tf: T[F])(implicit del: Delay[Show, F]): String =
    show(tf).toString

  def showT[F[_]: Functor](delay: Delay[Show, F]): Show[T[F]] =
    Show.show[T[F]](show[F](_)(Functor[F], delay))
}
```
Aren’t `show` and `shows` jus calling themselves recursively, how can that ever terminate?

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-09-10T06:39:07.843Z
Afaik you are supposed to overwrite one of the two "to break the loop" but it's up to you which one you want to overwrite

                                                                                                                                                      Greg Pfeil @sellout@2016-09-10T16:09:27.184Z
**\[Jean-Remi Desjardins, SlamData Inc.\]** @mgttlinger Thx! That is indeed the intent as confirmed by @sellout offline. Unfortunately, unlike Haskell, the Scala is not smart enough to know that needs to happen though :\( We should probably add a comment to add that intent since I don’t think it’s a common pattern in Scala.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T15:19:17.818Z
**\[Moss Prescott, SlamData Inc.\]** I'm finding that it's annoying to have to require a `Functor[F]` when I need to do `.project` on some `Fix[F]`, because the `Recursive[Fix].project` doesn't _actually_ need `F` to be a functor. NB, it actually is a Functor, so there's no real problem, it's just littering my code with `: Functor` where it wouldn't otherwise be needed.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T15:22:17.800Z
**\[Moss Prescott, SlamData Inc.\]** I guess what I want is to be able to require Functor only on the `Recursive.project` for the types where it's actually needed, which I guess is `Mu` and `Nu`. But that's not how typeclasses work, because you can't require the Functor on the `Recursive` instance, because `F` isn't known there, and you can't require it on only _some_ of the `project` definitions, because Scala. Not sure if Haskell would impose the same constraint.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T15:27:12.450Z
**\[Moss Prescott, SlamData Inc.\]** Thinking out loud, what you'd need to be able to express is "I'll give you a Recursive instance for T, but when I do its `project[F[_]]` will require `Functor[F]`". Which sounds like two different `Recursive` types, so I guess that's the rub. And unless the other operations on Recursive could be similarly generalized for the "general recursion" forms, then it's probably not worth the trouble.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T15:27:16.502Z
**\[Moss Prescott, SlamData Inc.\]** Thanks for listening ;\)

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T15:51:59.528Z
**\[Greg Pfeil, SlamData Inc.\]** @mprescot But the point with `Recursive` is that you don’t know if you have `Fix` or not. If you want to `project` from `Fix`, use `unFix`. But in Quasar we’ve been moving away from using `unFix`, because we want to move away from knowing about `Fix`. It should be `T[_[_]]: Recursive`.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T15:55:17.149Z
**\[Moss Prescott, SlamData Inc.\]** @sellout: Yes, I see that. I was writing to T\[\_\[\_\]\] but happened to know it would only be applied to Fix. But obviously I can't have it both ways.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T15:57:06.426Z
**\[Greg Pfeil, SlamData Inc.\]** @mprescot Yeah, you only know that because we haven’t fixed enough of the code yet. I had Quasar using `Mu` for `compile` for about two commits, until we realized that instantiating a new parser for each request was not a good idea. So more has to happen to make it actually flexible.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T15:59:35.140Z
**\[Moss Prescott, SlamData Inc.\]** Right. Well, I'll keep moving to `T[_[_]]` when I can and try to leave `Fix` only at the "top" where things are relatively static so far. I'm trying to make more incremental changes this time but still touching a lot of code as it is.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T16:06:45.525Z
**\[Moss Prescott, SlamData Inc.\]** @sellout: next question: I have an algebra that gets applied to a coproduct. Therefore the signature looks like this: `def foo[G[_]: Functor](arg: ...)(implicit inj: Inj[F, G]): Algebra[F, Fix[G]]`. That means you always have to apply it like this: `cp.cata(Typeclass[CP].foo[CP])`. That seems dumb, so I'm tempted to define a wrapper that applies `cata`, and  provides the type, as in `fooNotF(arg: ...)(t: T[F]): T[F] = t.cata(foo(arg))`

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T16:07:24.486Z
**\[Moss Prescott, SlamData Inc.\]** But it seems like matryoshka purity would call for _just_ defining the algebra and letting the caller think about cata.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T16:09:09.053Z
**\[Moss Prescott, SlamData Inc.\]** I can't capture that type without also defining the not-an-algebra function, I think.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T16:09:17.596Z
**\[Greg Pfeil, SlamData Inc.\]** @mprescot I think you should look at some of the type classes on QScript – it can be simpler than that. You need an instance on `Coproduct` itself. Then you don’t need the `inj` constraint … at least, I _think_ that’s what you’re trying to do.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T16:10:17.785Z
**\[Moss Prescott, SlamData Inc.\]** I have an instance for Coproduct. I need to be abel to inject because the algebra is a simplification, which builds new trees consisting of nodes from one of the types in the coproduct.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T16:10:53.838Z
**\[Moss Prescott, SlamData Inc.\]** @sellout: Probably we should just go over this code together when it'

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T16:11:48.523Z
**\[Moss Prescott, SlamData Inc.\]** Or maybe you

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T16:12:02.369Z
**\[Greg Pfeil, SlamData Inc.\]** Yeah, I’d like to. My guess is you really want `G` as an associated type, but I guess that doesn’t clean things up at all. That’s what we do in the QScript instances. You could add a second `apply` on the companion object for when F and G are the same.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T16:13:38.299Z
**\[Moss Prescott, SlamData Inc.\]** The typeclass

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T16:13:41.288Z
**\[Greg Pfeil, SlamData Inc.\]** Which is now something I want to do for QScript …

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T16:13:51.587Z
**\[Greg Pfeil, SlamData Inc.\]** Yea.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T16:14:30.726Z
**\[Greg Pfeil, SlamData Inc.\]** So, using an associated type, it’d look like `Typeclass[CP, CP].foo` – so it just moves the second type parameter.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T16:14:37.605Z
**\[Moss Prescott, SlamData Inc.\]** Oh, you mean, two types on the typeclass. I get it. Yes, I think that would help

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T16:14:47.446Z
**\[Greg Pfeil, SlamData Inc.\]** But with an additional apply, you could maybe do `Typeclass[CP].foo`

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T16:15:50.621Z
**\[Moss Prescott, SlamData Inc.\]** I have two algebras with this pattern, so that might make sense. On the other hand, there are two other simpler algebras, so maybe I have more than one type class here. Sigh.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T16:20:42.143Z
**\[Greg Pfeil, SlamData Inc.\]** Ah, in QScript we’ve been doing a lot of type classes – like one for each algebra. I’ve been meaning to condense some of them, but haven’t looked yet. This is definitely the kind of thing we should add to our style guide, though.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T19:03:39.207Z
**\[Greg Pfeil, SlamData Inc.\]** @mprescot BTW, just tried the two-apply thing, and it didn’t work, because they erase to the same type. But we could give one an explicit name. Should definitely discuss.

                                                                                                                                                      Alex Gryzlov @clayrat@2016-09-12T19:17:01.655Z
somehow the name "matryoshka" feels fitting for this split-personality-style dialogue ;)

                                                                                                                                                      Greg Pfeil @sellout@2016-09-15T21:25:31.818Z
**\[Moss Prescott, SlamData Inc.\]** @Here: if I want to define "macros" of 1, 2, and 3 arguments for my language whose nodes are F\[?\] using Free\[F, ...\], do I have to define my own types for the arguments as in `data UnaryArg = Arg; data BinaryArg = Arg1 | Arg2; data TernaryArg = Arg1 | Arg2 | Arg3`? There isn't any type lying around that I can use that way?

                                                                                                                                                      Greg Pfeil @sellout@2016-09-15T21:27:00.784Z
**\[Greg Pfeil, SlamData Inc.\]** Hrmm, I don’t think I understand the question.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-15T21:27:39.565Z
**\[Moss Prescott, SlamData Inc.\]** Haha that's not a good sign.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-15T21:28:53.455Z
**\[Greg Pfeil, SlamData Inc.\]** Are you talking about stuff like the structures we use in QScript? I.e., you’d have `Free[F, UnaryArg]`?

                                                                                                                                                      Greg Pfeil @sellout@2016-09-15T21:28:59.132Z
**\[Moss Prescott, SlamData Inc.\]** I want to write a translator from, e.g. `GenericFunc[_2] => Free[ExprOp, TwoArgs]`

                                                                                                                                                      Greg Pfeil @sellout@2016-09-15T21:29:12.126Z
**\[Moss Prescott, SlamData Inc.\]** Right.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-15T21:29:18.708Z
**\[Greg Pfeil, SlamData Inc.\]** `Free[ExprOp, Boolean]` ;\)

                                                                                                                                                      Greg Pfeil @sellout@2016-09-15T21:29:53.539Z
**\[Moss Prescott, SlamData Inc.\]** Sure, `Unit`, `Boolean`, and uh, `SignedBit`? What could go wrong?

                                                                                                                                                      Greg Pfeil @sellout@2016-09-15T21:30:09.460Z
**\[Moss Prescott, SlamData Inc.\]** Wait, `Ord`.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-15T21:30:28.298Z
**\[Greg Pfeil, SlamData Inc.\]** In QScript we have `Hole` for one arg, `JoinSide` for two … so yeah, I guess define your own. But you could also do something like `T[Coproduct[Const[UnaryArg, ?], ExprOp, ?]]`

                                                                                                                                                      Greg Pfeil @sellout@2016-09-15T21:30:51.791Z
**\[Greg Pfeil, SlamData Inc.\]** Which is what QScript will have to move to when we have mutu-rec available.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-15T21:31:21.722Z
**\[Moss Prescott, SlamData Inc.\]** _looks for brain-exploding emoji_

                                                                                                                                                      Greg Pfeil @sellout@2016-09-15T21:34:37.741Z
**\[Moss Prescott, SlamData Inc.\]** I guess I'll give it a try with my own types. Thanks ;\)

                                                                                                                                                      Torsten Scholak @tscholak@2016-10-03T14:11:42.776Z
Hi, is it true that I cannot separate my dsl into expressions and statements unless https://github.com/sellout/matryoshka/tree/mutually-recursive gets merged?

                                                                                                                                                      Greg Pfeil @sellout@2016-10-03T14:26:06.942Z
You can (and SlamData does), but it’s awkward. I’m planning to finish up and merge that branch soon, but it might still be like two weeks out.

                                                                                                                                                      Greg Pfeil @sellout@2016-10-03T14:30:48.941Z
@tscholak ^

                                                                                                                                                      Torsten Scholak @tscholak@2016-10-03T14:48:25.592Z
hmmm, thank you. I'm just starting with my design, and I guess I can work around this limitation in some way or the other.

                                                                                                                                                      Greg Pfeil @sellout@2016-10-03T14:55:19.086Z
@tscholak So, it’s “easy” to work around if your ADTs and type indices line up (which it sounds like they might for you). You can still make `Expr[A]` and `Stmt[A]`. Then you have a couple options.

                                                                                                                                                      Torsten Scholak @tscholak@2016-10-03T14:58:41.285Z
ah, I see. ok, good to know. Can I ask you for a link to a quasar source file with mutually recursive awkwardness?

                                                                                                                                                      Greg Pfeil @sellout@2016-10-03T14:58:48.800Z
1. you could still `Coproduct` them together, as you would for mutual-rec, but it means they can be arbitrarily intermingled, and you might need to protect against that with some other mechanism. Or, 2. you could pass around the fixed point operator. E.g., `Expr[T[_[_]], A]` and `Stmt[T[_[_]], A]` then, you might have something like `case class Block[T[_[_]], A](stmts: T[Stmt], result: A) extends Expr[T, A]` and `case class Assign[T[_[_]], A](name: String, value: T[Expr]) extends Stmt[T, A]`.

                                                                                                                                                      Greg Pfeil @sellout@2016-10-03T15:02:38.036Z
@tscholak Here’s a place with some of that: https://github.com/quasar-analytics/quasar/blob/master/connector/src/main/scala/quasar/qscript/QScriptCore.scala#L32. The types FreeMap and FreeQS are places that _should_ use mutual recursion. The FreeMap case is similar to what I was describing, whereas FreeQS is a _more_ awkward case where the ADT and indices don’t actually line up – which is the primary motivation for wanting mutual-rec.

                                                                                                                                                      Greg Pfeil @sellout@2016-10-03T15:04:20.449Z
The FreeMap type is a fixed-point of the type in https://github.com/quasar-analytics/quasar/blob/master/connector/src/main/scala/quasar/qscript/MapFunc.scala#L550, which has yet another ADT, `EJson` (representing literals), so you can see how that `T` is passed all the way down to be used as the fixed-point operator there.

                                                                                                                                                      Greg Pfeil @sellout@2016-10-03T15:05:40.923Z
FreeMap and FreeQS are a bit different from just using `T`, as they fake mutual-rec even a bit more, effectively giving a type like `Coproduct[Const[Hole, ?], F]`.

                                                                                                                                                      Greg Pfeil @sellout@2016-10-03T15:06:01.277Z
But let’s just say mutual-rec would help SlamData a lot, so I’m motivated to get it done 😄

                                                                                                                                                      Torsten Scholak @tscholak@2016-10-03T15:07:12.236Z
thank you very much. I now have to go and digest this stuff :) thanks a lot!

                                                                                                                                                      Greg Pfeil @sellout@2016-10-03T15:08:49.365Z
Sure, no problem. Feel free to ask anything.

                                                                                                                                                      Torsten Scholak @tscholak@2016-10-04T14:22:32.683Z
hm, so if I do something like this,
 ```
sealed trait Expr[T[_[_]], A]

sealed trait Stmt[T[_[_]], A]

final case class AssignDeterministically[T[_[_]], A](name: scala.Symbol, value: T[Expr]) extends Stmt[T, A]
```
to get mutual recursiveness, then scala complains that, in the last line, `Expr` takes one type argument. I can't replace `Expr` by `Expr[T, A]`, because these would be two type arguments. `Expr[T, ?]` compiles so far, but I think that may cause problems later. 
So I guess I have to say `Expr[T[_[_, _]], A]`, `Stmt[T[_[_, _]], A]`.

                                                                                                                                                      Greg Pfeil @sellout@2016-10-04T14:38:38.655Z
@tscholak You should use the kind-projector compiler plugin, then you can write `T[Expr[T, ?]]` … sorry I left out that bit of noise yesterday.

                                                                                                                                                      Greg Pfeil @sellout@2016-10-04T14:39:04.202Z
But that’s the annoying thing – you have to explicitly pass the `T` around.

                                                                                                                                                      Torsten Scholak @tscholak@2016-10-04T14:39:56.499Z
ah, ok, so `Expr[T, ?]` is the answer. cool

                                                                                                                                                      Torsten Scholak @tscholak@2016-10-04T14:41:04.700Z
I didn't see something like that in quasar. `EJson` is a coprodut of something and a `sealed trait Extension[A]`. So it's not really "mutually" recursive.

                                                                                                                                                      Torsten Scholak @tscholak@2016-10-04T14:41:51.728Z
btw, do you happen to know if ensime works with kind-projector?

                                                                                                                                                      Greg Pfeil @sellout@2016-10-04T15:32:44.706Z
**\[Greg Pfeil, SlamData Inc.\]** It works reasonably well with kind-projector ;\)

                                                                                                                                                      Sumedh Mungee @smungee@2016-10-19T00:44:06.994Z
Anyone see any issues using matryoskha with scalaz 7.2.2 (currently matryoshka is being built with 7.2.1)

                                                                                                                                                      Sumedh Mungee @smungee@2016-10-19T00:45:14.734Z
(Awesome library, I'm here after watching @sellout's talk at Scala North.)

                                                                                                                                                      Greg Pfeil @sellout@2016-10-19T00:47:29.532Z
@paulp submitted #36 with some updates, but it doesn’t update scalaz. Could have been an oversight, or might have been related to julien-truffaut/Monocle#399.

                                                                                                                                                      Sumedh Mungee @smungee@2016-10-19T00:50:36.186Z
Looks like @paulp tried to update it to 7.2.6 (which is the latest stable scalaz-core version), but then reverted it: https://github.com/slamdata/matryoshka/pull/36/commits/7da3483ffe600350fe0aef945624e51f3e226ad0

                                                                                                                                                      Greg Pfeil @sellout@2016-10-19T00:52:58.265Z
**\[Greg Pfeil, SlamData Inc.\]** Ah, good eye.

                                                                                                                                                      Sumedh Mungee @smungee@2016-10-19T00:52:58.923Z
"sbt test" passes for me, both with scalaz 7.2.2 and with scalaz 7.2.6

                                                                                                                                                      Sumedh Mungee @smungee@2016-10-19T00:55:06.999Z
That monocle issue has been fixed: https://github.com/julien-truffaut/Monocle/issues/399

                                                                                                                                                      Greg Pfeil @sellout@2016-10-19T00:56:03.955Z
Cool, so I should get @paulp to update his PR with the new Monocle and get scalaz, etc. updated again.

                                                                                                                                                      Sumedh Mungee @smungee@2016-10-19T00:56:53.724Z
awesome.. 

                                                                                                                                                      Paul Phillips @paulp@2016-10-19T05:52:09.043Z
Ugh, I tried and it blew up on a binary incompatibility which I could not figure out. 

                                                                                                                                                      Sumedh Mungee @smungee@2016-10-19T08:37:06.493Z
btw monocle 1.3.0 has now moved to scalajs 0.6.13, which needs matryoshka to do the same.. 

                                                                                                                                                      Paul Phillips @paulp@2016-10-19T15:56:17.305Z
I pushed another commit to https://github.com/slamdata/matryoshka/pull/36 and maybe someone else can see what I'm missing because I don't know what the problem is.

                                                                                                                                                      Paul Phillips @paulp@2016-10-20T06:08:49.822Z
Here is the problem: scalacheck 1.12.5. https://repo1.maven.org/maven2/org/scalaz/scalaz-scalacheck-binding_2.11/7.2.6/scalaz-scalacheck-binding_2.11-7.2.6.pom

                                                                                                                                                      Greg Pfeil @sellout@2016-10-20T16:17:17.550Z
**\[Jean-Remi Desjardins, SlamData Inc.\]** See [https://github.com/quasar-analytics/quasar/issues/1609](https://github.com/quasar-analytics/quasar/issues/1609)

                                                                                                                                                      Paul Phillips @paulp@2016-10-22T17:31:51.216Z
I updated the build PR with some Cogen efforts. Definitely not done, but I let it sidetrack me too long already.

                                                                                                                                                      Rob Norris @tpolecat@2016-10-31T18:08:53.998Z
@sellout ok so you can define `ana/anaM` for `Cofree` but you can't define `embed` so it's not corecursive. Is there a name for such things or is it just a special case? Or am I horribly confused?

                                                                                                                                                      Rob Norris @tpolecat@2016-10-31T18:15:14.253Z
Well, I mean. I'm certainly horribly confused. But with some luck that's an orthogonal concern.

                                                                                                                                                      Greg Pfeil @sellout@2016-10-31T18:22:54.053Z
**\[Greg Pfeil, SlamData Inc.\]** Cofree can be Corecursive, but it requires the changes from one of the PRs … something about directly-recursive types.

                                                                                                                                                      Greg Pfeil @sellout@2016-10-31T18:23:51.781Z
**\[Greg Pfeil, SlamData Inc.\]** Basically, the Functor of the fixed point in that case isn't just F, but rather CoEnv\[F\].

                                                                                                                                                      Greg Pfeil @sellout@2016-10-31T18:24:13.830Z
**\[Greg Pfeil, SlamData Inc.\]** Sorry, EnvT\[F\].

                                                                                                                                                      Rob Norris @tpolecat@2016-10-31T18:24:37.554Z
I see, ok. That's interesting.

                                                                                                                                                      Rob Norris @tpolecat@2016-10-31T18:25:29.680Z
Hey are you staying at the Holiday Inn Civic Center for SBTB?

                                                                                                                                                      Rob Norris @tpolecat@2016-10-31T18:25:54.755Z
I'd like to talk through some of this stuff with you so I can sound more like I know what I'm talking about in my talk.

                                                                                                                                                      Rob Norris @tpolecat@2016-10-31T18:26:14.946Z
Which is sadly scheduled after yours. So you can offer mine as a lifeboat for people in your talk I guess.

                                                                                                                                                      Greg Pfeil @sellout@2016-10-31T18:49:26.912Z
Heh – yeah, trying to make my talk a bit less … confusing this time. Focusing on usage more. We'll see.

                                                                                                                                                      Greg Pfeil @sellout@2016-10-31T18:50:32.153Z
I'm not sure where I'm staying – might commute back to Cupertino or crash with SF friends. But I'll keep the Holiday Inn in mind.

                                                                                                                                                      Greg Pfeil @sellout@2016-10-31T18:51:06.159Z
Happy to talk about it whenever, and hoping to get some of those PRs merged this week.

                                                                                                                                                      Sumedh Mungee @smungee@2016-10-31T23:45:23.547Z
Any ideas on how to serialize a `Fix`-based tree into JSON? We use upickle as our serializer, but it can't serialize a `Fix[Expr]`

                                                                                                                                                      Sumedh Mungee @smungee@2016-10-31T23:46:48.508Z
I have an `Expr` class that is very similar to the `Exp` and `Exp2` classes in matryoshka. Before making the change from `Expr` to `Expr[A]`, upickle had no trouble serializing it..

                                                                                                                                                      Greg Pfeil @sellout@2016-11-01T02:08:30.975Z
@smungee I don’t know anything about upickle, but we generally pretty-print with an algebra like `Expr[String] => String`. If you’re actually converting to some JSON AST, then similarly `Expr[Json] => Json` (aka. `Algebra[Expr, Json]`)

                                                                                                                                                      Greg Pfeil @sellout@2016-11-01T02:18:02.792Z
For actual `Serializable`, I think we could provide that, although haven’t looked into it.

                                                                                                                                                      Sumedh Mungee @smungee@2016-11-01T04:42:54.210Z
@sellout I don't need Serializable. We're converting to a JSON AST. I guess we could write `Expr[Json] => Json` but our Expr is huge (hundreds of classes), and upickle can generate JSON automatically for us. 

                                                                                                                                                      Sumedh Mungee @smungee@2016-11-01T04:43:46.615Z
Basically our `Expr` is exchanged across service boundaries, and so it needs to be written and read from JSON 

                                                                                                                                                      Sumedh Mungee @smungee@2016-11-01T04:47:48.676Z
Is there any way to take a `Fix`-ed tree and convert it into a tree that is only `Expr`? Then it can be easily JSON-ified by any library..

                                                                                                                                                      Greg Pfeil @sellout@2016-11-01T04:49:35.124Z
Oh, there is a `matryoshka.toTree` algebra – from `fixed.cata(toTree)` is `Fix[F] => Tree[F[Unit]]`. Would that work?

                                                                                                                                                      Sumedh Mungee @smungee@2016-11-01T07:06:20.516Z
That looks promising! Will try it out. :)

                                                                                                                                                      Pawel Szulc @rabbitonweb@2016-11-06T22:11:31.804Z
@sellout btw can u post ur slides online from Scala Up North? I hve the video but it's really hard to follow the slides on the recording

                                                                                                                                                      Greg Pfeil @sellout@2016-11-06T22:13:47.454Z
**\[Greg Pfeil, SlamData Inc.\]** I thought they were posted … hold on.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-06T22:14:08.428Z
**\[Greg Pfeil, SlamData Inc.\]** [https://github.com/sellout/recursion-scheme-talk/blob/master/fix-ing-your-types.org](https://github.com/sellout/recursion-scheme-talk/blob/master/fix-ing-your-types.org)

                                                                                                                                                      Greg Pfeil @sellout@2016-11-06T22:15:34.368Z
**\[Greg Pfeil, SlamData Inc.\]** \(the text doesn’t necessarily line up with the talk – that’s mostly notes as I put the talk together\)

                                                                                                                                                      Greg Pfeil @sellout@2016-11-06T22:32:30.900Z
*phew* _finally_ got #21 compiling and passing all tests. This is a big deal for Quasar, and Matryoshka in general.

                                                                                                                                                      Paul Phillips @paulp@2016-11-06T22:40:14.999Z
@sellout Nice job! Sorry but not that sorry that you managed it before I had a chance to look at it.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-06T22:41:19.707Z
Heh, I’m sure – I’m hoping you can still make it better, though ;)

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T00:17:13.150Z
@tpolecat So, during my talk, you asked about Functor/Foldable/etc. and I mentioned that if you have Bifoldable on the pattern functor, you have Foldable on the fixed-point.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T00:17:34.299Z
Which is true … but, I don’t know how to generalize it as much as I’d like.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T00:19:44.886Z
I.e, you get `Foldable[λ[A => Fix[F[A, ?]]]` for free, but I can’t figure out how to give you `Foldable[Cofree[F, ?]]` for free, because I can’t tie it to the `EnvT[?, F, ?]` pattern functor – it’s not exposed in directly-recursive types the way it is in fixed-point types.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T00:20:11.085Z
So, if anyone has any ideas on how to define that … I’m all ears.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T00:28:24.156Z
Also, while I’m here: implementing `Birecursive[T] extends Recursive[T] with Corecursive[T]` is on the list, too.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T00:28:43.557Z
Those implicits just won’t resolve.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T00:29:36.401Z
And … apparently that’s enough traffic to shut down my Sameroom connection for the day 😆

                                                                                                                                                      Pawel Szulc @rabbitonweb@2016-11-17T15:51:25.693Z
@sellout is it ok if I add my http://www.slideshare.net/paulszulc/going-bananas-with-recursion-schemes-for-fixed-point-data-types to README?

                                                                                                                                                      Torsten Scholak @tscholak@2016-11-17T15:53:38.094Z
oh, awesome!

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T15:53:41.721Z
Yeah, definitely!

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-11-17T16:14:49.302Z
What is the reasoning for defining the type alias `Algebra` and `Coalgebra`? I guess it captures the notion of the morphism defining the algebra. Maybe I have a wrong intuition about all this but if I read `Algebra[X, Y]` I think of some data structure rather than a morphism that can be used to tear down our data structure.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T16:34:30.262Z
@mgttlinger One of the reasons is that when people first see recursion schemes, the function types look pretty odd – they see `Expr[Int] => Int` in isolation, and have no notion of what to do with it. The aliases let them jump to the definition or Scaladoc and get more context.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-17T16:40:05.563Z
Funny, I have to undo the alias in my head. 

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-11-17T16:41:04.339Z
I guess I'm not familiar enough with the concepts to see why such a morphism can be called an `Algebra`. However I get the use of it as far as the documentation aspect you mentioned.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-17T16:41:12.253Z
I get alias fatigue and prefer to see simple types like that in expanded form because I see them as "words". 

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T16:41:30.448Z
https://en.wikipedia.org/wiki/F-algebra

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T16:41:36.463Z
@mgttlinger ^

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T16:42:11.617Z
@tpolecat In reality, Algebra isn’t too complicated, but GAlgebraM is much easier to see with the alias, IMO.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T16:42:23.080Z
Especially when you get transformers in there, etc.

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-11-17T16:42:36.888Z
> F-algebras can also be used to represent data structures used in programming, such as lists and trees.

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-11-17T16:42:47.122Z
But here we do not represent data structures.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-17T16:43:10.243Z
The thing that blew my mind is that `A` seems to come out of nowhere. 

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T16:44:56.572Z
@mgttlinger I could rename the alias to InitialFAlgebra if that’d clear things up ;)

                                                                                                                                                      Rob Norris @tpolecat@2016-11-17T16:45:04.880Z
Heh. 

                                                                                                                                                      Rob Norris @tpolecat@2016-11-17T16:45:47.710Z
I added "tut doc for matryoshka" to my infinite queue btw. Would be a good way to learn this stuff. 

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T16:46:16.029Z
But I just stole the aliases from Kmett’s recursion-schemes. Initially I used the functions directly, but I had to keep explaining that they were algebras.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T16:46:54.718Z
Once you know what an algebra is, you see `Algebra[F, A]` and say “ah, ok, this lets me fold a recursive F to an A”.

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-11-17T16:47:26.824Z
That would not fit my intuition of initial F-Algebras as well but again my intuition may be wrong :wink: . My intuition of an initial F-Algebra (which is again limited to data types) is that it is somewhat like the set of all possible instances that can be constructed.

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-11-17T16:48:58.231Z
Maybe it is wrong altogether to try to get an intuition about these things.

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-11-17T16:50:37.894Z
When I asked people about the intuition for those things they basically started to draw the commutative squares which did not really give me an intuition.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T16:52:17.538Z
I hope it’s not wrong – although I agree that it’s difficult, and I’m still trying to figure out how to provide one. Remember, though, that all data structures can be modeled exclusively with morphisms. Note that in the Wikipedia entry it says “F-algebras can **also** be used to represent data structures”.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T16:57:41.914Z
In @jdegoes’s Next Functional Programming Language talk, he discussed implementing all data structures as their folds. I don’t have a good reference for that idea, though.

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-11-17T17:01:52.385Z
That's similar to the way Morte implements things, right?

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T17:03:38.635Z
I _think_ so … since it’s basically lambda calc + proofs.

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-11-17T17:04:25.207Z
I will watch that talk when I find the time. Maybe that will clear things up.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T17:05:41.699Z
Well, I wouldn’t say John’s talk is big on explanation – more like “here’s a bunch of interesting ideas to look into” ;)

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-11-17T17:07:08.294Z
But maybe that is enough to make it click :wink: 

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-11-17T17:08:49.221Z
And if not that was probably still time well spent.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-17T17:09:35.057Z
Don't mention Morte. It's too exciting. I can't handle it.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T17:09:47.147Z
😆 Agreed.

                                                                                                                                                      Gabriel Claramunt @gclaramunt@2016-11-17T21:25:37.107Z
I'm trying to do a very similar thing as Matrioshka, but since I'm translating a library from Haskell, I ran into problems 

                                                                                                                                                      Gabriel Claramunt @gclaramunt@2016-11-17T21:27:03.547Z
it works but it has pattern matching on types :/

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T22:24:17.075Z
@gclaramunt Which library are you translating? Matryoshka started as a translation of Kmett’s recursion-schemes … sort of, I guess it actually started as a translation of fixplate, then moved toward recursion-schemes.

                                                                                                                                                      Gabriel Claramunt @gclaramunt@2016-11-17T22:27:37.398Z
Is something that my functional programming professor made, I don't think is public anymore

                                                                                                                                                      Gabriel Claramunt @gclaramunt@2016-11-17T22:27:41.780Z
here is my transaltion

                                                                                                                                                      Gabriel Claramunt @gclaramunt@2016-11-17T22:27:42.543Z
https://github.com/gclaramunt/scala-reggen

                                                                                                                                                      Gabriel Claramunt @gclaramunt@2016-11-17T22:27:59.689Z
but I have troubles with type inferece :)

                                                                                                                                                      Gabriel Claramunt @gclaramunt@2016-11-17T22:29:49.018Z
the haskell version uses type families to get the pattern functor, and then type classes to get the type <-> pattern functor conversions

                                                                                                                                                      Gabriel Claramunt @gclaramunt@2016-11-17T22:29:59.559Z
it only does fold tho

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T22:30:45.359Z
@gclaramunt Ah, recursion-schemes uses an open type family for that, too. In Matryoshka, it’s done with a type member in the type class.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T22:31:29.889Z
@gclaramunt https://github.com/slamdata/matryoshka/blob/master/core/shared/src/main/scala/matryoshka/Recursive.scala#L307

                                                                                                                                                      Gabriel Claramunt @gclaramunt@2016-11-17T22:31:37.998Z
yeah, I did the same since at the end, we need the type class anyway

                                                                                                                                                      Gabriel Claramunt @gclaramunt@2016-11-17T22:32:41.389Z
interesting, because one of my problems is the parametrization on the generic type 

                                                                                                                                                      Gabriel Claramunt @gclaramunt@2016-11-17T22:33:07.746Z
I came to the conclusion I don't know enough Scala for what I'm trying to do :P

                                                                                                                                                      Gabriel Claramunt @gclaramunt@2016-11-17T22:33:48.860Z
but I wanted to look into Matrioshka for inspiration :)

                                                                                                                                                      Gabriel Claramunt @gclaramunt@2016-11-17T22:34:44.724Z
https://github.com/gclaramunt/scala-reggen/blob/master/src/main/scala/reggen/Regular.scala

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T22:37:51.700Z
@gclaramunt Maybe not at all what you want to do – but I’d be willing to help you take advantage of Matryoshka directly (i.e., depend on it). I like unifying these things, but I understand if you just want your own sandbox.

                                                                                                                                                      Gabriel Claramunt @gclaramunt@2016-11-17T22:38:58.388Z
yep, the whole point was an experiment and depending on a already completed library is not what I want :D

                                                                                                                                                      Gabriel Claramunt @gclaramunt@2016-11-17T22:39:03.443Z
but thanks a lot

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T22:40:14.990Z
@gclaramunt So, Rather than using `Regular` as a type (as in `count[Z]: Regular[Z]#PF[Int] => Int`), I would recommend something like `count[Z, F[_]](implicit R: Regular.Aux[Z, F]): F[Int] => Int`.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T22:40:36.600Z
This is something @mandubian helped me with a while ago – I too had impossible implicit resolution.

                                                                                                                                                      Gabriel Claramunt @gclaramunt@2016-11-17T22:41:33.339Z
yeah, makes sense

                                                                                                                                                      Gabriel Claramunt @gclaramunt@2016-11-17T22:41:56.770Z
will try that, thanks !

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T22:42:20.601Z
Sure – let me know if you need any help with the details :)

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-21T19:55:58.713Z
this library isn't available for cats yet, right?

                                                                                                                                                      Greg Pfeil @sellout@2016-11-21T19:56:30.794Z
Correct – although recent changes _should_ make it easier to support both Cats & Scalaz.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-21T19:58:53.826Z
I want to make matryoshka-cats and -scalaz projects, and start pushing down the easy stuff – e.g., instances for the types in those libraries. Then there are some concrete data dependencies (e.g. `Free` in `futu`) that I _hope_ I can turn into type class constraints but, failing that, I can probably push them down as well, with implicit conversions that make them work as expected. After that, should just be left with type class dependencies, and then something like shims should help.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-21T19:59:04.848Z
So … there is a plan. Just not there yet.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-21T19:59:32.671Z
I’m open to other approaches, too – especially if suggested in a PR 😆

                                                                                                                                                      Greg Pfeil @sellout@2016-11-21T19:59:56.758Z
But we can’t _abandon_ scalaz, since Quasar (Matryoshka’s primary use case) depends on it.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-21T20:11:25.087Z
yeah its probably going to be a lot of work just looking through all the code

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-21T20:46:52.915Z
Is 0.11.1 the latest published version?

                                                                                                                                                      Greg Pfeil @sellout@2016-11-21T21:47:29.773Z
@dispalt Ah, sorry – I should publish a newer one.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-21T22:17:53.029Z
Hm is `type AnnFree[F[_], T, A] = Free[λ[α => (T, F[α])], A]` a thing?

                                                                                                                                                      Rob Norris @tpolecat@2016-11-21T22:20:22.828Z
I'm working on that thing I asked you about and I need to annotate the interior nodes of`Free[F,A]` by inspecting the `F`s, and then `cata` to get the final result ... I need prior information about the structure of each F before it's folded up.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-21T22:20:35.660Z
(where you = @sellout)

                                                                                                                                                      Greg Pfeil @sellout@2016-11-21T22:21:27.274Z
@tpolecat `Free[EnvT[T, F, ?], A]`

                                                                                                                                                      Greg Pfeil @sellout@2016-11-21T22:21:41.664Z
But it doesn’t have an alias as such.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-21T22:22:03.109Z
Cool. Just wanted to be sure I'm not stepping off the edge.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-21T22:22:12.436Z
Nope, we use that, too ;)

                                                                                                                                                      Rob Norris @tpolecat@2016-11-21T22:22:22.491Z
amazing

                                                                                                                                                      Greg Pfeil @sellout@2016-11-21T22:24:23.874Z
@tpolecat Admittedly, there are a bunch of things we do that I don’t think are good … but Matryoshka changes to improve that whenever possible/necessary (like the new directly-recursive stuff).

                                                                                                                                                      Rob Norris @tpolecat@2016-11-21T22:27:14.417Z
I'm convinced the thing I'm doing is awesome but I'm worried how far out on the plank I have to walk to convince my coworkers.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-21T22:27:44.720Z
@tpolecat Are you considering actually using Matryoshka yet? ;)

                                                                                                                                                      Rob Norris @tpolecat@2016-11-21T22:28:45.985Z
It's helpful to me to build it up on my own, at least until I'm convinced I understand the basics.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-21T22:29:10.271Z
But yes I'd like to pull it in once all the huge changes have been merged.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-21T22:29:24.035Z
@sellout feigns innocence.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-21T22:31:28.707Z
@tpolecat that approach is what I am trying to do, basically build some of the parts myself

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-21T22:31:46.620Z
so then my conviction is through the roof, and since I am bad at lying

                                                                                                                                                      Rob Norris @tpolecat@2016-11-21T22:37:07.410Z
okie dokie … `scalaOrganization := "org.typelevel"`

                                                                                                                                                      Greg Pfeil @sellout@2016-11-21T22:37:26.410Z
@tpolecat What took you so long? ;)

                                                                                                                                                      Greg Pfeil @sellout@2016-11-21T22:44:21.301Z
@dispalt BTW, I am in the process of publishing current Matryoshka – but apparently the wifi here is terrible (I generally never notice, because I just use Gitter/Slack/whatever), so it’s all taking a surprisingly long time.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-21T22:44:58.988Z
And, it also seems to want to lock ~/.ivy2, which is nice for me trying to do anything else while this publishes …

                                                                                                                                                      Rob Norris @tpolecat@2016-11-21T22:51:10.931Z
works \o/

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-21T23:13:44.611Z
All good, was just curious, I can of course publish locally 

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-21T23:13:58.931Z
btw `sbt-release` changed my life

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-22T00:27:11.959Z
spec.scala file melts my intellij

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T00:27:25.415Z
Oh yeah … it’ll do that …

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T00:27:49.110Z
I don’t think anyone at SlamData still uses IntelliJ.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-22T00:28:05.074Z
what do you use?

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T00:29:10.833Z
I use Emacs+Ensime, but even Ensime isn’t always great at this stuff. I mean, it takes the “right” approach (which is “ask the compiler”), but the presentation compiler isn’t always as forthcoming with answers as it should be.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-22T00:29:44.851Z
I don't think I could survive without being able cmd + click stuff

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T00:30:08.915Z
Well, Ensime should give you that, too – in some editor that supports it.

                                                                                                                                                      Torsten Scholak @tscholak@2016-11-22T00:31:00.270Z
it works in atom

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T00:31:02.829Z
But IntelliJ’s implementation of Scala is always going to fall short, and Typelevel in general doesn’t really limit itself to that ;)

                                                                                                                                                      Torsten Scholak @tscholak@2016-11-22T00:32:19.064Z
[![matryoshka.svg](https://files.gitter.im/slamdata/matryoshka/w5CB/thumb/matryoshka.jpg)](https://files.gitter.im/slamdata/matryoshka/w5CB/matryoshka.svg)

                                                                                                                                                      Torsten Scholak @tscholak@2016-11-22T00:32:39.877Z
ok, I thought that would work better

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T00:33:01.825Z
Hah! That opened in Atom for some reason.

                                                                                                                                                      Torsten Scholak @tscholak@2016-11-22T00:33:03.389Z
that’s an svg with the sticker I made yesterday

                                                                                                                                                      Torsten Scholak @tscholak@2016-11-22T00:33:31.016Z
lol

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T00:34:08.903Z
Yeah – we should definitely set that as the channel logo at the very least :D

                                                                                                                                                      Torsten Scholak @tscholak@2016-11-22T00:34:33.588Z
I’m glad people seem to like it. was a quick idea

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T00:34:43.858Z
If I could figure out how to do that …

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T00:35:46.569Z
@tscholak Yeah, I appreciate it – definitely streets ahead of my ideas. First one was nested boxes, but like a literal matryoshka, and the second was a sort of Sierpinski hexagon … which ended up looking more like a flower than a fractal.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T00:37:03.398Z
And I really wanted something that took advantage of the isometric aspect of the hexagon, so 👍🏾

                                                                                                                                                      Torsten Scholak @tscholak@2016-11-22T00:39:24.476Z
yay

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-22T05:07:58.321Z
btw, I think this is the most underrated type of documentation https://raw.githubusercontent.com/slamdata/matryoshka/master/resources/recursion-schemes.png

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-22T05:38:34.291Z
If I wanted to accumulate some audit log type thing as I am executing/recursing an expr tree, what kind of op would I use? I've built up a cofree tree with the `A` spot being information about the AST (like position, and the logical operation it maps to, etc).  The ast itself is fairly pure.  The example of `attributeTopDown` doesn't really give me a clue since that's about building up the AST.  Should I just add more information to the AST instead and reserve that purely for this operation?

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T06:33:33.646Z
@dispalt Glad you like that – at SlamData we tend to have copies printed out on our desks :)

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-22T06:34:24.300Z
Good idea, printed (landscape mode)

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T06:37:11.011Z
So, you want to accumulate a single log while folding, right? I think something like `cataM[Writer[Log, ?], Result]` is what you want.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-22T06:40:34.754Z
here's a smaller ask, say you wanted to execute your `Exp` example to a result.  Say you also wanted to implement something like explain in the sql world

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-22T06:40:59.816Z
say then you wanted to run the query with explain at the same time

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-22T06:41:58.446Z
and the second explain might be different because based on weights you changed what reductions you did

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-22T06:42:38.615Z
like since you had a limit on a subquery, so you did an inmemory join or something

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-22T06:43:22.107Z
so that's obviously just an analogy but my whole goal with this stuff is really good introspection of everything

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T06:45:47.550Z
Right, so if explain is an algebra like `Exp[String] => String`, then you can `(explain zip execute): Exp[(String, Result)] => (String, Result)` … but that would explain the same `Fix[Exp]` that you evaluated – assuming that you did whatever cost optimization before that step. But you could “chain” them in certain ways – maybe with a `zygo`, where you can “inform” a second algebra with the intermediate results from a first.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-22T06:50:34.991Z
Yeah interesting, gotcha, the full example section on your one of your talks was great when I cross referenced it with quasar btw

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T06:51:00.190Z
Oh cool – was that the Scala Up North one?

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-22T06:51:28.901Z
Yes

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-22T06:53:34.303Z
Okay last question before I try to do this, with your AST's if you had something like position and other metadata on a field, would you add it to the AST or generally put them in something like `a` position in Cofree

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T07:08:36.801Z
Yeah, I’d be inclined to use Cofree for that (or some other approach outside of the core AST).

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-22T17:45:55.793Z
if I wanted to match on something like this, what would my `case` statements look like? `val eval: AlgebraM[Writer[List[String], ?], Cofree[Expr, ?], Int] = ...`

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T17:55:54.957Z
So, Cofree _is_ a functor, but that’s probably not what you want to be doing. If you have `Cofree[Expr, A]` and want to fold it, you’d actually have `AlgebraM[Writer[List[String], ?], EnvT[A, Expr, ?], Int] `, then the body would probably look like `_.run match { case (SomeA, SomeExprCase(…)) => … }`

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T18:01:23.360Z
(`EnvT[A, F[_], B]` is just the transformer for `(A, F[B])`)

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-22T18:03:35.794Z
perfect, sorry for the dumb questions

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T18:03:56.816Z
Definitely not dumb questions. This stuff is very non-obvious.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T18:08:22.256Z
We say "annotate", the universe says `EnvT`.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T18:08:30.237Z
Apparently. It has happened to me at least twice.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T18:09:32.650Z
So, the thing I was working on is dramatically simpler just using direct recursion. Sadly.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T18:09:37.366Z
It's like 1/3 the code.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T18:15:39.619Z
Yeah … `(A, ?)` is the “environment comonad” (at least in Haskell parlance) where A is the environment. Not to be confused with the “writer monad”, which requires a monoid on A. Interestingly, the environment comonad is the same thing as the reader monad ∵ currying isomorphism.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T18:16:10.901Z
And there is also a comonad (traced, in Haskell) that is equivalent to the writer monad for the same reason.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T18:17:20.860Z
@tpolecat 😢

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T18:17:31.081Z
@tpolecat I would be interested in seeing the code ;)

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T18:18:52.957Z
Ok, yeah I'll make a gist. I'm going to be working on it more later today.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T18:23:19.993Z
It turns out that there are a bunch of different ways to write Algebras that are equivalent, but might be simpler in different situations. E.g., with `Algebra[EnvT[A, F, ?], Int]`, you might instead do `ElgotAlgebra[(A, ?), F, Int]` – the body looks the same as the one above, but you can drop the `_.run match`, since you’ll already have a value of `(A, F[Int])`. Then, if you need to use it on a Cofree, there’s an algebra transformation that’ll turn the Elgot into an algebra on EnvT.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-22T18:42:30.133Z
Yeah I was just noticing the weighted example

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T18:51:17.439Z
A `{Co}MonadTrans` type class should probably have a type member `M` and an isomorphism that wraps/runs the transformer. Then something like that Algebra/ElgotAlgebra conversion could be generic.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T18:59:55.718Z
Here's my [code](https://gist.github.com/tpolecat/150ca1089cd6a5b3d15ed75e5bd73865) ... having to do it in two steps is a hassle. It doesn't bother me but my coworkers won't like it.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T19:00:41.089Z
I'll add the direct recursion code in a sec.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T19:05:50.155Z
I guess the computation in question is about half the size, but also a lot simpler.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T19:06:31.386Z
@tpolecat This has a terrible name, but there’s an algebra transformation in Matryoshka called `interpret`, which takes an `A => B` and an `F[B] => B`, so your `str` could be written as an algebra on PlanF (ignoring that you _happen_ to use it in Free), then you can `plan.cata(interpret(_.shows, str))`

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T19:07:04.538Z
Ok, yeah I figured matryoshka would be able to eliminate some of the machinery.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T19:07:59.781Z
I guess the real question is how to implement `next`. Having to lift it into `EnvT` before folding is a lot of work.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T19:14:15.654Z
Right – so I would do the same thing with next initially – separate the A => List[A] from the EnvT => List[A], then I would actually write it as `(Int, PlanF[List[A]]) => List[A]`, again, postponing that you _happen_ to want it in EnvT until you actually apply the fold … because you might not actually want it in EnvT …

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T19:15:14.893Z
@tpolecat squints

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T19:17:26.297Z
So, finally, you use `coelgot` ;)

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T19:17:31.927Z
hooray!

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T19:18:25.794Z
So yeah it's going to come down to what we really want to do with this structure and I don't know yet.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T19:18:27.293Z
Mmm, maybe not that simple ;)

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T19:19:01.496Z
Yeah, but that’s kind of the goal of the algebras – is you implement them in the simplest way possible, then you massage things into the right shape when you use them.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T19:19:59.695Z
Right. I think I don't have enough mana to convince people yet since it's a lot to bite off for not much gain *yet*.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T19:20:12.063Z
Yeah, I get that.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T19:20:34.185Z
It's a matter of building it out a bit and learning how to think this way. I'm still on the outer edge.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T19:21:11.440Z
So I think I'll keep a parallel implementation going and attack when I'm sure I'm right.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T19:21:27.911Z
And you can implement `len` as just `PlanF[_] => Int`, then `plan.cata(attributeAlgebra(len))` will give you the Cofree you want.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T19:22:44.314Z
aaaaaaaaah

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T19:23:21.163Z
Is that terror or realization?

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T19:25:46.514Z
little of both?

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T19:25:52.777Z
No, that makes total sense.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T19:27:22.189Z
Ok I need to perform some actual work, if I can remember how. This is all helpful. I'll keep at it.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T19:36:53.514Z
@tpolecat Last thing – I’m thinking maybe Free (vs another node in PlanF) maybe does make this more complicated. With a 3-node, this is actually a zygo: `plan.zygo(len, next)` (using my changes to len and next) – so each `len` generates an Int, and then `next` takes `(Int, ProfF[List[A]])` and generates the list in a single pass. Anyway … I’ll comment on the gist ;)

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T19:37:30.621Z
Actually, maybe the Free doesn’t get in the way.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T22:09:40.193Z
Actually this turns horrible again if I don't use a pattern functor. If you're keeping score at home.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T22:10:05.045Z
Always.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T22:32:54.487Z
`Recursive[Cofree[?[_], Int]].convertTo[PlanF[Observation.Id, ?], Fix](a)` ... is this improved in 0.12? Or is there a less type-argumenty way to do it?

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T22:34:02.766Z
Oh wait I'm not on the typelevel compiler.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T22:34:21.713Z
*phew*

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T22:35:27.256Z
Yeah, it should work like `a.convertTo[Fix]` … I think … since it sounds like you’re on pre-directly-recursive-support.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T22:35:52.986Z
With the newer stuff, you wouldn’t be able to convert directly, because the functor would be `EnvT[PlanF]`.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T22:36:45.868Z
So you would do something like `a.cata(env => Fix(env.lower))` to actually discard the annotation.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T22:37:07.883Z
I think there may already be an algebra defined for that – like `a.cata(forget)` or something.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T22:37:38.357Z
Ok. Is there any reason why 0.12 isn't on sonatype? 

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T22:38:23.586Z
Oh, right :/ Yeah, I started doing it yesterday, but then it tried to publish stuff that it shouldn’t (we split into multiple subprojects) and it failed. I have to fix that.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T22:38:30.535Z
k

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T22:40:54.721Z
Any idea why I get “(root/*:publishSignedConfiguration) Repository for publishing is not specified.” with https://github.com/slamdata/matryoshka/blob/master/build.sbt#L150

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T22:41:55.016Z
I just added `publishTo := None` – see if that does anything.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T22:43:56.303Z
No, my `noPublishSettings` looks exactly the same as yours.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T22:44:07.777Z
This stuff is unforgivably complicated.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T22:44:33.012Z
Ok, well, it looks like it actually staged the stuff that succeeded, so I’m about to release it.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T22:46:06.875Z
Ok, looks like 0.14.0 is now released.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T22:46:17.013Z
@dispalt ^

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-22T22:46:36.756Z
@sellout thx!

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T22:46:53.013Z
Our next PR, IIRC, also crossbuilds on 2.12 and switches to TLS.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T22:54:49.691Z
oh sweet

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T23:03:14.068Z
Hm where are ana and anaM for cofree?

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T23:03:39.710Z
They are just in the Corecursive type class.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T23:04:04.309Z
You need `import matryoshka.implicits._`

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T23:04:27.536Z
Then you should be able to just call them on the Cofree.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T23:05:23.327Z
Ah ok I'm still on 0.11.1 ... 0.14 hasn't shown up yet.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T23:05:29.789Z
Oh …

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T23:05:46.272Z
getting the instance by hand works

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T23:07:39.227Z
Well, the problem there is the old Corecursive version just uses Monoid.zero to populate the annotation. This is basically the whole reason for the change to support directly-recursive types. Because doing anything properly with {co}free before required hand-written {un}folds.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T23:08:06.224Z
Your original use case is what led me to understand this :D

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T23:08:09.025Z
I see, ok. Well I can use `Cofree.unfoldC` if I need to.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T23:08:12.917Z
\o/

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T23:08:13.853Z
Yeah.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T23:53:27.712Z
```
[error] This looks like a specs2 exception...
[error] Please report it with the preceding stacktrace at http://github.com/etorreborre/specs2/issues
```
but there is no preceding stacktrace :/

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T23:54:31.730Z
Oh, phew, simple syntax error in the spec.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-23T00:07:24.845Z
Is there way to abstract over Fix vs Cofree, like for instance if I don't need any of the "annotations" ?

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-23T00:09:34.511Z
this method signature doesn't seem to work anymore with the change to direct recursion `def someExpr[T[_[_]]: Corecursive]: T[Exp] `

                                                                                                                                                      Greg Pfeil @sellout@2016-11-23T00:11:45.617Z
Yeah, so that’s the big change – now that would look like `def someExpr[T](implicit T: Corecursive.Aux[T, Exp]): T`.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-23T00:12:05.746Z
The `[T, Exp]` part basically says “Exp is the pattern functor for T”.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-23T00:12:14.957Z
The old syntax only worked for Fix/Mu/Nu.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-23T00:13:11.646Z
And, yes, if you have `val foo: Cofree[F, A]`, you can do `foo.cata(deattribute(f: F[A] => A))`

                                                                                                                                                      Greg Pfeil @sellout@2016-11-23T00:13:35.453Z
Which would work like `val foo: Fix[F]; foo.cata(f)`

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-23T00:19:50.500Z
ah the old aux pattern, great Ill give it a try

                                                                                                                                                      Greg Pfeil @sellout@2016-11-23T00:20:02.062Z
Indeed :/

                                                                                                                                                      Greg Pfeil @sellout@2016-11-23T00:21:30.812Z
The problem I’m having with it now is that I want to define `Birecursive` as a type class that extends Recursive and Corecursive, but when I do, there seems to be no hope of implicit resolution.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-23T00:21:42.397Z
_Someone_ probably knows a trick to sort that out, too.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-23T17:02:41.113Z
I feel like I am programming in braille sometimes with this stuff, but it's starting to come together

                                                                                                                                                      Rob Norris @tpolecat@2016-11-23T17:08:13.040Z
I feel like a 12th-century monk trying to set up a VCR.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-23T17:10:48.640Z
Yeah it probably isn't like laser disc, Vcr seems more appropriate

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-23T19:03:38.933Z
how would a substitute work with a cofree?  I basically have to make multiple passes in my datastructure because of the way scoping works.  I still feel like I am missing something with this Cofree -> EnvT concept.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-23T19:17:22.560Z
@dispalt `Base = EnvT` basically means that you can view `Cofree[F, A]` as `Fix[EnvT[A, F, ?]]`, and then all the {un}folds work as you’d expect on the latter.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-23T20:47:18.934Z
@tscholak If you want to submit a PR to Matryoshka that adds the logo to the README (and some mention that you made it), that would be awesome. Otherwise, I’ll get around to it eventually.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-23T22:00:32.002Z
@sellout where are the best examples to see this?  I don't see much (granted im really early on this stuff).

                                                                                                                                                      Torsten Scholak @tscholak@2016-11-23T22:01:30.365Z
@sellout I'll do it tonight. Does Lars Hupel want a copy of the svg? Wasn't sure what's going on in the typelevel channel

                                                                                                                                                      Greg Pfeil @sellout@2016-11-23T22:02:03.258Z
@tscholak Yeah, he probably does :D

                                                                                                                                                      Greg Pfeil @sellout@2016-11-23T22:02:22.405Z
@dispalt the best examples to see what? I have to run for a bit, but I’ll catch up when I’m back.

                                                                                                                                                      Torsten Scholak @tscholak@2016-11-23T22:02:27.707Z
kk

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-23T22:05:01.732Z
Ill formulate a better question for when you're back!

                                                                                                                                                      Rob Norris @tpolecat@2016-11-23T23:03:34.438Z
:+1:  for 0.14.0 … much nicer

                                                                                                                                                      Rob Norris @tpolecat@2016-11-23T23:03:50.743Z
However ... `root.ana[Fix[PlanF[Observation.Id, ?]]](planIdCoalgebra)` ... any way to make that less argumenty?

                                                                                                                                                      Rob Norris @tpolecat@2016-11-23T23:06:09.317Z
Also I can't find `T[F] => (F ~> G) => T[G]` but it has to be here somewhere.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-23T23:20:52.426Z
Hm looks like `.hmap` but it doesn't seem to exist for `Fix`.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-23T23:26:26.270Z
@tpolecat For the case of Fix/Mu/Nu, you could try `root.anaT[Fix]` (although, it might have different type params, since I doubt I hand-wrote that one) – it’s like the old `ana` –  doesn’t generalize to directly-recursive types.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-23T23:27:36.740Z
And (again, only for Fix/Mu/Nu), you want `transAna` or `transCata` to apply the natural transformation (depending on which direction).

                                                                                                                                                      Greg Pfeil @sellout@2016-11-23T23:27:46.912Z
Although, of course, it should be irrelevant.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-23T23:27:52.881Z
`value anaT is not a member of ...`

                                                                                                                                                      Greg Pfeil @sellout@2016-11-23T23:28:24.527Z
@tpolecat Yeah, I kind of was hoping no one would want to use `anaT` directly ;)

                                                                                                                                                      Greg Pfeil @sellout@2016-11-23T23:29:17.416Z
I mean, if you abstract over some `T` such that `Corecursive.Aux[T, PlanF[Observation.Id, ?]]`, then `root.ana[T]` is what you want.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-23T23:29:31.237Z
And then you’ve freed up the fixed-point operator, too ;)

                                                                                                                                                      Greg Pfeil @sellout@2016-11-23T23:31:16.467Z
But there’s no way to not specify the `T` because it only shows up in the result.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-23T23:35:37.102Z
I am very confused by `T` being a proper type.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-23T23:37:52.360Z
dammit

                                                                                                                                                      Rob Norris @tpolecat@2016-11-23T23:38:44.150Z
```
def unfold[T](root: PlanRow.Id)(
  implicit ev: Corecursive.Aux[T, PlanF[Observation.Id, ?]]
): WAT[PlanF[Observation.Id, ?]] = ...
```

                                                                                                                                                      Rob Norris @tpolecat@2016-11-23T23:39:18.801Z
If I want for instance to call this and say ok I want `Fix` what do I pass for `T` and what is the return type?

                                                                                                                                                      Rob Norris @tpolecat@2016-11-23T23:39:40.594Z
Or probably I misunderstood.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-23T23:41:53.011Z
oh it's just `T`. hm

                                                                                                                                                      Rob Norris @tpolecat@2016-11-23T23:42:52.115Z
Nevermind, got it. Ow my head.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-24T00:17:02.513Z
`transCata` :+1: 

                                                                                                                                                      Rob Norris @tpolecat@2016-11-24T00:18:19.221Z
I feel certain that once this clicks I will never be able to explain it to anyone.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-24T00:18:58.208Z
I keep going from wait, what to oh, duh.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T00:44:54.562Z
Im stuck on wait

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T00:45:07.932Z
or more precisely "I"

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T00:47:31.741Z
Okay here's what I want to do simplify an AST, similar to [this](https://github.com/slamdata/matryoshka/blob/master/tests/src/test/scala/matryoshka/spec.scala#L92-L101), but doing it over `Cofree[Expr, _]` and maintaining the annotations, I can't seem to negotiate the right types/transformations. 

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T00:48:04.879Z
basically there is a lack of order on my AST so you can declare something later and use it earlier in the tree.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T00:48:20.452Z
so I do a pass to collect everything and now I want to reduce it back to the number

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T00:49:10.197Z
I technically don't need the `A` in the cofree to do the reduction, I just need to manipulate the resulting tree with the `A`

                                                                                                                                                      Greg Pfeil @sellout@2016-11-24T03:46:02.973Z
So, if you’re doing the reduction, you’re going `Cofree[Expr, _] => Int` right?

                                                                                                                                                      Greg Pfeil @sellout@2016-11-24T03:46:24.971Z
And you’re saying you can ignore the annotation, right?

                                                                                                                                                      Greg Pfeil @sellout@2016-11-24T03:46:25.483Z
@dispalt ^

                                                                                                                                                      Greg Pfeil @sellout@2016-11-24T03:48:27.717Z
So, you can write an algebra `Expr[Int] => Int`, and use it like `_.cata(deattribute(reduceAlgebra))` – `deattribute` lets you apply an algebra over some `F` into an algebra over `EnvT[_, F, ?]`, just ignoring the annotation.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-24T03:50:08.288Z
I feel like I have to populate the space of these algebra transformations and come up with names that describe the motion around that space.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-24T03:50:29.615Z
there is sort of an attribute/deattribute dual, so ¯\\\_(ツ)_/¯

                                                                                                                                                      Greg Pfeil @sellout@2016-11-24T03:56:54.852Z
@dispalt Oh, and as for the doing something like `simplify` over Cofree, ignoring-but-maintaining the annotations … I’ve wanted that. Haven’t managed to get it to work yet. https://github.com/slamdata/matryoshka/blob/3e3de4f0f210de5e1aa3cf270c1023e038d118cd/core/shared/src/main/scala/matryoshka/package.scala#L556 – but I think I can make it work.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T04:14:11.229Z
I want to do a `Cofree[Expr,_]` => `Cofree[Expr,_]` similar to simplify in `spec.scala` file, but for cofrees.  I guess I am trying to reverse engineer my understanding through examples

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T04:14:21.437Z
https://github.com/slamdata/matryoshka/blob/master/tests/src/test/scala/matryoshka/spec.scala#L92-L101

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T04:14:31.031Z
@sellout ^

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T04:17:00.314Z
I'd like to simplify my ast with a step while maintaining the metadata attached to branches (which means probably some Monoid instance on `A` I am guessing)

                                                                                                                                                      Greg Pfeil @sellout@2016-11-24T04:21:14.991Z
Right – so if you write `simplify` algebra replacing `Exp[…]` in my examples with `EnvT[A, Exp, …]`, then you can explicitly manage the annotations. If you want to write it _without_ mentioning `EnvT`, then … that’s currently problematic, but I think solvable … I hope.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T04:23:15.833Z
Gotcha

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T04:23:20.163Z
Sorry for being dense

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T04:23:26.218Z
yeah ill give that a shot

                                                                                                                                                      Greg Pfeil @sellout@2016-11-24T04:24:43.553Z
No, you’re definitely not! I promise. Just not a lot of explanatory material yet. But, now that I have the API in what I think is a _pretty_ stable state (i.e., the shapes of type params, etc. shouldn’t change), I hope I can start getting some real docs put together, and think about some of this stuff more holistically.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T04:25:07.224Z
You know what I should do

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T04:25:18.718Z
keep notes, even if they look like a 3rd grader wrote them

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T04:25:39.862Z
then you can see how a beginner sees this stuff

                                                                                                                                                      Greg Pfeil @sellout@2016-11-24T04:26:01.458Z
Oh, that would be fantastic.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T04:29:17.919Z
Actually the biggest thing that clicked for me and made me want to go much further, was this realization, https://gist.github.com/dispalt/4ed461e14c66db6b6e13ceab7fe82538 that the substitution was able to work on the adt level not the tree level

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T04:29:23.644Z
that kinda blew my mind

                                                                                                                                                      Rob Norris @tpolecat@2016-11-24T04:30:38.844Z
I should do that too. Lots of things look impossible at first. 

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T04:31:12.139Z
basically if the types line up it will work as expected, which I guess is true of most fp

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T04:41:13.229Z
@sellout also `transCata` doesn't seem to be a part of cofree

                                                                                                                                                      Rob Norris @tpolecat@2016-11-24T05:42:51.606Z
Even with the 2712 fix the syntax doesn't work. If you alias it down to a simpler type it works. 

                                                                                                                                                      Rob Norris @tpolecat@2016-11-24T05:43:42.053Z
type Foo[F[_]] = Cofree[F, Woozle]

                                                                                                                                                      Rob Norris @tpolecat@2016-11-24T05:44:19.428Z
Then Foo[Qux] will have .transCata

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T05:49:45.266Z
ahh thanks

                                                                                                                                                      Greg Pfeil @sellout@2016-11-24T05:51:18.368Z
@dispalt Ah right, sorry. I’d like to make it work. One thing that’ll work now is to convert the Cofree to Fix[EnvT[…]] … because FunctorT requires that the pattern functor is directly exposed … like all of Matryoshka used to require.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T06:17:19.178Z
Is there a snippet somewhere for something that shows, `Cofree` to `Fix[EnvT[…]]`?

                                                                                                                                                      Greg Pfeil @sellout@2016-11-24T06:19:08.284Z
`someCofree.ana[Fix[EnvT[A, F, ?]]](_.project)`

                                                                                                                                                      Greg Pfeil @sellout@2016-11-24T06:20:36.378Z
Actually … this might work … `someCofree.convertTo[Fix[EnvT[A, F, ?]]]`

                                                                                                                                                      Greg Pfeil @sellout@2016-11-24T06:21:25.929Z
convertTo is just a wrapper around the opposite of that first one … `someCofree.cata[Fix[EnvT[A, F, ?]]](_.embed)`

                                                                                                                                                      Greg Pfeil @sellout@2016-11-24T06:21:47.690Z
The idea is you can convert between things that have the same pattern functor.

                                                                                                                                                      Torsten Scholak @tscholak@2016-11-24T14:56:14.755Z
@sellout sorry for the spam. there is no way to test this without pushing changes. I got it working now.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-24T16:43:47.297Z
**\[Greg Pfeil, SlamData Inc.\]** @tsccholak No worries. Thanks!

                                                                                                                                                      Torsten Scholak @tscholak@2016-11-24T16:49:43.952Z
you're welcome

                                                                                                                                                      andy scott @andyscott@2016-11-24T22:04:41.016Z
@andyscott waves at @sellout 

                                                                                                                                                      Greg Pfeil @sellout@2016-11-24T22:06:38.853Z
Hey :D

                                                                                                                                                      Greg Pfeil @sellout@2016-11-24T22:22:04.231Z
So, if I have a `matryoshka.scalaz` package, should I _also_ have a `matryoshka.scalaz.implicits` package, or is there some magic that will only allow the implicits to work in the case that I have imported `matryoshka.implicits._`, or is that just bad mojo?

                                                                                                                                                      Greg Pfeil @sellout@2016-11-24T22:32:10.213Z
@tpolecat Is your preprocessor library public somewhere? I couldn’t find it on your GH. Debating this whole matryoshka-scalaz thing once again ;)

                                                                                                                                                      Rob Norris @tpolecat@2016-11-25T02:29:30.218Z
@sellout it's just kind of hacked into the doobie build. Not a whole lot to it. I didn't make it a plugin because I don't want to be blamed.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-25T02:30:20.916Z
Ross got it working pretty easily for http4s but in the end he decided to do a fork instead. 

                                                                                                                                                      Rob Norris @tpolecat@2016-11-25T02:31:32.345Z
I'm on my phone until Comcast fixes my internets so I'm a bit limited in my powers atm. 

                                                                                                                                                      Greg Pfeil @sellout@2016-11-25T02:42:52.135Z
As I’m trying to abstract over dependencies, I realize I don’t even know how to construct an `Either`.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-25T04:07:51.526Z
I did the shimmy/stubby/stabby thing with atto so you might check that out. Seems to work but irritating in places. 

                                                                                                                                                      Greg Pfeil @sellout@2016-11-25T06:01:19.969Z
Yes … I am certainly doing the stabby thing at the moment.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-25T06:02:09.602Z
I _think_ I’ve pushed all Scalaz datatypes down to the subproject. So next is shims. Then adding a comparable Cats subproject.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-25T06:33:49.002Z
Tried the bananas paper again and I'm irritated by the notation. It's hard to follow even when I know what they're talking about. 

                                                                                                                                                      Greg Pfeil @sellout@2016-11-25T06:34:00.953Z
@tpolecat Yeah, agreed.

                                                                                                                                                      Torsten Scholak @tscholak@2016-11-25T13:28:45.925Z
@sellout do you want me to squash my commits?

                                                                                                                                                      Greg Pfeil @sellout@2016-11-25T16:18:12.951Z
@tscholak Only if you want to – we don’t usually squash.

                                                                                                                                                      Torsten Scholak @tscholak@2016-11-25T16:22:49.713Z
@sellout k, then I'm done.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-25T16:24:01.268Z
Merged! Thanks :D

                                                                                                                                                      Torsten Scholak @tscholak@2016-11-25T16:24:15.724Z
:+1:

                                                                                                                                                      Rob Norris @tpolecat@2016-11-26T06:30:10.897Z
I'm puzzled about Nu

                                                                                                                                                      Rob Norris @tpolecat@2016-11-26T06:32:30.308Z
If I unfold (A, ?) with n => (n, n + 1) and then unNu I get (1, 2) but I expected (1, the next Nu)

                                                                                                                                                      Rob Norris @tpolecat@2016-11-26T06:34:10.957Z
How do I turn the crank to walk the structure? I think maybe I'm doing `Ana` wrong. 

                                                                                                                                                      Rob Norris @tpolecat@2016-11-26T06:34:38.562Z
On my phone so this is hard to type. Standby. 

                                                                                                                                                      Rob Norris @tpolecat@2016-11-26T06:36:00.172Z
`1.ana[Nu[(Int, ?)]((n: Int) => (n, n + 1))`

                                                                                                                                                      Greg Pfeil @sellout@2016-11-26T06:36:16.166Z
**\[Greg Pfeil, SlamData Inc.\]** Yeah, you don't want unNu – you want .project

                                                                                                                                                      Rob Norris @tpolecat@2016-11-26T06:36:26.182Z
Hmm. 

                                                                                                                                                      Rob Norris @tpolecat@2016-11-26T06:36:44.020Z
Oh rock on. 

                                                                                                                                                      Greg Pfeil @sellout@2016-11-26T06:36:51.476Z
**\[Greg Pfeil, SlamData Inc.\]** Notice that for Fix project = unFix, but not for the other types.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-26T06:37:22.420Z
Ok gotcha. That clicks. 

                                                                                                                                                      Greg Pfeil @sellout@2016-11-26T06:37:44.645Z
**\[Greg Pfeil, SlamData Inc.\]** unNu is just a bad name that I should change. I hate when Haskell gets to avoid naming something ;\)

                                                                                                                                                      Rob Norris @tpolecat@2016-11-26T06:40:11.501Z
I'm trying to load up the dikumud map and represent the user's location with a cursor in an infinite unfold. 

                                                                                                                                                      Rob Norris @tpolecat@2016-11-26T06:40:24.726Z
Seems like this will work. 

                                                                                                                                                      Rob Norris @tpolecat@2016-11-26T06:41:00.543Z
Maybe unFix should just be called project. 

                                                                                                                                                      Greg Pfeil @sellout@2016-11-26T21:39:58.724Z
So … `Seq` and Matryoshka … I feel like it’s important to do _something_, because of variadic functions, but it’d be nice if there were some way to dissuade its use in general.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-26T22:42:37.232Z
Also, I’m _really_ not feeling this thing where we keep implicit conversions in a separate package.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-26T23:44:27.808Z
do what with Seq?

                                                                                                                                                      Rob Norris @tpolecat@2016-11-26T23:47:36.198Z
I usually pretend it doesn't exist since it has no instances. 

                                                                                                                                                      Greg Pfeil @sellout@2016-11-26T23:47:54.676Z
@tpolecat I mean I want to be able to apply algebras, etc. to Seq, so you don’t need to do some conversions to deal with `A*`.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-26T23:48:32.656Z
Ah

                                                                                                                                                      Greg Pfeil @sellout@2016-11-27T00:15:53.199Z
Or should I just not encourage use of variation functions either?

                                                                                                                                                      Greg Pfeil @sellout@2016-11-27T00:16:01.958Z
Grr autocorrect.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-27T00:17:19.544Z
I only added instances for Seq in the first place because I was implementing List.apply.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-27T00:19:23.257Z
Which is `seq.convertTo[List[A]]`

                                                                                                                                                      Paul Phillips @paulp@2016-11-27T01:03:30.602Z
@sellout trying to abstract over `A*` like it isn't just a little bundle of snowflakiness is a doomed errand.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-27T01:12:51.859Z
@sellout What do you need for shims?

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-27T01:13:17.543Z
I have a copy with newer cats and scalaz versions and JS and JVM both building, which I was about to contribute back

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-27T01:16:54.482Z
PR is now up

                                                                                                                                                      Greg Pfeil @sellout@2016-11-27T02:04:44.586Z
@paulp 👍🏾 then I'll just make the minimal thing for getting a List from a Seq.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-27T02:06:54.261Z
@edmundnoble That sounds useful for me – I'll upvote. I haven't started with shims yet – still getting everything working with pushing the non-type class stuff to subprojects. Might get to try shims tonight.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-27T04:05:31.051Z
@sellout Glad to hear my PR for shims is what you need. It's not a coincidence ;)

                                                                                                                                                      Greg Pfeil @sellout@2016-11-27T04:07:22.038Z
I still have to add a bunch of others … Foldable, Bi*, etc. but getting closer. And … it’s not possible to define an instance in the shims-only project, right? You have to make instances in the specific subprojects?

                                                                                                                                                      Greg Pfeil @sellout@2016-11-27T04:08:06.759Z
How does anyone manage to use Shims without Comonad? ;)

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-27T04:09:46.917Z
Ugh I know ;) it's a lazily evaluated library, as Daniel puts it. You can totally define instances in the shims-only project

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-27T04:10:21.310Z
My mistake earlier

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-27T04:10:22.504Z
You totally can

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-27T04:10:33.590Z
Shims provides implicit conversions from the shims typeclasses

                                                                                                                                                      Greg Pfeil @sellout@2016-11-28T05:16:39.816Z
Down to 582 shims-related errors ;) This has not been a good weekend for coding …

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-28T05:18:07.478Z
I bet there's more hidden under those though :P hope it's going alright :) can't wait to re-introduce matryoshka to slate, I've been working with just Fix for too long now

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-28T05:18:55.483Z
Are you working at all on stack-safety or is that still an open issue?

                                                                                                                                                      Greg Pfeil @sellout@2016-11-28T05:23:37.211Z
Oh, that’s still an open issue. But your shims PR should help :D

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-28T05:24:00.473Z
I hoped as much

                                                                                                                                                      Greg Pfeil @sellout@2016-11-28T05:24:18.474Z
The code is going fine … just haven’t had much time. Woke up yesterday to a flooded basement … but hey, it’s the fourth time, so it goes pretty smoothly now :laughing:

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-28T05:27:49.284Z
That's not a great thing to make a routine of ;) at least the code is DRY.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-28T05:35:39.120Z
:clap:

                                                                                                                                                      Greg Pfeil @sellout@2016-11-28T05:49:05.144Z
I think Shims may just be a ploy to show everyone how much they depend on Scalaz.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-28T05:50:12.661Z
To get them to contribute to it, probably :P

                                                                                                                                                      Greg Pfeil @sellout@2016-11-28T05:54:15.335Z
So, I think there’s no way for me to avoid defining `~>` and `Id` locally, right? Not that they’re very complicated. I might also add `Const`.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-28T06:07:10.208Z
Probably. Which const? Type-level or the class?

                                                                                                                                                      Greg Pfeil @sellout@2016-11-28T06:19:32.707Z
I’m confused … isn’t the class the type-level const? Value-level one is Function1.const, or scala.Predef.const … or at least _somewhere_ in the stdlib.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-28T06:24:34.874Z
@sellout dang flooded basement sounds crappy

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-28T06:36:55.156Z
So there's `Lambda[A => C]`, then there's `class Const[A, B] { def getConst: A }`, then there's `def const(a, b) = a`

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-28T06:37:16.617Z
Two of em are type level, just from different perspectives

                                                                                                                                                      Greg Pfeil @sellout@2016-11-28T16:11:55.371Z
@edmundnoble Ah yeah – just the class then :)

                                                                                                                                                      Rob Norris @tpolecat@2016-11-29T00:36:23.929Z
Feeling pretty macho with fixpoints of `EnvT` of  `CoEnv` [here](https://gist.github.com/tpolecat/f2c1005b66f18f925232e55f646369a6). My coworkers will never go for it but it's fun that it works. Do you see any obvious simplifications?

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-29T00:39:50.073Z
Is this the kind of thing that gets fused into a single iteration? The transCata followed by cata?

                                                                                                                                                      Rob Norris @tpolecat@2016-11-29T00:44:28.465Z
Would be cool but I don't know how to do that.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-29T00:44:46.536Z
I thought they did when you used Mu instead of Fix. Dunno. @sellout?

                                                                                                                                                      Rob Norris @tpolecat@2016-11-29T00:45:21.174Z
Oh that's possible, sure.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-29T00:51:44.601Z
transCata, unfortunately, loses any real benefit of Mu. But … these sorts of things can be manually fused in a couple ways. I’ll take a look later, but I’m about to run.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-29T15:17:30.634Z
Every time I add anything to Matryoshka, I’m like “oh, I really need this one more thing …”

                                                                                                                                                      Greg Pfeil @sellout@2016-11-29T15:18:15.471Z
Today, in coming up with a mutually-recursive representation for QScript, I’m like “mmmm, ABTs would make this nicer …”

                                                                                                                                                      Greg Pfeil @sellout@2016-11-29T15:24:05.572Z
I’m like so close to having a correct-by-construction AST for Quasar. Think I’m gonna need HList to finish it.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-29T15:26:21.959Z
It does require a bit in the way of type parameters, though :laughing:

                                                                                                                                                      Greg Pfeil @sellout@2016-11-29T23:40:06.548Z
So, if anyone can figure out how to make `Birecursive[T] extends Recursive[T] with Corecursive[T]` work, I would be pretty grateful.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-29T23:42:16.597Z
That's the only requirement?

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-29T23:42:27.828Z
I'll take a look, no other code for it already?

                                                                                                                                                      Greg Pfeil @sellout@2016-11-29T23:43:51.952Z
No other code for it – I basically want to be able to replace `implicit TR: Recursive.Aux[T, F],  TC: Corecursive.Aux[T, F]` with `implicit T: Birecursive.Aux[T, F]` (and have method calls within that that only depend on the `Recursive` or `Corecursive` aspect).

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-30T00:04:46.783Z
How opposed are you to `type Birecursive[T] = Recursive[T] with Corecursive[T]` ;)

                                                                                                                                                      Greg Pfeil @sellout@2016-11-30T00:19:42.888Z
Not at all if it works. That won't actually get me the constraints I need though … will it?

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-30T00:33:55.857Z
Why not?

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-30T00:34:05.423Z
Either way it will break a lot

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-30T00:34:23.415Z
I went with actually making a Birecursive, I'm almost done and I had to duplicate the ops crap in Recursive that's not possible with simulacrum

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-30T00:35:02.342Z
It will break everybody who uses both constraints, so it forces a lot of change

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-30T00:51:33.759Z
@sellout I cannot get it to find an implicit Recursive.Aux[T[F], F] given an implicit Birecursive.Aux[T[F], F]. Guess this is the limit of the type system.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-30T00:54:08.227Z
`Recursive.Aux[T[F]] with Corecursive.Aux[T[F]]` is not the same as `Recursive[T] with Corecursive[T] { type Base = F }`, at least enough for implicit search

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-30T01:29:35.655Z
Yeah this looks impossible without duplicating the ops classes. Can't use either of their syntax. I've only spent an hour on it, but that's how it looks at the mo.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-30T02:48:52.516Z
@edmundnoble What about
```scala
object Birecursive {
  type Aux[T, F[_]] = (Recursive[T] with Corecursive[T]) { type Base[A] = F[A] }
}
```
?

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-30T04:17:38.556Z
Tried that as well after unfortunately implicit search still won't let you use rec or corec syntax on birec 

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-30T04:18:22.776Z
You can make birecs then from both instances, fixing some compatibility issues, but still

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-30T04:19:03.298Z
Some intersection of implicits and subtyping and refinement types which just ain't enough

                                                                                                                                                      Greg Pfeil @sellout@2016-11-30T04:19:47.910Z
Maybe @milessabin can fix the compiler ;)

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-30T04:21:08.118Z
Mayyyybe I can provide an implicit conversion which performs subtyping's job

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-30T04:21:28.716Z
And remove one of the things in play. Worth a shot, trying later

                                                                                                                                                      Greg Pfeil @sellout@2016-11-30T04:21:36.631Z
Ohhh, _that’s_ a good idea.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-30T04:21:51.027Z
Well, thanks for all the help, regardless of the outcome :laughing:

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-30T04:22:05.389Z
Welcomes :)

                                                                                                                                                      Miles Sabin @milessabin@2016-11-30T09:33:15.322Z
What's all this?

                                                                                                                                                      Pawel Szulc @rabbitonweb@2016-11-30T09:35:17.836Z
@milessabin black magic

                                                                                                                                                      Miles Sabin @milessabin@2016-11-30T09:37:38.873Z
Apparently I'm being volunteered to fix more compiler bugs :-)

                                                                                                                                                      Miles Sabin @milessabin@2016-11-30T09:39:10.141Z
@edmundnoble can you post a minimal standalone gist ... I think this one is most likely doable.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-30T18:13:38.730Z
@milessabin Here’s a standalone gist: https://gist.github.com/sellout/3bec3b9d3b6de2fd224daee5cf859ed6 – line 28 being the thing that I would like to make work. Anything outside of the `Test` class can be terrible, because it’ll be within Matryoshka.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-30T18:16:23.224Z
Unicode Primes!

                                                                                                                                                      Greg Pfeil @sellout@2016-11-30T18:16:40.139Z
@tpolecat I waste no time 😆

                                                                                                                                                      Greg Pfeil @sellout@2016-11-30T18:20:19.465Z
@paulp and @edmundnoble Wanted to point you at that ↑ gist, since you’ve both tried to attack the problem.

                                                                                                                                                      Paul Phillips @paulp@2016-11-30T18:26:11.950Z
"Mayyyybe I can provide an implicit conversion which performs subtyping's job" I've tried that before. Nope.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-30T18:54:02.478Z
If anyone has any ideas, @rabbitonweb is looking for some low-hanging Matryoshka fruit. I think `Birecursive` is probably not that …

                                                                                                                                                      Greg Pfeil @sellout@2016-11-30T18:54:31.164Z
I know I still have a bunch of things in my head, so I’m trying to reify them into issues as I think of them.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-12-01T21:35:29.401Z
if I just wanted cataM for cats, how hard would you think it'd be to pull that out?

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-01T21:35:52.895Z
@dispalt It would take around 4 lines

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-01T21:36:08.749Z


                                                                                                                                                      Dan Di Spaltro @dispalt@2016-12-01T21:36:10.294Z
so @edmundnoble your saying, it would be really hard

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-01T21:36:20.470Z
Real easy :)

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-01T21:36:22.620Z
One sec

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-01T21:36:36.817Z
What do you have? `Recursive`? `Fix`?

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-01T21:36:39.604Z
What you gonna tear down?

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-01T21:37:10.158Z
I ended up having to pull it out to work with cats myself, I just have a stack-safe version

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-12-01T21:37:12.160Z
A Cofree which I've stolen from your GH

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-01T21:37:26.718Z
(do you want the stack-safe version ;))

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-12-01T21:37:32.494Z
yes pls =)

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-01T21:40:54.255Z
(if you've just got Fix, [here's a gist](https://gist.github.com/edmundnoble/44e17ce1665076a7e82f6115efc8b2b1))

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-01T21:44:39.290Z
The source appears to be the same for scalaz and cats, funnily enough

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-01T22:18:05.400Z
@dispalt Glad to know you're getting use out of it :) do you want to cataM your cofree? I can help with that

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-01T22:18:15.721Z
Sorry for the delay, didn't get those messages for some reason

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-01T22:23:04.038Z
[Here you go, for Cofree instead](https://gist.github.com/edmundnoble/b9e4f9693a8f8601d2d3af7aaba9d5fb)

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-01T22:23:34.329Z
Call me... the *eliminator* ;)

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-12-01T22:54:56.327Z
haha, Ill give it a shot, thanks a bunch @edmundnoble !

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-01T23:12:32.151Z
Welcomes :)

                                                                                                                                                      Hamish Dickson @hamishdickson@2016-12-02T08:38:00.546Z
Ah awesome @edmundnoble ! I'm in need of this for cats as well - couldn't have timed that much better :smile: 

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-02T10:07:17.225Z
Excellent. It'll be in matryoshka-cats soon ;)

                                                                                                                                                      Valentin Kasas @vil1@2016-12-02T14:55:34.168Z
Hello recursive people. 
I have a little project in mind : I want to define a simple format to represent data and schemas that I would easily translate to other formats (eg sparkSQL `DataType`, avro `Schema` and so on). I feel that matryoshka would probably will be of good help for that purpose. Would someone here be so nice to point me out where I should start, considering that I have absolutely no prior knowledge of those matters and a fairly limited amount of time to  assign to this task ?

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-02T22:56:09.927Z
@tpolecat Nu is a partially-applied anamorphism. Mu is a partially-applied catamorphism. An anamorphism can be used to represent a potentially infinite dataset, because you can keep applying it, whereas a catamorphism can only be further destructed. That's my understanding.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-02T22:56:44.736Z
@vil1 You may be just fine with normal Scala data types and Shapeless for datatype-generic programming.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-02T22:57:28.514Z
Though with that said Matryoshka is mostly for recursive data, if your data is naturally recursive it may help with constructing and eliminating that data but probably not converting it.

                                                                                                                                                      Rob Norris @tpolecat@2016-12-02T22:59:00.036Z
In my experiments it's the opposite. Unfolding into `Nu` can be infinite but not into `Mu`.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-02T23:01:08.829Z
Wow I swapped them round :P one sec

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-02T23:01:21.991Z
There ya go

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-02T23:01:45.903Z
Admittedly though I don't know anything about their operational characteristics: all I know is they are each half the speed of Fix on a normal day (in JS, in my compiler)

                                                                                                                                                      Valentin Kasas @vil1@2016-12-03T00:24:19.618Z
@edmundnoble thanks for the insight. I'm quite comfortable with shapeless so I might give it a shot at my problem at some point. But I envision my conversions as catamorphisms from my (to be defined) data structure into the (kind *) spark/avro types, so I guessed it was a good occasion to use/learn matryoshka. Am I completely wrong  ?  (that's a genuine question, please beat in mind 

                                                                                                                                                      Valentin Kasas @vil1@2016-12-03T00:27:05.140Z
   that I know nothing)

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T00:29:00.375Z
@vil1 it depends. Is your data naturally recursive?

                                                                                                                                                      Valentin Kasas @vil1@2016-12-03T01:10:59.307Z
Well I guess so, I have simple types (integers, strings, booleans, etc ...) and structs and arrays containing simple types or stucts or arrays, and so on

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T01:12:15.680Z
Well catamorphisms may be useful for the recursion, absolutely. Come up with a pattern functor and you can see what you can do.

                                                                                                                                                      Valentin Kasas @vil1@2016-12-03T01:14:25.112Z
From a beginner point of view, the tricky part is structs , since the "content" of such struct would be something like a shapeless record

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T01:14:30.183Z
```
  final case class True[A]() extends JSONF[A]
  final case class False[A]() extends JSONF[A]
  final case class Null[A]() extends JSONF[A]
  final case class Str[A](value: String) extends JSONF[A]
  final case class Num[A](value: Double) extends JSONF[A]
  final case class ObjList[A](value: Vector[(String, A)]) extends JSONF[A]
  final case class Arr[A](value: Vector[A]) extends JSONF[A]
```

                                                                                                                                                      Valentin Kasas @vil1@2016-12-03T01:15:00.329Z
makes sense

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T01:15:11.649Z
Like if you recurse over that, do you get something close to what you want?

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T01:15:16.143Z
Given Fix[JSONF]?

                                                                                                                                                      Valentin Kasas @vil1@2016-12-03T01:15:39.057Z
absolutely

                                                                                                                                                      Valentin Kasas @vil1@2016-12-03T01:17:00.584Z
but how would I write an `Algebra[JSONF, DataType]` ? (`DataType` being the stuff I want to fold into) 

                                                                                                                                                      Valentin Kasas @vil1@2016-12-03T01:17:34.478Z
(or maybe `Algebra` is not what I need)

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T01:17:35.089Z
Ah, that'll be a function that given a JSONF[DataType] makes a DataType

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T01:18:00.335Z
Algebra probably will be what you need if you are destructing your data type to make some other one

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T01:18:18.020Z
Then `cata` will make that algebra into a function Fix[JSONF] => DataType

                                                                                                                                                      Valentin Kasas @vil1@2016-12-03T01:19:34.604Z
ok

                                                                                                                                                      Valentin Kasas @vil1@2016-12-03T01:20:47.041Z
mist comes a little bit clearer, thanks a lot

                                                                                                                                                      Valentin Kasas @vil1@2016-12-03T01:22:39.805Z
(it's 2AM here so I need to go to sleep, but I'll try to make some progress first time tomorrow, expect some more dummy questions)

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T01:25:02.131Z
RIghto, sounds good :D

                                                                                                                                                      Greg Pfeil @sellout@2016-12-03T16:51:06.868Z
@tpolecat I understand much less of this stuff than is generally assumed, I think. Re: Mu vs. Nu, my hand-wavy explanation is that we need laziness/trampolining/something to avoid stack-overflow on large finite values, but want to be able to reason about the structure inductively rather than coinductively. In most languages that’s a distinction without difference, I suppose. But now I wonder how Idris deals with `data` (vs lazy `codata`) internally. It’s a strict language, so is it just not stack-safe, or what?

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T19:33:47.864Z
@vil1 LOL, things really do get invented in parallel in our world. Have a look at http://github.com/nuttycom/sjsch and http://github.com/nuttycom/thx.schema

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T19:34:07.730Z
I'm just in the process of building almost exactly what you're describing.

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T19:35:59.997Z
https://github.com/nuttycom/sjsch/blob/master/src/main/scala/sjsch/Schema.scala is the main schema definition; I'm still figuring out how to build all the cofree structure that's needed for the interpreter. The thx.schema project is in Haxe, which doesn't have higher-kinded types and thus has to use direct recursion (and so you can't annotate the tree or do more interesting manipulations.)

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T19:36:28.384Z
But it's more complete, having interpreters from the Schema type into parsers, generators, etc.

                                                                                                                                                      Valentin Kasas @vil1@2016-12-03T19:38:34.324Z
interesting !

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T19:38:34.404Z
Anyway, the underlying concept is to use free applicative functors to allow you to describe the structure of JSON objects.

                                                                                                                                                      Valentin Kasas @vil1@2016-12-03T19:41:22.197Z
That sounds more advanced than what I had in mind though

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T19:43:16.622Z
Once you have a typed description of the JSON structure you're interested in, you can do whatever you want with it - generate a parser, generate the JSON-schema description of the structure, generate a ScalaCheck Gen instance, etc. So it might work for your use case, is all I'm saying.

                                                                                                                                                      Valentin Kasas @vil1@2016-12-03T19:45:12.053Z
yeah definitely

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T19:47:57.917Z
Mmmm it's beautiful. I think this might suffice as a basis for a JSON type system. I am also curious what you get out of this versus a more conventional free invariant monoidal, which is ordinarily what I look at for codecs.

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T19:49:18.046Z
Free invariant monoidal? I know all of those words individually, but my brain is having a hard time putting them together, can you describe in more detail?

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T19:52:56.804Z
Absolutely. These are the operations provided.
```
  def imap[B](f: A => B)(g: B => A): FA[F, B] = Imap(this, f, g)

  def product[B](b: FreeInvariant[F, B]): FA[F, (A, B)] = Zip(this, b)

  def foldMap[G[_]](n: F ~> G)(implicit I: Invariant[G], M: Monoidal[G]): G[A]
```
As you can see, the ordinary FreeInvariantMonoidal (in cats, I think) admits operations that a. zip two codecs together and b. map functions both ways. Adding a little bit of spice, you can come up with something similar:
```
sealed trait Iso[A, B] {
  def to: A => Option[B]
  def from: B => A
}
case class Id[A]() extends Iso[A, A]
case class Zip[A, B](fst: Iso[A, B], snd: Iso[C, D]) extends Iso[(A, C), (B, D)]
case class PartialImap[A, B, C](fst: Iso[A, B], to: B => Option[C], from: C => A) extends Iso[A, C]
```

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T19:55:21.552Z
Essentially, a category for correct-by-construction isomorphisms.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T19:56:05.405Z
(there is a similar, more practical example in my github repo [here](https://github.com/edmundnoble/slate/blob/23563a1cc42ac4579f4e4e634e2ca03181cd9aa6/ui/src/main/scala/slate/util/Delimiters.scala))

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T19:56:20.946Z
Huh... that PartialImap looks really familiar. That's almost exactly the signature that's necessary to support sum types. 

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T19:57:40.982Z
Composing partial isomorphisms. I can definitely see there being a relationship with say prisms.

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T19:57:58.103Z
Yup.

                                                                                                                                                      Valentin Kasas @vil1@2016-12-03T20:07:34.857Z
I definitely understand everything that is said here (*laughs nervously*)

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T20:21:57.182Z
@nuttycom i.... have also written a bidirectional parser/printer for JSON https://github.com/adelbertc/circular

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T20:22:15.784Z
and it uses essentially what @edmundnoble described

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T20:22:18.683Z
partial isomorphisms

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T20:22:26.872Z
i haven't found a way to unify it with optics yet

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T20:22:31.097Z
but i also haven't tried very hard

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T20:22:43.995Z
@adelbertc it's all the rage lately, apparently! :)

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T20:22:56.659Z
i'm sure many of us wrote a JSON encoder/decoder for the Nth time

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T20:23:06.864Z
and thought "there should be a better way" ;)

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T20:24:12.618Z
Eyyyy hell yes. Interesting you define it as partial both ways.

                                                                                                                                                      Miles Sabin @milessabin@2016-12-03T20:24:28.025Z
@adelbertc is circular in the TL incubator yet?

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T20:24:47.669Z
@milessabin not yet.. sooon... if i feel comfortable saying i will actively maintain it :)

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T20:24:51.606Z
Hey, @milessabin, it's been a while, how have you been?

                                                                                                                                                      Miles Sabin @milessabin@2016-12-03T20:25:05.331Z
Very busy :-)

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T20:27:06.717Z
Circular looks to be about two levels up from my current level of understanding... being out of the scala world for a bit has clearly caused me to fall behind. :/'

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T20:27:53.351Z
most of it is me transliterating Haskell code :P

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T20:34:14.438Z
@adelbertc so looking at https://github.com/adelbertc/circular/blob/master/argonaut/src/main/scala/circular/argonaut/JsonPIso.scala and PIso, is there a way to deconstruct the structure that you've built up to do anything other than run the isomorphism in one direction or the other? One of the things I want to be able to do is, for example, to write `Schema[E, ?] ~> Gen`

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T20:36:06.040Z
All the operations end up being like that: `Schema[E, ?] ~> CodecJson` etc. 

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T20:37:58.484Z
As a consequence, in sjsch the primitive types that everything eventually decomposes to have to be reified. At least right now, that is... eventually I want to change it up so that you can provide your own sum type to define what is "primitive."

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T20:38:41.041Z
Actually, maybe I should do that now.

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T20:59:55.528Z
@nuttycom my understanding is no, but i havent looked at it hard enough

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T21:00:24.948Z
@adelbertc okay, good, I'm still doing something useful then. :D

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T21:00:27.110Z
it doesn't look like it though since everything runs off `PIso`

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T21:00:39.311Z
and the end type you get assumes `Json` on one side and `A` on the other

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T21:00:52.209Z
so i guess unless `A` was parametric or something

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T21:01:09.415Z
I don't see why you couldn't do that

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T21:01:23.816Z
Make one of your circular codecs into a Gen

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T21:01:44.315Z
If you reified your structure a bit more maybe

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T21:02:05.057Z
@edmundnoble yeah, the reification of the structure is exactly why I need FreeAp

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T21:02:57.131Z
And the preservation of the A type parameter throughout is why I need generalized cofree

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T21:03:08.116Z
Generalized cofree?

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T21:03:33.949Z
Like the dual of generalized free?

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T21:03:46.489Z
https://github.com/nuttycom/sjsch/blob/master/src/main/scala/sjsch/GFunctor.scala#L18

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T21:03:47.363Z
Free c a = c f => f a?

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T21:04:12.186Z
That thing, whatever it is. Like cofree, but one kind level higher?

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T21:04:26.266Z
Oh my god, all of this talk of cofree is reminding me I haven't had a coffee

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T21:04:42.966Z
I wonder if you'll be able to unify that with ordinary cofree with polykinds.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T21:05:11.572Z
Your GFunctor is very familiar as HFunctor as well, have you looked at khats?

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T21:05:42.413Z
Maybe indexed cofree?

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T21:05:58.445Z
Maybe? polykinds still sketch me out a bit... I feel like if I lose the ascribed kinds, that I'll completely fail to be able to understand the code.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T21:06:35.954Z
I feel like I agree completely. The discussion as to the ways we might be able to manipulate it doesn't seem to be heading in a very human-friendly direction so far

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T21:06:56.960Z
Bunch of subtyping rules being invented, AnyKind and SameKind

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T21:07:30.222Z
And yeah, @sellout was mentioning that there were about 3 or 4 of these generalized functor types floating around. I just wrote this one myself for toying around purposes, I'll add a dependency on something (whether matryoshka or khats) once this all firms up a bit.

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T21:07:47.890Z
@edmundnoble probably if i substituted `PIso` with `FreeInvariantMonoidal` or something similar

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T21:20:20.728Z
If you need any [inspiration](https://github.com/edmundnoble/slate/blob/23563a1cc42ac4579f4e4e634e2ca03181cd9aa6/ui/src/main/scala/slate/util/Delimiters.scala)

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T21:42:48.608Z
maybe ill do the finally tagless version of FreeInvariantMonoidal #comeatmebro

                                                                                                                                                      Greg Pfeil @sellout@2016-12-03T22:03:51.625Z
@edmundnoble Yeah, @mossprescott eventually convinced me that generalized invertible syntax needs to be partial in both directions. Eventually he got tired of me always saying it should be a Prism ;)

                                                                                                                                                      Greg Pfeil @sellout@2016-12-03T22:09:41.702Z
Does anyone understand what the list of people on the right-hand side of a Gitter channel is for?

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T22:10:21.902Z
yeah at one point i had converted it to a Prism

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T22:10:23.643Z
and ran into a wall

                                                                                                                                                      Greg Pfeil @sellout@2016-12-03T22:10:38.857Z
Seems to be a random list of 10 people who were in the channel at some point during its existence.

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T22:11:21.123Z
the issue is the **expectation** is parsing may fail which accounts for partiality in one direction, but serialization is almost always total (there are some exceptions, like Scodec's utf8encode)

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T22:11:28.382Z
but due to the way its setup, at least in the paper

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T22:11:50.741Z
if you have a sum type, the codec is setup to be specific to **one of** the data constructors

                                                                                                                                                      Greg Pfeil @sellout@2016-12-03T22:12:00.144Z
@adelbertc Yeah – Moss’ example was when you have something like `Ident(name: String)`, but only some chars are valid in identifiers and the syntax has no escaping mechanism. You just can’t guarantee that you can print that AST.

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T22:12:40.141Z
so if you pass in a different data constructor to the codec, it fails. what we'd like is to be able to compose these codecs such that they can track partiality/totality.. maybe something like that patmat thing the haskell folks do with prisms http://www.haskellforall.com/2015/01/total-100-exhaustive-pattern-matching.html

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T22:12:56.388Z
yeah that too

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T22:13:21.288Z
and idnt hte right hand side of the channel the list of everyone in the channel?

                                                                                                                                                      Greg Pfeil @sellout@2016-12-03T22:13:27.711Z
Heh, yeah, I brought up exhaustive prisms at some point, but didn’t convince anyone to help me with it ;)

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T22:13:28.987Z
oh wait no  i take that back

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T22:13:32.967Z
guess not. no clue what it is thne

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T22:13:44.429Z
i think brian/puffnfresh tried it at some point and hit aw all

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T22:13:58.864Z
i spent a day on it a while back with Monocle and couldnt get the type checker to not give me the finger

                                                                                                                                                      Paul Phillips @paulp@2016-12-06T06:34:34.140Z
@sellout I'm really having trouble coming to terms with the fact that you can write `deriving Traversable` in haskell.

                                                                                                                                                      Paul Phillips @paulp@2016-12-06T06:35:06.185Z
Hmmm, maybe an annotation macro...

                                                                                                                                                      Greg Pfeil @sellout@2016-12-06T06:37:14.259Z
@paulp Shapeless should let us write that, I think … I tried like a year ago or so(?) but was fairly confused by it at the time.

                                                                                                                                                      Paul Phillips @paulp@2016-12-06T06:37:47.505Z
I do have to better acquaint myself with shapeless.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-06T06:39:42.926Z
There’s this: https://github.com/typelevel/shapeless-contrib/blob/master/scalaz/src/main/scala/typeclass.scala – but it doesn’t (yet) cover things like Functor & Traverse. But I think perhaps those are covered in wherever the Cats equivalent of this lives.

                                                                                                                                                      Rob Norris @tpolecat@2016-12-06T06:39:44.531Z
See https://github.com/milessabin/kittens … I think he got functor and foldable but not traverse yet.

                                                                                                                                                      Rob Norris @tpolecat@2016-12-06T06:41:00.339Z
I haven't played with it, just seen some examples.

                                                                                                                                                      Paul Phillips @paulp@2016-12-06T06:41:09.076Z
Mmm. We're a ways from using cats anyway.

                                                                                                                                                      Rob Norris @tpolecat@2016-12-06T06:41:39.227Z
I don't know that it's *that* specific to cats. Functor is functor more or less.

                                                                                                                                                      Paul Phillips @paulp@2016-12-06T06:44:58.380Z
Without looking I just kind of assume a library called "kittens" is likely to make certain assumptions

                                                                                                                                                      Greg Pfeil @sellout@2016-12-06T06:46:34.881Z
Yeah, the same stuff could be added to shapeless-contrib … that just stopped getting updated at _some_ point.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-06T15:46:48.064Z
Wondering how “helpful” Matryoshka should be. For example, it’s often nice to write things with a shape like `F[T[G] => G[T[G]]` (which I call transformations) rather than `F[T[G]] => T[G]` (which is a fold). Converting a transformation to a fold is easy: `_ >>> (_.embed)`.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-06T15:48:57.311Z
Now, should I let users write `_.cata(transform >>> (_.embed))`, which adds no weight to Matryoshka, provide (a small number of) functions that do the conversion like `_.cata(transformToAlgebra(transform))`, provide (a larger number of) transformations in addition to folds like `_.transCata(transform)`, or what?

                                                                                                                                                      Greg Pfeil @sellout@2016-12-06T15:50:35.983Z
Before 0.14, I took the last route because there were types that could do `transCata` that couldn’t do `cata`, but that’s no longer the case. But that also means the definition of `transCata` is simpler now (can be defined in terms of `cata`, as above).

                                                                                                                                                      Greg Pfeil @sellout@2016-12-06T15:51:11.510Z
I was leaning toward the first, because it’s shorter to write `>>> (_.embed)` than `transformToAlgebra` anyway ;)

                                                                                                                                                      Greg Pfeil @sellout@2016-12-06T15:51:43.029Z
And, IIRC, when I tried `transformToAlgebra` (and its ilk), I needed more type annotations.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-06T15:55:42.504Z
Actually, the last one (keeping pre-0.14 `transCata`) may not be generally possible until #44 is fixed, but it could still work for Fix/Mu/Nu in the mean time, I think.

                                                                                                                                                      Valentin Kasas @vil1@2016-12-08T09:28:30.624Z
Hello there. So I've made some (slight) progress since last time, elaborating on the example in the README. I have a Algebra and CoAlgebra allowing me to translate my (recursive) schema representation to `org.apache.spark.sql.types.DataType` back and forth. 
The next step is to find an easy way to embed a `F[F[F[X]]]` in, say a `Fix[F]`. Is there a method for that somewhere ? (the solution used in `someExpr` in the README is not acceptable for my use case)

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-08T09:38:54.389Z
What's your X? Essentially the Fix[F] is F[F[F[F[F[F[...]]]]]]. That's not something you can get directly from a F[F[F[X]]].

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-08T09:39:31.032Z
Perhaps what you'd like is to unfold the X into a Fix[F] so you have an F[F[F[Fix[F]]]], then embed the F's so you have a Fix[F]?

                                                                                                                                                      Valentin Kasas @vil1@2016-12-08T09:57:07.858Z
Well to make my question more clear, using the example in the README, I have a `Mul(Num(21), Num(2))` and I want a `Fix[Expr]` (so that I can `.cata(eval)` on it

                                                                                                                                                      Valentin Kasas @vil1@2016-12-08T09:57:36.138Z
I've tried to go the unfold way, but failed so far

                                                                                                                                                      Valentin Kasas @vil1@2016-12-08T10:42:10.661Z
First, I cannot write a `Coalgebra[Fix, Expr]` (since `Expr` takes a type parameter)

                                                                                                                                                      Greg Pfeil @sellout@2016-12-08T15:31:40.977Z
@vil1 I don’t see an example like that in the README (although I wouldn’t be surprised if there were). I’ve been meaning to write up a page about how/when to avoid writing `.embed` everywhere.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-08T15:32:43.041Z
(Mostly it shows up in tests, when you’re writing significant expectations, so there are a few tricks that I’m happy using in test code that I wouldn’t want in “main”.)

                                                                                                                                                      Valentin Kasas @vil1@2016-12-08T15:36:34.133Z
Sorry, I'm not really clear. I meant : using the `Expr` ADT defined in the readme, I'd like to be able to do what I described (embedding a whole, arbitrary, graph of `Expr` into a `Fix[Expr]` without having to write `.embed` on each node)

                                                                                                                                                      Greg Pfeil @sellout@2016-12-08T15:38:24.517Z
Yeah, so the problem with doing that “directly” is that the type changes at every iteration, right? Because if the type is actually infinite, then you have the problem that Fix … fixes. And if it’s _not_ infinite, then you have `Expr[Expr[Expr[Unit]]]` then `Expr[Expr[Unit]]`, etc.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-08T15:38:34.519Z
So, in Scala, maybe you could do something like …

                                                                                                                                                      Greg Pfeil @sellout@2016-12-08T15:41:37.909Z
```scala
def recurse: CoalgebraM[SomeErr \/ ?, Expr, Any] = {
  case e: Expr[Any] => e.right
  case _            => SomeErr("not an expr”).left
}
```

                                                                                                                                                      Greg Pfeil @sellout@2016-12-08T15:42:13.178Z
I wonder if that would work.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-08T15:57:18.296Z
The way we tend to do it (when we want to use it in production code is like on https://github.com/slamdata/matryoshka/wiki/Best%5B%E2%80%A0%5D-Practices – in the “FooR.scala” section. That example is broken the same way as the one you fixed in the README ;)

                                                                                                                                                      Greg Pfeil @sellout@2016-12-08T15:57:30.280Z
Definitely need to get around to tutting everything.

                                                                                                                                                      Rob Norris @tpolecat@2016-12-08T16:01:52.488Z
Let me know if you need help with that. I can set you up with an empty sbt-microsite if that would help.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-08T16:02:37.025Z
I don’t even know what that means, so … _maybe_?

                                                                                                                                                      Valentin Kasas @vil1@2016-12-08T16:03:22.225Z
I was intending to do that this week-end or the next one, but @tpolecat sur have more experience than I do in these kind of things

                                                                                                                                                      Rob Norris @tpolecat@2016-12-08T16:04:56.550Z
On my phone now but I'll set it up later and you can take a look. 

                                                                                                                                                      Valentin Kasas @vil1@2016-12-08T16:35:50.501Z
@sellout I'll take a look, thx

                                                                                                                                                      Greg Pfeil @sellout@2016-12-08T16:38:36.202Z
@vil1 I just fixed the Wiki page too, so it’s no longer broken.

                                                                                                                                                      Valentin Kasas @vil1@2016-12-08T16:45:37.032Z
Oh god, got it

                                                                                                                                                      Valentin Kasas @vil1@2016-12-08T16:46:05.826Z
I can use the said `FooR` like a "builder" 

                                                                                                                                                      Valentin Kasas @vil1@2016-12-08T16:58:13.315Z
This feels like magic

                                                                                                                                                      Greg Pfeil @sellout@2016-12-08T22:52:41.852Z
@tpolecat Thanks for getting the ball rolling!

                                                                                                                                                      Rob Norris @tpolecat@2016-12-08T22:55:06.542Z
happy to help

                                                                                                                                                      Greg Pfeil @sellout@2016-12-09T05:28:15.301Z
I’m going to issue some bounties – $1k for each type annotation you can remove from the unit tests.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-09T05:28:24.291Z
Might need to get spousal approval first …

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-09T05:29:20.142Z
I'll work full-time on removing type annotations :D

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-09T05:29:32.550Z
(no promises that I won't add any ;))

                                                                                                                                                      Greg Pfeil @sellout@2016-12-09T05:30:28.441Z
You get paid by `prevAnnotations - currentAnnotations`. You add any, you owe me ;)

                                                                                                                                                      Greg Pfeil @sellout@2016-12-09T17:17:55.828Z
@tpolecat BTW, I’m hoping to get in one other PR before merging yours – because then I can merge yours and immediately merge some actual docs afterward.

                                                                                                                                                      Rob Norris @tpolecat@2016-12-09T17:18:20.860Z
Cool, no worries at all.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-09T17:18:58.992Z
@sellout does the machine-checked docs dance 💃🏽

                                                                                                                                                      Greg Pfeil @sellout@2016-12-09T22:23:12.373Z
Loving `publishLocal`, but thinking I wouldn’t have to use it so much if I didn’t rely on Quasar as the Matryoshka test suite.

                                                                                                                                                      Valentin Kasas @vil1@2016-12-09T22:28:22.960Z
Hi. I reached a satisfying point (what I'm about to describe is probably completely trivial, but I like to share my joy when I understand new things). So I've defined a kind `*` `Schema` ADT for my users to instantiate. Using `cata` and an ad hoc `Coalgebra` I'm able to transform a `Schema`to a `SchemaF[A]` (which is a kind `* -> *` ADT that has the same modalities as `Schema` but with a type parameter replacing recursive references). Then I use a `SchemaR[A]` similar to the `FooR[A]` trick described in the wiki to embed `SchemaF` instances in a fixed-point type. So now, I'm an `Algebra` away from being able to translate my `Schema` into any other isomorphic representations like `org.apache.spark.sql.types.DataType` and so on. 

                                                                                                                                                      Greg Pfeil @sellout@2016-12-09T22:29:25.596Z
@vil1 🎉 sharing joy is very much encouraged :D

                                                                                                                                                      Valentin Kasas @vil1@2016-12-09T22:30:53.202Z
All this feels extremely cool. There is still some boilerplate going on, but it's mostly on the library part, so this is completely acceptable (and perhaps shapeless can help me getting rid of it)

                                                                                                                                                      Valentin Kasas @vil1@2016-12-09T22:32:20.985Z
@sellout about your `publishLocal` concerns, maybe you can steal some ideas from `scala/scala`'s build (especially the part with the pos/neg tests)

                                                                                                                                                      Valentin Kasas @vil1@2016-12-09T22:36:43.395Z
(sorry I was too verbose, in fact I do not really use the mentioned `SchemaR` thing anymore, at least for the moment)

                                                                                                                                                      Greg Pfeil @sellout@2016-12-09T22:39:38.983Z
@vil1 I don’t know that I’ve documented this anywhere, but if you have a directly-recursive Schema (as it sounds like you do), you can define your own `Recursive.Aux[Schema, SchemaF]` and `Corecursive` instances, then you never need to explicitly convert between the two – you can apply `cata`, etc. to your `Schema` values using `SchemaF` algebras.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-09T22:39:55.051Z
So it sounds like _maybe_ you can eliminate some more code?

                                                                                                                                                      Greg Pfeil @sellout@2016-12-09T22:41:07.982Z
It was on one of my last slides from Scala By The Bay (and perhaps also Moonconf), but I never got to show it.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-09T22:43:41.763Z
Some day `Birecursive` will work, and you’ll be able to just do
```scala
implicit val birecursive: Birecursive.Aux[Schema, SchemaF] =
  Birecursive.fromIso(iso: Iso[Schema, SchemaF[Schema]])
```

                                                                                                                                                      Greg Pfeil @sellout@2016-12-09T22:44:58.303Z
Actually, Birecursive will provide the Iso, you’ll just provide the two functions.

                                                                                                                                                      Valentin Kasas @vil1@2016-12-09T22:52:29.874Z
I'm not sure we're on the same page there

                                                                                                                                                      Valentin Kasas @vil1@2016-12-09T22:52:47.899Z
here's what I have https://gist.github.com/vil1/d48d612eba0900935b102d0e4fe0159a

                                                                                                                                                      Valentin Kasas @vil1@2016-12-09T22:55:38.110Z
what feels boilerplate-y is the apparent duplication  between `Schema` and `SchemaF`. But these are mirror of each other, one in the user world and the other one in the recursive world

                                                                                                                                                      Valentin Kasas @vil1@2016-12-09T22:56:06.317Z
ow well, I think I get what you said

                                                                                                                                                      Valentin Kasas @vil1@2016-12-09T22:56:27.283Z
I may be able to remove the `schemaToSchemaF` part, right ?

                                                                                                                                                      Greg Pfeil @sellout@2016-12-09T22:58:31.834Z
Yeah, I just commented – let me know if it makes any sense.

                                                                                                                                                      Valentin Kasas @vil1@2016-12-09T22:59:47.140Z
ok, my mind has just blown, did you hear it ?

                                                                                                                                                      Valentin Kasas @vil1@2016-12-09T23:00:27.736Z
yeah that makes perfect sense

                                                                                                                                                      Greg Pfeil @sellout@2016-12-09T23:00:45.618Z
And you define the reverse function – basically `Algebra[SchemaF, Schema]` to get a Corecursive instance.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-09T23:01:01.588Z
And those two functions form an isomorphism, yada yada.

                                                                                                                                                      Valentin Kasas @vil1@2016-12-09T23:02:39.182Z
I really need to learn some theory, but that opens so much opportunities 

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-11T06:09:05.315Z
@sellout I added `cata` and `cataM` for `Free` to cats in a PR. I was not able to use `tailRecM`. I came up with a less sexy solution, which forces trampolining in all uses. The question is whether we'd like to do something similar in matryoshka or make trampolining optional, and then the question is how to propagate that option.

                                                                                                                                                      Rob Norris @tpolecat@2016-12-11T06:22:24.636Z
Hm how would I go about conjuring the comonad instance for fix of envT? Also equal

                                                                                                                                                      Rob Norris @tpolecat@2016-12-11T06:23:33.979Z
Eh actually I don't need the comonad. But equal would be nice.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-11T06:26:41.410Z
@tpolecat So … I think I broke the Equal at some point. I’m about to submit a PR that fixes it, but what’s missing is basically
```scala
  implicit def equalTEqual[T[_[_]], F[_]: Functor]
    (implicit T: EqualT[T], F: Delay[Equal, F])
      : Equal[T[F]] =
    T.equalT[F](F)
```

                                                                                                                                                      Rob Norris @tpolecat@2016-12-11T06:34:47.070Z
Ok I can work around it for now.

                                                                                                                                                      Mark de Jong @Fristi@2016-12-12T21:31:10.782Z
Could matryoshka work with the GADT's encoding of Scala? Any tried or has examples?

                                                                                                                                                      Mark de Jong @Fristi@2016-12-12T21:41:40.411Z
Use-case: I have a GADT describing scala data types (product and coproducts) which can be used to construct JSON encoder/decoders, validators and documentation. Basically you reify the GADT structure into something you want. Generating the documentation is a bit hairy, at some points in building up my tree I combine certain data together to get new data. Which involves introducing some types in my documentation ADT I don't want.  As I am brand new to matryoshka, I wonder.. could this lib help ;)? And maybe it opens some more possibilities

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-12T21:46:52.570Z
@Fristi I dunno what you mean. GADTs are just case classes that fix type params of traits they inherit from. Make your GADT *recursive* and you should be able to matryoshka all over it

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-12T21:47:37.341Z
Everyone's made one of those at this point. If we could standardize on an awesome matryoshka-ified JSON impl that'd be just greeeeeeat

                                                                                                                                                      Rob Norris @tpolecat@2016-12-12T21:48:51.993Z
I know, I have been tempted to offer `JsonF` as an alternative to the Platform proposal but thankfully I'm too lazy.

                                                                                                                                                      Mark de Jong @Fristi@2016-12-12T21:56:56.128Z
@edmundnoble I am using a different encoding of GADT's I think. Guess you use a encoding like this: https://github.com/typelevel/cats/blob/master/free/src/main/scala/cats/free/FreeInvariantMonoidal.scala.

I am doing the finally tagless stuff like here: https://gist.github.com/pchiusano/10678834

Does it clear up things, or am I still vague ;) ?

                                                                                                                                                      Mark de Jong @Fristi@2016-12-12T21:58:29.316Z
JSON is great, but you could also use it to create binary codecs and schema data as data evolves over time and this could be useful. Even with JSON

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-12T21:58:31.184Z
Ah yeah, I am not sure

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-12T21:58:33.247Z
I'm using finally tagless as well but I think you need higher kinded recursion to make it work out.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-12T21:59:25.282Z
Actually you might be fine, just recurse over the A.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-12T21:59:28.926Z
There’s a PR for higher-kinded recursion in Matryoshka … hopefully I’ll get to it soon.

                                                                                                                                                      Mark de Jong @Fristi@2016-12-12T22:00:36.523Z
With only one type param it's oke ;P Thing is `Cartesian`, `CoCartesian` and `Invariant` use 2

                                                                                                                                                      Greg Pfeil @sellout@2016-12-12T22:01:39.373Z
Also, Quasar has its own Matryoshka-fied Json: https://github.com/quasar-analytics/quasar/blob/master/ejson/src/main/scala/quasar/ejson/EJson.scala ;)

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-12T22:02:41.872Z
Tuples?

                                                                                                                                                      Mark de Jong @Fristi@2016-12-12T22:02:42.583Z
@sellout Looking forward to it, till then I'll start with some simple basics of matroyshka then ;p

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-12-12T22:09:11.796Z
What is the `Delay[Equal, A]` pattern analogous to in Cats?

                                                                                                                                                      Paul Phillips @paulp@2016-12-12T22:19:04.339Z
I think ejson would be a very hard sell outside of quasar because the coproduct complicates it a lot and doesn't buy you anything if you're not trying to abstract over json extensions. 

                                                                                                                                                      Greg Pfeil @sellout@2016-12-12T22:28:10.471Z
@dispalt I don’t think there is one. It’s just `Equal[A] => Equal[F[A]]`, so it lets you defer type class resolution, with is necessary with the recursive types (otherwise you’d end up trying to infinitely resolve type class instances). Shapeless(?) has `Lazy[Equal[F[A]]]`, which does sort of the same thing, but requires a lot more machinery. In Haskell you sometimes see `EqualF`, which is yet another way. I’m not sure what is the best way to defer type class resolution, but I am all ears :D 

                                                                                                                                                      Greg Pfeil @sellout@2016-12-13T05:38:20.464Z
Ok, 0.16.1 is out (@tpolecat – this fixes `Equal`)

                                                                                                                                                      Rob Norris @tpolecat@2016-12-13T05:39:31.398Z
![](https://media0.giphy.com/media/JwjBy94VzDd6/200w.gif#0)

                                                                                                                                                      Rob Norris @tpolecat@2016-12-13T07:13:58.339Z
@sellout it appears that 0.15.1 is the latest on central … 

                                                                                                                                                      Greg Pfeil @sellout@2016-12-13T16:06:31.871Z
What is that? Is that different than Sonatype?

                                                                                                                                                      Greg Pfeil @sellout@2016-12-13T16:06:40.686Z
@tpolecat 

                                                                                                                                                      Rob Norris @tpolecat@2016-12-13T16:11:01.675Z
Sonatype, yes 

                                                                                                                                                      Rob Norris @tpolecat@2016-12-13T16:11:19.855Z
Maven central. Same thing as far as I can tell. 

                                                                                                                                                      Greg Pfeil @sellout@2016-12-13T16:28:37.448Z
This shows 16.1: https://oss.sonatype.org/#nexus-search;quick~matryoshka, and I made sure I could depend on 16.1 from Quasar before I posted that message.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-13T16:28:43.869Z
But … how does publishLocal work?

                                                                                                                                                      Greg Pfeil @sellout@2016-12-13T16:29:34.290Z
Because I was using that with Matryoshka/Quasar before, so is it possible that last night I actually picked up a locally-published 16.1? I thought I had to explicitly run `publishLocal` again to update it.

                                                                                                                                                      Rob Norris @tpolecat@2016-12-13T16:35:37.655Z
I'll try again. It wasn't resolving last night. On my phone but I'll check back in a bit. 

                                                                                                                                                      Rob Norris @tpolecat@2016-12-13T16:36:59.558Z
Yeah it comes up on search now. 

                                                                                                                                                      Greg Pfeil @sellout@2016-12-13T16:50:17.745Z
[your giphy back at you]

                                                                                                                                                      Greg Pfeil @sellout@2016-12-13T16:50:51.035Z
Also, I should have your PR merged today as well. Then … Doc City 💃🏽

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-12-13T16:58:11.112Z
Maven central is just a cache so sometimes it won’t show up til you try to download it

                                                                                                                                                      Miles Sabin @milessabin@2016-12-13T19:28:15.249Z
@sellout in a future version of scalac it'll be possible to replace `Lazy[T]` with `=> T` :-)

                                                                                                                                                      Greg Pfeil @sellout@2016-12-13T19:32:45.240Z
@milessabin How future?

                                                                                                                                                      Miles Sabin @milessabin@2016-12-13T19:33:08.759Z
Single digit months.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-13T19:33:18.732Z
That’s my favorite number of digits!

                                                                                                                                                      Rob Norris @tpolecat@2016-12-13T19:44:21.103Z
!

                                                                                                                                                      Valentin Kasas @vil1@2016-12-13T20:48:25.199Z
Hi again. 
Pursuing my schema-translation-thingy with matryoshka, I face an interesting challenge : using my "generic" `SchemaF[A]`, I want to produce (cata) a `avro.Schema`, which AFAIK is only possible using a java-based, side-effecting API. 
Should I go for an `AlgebraM` with `State` as the monad, or is there a simpler solution ?

                                                                                                                                                      Greg Pfeil @sellout@2016-12-13T20:54:46.345Z
Would `State` help? I think you want “the Java monad” – `OptionT[Task, ?]` ;)

                                                                                                                                                      Valentin Kasas @vil1@2016-12-13T20:59:04.377Z
well, I don't see why I need asynchrony there TBH

                                                                                                                                                      Valentin Kasas @vil1@2016-12-13T21:00:22.391Z
but maybe State is not the solution either

                                                                                                                                                      Greg Pfeil @sellout@2016-12-13T21:00:50.240Z
@vil1 Task keeps unmanaged side-effects out of your program.

                                                                                                                                                      Valentin Kasas @vil1@2016-12-13T21:05:36.556Z
ok but, the choice of the monad set aside, is an `AlgebraM` the way to go ?

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-13T21:54:50.985Z
@vil1 It's how I would do it.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-13T21:55:09.288Z
The Java monad, interesting :D

                                                                                                                                                      Paul Phillips @paulp@2016-12-13T22:09:10.878Z
@sellout speaking of the complication that is ejson, I want to cry for how hard it is to print it. What do I need to do to see it rendered in a way I can read it? And what is missing such that this piece doesn't work?
```scala
scala> implicitly[Show[ejson.Common[Data]]]
res5: scalaz.Show[quasar.ejson.Common[quasar.physical.fallback.fs.Data]] = scalaz.Show$$anon$4@1249bdbe

scala> implicitly[Show[ejson.Extension[Data]]]
res6: scalaz.Show[quasar.ejson.Extension[quasar.physical.fallback.fs.Data]] = scalaz.Show$$anon$4@345d1008

scala> implicitly[Show[ejson.EJson[Data]]]
<console>:51: error: could not find implicit value for parameter e: scalaz.Show[quasar.ejson.EJson[quasar.physical.fallback.fs.Data]]
        implicitly[Show[ejson.EJson[Data]]]
                  ^
```

                                                                                                                                                      Paul Phillips @paulp@2016-12-13T22:22:33.734Z
(That's a great example of what I might call "the coproduct tax")

                                                                                                                                                      Valentin Kasas @vil1@2016-12-13T22:31:48.316Z
@sellout, @edmundnoble  or maybe should I use some `Free` stuff to abstract that crappy java thing. God I still have so much things to learn. Be right back in a year or two

                                                                                                                                                      Greg Pfeil @sellout@2016-12-13T22:36:43.269Z
@paulp You _probably_ just need to `import quasar.fp._`

                                                                                                                                                      Valentin Kasas @vil1@2016-12-13T22:43:45.493Z
@sellout : having pondered about your "java monad" for 90+ minutes, I think I'll be remembering it as "computation that might fail but would eventually yield a value, which may be `null` though" 

                                                                                                                                                      Valentin Kasas @vil1@2016-12-13T22:44:16.137Z
(I agree, "java monad" sums it up quite well)

                                                                                                                                                      Paul Phillips @paulp@2016-12-13T22:45:27.029Z
@sellout yep, just discovered that myself

                                                                                                                                                      Paul Phillips @paulp@2016-12-13T22:45:57.528Z
what do you think is a plausible "best practice" way to discover that? I found it by "strategic grepping"

                                                                                                                                                      Rob Norris @tpolecat@2016-12-13T22:52:22.734Z
"How was I supposed to know that?" is an under-appreciated followup question.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-12-13T22:55:57.753Z
Omg totally agree.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-13T23:39:52.709Z
@paulp Yeah, I dunno – basically, we have to redefine a bunch of Scalaz instances so that they work with recursive types – Equal, Show, etc. We should probably do that in matryoshka-scalaz and make them available with all the other instances.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-13T23:40:44.282Z
Even if they stayed in Quasar, they probably belong in `quasar.contrib.scalaz`, not `quasar.fp` (but those two things were synonymous in early days).

                                                                                                                                                      Greg Pfeil @sellout@2016-12-13T23:48:56.476Z
@paulp In the current version, maybe we can add all these Scalaz instances to the `Delay` companion.

                                                                                                                                                      Paul Phillips @paulp@2016-12-14T01:34:36.641Z
@sellout I don't suppose we can mechanically derive all the Delay instances with an implicit macro or something...

                                                                                                                                                      Greg Pfeil @sellout@2016-12-14T03:13:18.186Z
@paulp I imagine with the Shapeless deriving stuff, we could probably get a bunch of the instances … it’s been on my list to dig into forever. I was hoping someone else would have added most of the (non-Delay) cases to shapeless-contrib by now ;)

                                                                                                                                                      Greg Pfeil @sellout@2016-12-14T05:01:50.107Z
So, there is a `Birecursive.Aux[Free[F, A], EnvT[A, F, ?]]` instance, but I’m thinking there can be a lower-priority `Corecursive.Aux[Free[F, A], F]` instance (which is like the pre-0.14 behavior of `Free`). Anyone have any thoughts on this?

                                                                                                                                                      Greg Pfeil @sellout@2016-12-14T05:03:26.762Z
With Cofree, there could be two lower-priority ones `Birecursive.Aux[Cofree[F, A], F]` when `A: Semigroup` and `Recursive[Cofree[F, A], F]` even lower priority.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-14T09:27:06.729Z
@sellout I think it's nice to have the less constrained instances. But all of the operations from them can be implemented using the other instances by ignoring values in a product or always ignoring a value from a `Reader`, except (I believe) the `Cofree` instance with `Semigroup`.

Depends how easy we'd like to make things.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-14T15:12:51.023Z
Yeah, that’s right. The case we run into in Quasar is we have stuff like
```scala
object Expr {
  final class fixpoint[T](implicit T: Corecursive.Aux[T, Expr]) {
    def var(x: String) = Var[T](x).embed
  }
}
```
which provides smart constructors. And we sometimes use those with `Free[Expr, A]`, so what I’ve done for now is to replace the implicit with an explicit `(embed: Expr[T] => T)` parameter and pass `Free.roll` when we want to use `Free`. It’s not a big hassle, but it seems reasonable to be able to use the old approach.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-15T23:00:09.878Z
Using mutual recursion in anger … and it turns out there’s a lot more machinery that has to be “lifted” to higher-order functors.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-15T23:02:22.284Z
PolyKinds and multiple implicit lists are looking better every minute. And there’s no way I would have gotten this far were it not for polymorphic lambdas in kind-projector.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-15T23:02:30.920Z
@sellout What do you think of a macro which generates smart constructors for each Corecursive?

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-15T23:02:44.223Z
Multiple implicit lists are great, where did you get something out of PolyKinds?

                                                                                                                                                      Greg Pfeil @sellout@2016-12-15T23:03:14.399Z
@edmundnoble Well, I haven’t yet – but I want Recursive + HRecursive to be the same type class, etc.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-15T23:03:58.760Z
Ah I see. Great.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-15T23:08:04.464Z
@edmundnoble You mean something that auto-creates the `FooR` class? Yes, that’d be great. There’s definitely a ton of stuff that could be auto-genned.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-15T23:09:21.247Z
Hmmm I smell matryoshka-generic ;)

                                                                                                                                                      Greg Pfeil @sellout@2016-12-16T19:41:31.185Z
Quick, someone get me PolyKinds before I implement `BitraverseKK`.

                                                                                                                                                      Miles Sabin @milessabin@2016-12-16T20:25:06.637Z
Still aiming for "before Xmas".

                                                                                                                                                      Rob Norris @tpolecat@2016-12-17T07:53:23.767Z
Hm, I want to go from `Nu[FooF]` to `Nu[BarF]` bottom-up … what should I be looking at?

                                                                                                                                                      Rob Norris @tpolecat@2016-12-17T07:54:06.130Z
Er `Fix` actually but it shouldn't matter.

                                                                                                                                                      Rob Norris @tpolecat@2016-12-17T07:55:47.418Z
Oh is it just  `cata` with `Algebra[FooF, Nu[BarF]]`? I guess that works.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-17T11:29:23.242Z
@tpolecat You could also use `transCata[Nu[BarF]]` and write your algebra like `FooF[Nu[BarF]] => BarF[Nu[BarF]]`, which is often slightly more convenient.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-20T19:26:16.855Z
https://github.com/slamdata/purescript-matryoshka

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-20T19:46:10.863Z
Mmmmm

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-20T19:46:18.526Z
:+1:

                                                                                                                                                      Rob Norris @tpolecat@2016-12-21T00:35:48.439Z
Say I have two ASTs that are mutually recursive. Is `Birecursive` what will allow me to do the pattern functor thing?

                                                                                                                                                      Rob Norris @tpolecat@2016-12-21T00:58:55.563Z
Oh, clearly not. Something else then?

                                                                                                                                                      Greg Pfeil @sellout@2016-12-21T01:38:34.632Z
@tpolecat You want my PR – #28. I have a bunch of changes that I should push to it, and then try to get it reviewed – it works, but it’s pretty spartan compared to the non-mutually-recursive stuff so far.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-21T01:39:04.505Z
Locally I have at least a few more folds and stuff added – things I needed for Quasar.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-21T01:41:51.202Z
Is there a paper on it? I'd love to learn more. The symbols are making my eyes glaze over ;)

                                                                                                                                                      Greg Pfeil @sellout@2016-12-21T01:45:25.007Z
Hrmm … I dunno. There’s probably something. I cobbled it together from compdata in Haskell, and from reading stuff about multi-sorted ABTs, etc. After staring for a while, you start seeing that everything that was `* -> *` is now `(* -> *) -> (* -> *)`, and the rest falls out of that (which, I know, vastly underestimates the amount of understanding required). But that plus two years ought to do it ;)

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-21T01:50:55.554Z
Damn, I need to look into ABTs now :). Hopefully polykinds helps clean it up and perhaps even gives it more power. compdata also looks interesting.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-21T01:52:46.470Z
@edmundnoble I think PFPL has a good intro to ABTs. I was introduced to them via working with Jon Sterling, who’s now studying under Bob Harper. ABT’s are on my Matryoshka todo list.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-21T01:55:56.374Z
Ahhh thank you. I found Jon's paper through some googling as well. More generic constructs for programming language development is always great :D

                                                                                                                                                      Rob Norris @tpolecat@2016-12-21T02:43:42.221Z
I'm going to conclude that I shouldn't attempt this quite yet.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-21T02:45:40.661Z
@tpolecat Well, I’d be happy to sit down with you and talk through it if you want to – but I understand if you don’t want to invest the time yet. I’m definitely still fleshing it all out.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-21T02:47:36.747Z
Conceptually, it adds an additional type parameter, so you use GADTs to restrict which parts of your coproduct are allowed at each node. But that means duplicating tons of abstractions over `F[_[_], _]` rather than `F[_]`, which isn’t yet there enough to make using it a simple task.

                                                                                                                                                      Tristan Lohman @gatorcse@2016-12-21T03:35:51.327Z
I’m looking through the source trying to familiarize myself with what matryoshka has to offer. I’m still pretty new to a bunch of the ‘hard’ FP stuff, so I’m trying to figure how this library relates to cats, fs2, and the like. In fixedpoint/package.scala, I see instances for Free (also in cats) and Stream (also in fs2). Where do you see this library fitting in with, or competing with, some of these libraries?

                                                                                                                                                      Greg Pfeil @sellout@2016-12-21T03:52:02.766Z
@gatorcse I see it fitting in with … the `matryoshka.instances.fixedpoint` package is mostly just for illustration as to how you could represent the same ideas in a fixed-point way (although Matryoshka’s Stream is different from fs2’s). I don’t want to necessarily advocate for that implementation (at least not until I can do some benchmarking, which I don’t expect will come out in my favor). Recent changes have made it fit in much better – you can see the {Co}Recursive instances for things like `List` in `matryoshka.data`, which weren’t really possible before v0.12 or so.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-21T04:08:30.362Z
That might read better if you imagine “fitting in with” in quotes.

                                                                                                                                                      Tristan Lohman @gatorcse@2016-12-21T04:43:57.399Z
So I shouldn’t read to much into `Mu`/`Nu` possibly representing streams of data?

                                                                                                                                                      Tristan Lohman @gatorcse@2016-12-21T04:44:37.315Z
Just asking because I’m enjoying working with fs2, but their streams can be a little slow sometimes, and I’m exploring to see if there’s anything faster

                                                                                                                                                      Tristan Lohman @gatorcse@2016-12-21T04:45:15.775Z
although I guess it doesn’t matter until @tpolecat writes `doobie-matryoshka`...

                                                                                                                                                      Rob Norris @tpolecat@2016-12-21T04:47:36.708Z
The devils (and there are many) are in the details with effectful streaming and fa2 is the best approach I know. 

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-21T04:47:45.902Z
@gatorcse `Mu` and `Nu` are not effectful streams

                                                                                                                                                      Rob Norris @tpolecat@2016-12-21T04:48:08.777Z
This is starting to get kind of spooky. 

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-21T04:48:16.413Z
You may be able to shove a pattern functor which is a monad transformer in, but I don't think it'd quite work.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-12-21T04:48:25.837Z
Michael Pilquist is also really smart

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-21T04:49:08.965Z
What do you mean, everybody who writes Scala is smart ;)

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-21T04:49:31.679Z
Oh yes as in fs2, yeah it's not quite trying to solve the same problems.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-21T04:49:49.544Z
Nu and Mu are for fusion, essentially you can separate producers and consumers of recursive data at the type-level

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-21T04:50:23.562Z
That is my extremely limited understanding of them anyway

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-12-21T04:50:36.040Z
It’s my generic answer for any reason I like a library

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-12-21T04:51:00.703Z
<library author name> is also really <smart or something similar>

                                                                                                                                                      Tristan Lohman @gatorcse@2016-12-21T05:01:28.593Z
ah, that makes sense, thanks!

                                                                                                                                                      Tristan Lohman @gatorcse@2016-12-21T05:02:02.235Z
and yes, fs2 Streams are pretty sweet!

                                                                                                                                                      Mark de Jong @Fristi@2016-12-21T11:49:00.206Z
I think `doc.transAna[Fix[Schema]](ana).transCata[Fix[Schema]](cata)` is a hylomorphism right? Can you write that as such, couldn't figure out the type signature ;P

                                                                                                                                                      Mark de Jong @Fristi@2016-12-21T11:49:17.253Z
should be something like `transHylo` right?

                                                                                                                                                      Greg Pfeil @sellout@2016-12-21T14:59:50.945Z
@Fristi I think `transHylo` exists in the `Recursive` type class, no?

                                                                                                                                                      Greg Pfeil @sellout@2016-12-21T15:00:02.751Z
(and yes, you should be able to)

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-21T15:00:22.773Z
@sellout @Fristi it's in FunctorT

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-21T15:00:35.796Z
Same place as the rest of the `trans*` family

                                                                                                                                                      Greg Pfeil @sellout@2016-12-21T15:00:44.757Z
@edmundnoble There is no more FunctorT ;)

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-21T15:01:26.675Z
:'( I am clearly in the past.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-21T15:02:18.756Z
That's what happens when I stop contributing to matryoshka for too long ;)

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-21T15:02:26.121Z
(speaking of which @sellout the shims PR is in)

                                                                                                                                                      Greg Pfeil @sellout@2016-12-21T15:02:52.922Z
@edmundnoble I saw 💯

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-21T15:18:56.780Z
:D and 2.12.1 support, woop

                                                                                                                                                      Mark de Jong @Fristi@2016-12-21T15:20:53.450Z
On fire :fire: 

                                                                                                                                                      Pawel Szulc @rabbitonweb@2016-12-22T09:00:29.967Z
hi, so regarding `RecursiveT` - I need it to be `Serializable`, any objections?

                                                                                                                                                      Pawel Szulc @rabbitonweb@2016-12-22T09:00:44.427Z
I will make PR for you guys to comment

                                                                                                                                                      Pawel Szulc @rabbitonweb@2016-12-22T09:14:22.972Z
https://github.com/slamdata/matryoshka/pull/55

                                                                                                                                                      Greg Pfeil @sellout@2016-12-22T18:32:35.994Z
@tpolecat So, returning to a conversation that started in tpolecat/tut … I don’t understand why certain instances aren’t found. Like I have  an instance `Recursive.Aux[Foo, FooF]`, which is actually `Recursive[Foo] { type Base[A] = FooF[A] }` So, then how come later an implicit for `Recursive[Foo]` can’t be resolved?

                                                                                                                                                      Greg Pfeil @sellout@2016-12-22T18:38:12.921Z
Oh, I think I understand. And I think multiple implicit lists may fix it?

                                                                                                                                                      Greg Pfeil @sellout@2016-12-22T18:44:06.179Z
Nope, I’m lost again.

                                                                                                                                                      Valentin Kasas @vil1@2016-12-23T13:57:20.784Z
HI there. Given I have a `F[_]: Functor`, a `Recursive.Aux[A, F]` and a `Corecursive.Aux[B, F]`, is there a way to convert a `A` to a `B` ?

                                                                                                                                                      Greg Pfeil @sellout@2016-12-23T13:58:15.865Z
@vil1 `a.convertTo[B]` should do it.

                                                                                                                                                      Valentin Kasas @vil1@2016-12-23T14:20:14.163Z
indeed, thx !

                                                                                                                                                      Greg Pfeil @sellout@2016-12-23T14:20:39.625Z
👍🏾 Had my fingers crossed 😄

                                                                                                                                                      Valentin Kasas @vil1@2016-12-23T14:27:33.242Z
I realize it is equivalent to having an `Algebra[F, B]` and using a `cata`  

                                                                                                                                                      Greg Pfeil @sellout@2016-12-23T14:27:55.781Z
Yep – and that algebra is simply `_.embed`

                                                                                                                                                      Valentin Kasas @vil1@2016-12-23T14:29:00.928Z
what a time to be alive

                                                                                                                                                      Rob Norris @tpolecat@2016-12-29T18:04:47.494Z
@sellout I'm playing around with typechecking and need a fold I can't quite figure out. I need to pass an Env down and yield an annotated tree or a type error. Something like `F[T] => A => (A, F[T]) => (A, M[G[T]]) => M[G[T]]` where `M` is `Error \/ ?`. I think.

                                                                                                                                                      Rob Norris @tpolecat@2016-12-29T18:07:22.346Z
`transSomething`, looks like.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T18:08:25.980Z
Ok, so what’s the type of the overall fold? `T => A => Error \/ U` (where `T.Base = F` and `U.Base = G`)?

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T18:10:13.130Z
It looks _kind of_ like `transElgotZygoM`, which would have an algebra like `(A, F[U]) => Error \/ G[U]`

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T18:10:47.558Z
Where the `A` is generated from a helper algebra like `F[A] => A`

                                                                                                                                                      Rob Norris @tpolecat@2016-12-29T18:13:27.933Z
The overall thing I want to do is `Cofree[Ast, Stuff] => TyEnv => Error \/ Cofree[Ast, (Stuff, Type)]` and the env I pass down to the next level might need a new binding, which I determine by looking at the current node, kind of like what you can do with attributeTopDown.

                                                                                                                                                      Rob Norris @tpolecat@2016-12-29T18:16:13.721Z
Not urgent, I'm experimenting with a talk idea.

                                                                                                                                                      Rob Norris @tpolecat@2016-12-29T18:19:07.025Z
(Instead of a generating a new `TyEnv` I may error out.)

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T18:21:09.043Z
Ok, so maybe `ana` with
```scala
(TyEnv, Cofree[Ast, Stuff]) => Error \/ EnvT[(Stuff, Type), Ast, (TyEnv, Cofree[Ast, Stuff])]
```
 … which is
```scala
CoalgebraM[
  Error \/ ?,
  EnvT[(Stuff, Type), Ast, ?],
  (TyEnv, Cofree[Ast, Stuff])]
```

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T18:21:19.856Z
Good thing I made that so readable.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T18:21:59.344Z
I give up.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-29T18:22:34.358Z
:clap: `transCataM` with Reader composed with Either?

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T18:24:08.681Z
@tpolecat You might pass a different TyEnv down to each branch, right?

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T18:24:23.160Z
@edmundnoble That’ll go bottom-up, though.

                                                                                                                                                      Rob Norris @tpolecat@2016-12-29T18:31:40.757Z
Well, duh. Stuff needs to bubble back up so I think maybe annotateTopDown and then transCata will do what I want. Ignore me, I'll mess around and then maybe you can tell me how to make it better.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T18:32:16.705Z
👍🏾 We’ll figure out _something_ that fuses ;)

                                                                                                                                                      Rob Norris @tpolecat@2016-12-29T18:32:22.442Z
right on

                                                                                                                                                      Rob Norris @tpolecat@2016-12-29T20:20:12.661Z
Hm Fix of EnvT of List doesn't have a Recursive instance. Is this right?

                                                                                                                                                      Rob Norris @tpolecat@2016-12-29T20:20:45.083Z
I could have sworn I did cata on Fix of EnvT before.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T20:21:12.888Z
Well, there’s a Recursive instance for any Fix.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T20:21:37.600Z
Probably missing an import? `import matryoshka._, data.Fix, implicits._`

                                                                                                                                                      Rob Norris @tpolecat@2016-12-29T20:24:41.472Z
Doh, sorry. 2712. I wasn't using scalatl

                                                                                                                                                      Rob Norris @tpolecat@2016-12-29T20:24:48.214Z
Works.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T20:25:26.721Z
👍🏾 I have happily forgotten about 2712. I _think_ it’s mentioned in the README? Should definitely be in the upcoming docs.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T20:25:55.518Z
Could also add that as a scala-clippy hint.

                                                                                                                                                      Rob Norris @tpolecat@2016-12-29T20:27:48.707Z
[redacted]

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T20:28:27.091Z
😂

                                                                                                                                                      Rob Norris @tpolecat@2016-12-29T20:28:35.705Z
That was mean, sorry.

                                                                                                                                                      Valentin Kasas @vil1@2016-12-29T20:31:16.690Z
Hi again !
Thanks  to you (especially @sellout) I made some valuable progress, I have a generic representation of a schema that I am able to translate to spark and avro flavours.
 Now I have to do something like : `F[A] => M[G[B]]`. 
To be more precise, I have my `SchemaF[A]` that I want to translate to a `Rule[I, Data]` where `Rule` is from `jto.validation` and `Data` a custom type (for which I have a pattern functor `DataF` FWIW). 
Since `Rule[I, ?]` has a monad instance, I think what I seek is around metamorphism/generalized in the cheatsheet provided in the README, but I'm not that confident.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T20:36:01.746Z
That sounds like some transform – either `transCataM` or `transAnaM` (bottom-up or top-down, respectively). I _hope_ you don’t need a metamorphism, because Matryoshka doesn’t have one yet (although I’d like to get around to it – it’s a neat one).

                                                                                                                                                      Valentin Kasas @vil1@2016-12-29T20:39:52.733Z
So, for what I understand from the cheatsheet, I need something that can destruct my SchemaF to its basic components and then build up Rule[I, DataF] from that, which I read like a cata-then-ana (and therefore metamorphism), but since I feel like Jon Snow north the Wall (I know nothing), I may be wrong

                                                                                                                                                      Valentin Kasas @vil1@2016-12-29T20:42:56.360Z
The thing is, I  need to create Rule[I, ?] bottom up

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T20:43:10.499Z
So, you’re overall doing `Fix[SchemaF] => Rule[I, Fix[DataF]]`, right? (although I think you actually have directly recursive `Schema` and `Data` data types). On of the nice things about the new representations, is that it doesn’t matter which of those types you have – they behave the same. So, you don’t need to destruct your Schema as a separate step – it is automatically destructed as you go (and `Data` is automatically built up). So you only need to worry about the “what do I do with one node of SchemaF?” problem.

                                                                                                                                                      Valentin Kasas @vil1@2016-12-29T20:44:31.230Z
I'm not sure I understand everything you wrote (yet) but that feel about it, yes

                                                                                                                                                      Valentin Kasas @vil1@2016-12-29T20:45:34.829Z
to illustrate, I know how to do `IntType => Rule[I, IntValue]` 

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T20:45:59.837Z
So, yeah, I’m _guessing_ you want something like `SchemaF[Data] => Rule[I, DataF[Data]]` and pass that to `transCataM`

                                                                                                                                                      Valentin Kasas @vil1@2016-12-29T20:47:29.381Z
well, that should work 

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T20:47:37.749Z
Also, you can do it without the `trans` bit … `SchemaF[Data] => Rule[I, Data]` – the `trans` variation is semantically the same, just sometimes easier to write. But if you have a directly-recursive `Data`, it probably doesn’t buy you anything.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T20:48:00.017Z
By “without the `trans` bit”, I mean use `cataM` rather than `transCataM`.

                                                                                                                                                      Valentin Kasas @vil1@2016-12-29T20:48:37.507Z
(I still have to work the X part of `AnyPattern[X]`, my brain focuses too much on the `AnyPattern` part)

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T20:50:23.216Z
Yeah – when you’re looking at `SchemaF[Data]`, the subtrees of that node have already been converted to `Data`. There are other morphisms that give you different additional data – e.g., you can have `SchemaF[(Schema, Data)]` that gives you both the converted and unconverted subtrees.

                                                                                                                                                      Valentin Kasas @vil1@2016-12-29T20:51:25.383Z
like histomorphisms ?

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T20:52:15.488Z
Well, that’s a paramorphism – a histo gets you even _more_ info, as you have the original tree plus the intermediate results at every step – `SchemaF[Cofree[SchemaF, Data]]`

                                                                                                                                                      Valentin Kasas @vil1@2016-12-29T20:54:10.722Z
well, I need an onsite teacher

                                                                                                                                                      Valentin Kasas @vil1@2016-12-29T20:54:11.294Z
anyway

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T20:54:26.481Z
heh, docs coming soon, I promise :D

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T20:54:34.232Z
And then scala-exercises!

                                                                                                                                                      Valentin Kasas @vil1@2016-12-29T20:54:46.457Z
let's try that transcataM stuff in the meantime

                                                                                                                                                      Valentin Kasas @vil1@2016-12-29T20:56:32.103Z
(that's the problem with me, as long as I get something that works for the problem at hand, I can bear not understanding *why* it works, wink @nuttycom ^^)

                                                                                                                                                      Valentin Kasas @vil1@2016-12-29T21:18:59.299Z
well, I may not have been precise enough

                                                                                                                                                      Valentin Kasas @vil1@2016-12-29T21:20:31.258Z
what I'm able to do is to build, say,  a `Rule[I, Array[X]]` from a `Rule[I, X]`

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T21:21:12.951Z
Ah, I _almost_ mentioned this, but then thought I had been confusing enough already ;)

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T21:22:37.429Z
So, just because `Rule` _has_ a monad, doesn’t mean you’re using it _as_ a monad. So it sounds like you want a simple `cata` with `SchemaF[Rule[I, Data]] => Rule[I, Data]`

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T21:23:20.733Z
So, your `A` is `Rule[I, Data]`.

                                                                                                                                                      Valentin Kasas @vil1@2016-12-29T21:23:42.990Z
hmm

                                                                                                                                                      Valentin Kasas @vil1@2016-12-29T21:23:53.652Z
(that's so much fun)

                                                                                                                                                      Valentin Kasas @vil1@2016-12-29T21:24:26.004Z
I need an `Algebra[SchemaF, Rule[I,Data]]`

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T21:24:31.202Z
Yup.

                                                                                                                                                      Valentin Kasas @vil1@2016-12-29T21:55:35.270Z
So that seems to work fine (compiles). But it makes me wonder how I can put other schemes to real-world use (all my seemingly complicated use-cases end up to be simple cata/ana-morphisms). But I may only be doing boring stuff

                                                                                                                                                      Valentin Kasas @vil1@2016-12-29T21:56:10.341Z
(at last am I enjoying it ^^)

                                                                                                                                                      Greg Pfeil @sellout@2016-12-30T13:50:08.473Z
@vil1 Heh, whenever I have to use a different scheme, I wonder “can I get this down to a `cata`?” ;) But I think the “compositional” schemes are the most useful – zygo, hylo, etc.

                                                                                                                                                      Rob Norris @tpolecat@2016-12-30T16:09:34.826Z
Turns out all I needed was cata btw. 

                                                                                                                                                      Greg Pfeil @sellout@2016-12-30T16:11:26.708Z
@sellout just starts deleting the other morphisms from Matryoshka.

                                                                                                                                                      Valentin Kasas @vil1@2016-12-30T16:13:15.412Z
So I'm nearly reaching my goal for that pet project (thanks to your advice). What's kind of fun is that I end up with mostly repetitive, boilerplate-y code (but with way less lines than in the original, recursion-by-hand code)

                                                                                                                                                      Rob Norris @tpolecat@2016-12-30T16:33:46.339Z
@sellout the key was to cata into function types … this lets you define top-down state passing from the bottom up. 

                                                                                                                                                      Greg Pfeil @sellout@2016-12-30T16:36:51.155Z
So, like with @vil1’s case, where it _looks_ like you have a `cataM` with `State`, but really the `State` is part of the `A`?

                                                                                                                                                      Greg Pfeil @sellout@2016-12-30T16:37:15.780Z
Actually, I guess looks like `Reader` in your case.

                                                                                                                                                      Rob Norris @tpolecat@2016-12-30T16:45:40.369Z
Yeah. It smelled like cataM with Kleisli but I have to observe the env so it ended up as normal cata into a function type. I'll decruft and make a gist once I have had more coffee. 

                                                                                                                                                      Greg Pfeil @sellout@2016-12-30T16:48:06.194Z
Yeah, I think I actually have the same problem with a function I’ve been trying to turn into an algebra. I’ll have to try that approach. Although, when @paulp saw me write an algebra that folded to a function, he gave me the 😱

                                                                                                                                                      Rob Norris @tpolecat@2016-12-30T16:53:35.788Z
:+1: 

                                                                                                                                                      Greg Pfeil @sellout@2016-12-30T17:58:07.683Z
@tpolecat Yep – just converted a troublesome function to `Algebra[F, A => B]`, and boom. It works. Thanks.

                                                                                                                                                      Rob Norris @tpolecat@2016-12-30T17:58:46.848Z
rock on

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-30T18:14:13.353Z
Damn, I've been doing that a lot lately as well but I gave up on fitting it into an algebra. Double stack-unsafe :O

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-30T18:14:36.543Z
Setter recursion, I've been calling it

                                                                                                                                                      Greg Pfeil @sellout@2016-12-30T18:15:11.730Z
:tim gunn: Make it work, people.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-30T18:16:14.749Z
Yet another emoji missing from Unicode ;)

                                                                                                                                                      Mark de Jong @Fristi@2016-12-30T19:13:04.038Z
@vil1 Curious what you've coded, I am doing something similar.. deriving schema's, codecs, validators, etc from ADT's

                                                                                                                                                      Mark de Jong @Fristi@2016-12-30T19:15:13.050Z
For the schema part I need to rewrite some parts of my tree of data, that's where matryoshka comes in atm

                                                                                                                                                      Valentin Kasas @vil1@2016-12-31T11:07:43.610Z
@Fristi I have an external schema describing incoming data (flat files on HDFS or messages in kafka topics) and some additional metadata for each field (e.g. privacy levels) 
I use this schema to validate the data, process it (e.g. encrypt the private fields) and convert it to more useful formats (parquet, avro,  etc)

                                                                                                                                                      Valentin Kasas @vil1@2016-12-31T11:09:33.520Z
The schema is known only at runtime, and I've in fact many different sources (each with its specific schema) that I need to process with this generic mechanism

                                                                                                                                                      Mark de Jong @Fristi@2017-01-01T12:35:31.915Z
@vil1 Cool stuff! Sounds abit different from what I am doing, but also some overlap. I am nowhere near anything worth showing off, playing around with it and looking for small projects where I can learn from :-)

                                                                                                                                                      Paul Phillips @paulp@2017-01-01T20:13:56.273Z
@sellout in principle, shouldn't we work in type and expression languages which don't allow recursion at all, then exploit those non-recursive-by-construction pieces at a higher layer which exists only to articulate recursive structure? Is there some obstacle or undesirable property to it? 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-02T21:16:15.249Z
@paulp Like Morte? Or perhaps a language which compiles to Morte? I would definitely be interested in segregating recursive code.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-02T21:16:42.911Z
Excluding fixpoints from one part of your language and not allowing primitive recursion should be sufficient.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-02T21:17:43.854Z
Ah yeah, I meant to respond to this … I’ve made a couple steps toward a language (working name: Fix) that compiles to Morte, specifically to play with this idea.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-02T21:18:59.327Z
:D

                                                                                                                                                      Greg Pfeil @sellout@2017-01-02T21:19:40.922Z
You don’t even need to exclude fixpoints – you can implement Mu and Nu (but not Fix) just fine in such a language.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-02T21:20:19.323Z
But, that _doesn’t_ give you all generalized recursion schemes (I don’t think).

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-02T21:20:40.554Z
Because of mutual recursion?

                                                                                                                                                      Greg Pfeil @sellout@2017-01-02T21:20:41.622Z
Anyway, yeah, I would love to be able to spend more time on that.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-02T21:21:07.388Z
Oh, I hadn’t even thought about mutual recursion in it yet :D

                                                                                                                                                      Rob Norris @tpolecat@2017-01-02T21:21:19.472Z
Neato. I was obsessed with morte for an hour or two but got distracted as usual. 

                                                                                                                                                      Greg Pfeil @sellout@2017-01-02T21:22:27.442Z
It’s actually my second “recursion”-free language (the first is a process-calculus language, though, so it’s really replication-free, not recursion-free).

                                                                                                                                                      Miles Sabin @milessabin@2017-01-02T21:23:45.483Z
https://twitter.com/pigworker/status/814439099889254401

                                                                                                                                                      Greg Pfeil @sellout@2017-01-02T21:25:22.820Z
@milessabin https://github.com/slamdata/matryoshka/pull/28 – so close to mergeable. I’ve been using publishLocal to use it to convert stuff in Quasar, which really helps me see which pieces are needed to make it useful.

                                                                                                                                                      Miles Sabin @milessabin@2017-01-02T21:26:22.074Z
:clap:

                                                                                                                                                      Valentin Kasas @vil1@2017-01-03T09:17:21.842Z
What kind of trick should I use to grab some information from an upper node during a cata ? (I already know how to grab info from lower nodes using histo) 

                                                                                                                                                      Valentin Kasas @vil1@2017-01-03T09:19:26.379Z
I know it's not the way cata works, my understanding is that during a cata, the algebra is applied to the (recursive) result of its application to lower nodes

                                                                                                                                                      Valentin Kasas @vil1@2017-01-03T09:20:27.863Z
so my intuition is that my problem is a case of refold (maybe dyna) but the type signatures look not convincing (yet)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-03T18:08:54.240Z
@vil1 you'd like to grab info from the results you've already processed?

                                                                                                                                                      Valentin Kasas @vil1@2017-01-03T18:54:22.212Z
@edmundnoble not exactly (that is, not in the sense of histo, as far as I understand it). Basically, what I need is to know when processing (destructing) a node is the path to this node from the root of the whole structure

                                                                                                                                                      Valentin Kasas @vil1@2017-01-04T11:27:32.069Z
So finally, I obtained the desired result with a simple cata, as usual 😀

                                                                                                                                                      Greg Pfeil @sellout@2017-01-04T16:02:44.091Z
@vil1 heh, I promise you'll eventually get to use a different fold ;)

                                                                                                                                                      Valentin Kasas @vil1@2017-01-04T16:21:56.857Z
I'll keep on trying

                                                                                                                                                      Valentin Kasas @vil1@2017-01-04T16:25:03.600Z
But I'm considering getting a tatoo saying "in the end, it's always a cata"

                                                                                                                                                      Rob Norris @tpolecat@2017-01-04T23:46:41.738Z
@sellout [playing around with extractors](https://gist.github.com/tpolecat/ea87ce95f9b19143e98bdf447f07bb1a) for writing algebras ... not convinced yet but might be worth it.

                                                                                                                                                      Rob Norris @tpolecat@2017-01-04T23:47:26.704Z
I know haskell has pattern synonyms. Same kind of idea? I haven't used them.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-04T23:56:35.322Z
Yeah – now just gotta find a way to make it not break exhaustiveness checking ;)

                                                                                                                                                      Rob Norris @tpolecat@2017-01-04T23:59:11.583Z
@tpolecat puts a bucket over his head

                                                                                                                                                      Mark de Jong @Fristi@2017-01-05T13:16:18.387Z
While learning recursion-schemes I've found the blog posts of https://jtobin.io quite useful sofar

                                                                                                                                                      Greg Pfeil @sellout@2017-01-06T15:30:57.790Z
@Fristi Thanks for the PR!

                                                                                                                                                      Greg Pfeil @sellout@2017-01-06T15:38:02.051Z
Why does my computer only let me choose Celsius and Farenheit? I want Rankine, damn it!

                                                                                                                                                      Greg Pfeil @sellout@2017-01-06T15:38:48.608Z
Regardless, it was -9°F/-20°C this morning. Fun times getting the kids to walk to school 😆

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-06T15:44:23.844Z
Are you in Canada too? :D

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-06T15:44:26.157Z
Same over here

                                                                                                                                                      Greg Pfeil @sellout@2017-01-06T15:46:19.513Z
@edmundnoble Boulder, CO. Oh, Waterloo – awesome. Used to work with a bunch of Waterlooers back in my Amazon days. The most sought-after hires :)

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-06T15:56:18.785Z
@sellout personally, I **love** the Réaumur scale

                                                                                                                                                      Greg Pfeil @sellout@2017-01-06T15:57:26.943Z
@tscholak If 0 isn’t absolute, I don’t want it ;)

                                                                                                                                                      Greg Pfeil @sellout@2017-01-06T15:58:28.925Z
But, after that, I have very little opinion on how big 1° should be.

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-01-06T16:30:47.606Z
I used to live in Oregon but now 

                                                                                                                                                      Rob Norris @tpolecat@2017-01-06T16:58:11.512Z
Yeah we used to fight over the Waterloo people back in Austin. Really good rep. 

                                                                                                                                                      Mark de Jong @Fristi@2017-01-06T23:36:16.512Z
@sellout No problem! I'll look at the revision.md soon!

                                                                                                                                                      Greg Pfeil @sellout@2017-01-07T20:17:16.744Z
@Fristi You know, don’t worry about that revision file – I’m changing the way we handle it, so it should be unnecessary, and I’ll get it merged today.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-08T01:27:58.799Z
@sellout how is matryoshka-cats doing? shims looks to be updated

                                                                                                                                                      Greg Pfeil @sellout@2017-01-08T01:30:13.250Z
Heh – working on getting a $work release out in a week, so a bit bogged down. I have a branch with a lot of the requisite changes on it, but some stuff I was hoping to be able to do, I haven’t figured out yet.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-08T01:31:47.226Z
E.g. – rather than pushing `futu` into the -scalaz and -cats projects, I was hoping to generalize `Free` to `Recursive[T, CoEnv[A, F, ?]]`, so then it could be defined in -core, and work with any implementation of Free.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-08T03:20:30.557Z
Excellent, I have a few Free implementations that need to see the light of day ;)

                                                                                                                                                      Greg Pfeil @sellout@2017-01-08T03:23:23.383Z
Right? There’s three more in Matryoshka as well ;)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-08T03:25:04.440Z
Really? I can only find one.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-08T03:25:17.149Z
Oh one per fixpoint combinator :P

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-08T03:25:18.666Z
Oh u

                                                                                                                                                      Greg Pfeil @sellout@2017-01-08T03:25:24.894Z
Heh

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-08T03:25:40.233Z
I got one with reflection without remorse and one that also has map fusion over [here](https://github.com/edmundnoble/scabsbench/blob/master/core/shared/src/main/scala/scabs/free/FreeMonad.scala)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-08T03:25:58.395Z
(Mu sounds like it would also have map fusion though)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-08T03:26:43.943Z
And one church-encoded if all you care about is performance and not stack-safety (or allocations :P)

                                                                                                                                                      Mark de Jong @Fristi@2017-01-08T15:32:59.682Z
@sellout Aight great :-) thanks for the merge

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-10T05:30:24.884Z
Can someone help me gain some intuition (or point me to a blog post) on what EnvT is? In the docs it just says it is the `transformer for the (,) comonad`, but I don’t know what a comma comonad is either...

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-10T05:31:31.558Z
It's a writerT without the monoid requirement.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-10T05:31:42.646Z
The comma comonad is the reader comonad.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-10T05:32:29.437Z
Well, or the “environment” comonad – which is isomorphic to the reader monad.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-10T05:33:27.889Z
@gatorcse `(,)` is just meant to be `Tuple2` or whatever.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-10T05:33:31.582Z
It's making a function able to access an extra value, but by changing the input type rather than the output type.

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-10T05:34:41.143Z
Thanks team that helps!

                                                                                                                                                      Greg Pfeil @sellout@2017-01-10T05:37:11.292Z
Matryoshka uses it both as a comonad (in `gpara`), but also just for its structure as the pattern functor of Cofree.

                                                                                                                                                      Sumedh Mungee @smungee@2017-01-11T02:30:40.012Z
Is 0.16.3 published to maven yet?

                                                                                                                                                      Greg Pfeil @sellout@2017-01-11T03:19:51.719Z
@smungee Nope, sorry – I’ll get that out now.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-11T03:23:07.430Z
Oh right, sbt-microsites is broken with git worktree :/

                                                                                                                                                      Greg Pfeil @sellout@2017-01-11T03:23:19.352Z
Ok, I’ll get it out, it’ll just take a little longer.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-11T03:24:14.268Z
But I don’t think there’s much since the last published release – 0.16.1 – just a new entry in the README and a tut/microsite skeleton.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-11T03:24:45.221Z
So, nothing new in the published artifacts, I mean – not to diminish the contributions, which are _very_ appreciated.

                                                                                                                                                      Sumedh Mungee @smungee@2017-01-11T03:37:29.106Z
ok, great. I'll use 0.16.1 for now :)

                                                                                                                                                      Sumedh Mungee @smungee@2017-01-11T03:41:04.487Z
btw code that worked in 0.15.1 is throwing the following exceptions in 0.16.1. Has anyone seen this? 

                                                                                                                                                      Greg Pfeil @sellout@2017-01-11T03:42:59.140Z
@smungee There are definitely breaking changes between 0.15 and 0.16 – what are the exceptions?

                                                                                                                                                      Greg Pfeil @sellout@2017-01-11T03:43:11.499Z
Wait … throwing exceptions? Like, at runtime?

                                                                                                                                                      Sumedh Mungee @smungee@2017-01-11T03:45:07.492Z
sorry i meant, compilation errors:
```
matryoshka.Recursive.Ops[matryoshka.data.Fix[$file.ExprTest.Expr],$file.ExprTest.Expr]#transAna.type does not take parameters
val afterParsing = beforeParsing.transAna(parseExpression)
```


                                                                                                                                                      Greg Pfeil @sellout@2017-01-11T03:45:15.541Z
*phew*

                                                                                                                                                      Sumedh Mungee @smungee@2017-01-11T03:45:38.101Z
I had actually forgotten what runtime exceptions were :)

                                                                                                                                                      Greg Pfeil @sellout@2017-01-11T03:45:49.513Z
Yeah, me too for a second there :D

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-11T03:46:15.841Z
Hehehe that's what happens when you do enough FP ;)

                                                                                                                                                      Sumedh Mungee @smungee@2017-01-11T03:47:07.127Z
it makes you incapable of passing java phone screens :)

                                                                                                                                                      Greg Pfeil @sellout@2017-01-11T03:47:43.430Z
So, I think the thing there is that you need to tell `transAna` the result type – `transAna[Fix[Expr]]`, because where it used to transform within a fixed-point, possibly changing the functor, it’s now more general, and can generate any Corecursive type.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-11T03:48:25.176Z
There – this can be the first entry in Matryoshka’s clippy file :D

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-11T03:48:45.846Z
Mmmmmm. Nice.

                                                                                                                                                      Sumedh Mungee @smungee@2017-01-11T03:49:41.118Z
Awesome, that fixes it :)

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-11T16:13:29.242Z
What’s the current downloadable artifact, and is there a 2.12 build yet?

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-11T16:14:02.745Z
I see 2.11@16.1 in sonatype

                                                                                                                                                      Greg Pfeil @sellout@2017-01-11T16:22:13.173Z
@gatorcse Yeah, 0.16.1 is the latest. There’s no 2.12 yet, but I should have that out soon (been playing the depdendency matching game to get everything to work together).

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-11T16:23:12.017Z
Thanks, sounds like a fun game!

                                                                                                                                                      Sumedh Mungee @smungee@2017-01-12T20:05:33.733Z
Are there any examples that show something like `Fix[Option[Exp]]`? Like in the `Exp` example, if I had an `Option[A]` instead of an `A`:

 ```case class Mul[A](left: A, right: Option[A]) extends Exp[A]```

 Would that cause any issues? Does the helper look like this, then?

 ```def mul(left: Fix[Exp], right: Fix[Option[Exp]]) = Fix[Exp](Mul(left, right))```


                                                                                                                                                      Greg Pfeil @sellout@2017-01-12T20:07:46.339Z
@smungee That would be `Fix[Exp]`, with `Mul` having an `Option[Fix[Exp]]` parameter.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-12T20:07:55.769Z
A = Fix[Exp]

                                                                                                                                                      Sumedh Mungee @smungee@2017-01-12T20:11:25.582Z
Ah ok, will try that, thanks

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-17T20:15:02.626Z
Trying to learn about the different “container” types described in the README, and it talks about `F`, `M`, `N`, and `W`. There seems to be specific meaning attached to all of them that isn’t discussed in the README. I get what some of them are (`F`, is your fix-point type, `M` seems to be an (possibly effectful) result monad maybe (it only occurs on the right side of an arrow). Not sure about `W`, is that supposed to be some sort (possibly effectful) monad that the left side is wrapped up in? Seems like it’s a pretty important to understand them, as the various algebras are for different uses of those type arguments. Any help?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-17T20:16:02.689Z
It's a loosely held to convention but M is monads W is comonadic and F and G are both pattern functors.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-17T20:16:42.361Z
T is your fixpoint (like Fix or Mu or Nu) and F or G is the functor recursed on.

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-17T20:17:07.142Z
Sorry, by `G` above I mean `W`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-17T20:18:09.817Z
Ah yes well that makes sense because comonads typically appear on the left and monads on the right.

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-17T20:20:51.751Z
Thanks

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-17T20:21:33.408Z
Very welcome. I'm here for any other questions :)

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-17T20:22:45.425Z
Sorry for all my base level questions, I’m coming at this without the category-theory/haskell background that I think was the expected audience. It’s just the more I learn about this library and other “Free” stuff in the community, the more I see that there is a beautifully simply general eventsourcing library to be had there somewhere, and I’m trying to find it...

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-17T20:23:06.884Z
(hence my insistence on mixing the effectful stuff with this recursion scheme stuff)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-17T20:24:56.260Z
Event sourcing is just the update monad I thought? Free constructions are excellent to learn from and also provide a good CS focused intro to category theory.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-17T20:25:26.438Z
The update monad is basically when you emit updates to your state instead of emitting new state values directly, unfortunately there's not a huge amount of code 

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-17T21:29:16.632Z
That sounds interesting, have to look into that

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-17T21:30:57.562Z
If your updates are best expressed recursively then matryoshka will also likely be hugely helpful.

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-17T21:32:01.443Z
The idea I’m bouncing around is that with algebras/free/etc, your’re building up a data structure that represents your program, and then executing your algebra against it. Since you have a data structure, you can store that structure (your program) in a database. I want to be able to say “Load event stream from database as the stream of program steps to execute, and then just throw the algebra at it

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-17T21:33:50.445Z
Sure, I'm just wondering about the branching factor of your data structure.

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-17T21:33:52.967Z
I think they are recursive because I’m representing an append-only log, where each event happens on top of the last one. But I’m not entirely sure that I’m not trying to make a screw look like a nail so I can use my fancy hammer.

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-17T21:34:03.745Z
The structure should be strictly linear

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-17T21:34:16.344Z
Look like a single linked list

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-17T21:34:34.466Z
Have you taken a look at foldM?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-17T21:34:49.279Z
That folds a monad through a list. Might be helpful.

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-17T21:37:12.810Z
do you mean foldMapM (Can’t find foldM)? Seems pretty good thanks!

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-17T21:38:08.725Z
It may be foldLeftM, dunno where it is.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-17T21:38:17.900Z
FoldMapM is similar.

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-17T21:39:45.312Z
Ah, those are in ScalaZ

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-17T21:41:04.150Z
Yeppers, not in matryoshka, sorry for the ambiguity

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-17T21:42:40.937Z
no worries

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-17T22:27:47.620Z
Well if anyone in the SF bay area wants to help me hack on this, I’ll be at the meetup tonight

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-17T22:33:29.624Z
there's a matryoshka meetup in the SF bay area?

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-17T22:33:48.309Z
that's awesome

                                                                                                                                                      Greg Pfeil @sellout@2017-01-17T22:33:48.511Z
🤣

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-17T22:33:50.184Z
a general scala un-meetup

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-17T22:34:08.621Z
ah :D

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-17T22:34:13.937Z
which basically means intead of talks, we break off and do side projects, experiments, mini presentations, etc

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-17T22:34:47.296Z
Shameless plug (my office is hosting it): https://www.meetup.com/SF-Scala/events/236808083/

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-17T22:34:48.186Z
people from the haskell meetup in toronto are interested in matryoshka

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-17T22:35:04.911Z
woah big embedded cards...

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-17T22:38:41.445Z
Aw should've gone I was in town

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-17T22:39:02.232Z
which one?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-17T22:39:48.695Z
Toronna

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-17T22:39:54.044Z
the haskell meetup is tomorrow

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-17T22:40:13.763Z
Aw I left today :P

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-17T22:40:33.248Z
Some other time. Where was it?

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-17T22:40:38.234Z
bento miso

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-17T22:41:32.981Z
Oh wow cool. Any website?

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-17T22:41:45.762Z
https://bentomiso.com/events/haskell-meetup-2017-jan

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-17T22:41:57.147Z
Excellent. Thank you.

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-17T22:42:19.252Z
np

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-17T22:42:23.774Z
some other time mayhaps?

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-17T22:42:56.188Z
https://groups.google.com/forum/#!topic/toronto-haskell/ubAN0mM1RFQ

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-17T22:43:09.398Z
Oh hell yeah. I'd love to.

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-17T22:43:39.851Z
:+1:

                                                                                                                                                      Rob Norris @tpolecat@2017-01-19T17:51:15.737Z
Does matryoshka have a way to deal with mutually recursive types like users+groups? I can do it by inlining one into the other but that's kind of gross.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-19T17:53:31.030Z
https://github.com/slamdata/matryoshka/pull/28

                                                                                                                                                      Greg Pfeil @sellout@2017-01-19T17:53:48.317Z
I have a pile of unpushed changes to that branch.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-19T17:54:21.698Z
_Hopefully_ it’ll get merged next week, but trying to wrap up this release for $work first.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-19T17:54:45.106Z
But every time I think about it, everything spins toward PolyKinds ;)

                                                                                                                                                      Rob Norris @tpolecat@2017-01-19T18:03:33.112Z
:-)

                                                                                                                                                      Greg Pfeil @sellout@2017-01-19T18:34:48.159Z
Just had a discussion of PolyKinds, MonoidK, etc. at $work. And got to show @mandubian’s excellent “monad = endofunctor monoid” gist: https://gist.github.com/mandubian/dfd670f7740f47a1a2a7b662f828aac6#file-kp-monoid-scala-L52

                                                                                                                                                      Greg Pfeil @sellout@2017-01-19T18:35:30.006Z
(Although, @mandubian, you should really add `def join` to your Monad def, to show that it’s “just” mult, making the parallel to Monoid even clearer.)

                                                                                                                                                      Miles Sabin @milessabin@2017-01-19T19:23:30.328Z
@sellout what are your thoughts on the KP stuff now that you've had a chance to play with it? Is it enough to get useful work done?

                                                                                                                                                      Pascal Voitot @mandubian@2017-01-19T20:27:42.822Z
@sellout I haven't added that `join` because people in scala mostly use `flatMap`

                                                                                                                                                      Pascal Voitot @mandubian@2017-01-19T20:28:11.835Z
but I agree ;)

                                                                                                                                                      Pascal Voitot @mandubian@2017-01-19T20:30:02.535Z
yet I think this def is cool for education but a bit too abstract in practice certainly

                                                                                                                                                      Greg Pfeil @sellout@2017-01-19T20:45:39.983Z
@milessabin Yeah, I think between KP and interleaved implicits that Matryoshka code is going to change (be generalized and simplified) a ton.

                                                                                                                                                      Pascal Voitot @mandubian@2017-01-19T20:53:22.795Z
@sellout BTW, I had written a less generic but a bit more practical version of a KP monoid which would not be usable to represent monads https://gist.github.com/mandubian/083abf83798f35ed42a140755bd90a7f

                                                                                                                                                      Greg Pfeil @sellout@2017-01-19T22:46:01.327Z
@mandubian Why is that one more practical? To me, the `Monad extends Monoid` seems cleaner.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-19T22:51:26.988Z
Also, you can define `MonoidK[M[_]] extends Monoid[M, ~>, Prod[M, M, ?], Const[Unit, ?]]`, no?

                                                                                                                                                      Pascal Voitot @mandubian@2017-01-19T23:10:10.309Z
@sellout `⊗ <: AnyKind` doesn't represent the fact that it's an operation between 2 elements `M ⊗ M` and if you want to describe the category deriving from a Monoid, then it's blocking and I feel like this will be blocking in other cases

                                                                                                                                                      Greg Pfeil @sellout@2017-01-19T23:14:32.188Z
@mandubian Ah, I see … yeah, that’s the kind of thing I kept getting stuck on before, like I wanted to be able to say something like `⊗[M, M] <: AnyKind` … which is terrible syntax that you can hopefully decode.

                                                                                                                                                      Pascal Voitot @mandubian@2017-01-19T23:17:21.385Z
yep and you can't write it for now, clearly ;)

                                                                                                                                                      Pascal Voitot @mandubian@2017-01-19T23:17:57.070Z
it's not really deterministic actually

                                                                                                                                                      Greg Pfeil @sellout@2017-01-19T23:17:58.099Z
Yeah, but I am actually not too upset about the way you punted on it 😉

                                                                                                                                                      Pascal Voitot @mandubian@2017-01-19T23:18:36.149Z
if you have ideas that would seem good, don't hesitate to say

                                                                                                                                                      Pascal Voitot @mandubian@2017-01-19T23:18:41.214Z
this is a first version for KP

                                                                                                                                                      Greg Pfeil @sellout@2017-01-19T23:19:30.108Z
Oh, what you have now seems pretty great. I mean there are things I want to be able to do, like the above, but I have no idea how you would actually do it, and you’re already aware of them.

                                                                                                                                                      Pascal Voitot @mandubian@2017-01-19T23:21:30.704Z
if you see cases that seem inconsistent, don't hesitate to say... that's the most important, we need KP to be consistent in the features we allow

                                                                                                                                                      Alexander Konovalov @alexknvl@2017-01-20T03:10:26.928Z
Does anyone have (or could point to) an example of tying the knot with `matryoshka.data.Nu`?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-20T05:35:56.975Z
Tying the knot, @alexknvl? As in `def x = 1 #:: x`?

                                                                                                                                                      Alexander Konovalov @alexknvl@2017-01-20T05:43:22.039Z
Yes.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-20T05:43:55.716Z
There's a Cofree impl in matryoshka based on Nu.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-20T05:44:14.060Z
Cofree can give you lazy NELs.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-20T06:21:39.537Z
@alexknvl Something like
```scala
def repeat[A]: Coalgebra[(A, ?), A] = a => (a, a)
1.ana[Nu[(Int, ?)]](repeat)
```

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-20T07:10:51.442Z
But can you do Fibonacci? ;)

                                                                                                                                                      Greg Pfeil @sellout@2017-01-20T13:55:11.981Z
@edmundnoble I’m sure you’re kidding, but https://github.com/slamdata/matryoshka/blob/master/core/shared/src/main/scala/matryoshka/package.scala#L713, so `(0, 1).ana[Nu[(Int, ?)]](binarySequence(_ + _))`

                                                                                                                                                      Valentin Kasas @vil1@2017-01-20T14:39:34.007Z
Where can I learn about Mu and Nu, now that I've almost understood the point of Fix (almost no pun intended)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-20T18:41:18.402Z
@vil1 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-20T18:41:51.846Z
https://jyp.github.io/posts/controlled-fusion.html

                                                                                                                                                      Valentin Kasas @vil1@2017-01-20T18:44:50.099Z
Looks very promising. Thx a lot

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-20T18:45:33.405Z
Welcomes

                                                                                                                                                      Valentin Kasas @vil1@2017-01-20T18:49:16.547Z
I've no idea what it means to "polarize the type to deforest" but I'm not afraid 😁

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-20T18:50:37.694Z
On the Duality of Streams (same author) may help.

                                                                                                                                                      Valentin Kasas @vil1@2017-01-20T18:52:58.726Z
Ok

                                                                                                                                                      Greg Pfeil @sellout@2017-01-20T18:53:35.823Z
Also, feel free to add helpful refs to the README … which will be moved to tut docs, once I actually submit my PR that gives us actual tut docs.

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-20T23:22:13.726Z
Do I notice correctly that matryoshka no longer has its own implementation of `Free`, but instead just defers to the one in ScalaZ?

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-20T23:24:23.602Z
nm, found it

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-20T23:25:37.289Z
nm, no I didn’t...

                                                                                                                                                      Greg Pfeil @sellout@2017-01-20T23:47:47.017Z
@gatorcse It does have its own – in matryoshka.instances.fixedpoint, but it uses Scalaz’s elsewhere. That package is mostly meant for illustration at this point.

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-20T23:48:32.459Z
ah, there it is, thanks!

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-20T23:48:47.700Z
so I should probably use ScalaZ’s then?

                                                                                                                                                      Greg Pfeil @sellout@2017-01-20T23:49:03.606Z
I’d _like_ to generalize the Scalaz Free cases to `Birecursive.Aux[T, CoEnv[A, F, ?]]`, so it works with Cats’ Free, Matryoshka’s, etc. interchangably.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-20T23:49:10.953Z
@gatorcse Oh yeah, definitely.

                                                                                                                                                      Konstantin Läufer @klaeufer@2017-01-23T20:58:15.292Z
@sellout or others, I have a nice `fromInt: Coalgebra[Option, Int]` but can't figure out how to invoke `ana` on it. I tried `implicitly[Birecursive[Fix[Option]]].ana(7)(fromInt)` but it says `required: Int => _5.Base[Int] where val _5: matryoshka.Birecursive[matryoshka.data.Fix[Option]]`. Any help would be greatly appreciated.

                                                                                                                                                      Valentin Kasas @vil1@2017-01-23T21:17:07.316Z
maybe you can do something like `7.ana[Nu[Option]](fromInt)`, provided there's a `Functor[Option]` in scope

                                                                                                                                                      Konstantin Läufer @klaeufer@2017-01-23T21:49:21.675Z
Thanks, you're the man! That worked right away!
```
7.ana[Nat](fromInt)
res6: Nat = Fix(Some(Fix(Some(Fix(Some(Fix(Some(Fix(Some(Fix(Some(Fix(Some(Fix(None)))))))))))))))
```

                                                                                                                                                      Valentin Kasas @vil1@2017-01-23T21:51:01.553Z
Great  ! 

                                                                                                                                                      Greg Pfeil @sellout@2017-01-24T02:03:16.667Z
Ok, wow, this is connected to our work Slack, and some of the code showed up there like
```
7.ana<fromInt|Nat>
```

                                                                                                                                                      Greg Pfeil @sellout@2017-01-24T02:03:46.002Z
And I _thought_ I was fairly familiar with Scala by now …

                                                                                                                                                      Greg Pfeil @sellout@2017-01-24T02:05:31.038Z
@klaeufer Corecursive operations are available on any value, but you always have to explicitly supply the result type.

                                                                                                                                                      JerrySwan @JerrySwan@2017-01-26T10:34:39.192Z
Hi all. Newbie question. I know that there's already a matryoshka Nat type which is isomorphic to Option, but as an exercise, I've rolled my own NatF[A] (I can supply the definition but I guess it's obvious to most people), and am looking to express addition as a catamorphism. For generality, I've assumed that the type parameter forms a Monoid.

Q1. Is the following representative of the way these things should be done, or am I missing something?:
Q2. Can I get away with any fewer implicits (or less parametricity) than I am doing?
```
  def addViaCata[T](n: NatF[T], m: NatF[T])(
    implicit TR: Recursive.Aux[NatF[T], NatF],
    TC: Corecursive.Aux[T, NatF],    
    monoid: Monoid[T]): NatF[T] = {

    def algebra(m: NatF[T]): Algebra[NatF, NatF[T]] = { 
      case Z()  => m
      case S(x) => m match {
        case Z() => n
        case S(y) => S(S( x.embed |+| y ).embed )
      }
    }    
    n.cata { algebra(m) }
  }
```

                                                                                                                                                      Greg Pfeil @sellout@2017-01-26T13:00:45.351Z
A1. Yeah, pretty much. The one change is that all of your `NatF[T]` should be just `T`. `T` will eventually be specialized to something like `Fix[NatF]`.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-26T13:05:06.227Z
A2. You can get rid of `Monoid[T]`.  the `S(x)` case in `algebra` is doing too much work – `algebra` should look more like
```scala
case Z() => m
case s   => s.embed
```

                                                                                                                                                      Greg Pfeil @sellout@2017-01-26T13:05:29.774Z
@JerrySwan ↑

                                                                                                                                                      Greg Pfeil @sellout@2017-01-26T13:16:16.315Z
Let me know if anyone sees those messages I sent before this one – they _look_ like they sent, but my Gitter went weird for a bit there.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-26T13:29:07.653Z
@JerrySwan Using this, you can _define_ `Monoid[T]`, with `Z().embed` and `addViaCata`.

                                                                                                                                                      Valentin Kasas @vil1@2017-01-26T14:32:42.009Z
I don't understand the `case s => s.embed` part  (-_-)'

                                                                                                                                                      Greg Pfeil @sellout@2017-01-26T14:59:42.532Z
@vil1 I think it’s a bit confusing because you’re folding to the same type that you started with. But `cata` works from the leaves, right? So, adding `S(S(Z))` (which is really `Fix(S(Fix(S(Fix(Z)))))`) to … we’ll say `8` rather than writing it out, you first hit the `Z` case, and replace it with `8`. Then you hit the inner `S`, with `S(8)`, and you want to return `Fix(S(8))` (where `8` is _really_ `Fix(S(…))`), so `.embed` does that. Then you hit the outer `S` with `S(Fix(S(8)))`, so you just embed that.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-26T15:00:10.073Z
@vil1 Does that help? I’m not sure if making the one side _look like_ an int clarifies things.

                                                                                                                                                      Valentin Kasas @vil1@2017-01-26T15:52:09.824Z
One day, I'll remember that `cata` calls the algebra from the leaves up, one day

                                                                                                                                                      Valentin Kasas @vil1@2017-01-26T15:53:01.206Z
thanks, that makes perfect sense indeed

                                                                                                                                                      JerrySwan @JerrySwan@2017-01-26T16:45:48.162Z
@sellout - thanks a lot. For completeness, below is as far as I've now got, which leads to 2 more questions: 
1. I currently have the return type of fromInt as Nu[NatF]. Should I not prefer to have that as a NatF[Int]? 
2. The compiler is complaining about the lack of recursive/corecursive implicits. Where do I get these from?

```    
    sealed trait NatF[A]
    final case class Z[A]() extends NatF[A]
    final case class S[A](a: A) extends NatF[A]
    
    implicit val natFunctor = new scalaz.Functor[NatF] {
      override def map[A, B](fa: NatF[A])(f: (A) => B) = fa match {
        case Z()  => Z[B]()
        case S(a) => S(f(a))
      }
    }

    ///////////////////////////////
    
     def toInt[T](x: NatF[T])(implicit TR: Recursive.Aux[NatF[T], NatF]): Int =        
        x.cata[Int] { case Z()  => 0; case S(x) => 1 + x }
    
    def fromInt(x: Int)(
      implicit TC: Recursive.Aux[Int, NatF]): Nu[NatF] = {
      
      val coalgebra: Coalgebra[NatF,Int] = { 
        case 0    => Z()
        case s => S(s-1)
      }
      x.ana[Nu[NatF]] { coalgebra }
    }
    
    ///////////////////////////////

    def add[T](n: T, m: T)(
      implicit TR: Recursive.Aux[T, NatF],
        TC: Corecursive.Aux[T, NatF]): T = {

      def algebra(m: T): Algebra[NatF, T] = { 
        case Z()  => m
        case s  => s.embed       
      }    
      n.cata { algebra(m) }
    }  

    println( add( fromInt(1), fromInt(2) ) )
```
 

                                                                                                                                                      Greg Pfeil @sellout@2017-01-26T16:51:43.883Z
@JerrySwan 1. The return type of the coalgebra is `NatF[Int]`, but once it’s applied repeatedly by `ana`, the result of `fromInt` will be `Nu[NatF]`, as you have. 2. You need to import `matryoshka_` (for the type classes), `matryoshka.data._` (for the Fix/Mu/Nu instances), and `matryoshka.implicits._` (for the implicit conversions that inject `ana` etc. on arbitrary values).

                                                                                                                                                      JerrySwan @JerrySwan@2017-01-26T17:10:56.146Z
@sellout Thanks a lot - it also turns out that the implicit for ```fromInt``` was spurious. That now works (in the sense of printing out S(Nu)).  So, question now is  what do I need to do to make ```println( toInt( add( fromInt(1), fromInt(2) ) ) )``` work? Currently, I'm getting "type mismatch; found : matryoshka.data.Nu[NatF] required: NatF[?]". Sorry if this should be obvious: I'm hoping that once I see the process working end-to-end, I'll be able to generalize appropriately from there...

                                                                                                                                                      Greg Pfeil @sellout@2017-01-26T17:14:11.138Z
@JerrySwan Oh, yeah, I didn’t notice the implicit there – that implicit can’t exist … or, I guess maybe it could. You could define `Recursive[Int]` such that `project(t: Int) = t match { case 0 => Z(); case n => S(n - 1) }`, which is your `fromInt` (but notice that that function won’t terminate if you give it a negative Int)

                                                                                                                                                      Greg Pfeil @sellout@2017-01-26T17:15:27.278Z
@JerrySwan Your `NatF[T]`s in `toInt` should be just `T`

                                                                                                                                                      Valentin Kasas @vil1@2017-01-26T17:23:18.043Z
For what it's worth, I'd write `sealed trait NatF[+A]` and `case object Z extends NatF[Nothing]`, that would save some keystrokes elsewhere

                                                                                                                                                      Greg Pfeil @sellout@2017-01-26T17:27:19.318Z
Yeah … I’ve been meaning to try playing with variance in Matryoshka, but I usually end up running into a wall with it somewhere or other. One place we try to manage subtypes is https://github.com/slamdata/matryoshka/blob/master/core/shared/src/main/scala/matryoshka/implicits/package.scala#L28, but that won’t make `Z.embed` work, so I always need `Z[T]().embed` on leaf nodes. Definitely not ideal.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-26T17:28:34.873Z
We _should_ be able to make `Corecursive[T].embed(Z)` work, though, with something like `F[TT]` where `TT <~< T`.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-26T17:30:11.403Z
Actually, maybe even another version of `CorecursiveOps` that expects explicitly `F[Nothing]` and has the `def embed[T]` *shrug*

                                                                                                                                                      Greg Pfeil @sellout@2017-01-26T17:30:56.395Z
So, something I’d _like_ to try, but happy to get PRs to work better with those cases. SlamData doesn’t use subtyping, so we don’t generally see these cases in practice.

                                                                                                                                                      JerrySwan @JerrySwan@2017-01-26T17:43:39.544Z
@sellout @vil1 Thanks - now works and I'm starting to get a better feel for the required patterns...

                                                                                                                                                      JerrySwan @JerrySwan@2017-01-27T13:02:44.096Z
OK, stuck again ;-) Would anyone be kind enough to show how to express factorial as a para and/or hylo?

                                                                                                                                                      Valentin Kasas @vil1@2017-01-27T14:02:32.078Z
I can't. I've come to believe that "in the end it's always a cata", but YMMV

                                                                                                                                                      Greg Pfeil @sellout@2017-01-27T16:43:27.669Z
@JerrySwan Here it is as a `para`:
```scala
def factorial: GAlgebra[(Nat, ?), NatF, Nat] = {
  case Z()            => S(Z().embed).embed
  case S((prev, acc)) => (prev * acc) + acc
}
```
(defining `*` is left as an exercise for the reader 😄)

                                                                                                                                                      Greg Pfeil @sellout@2017-01-27T16:50:58.547Z
In English: `!0` is defined to be `1`, and the factorial of any other number, `n` is the previous factorial (`acc`) times `n` … so the latter case could be rewritten `S(prev).embed * acc`. And there _may_ be a way to write it using an elgot algebra rather than a generalized algebra, let me see …

                                                                                                                                                      Greg Pfeil @sellout@2017-01-27T16:53:15.759Z
Eh, it’s not immediately apparent to me.

                                                                                                                                                      Valentin Kasas @vil1@2017-01-27T16:55:33.879Z
Should I remember para as "recursion with an accumulator" ?

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-27T16:56:05.103Z
stupid question asked by someone who never did anything with `NatF` beyond tinkering: since factorial grows faster than any exponential, won't this break down more or less immediately?

                                                                                                                                                      Greg Pfeil @sellout@2017-01-27T16:56:17.748Z
Actually, the accumulator is really the `cata` part – the para is maintaining the original structure.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-27T16:56:28.154Z
@tscholak Oh, yes. Definitely.

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-27T16:56:56.217Z
ah ok, well then :D

                                                                                                                                                      Greg Pfeil @sellout@2017-01-27T16:57:10.686Z
the performance of `!Nat` is `!n` 😆

                                                                                                                                                      Valentin Kasas @vil1@2017-01-27T16:59:51.362Z
Maybe it's time for me to confess: I don't know how to read the cheat sheet (-_-)'

                                                                                                                                                      Greg Pfeil @sellout@2017-01-27T16:59:52.574Z
There are ways around that, though – Wadler (I think) has the concept of views, which is basically the mapping of an inductive structure onto a non-inductive one. E.g., Idris lets you use Nat, but compiles it to integers, so their performance scales (at least to the extent that you’ve mapped the operations – e.g., if you’ve mapped Nat `+` to Int `+`, but haven’t mapped `*`, then Nat `*` will be O(n), not O(1) … I think)

                                                                                                                                                      Greg Pfeil @sellout@2017-01-27T17:06:18.373Z
@vil1 I’m not surprised … but I would like it to be helpful. I was hoping the English on there was enough to assist, and the red highlights how each one differs from the basic cata / ana. And clearly there were things I didn’t know how to fit in 😆

                                                                                                                                                      Valentin Kasas @vil1@2017-01-27T17:08:49.974Z
Well, please take into account the fact that my brain still struggles to read haskell-ish type signatures (among other struggles) 

                                                                                                                                                      Valentin Kasas @vil1@2017-01-27T17:09:05.099Z
but lets take para as an example

                                                                                                                                                      Valentin Kasas @vil1@2017-01-27T17:13:06.380Z
I read `f (Fix f × a) → a` but I don't see the algebra in there

                                                                                                                                                      Greg Pfeil @sellout@2017-01-27T17:13:14.907Z
So, I think I can re-organize the cheat sheet a bit now, too. I haven’t really looked at it in a while.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-27T17:13:42.280Z
@vil1 If you ignore the characters in red, you’ll see `f a -> a` (or `F[A] => A` in Scala)

                                                                                                                                                      Valentin Kasas @vil1@2017-01-27T17:14:06.661Z
hmm, ok

                                                                                                                                                      Valentin Kasas @vil1@2017-01-27T17:14:36.027Z
so `f (Fix f × a) → a` is basically the algebra I need to pass to a para

                                                                                                                                                      Greg Pfeil @sellout@2017-01-27T17:16:17.816Z
Yeah, exactly.

                                                                                                                                                      Valentin Kasas @vil1@2017-01-27T17:17:09.307Z
Well, now it's obvious (I could have deduced that from the signature under cata)

                                                                                                                                                      Greg Pfeil @sellout@2017-01-27T17:17:26.414Z
the big “generalized” block shows the general form – which is `F[W[A]] => A`, where `W` is some `Comonad` (which is a cheeky pun on `M` being `Monad`).

                                                                                                                                                      Greg Pfeil @sellout@2017-01-27T17:18:34.051Z
For `cata` `W = Id`, for `para` `W = (Fix[F], ?)` (which is actually just a special case of `zygo` where `W = (B, ?)`).

                                                                                                                                                      Valentin Kasas @vil1@2017-01-27T17:18:44.398Z
(yep, "`W` is  co`M`" is rather clear)

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-27T17:19:43.660Z
`(Fix[F], ?)` is a comonad?

                                                                                                                                                      Valentin Kasas @vil1@2017-01-27T17:20:53.474Z
I think `(X, ?)` is a comonad for any `X` (you can always extract a `A` from a `(X, A)` for any `X`)

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-27T17:21:42.105Z
ah, thanks, now it's obvious

                                                                                                                                                      Valentin Kasas @vil1@2017-01-27T17:23:04.461Z
I guess `(?, X)` would be too, but kind-projector has limitations on the position of the `?` 

                                                                                                                                                      Greg Pfeil @sellout@2017-01-27T17:23:05.948Z
@tscholak Yeah, it’s called the “environment” comonad, isomorphic to the reader monad.

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-27T17:24:50.041Z
yeah, I remember now. I read runarorama's article on comonadic reader a while back

                                                                                                                                                      Valentin Kasas @vil1@2017-01-27T17:25:17.902Z
ok so it's quite clearer now : during a para, my algebra is called with a product of 1. the full structure below the current node & 2. the partial result of the application of the algebra to what's below the current node 

                                                                                                                                                      Greg Pfeil @sellout@2017-01-27T17:25:40.532Z
@vil1 Exactly :D

                                                                                                                                                      Greg Pfeil @sellout@2017-01-27T17:25:51.626Z
I think the cheat sheet may just need a bit of a legend attached.

                                                                                                                                                      Valentin Kasas @vil1@2017-01-27T17:26:07.835Z
Yep, that would help I think

                                                                                                                                                      Rob Norris @tpolecat@2017-01-27T18:51:06.148Z
ping https://www.reddit.com/r/scala/comments/5qiv1d/simple_real_world_matryoshka_example/

                                                                                                                                                      Greg Pfeil @sellout@2017-01-27T18:52:18.118Z
If there were just _one_ less word in that post, I’d link to Quasar 😆

                                                                                                                                                      Greg Pfeil @sellout@2017-01-27T18:56:38.392Z
@vil1 Well, I just made a pile of changes to the cheat sheet, but I’m not sure it helps. Maybe I should use layers, like those books with transparent pictures of the human body.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-27T18:57:17.227Z
First you just see cata / ana, then you see gcata + para, etc., then you see gpara, ghisto …

                                                                                                                                                      Valentin Kasas @vil1@2017-01-27T20:24:04.846Z
err, where can I see those changes ?

                                                                                                                                                      Greg Pfeil @sellout@2017-01-27T20:24:47.185Z
@vil1 Oh, sorry – just on my machine at the moment. I’ll publish it soon. A few more things to change, I think … like adding a legend :D

                                                                                                                                                      Valentin Kasas @vil1@2017-01-27T20:55:28.203Z
can't wait ^^

                                                                                                                                                      Valentin Kasas @vil1@2017-01-27T20:56:07.250Z
@tpolecat made my humble contribution https://www.reddit.com/r/scala/comments/5qiv1d/simple_real_world_matryoshka_example/dczrakd/

                                                                                                                                                      Greg Pfeil @sellout@2017-01-27T20:59:42.362Z
@vil1 Thanks 😃

                                                                                                                                                      Valentin Kasas @vil1@2017-01-27T21:11:34.234Z
(I subscribed to reddit only for that (yes I know it's 2017…))

                                                                                                                                                      JerrySwan @JerrySwan@2017-01-29T16:25:58.025Z
@sellout - thanks. Am I right in thinking that this requires the kind-projector compiler plugin?

                                                                                                                                                      Greg Pfeil @sellout@2017-01-29T16:36:30.975Z
@JerrySwan Yeah – it’s hard to write much FP code without it. I mean, you can, but it gets ugly fast.

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-29T16:54:13.349Z
hi, I've been teaching myself recursion schemes for the past few days.
I started by looking into recursion with `Fix[ListF[?, B]]` and some `Fix[ExprF]` with `ConstF` and `ProductF`.
I worked my way to a definition of a `fold` that works for both, i.e.
```scala
    def fold[B, C](l: Fix[ListF[?, B]])(zf: Algebra[ListF[?, B], C]): C =
      zf(map(l.unFix)(fold(_)(zf)))
```
and
```scala
    def fold[B](e: Fix[ExprF])(zf: Algebra[ExprF, B]): B =
      zf(map(e.unFix)(fold(_)(zf)))
```
Now I'm trying to repeat this exercise with `Free[ListF[?, B], A]` and `Free[ExprF, A]`.
However, this time, by following the types (and peeking into Matryoshka), I arrived at:
```scala
    def fold[A, B](e: Free[ExprF, A])(zf: Algebra[CoEnv[A, ExprF, ?], B]): B = {
      zf(map(CoEnv(e.resume.swap))(fold(_)(zf)))
    }
```
where
```scala
    def map[A, B, C](ef: CoEnv[A, ExprF, B])(f: B => C): CoEnv[A, ExprF, C] =
      CoEnv(ef.run.rightMap {
        case ConstF(v) => ConstF(v)
        case ProductF(l, r) => ProductF(f(l), f(r))
      })
```
What is the deeper reason for why I get `Algebra[CoEnv[A, ExprF, ?], B]` instead of `Algebra[ExprF, B]` here?
I understand that shaving off a layer of `Free` gives you *either* a value *or* another computation and that this has to be reflected in the types.
However, conceptually, I don't like that I seem to need different algebras for working with `Fix` and `Free`.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-29T17:18:44.808Z
@tscholak There are a few ways to deal with that –
1. while you can’t ignore the _either_ aspect when folding, I’ve considered adding a lower priority `Corecursive.Aux[Free[F, ?], F]` instance that _does_ allow you to ignore the extra structure when unfolding;
2. if you look for `matryoshka.interpret` (poorly named) and friends, you can use your regular `Algebra[ExprF, B]` and pair it with a function `A => B` to deal with the leaves of the Free; and
3. I swear there was a third thing, but I’ve forgotten what it was.

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-29T17:32:37.417Z
:D Thank you for your suggestions

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-29T17:39:04.581Z
another thing I have tried (but so far have not achieved) is to find and make explicit the connection between a (monadic) `Algebra` and a natural transformation `~>`

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-29T17:41:35.811Z
what I'm after in general is an understanding of the relationship between the interpreter pattern with `Free` and the recursion schemes found in Matryoshka

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-29T19:43:14.294Z
re: connection btw `Algebra` and `~>`:
```scala
    def mkInterpreter[B](zf: Algebra[ExprF, B])(implicit F: Functor[ExprF]) = new (ExprF ~> Const[B, ?]) {
      override def apply[A](ef: ExprF[A]): Const[B, A] = Const(zf(F.map(ef)(leafer)))

      def leafer[A](a: A): B = ???
    }
```
hmm, it seems I can't write a non-trivial `leafer`

                                                                                                                                                      Greg Pfeil @sellout@2017-01-29T19:48:37.136Z
@tscholak I _think_ that a Free interpreter is just a special case of `AlgebraM`. In Haskell you can write it like `forall a. AlgebraM m f a`, but unfortunately it’s not so direct in Scala. And not all `AlgebraM`s are `A`-agnostic, so mostly can’t be represented as natural transformations.

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-29T19:54:56.482Z
I see. Thank you, that gives me something to think about

                                                                                                                                                      Olivier Mélois @Baccata@2017-01-29T20:59:30.262Z
Hi there, is Matryoshka published in any maven / ivy repository for scala 2.12 by any chance ?

                                                                                                                                                      Greg Pfeil @sellout@2017-01-29T21:10:56.571Z
@Baccata Ah, sorry – I always forget to publish. I'll get a 2.12 version out in an hour or so.

                                                                                                                                                      Olivier Mélois @Baccata@2017-01-29T21:13:10.869Z
@sellout :+1: cheers !

                                                                                                                                                      Greg Pfeil @sellout@2017-01-29T23:53:38.735Z
@Baccata ok, sorry, hopefully tonight, but having issues with publishing multiple versions and need to step away for a few hours.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-30T02:55:41.295Z
@Baccata Ok – 0.16.5 is published for both 2.11 and 2.12

                                                                                                                                                      Olivier Mélois @Baccata@2017-01-30T12:09:26.725Z
@sellout thank you ! Apart from that, I have a question : I'm trying to model a recursive structure where recursive points can be parameterized. The goal would 
be for people to provide their custom algebras (such as KVStore below), and provide them with a common structure for composing them (think `Exp[A]`in matryoshka tests) 
```scala
sealed trait KVStore[F[_], A]
 case class Put[F[_]](key : F[String], value : F[String]) extends KVStore[F[_], String]
case class Get[F[_]](key : F[String] extends KVStore[F[_], Option[String]]
... 
```
I'm thinking that it must be possible to extract from such an ADT,  the coproduct `C` of all types involved in the operations, and by using a constant type, lift the values into `C` whilst retaining type-safety when composing operations. I instinctively believe that it's probably possible to provide a Functor for KVStore that acts on the `F[_]` type (through Const), and therefore allow the delegation of the recursion to a fixed-point (by saying F[_] == A)

So my question basically boils down to, would it be possible for a Fixed-Point type to carry a phantom type around ? 



                                                                                                                                                      Greg Pfeil @sellout@2017-01-30T18:23:56.016Z
@Baccata So, I don’t understand exactly what you’re trying to do, but it sounds roughly like mutual-recursion (but I’m probably wrong). If I’m _not_ wrong, look at https://github.com/slamdata/matryoshka/pull/28 for work about to get into Matryoshka – perhaps specifically https://github.com/sellout/matryoshka/blob/56c2ce8343d43c4513d890511c60fda4fbe79085/core/jvm/src/test/scala/matryoshka/mutu/Common.scala 

                                                                                                                                                      Olivier Mélois @Baccata@2017-01-30T19:03:46.404Z
@sellout, that's exactly what I want to do :smile: 

                                                                                                                                                      Olivier Mélois @Baccata@2017-01-30T19:09:05.471Z
ideally combined with shapeless to derive the HTraverse 

                                                                                                                                                      Olivier Mélois @Baccata@2017-01-30T19:16:19.040Z
(which would very likely be made possible if this issue was solved : https://github.com/milessabin/shapeless/issues/683) 

                                                                                                                                                      dwhitney @dwhitney@2017-01-30T19:17:09.871Z
@sellout did you see this? https://www.reddit.com/r/scala/comments/5qiv1d/simple_real_world_matryoshka_example/

                                                                                                                                                      Greg Pfeil @sellout@2017-01-30T19:41:14.502Z
@dwhitney Yeah, thanks. I could do a Matryoshka port of @tpolecat's talk if he's cool with it. Would be a good use of tut :smile: 

                                                                                                                                                      Paul Phillips @paulp@2017-01-30T19:41:35.189Z
You know a really compelling use case for recursion schemes would be type operations. So many scala compiler bugs are in the subtyping and equivalence logic - often tied up in when and how to handle recursive cases. All the recursion logic is ad hoc and embedded in variously named organically grown methods.

                                                                                                                                                      Rob Norris @tpolecat@2017-01-30T19:42:59.187Z
@sellout mi casa es tu casa

                                                                                                                                                      dwhitney @dwhitney@2017-01-30T19:47:25.176Z
w00t!

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-30T23:10:21.056Z
@paulp I'm going to look at making a scala compiler doing that once we have matryoshka-cats

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-30T23:10:41.210Z
Fusion then also becomes actually rigorous

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-30T23:11:29.430Z
Combined with tagless style it may be possible to add several tree types without forcing reallocation; for example, one pre-desugar, one post-, and one post-typer.

                                                                                                                                                      Paul Phillips @paulp@2017-01-30T23:23:26.964Z
@edmundnoble yes I had similar thoughts.

                                                                                                                                                      Greg Pfeil @sellout@2017-02-02T21:13:25.540Z
So … how much would it affect people if Matryoshka moved from Scalaz 7.2.8 to 7.3.0-M8?

                                                                                                                                                      Greg Pfeil @sellout@2017-02-02T21:14:38.160Z
Alternatives include building multiple artifacts and trying to get the change I need backported to the 7.2 line.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-02T21:14:55.056Z
Which change?

                                                                                                                                                      Greg Pfeil @sellout@2017-02-02T21:14:58.093Z
But bumping my dep is the easiest from my perspective.

                                                                                                                                                      Greg Pfeil @sellout@2017-02-02T21:15:36.232Z
@edmundnoble `Inject#unapply`. I actually only need it downstream in Quasar, but binary compatibility and all that.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-02T21:19:11.126Z
Oh my. That sounds very possible to add to 7.2

                                                                                                                                                      Greg Pfeil @sellout@2017-02-02T21:19:24.027Z
Yeah, it’d be trivial.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-02T21:19:28.966Z
Though of course, that depends on a good Samaritan ;)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-02T21:19:37.654Z
I'll take a look today

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-02T21:19:44.525Z
Couldn't be that bad

                                                                                                                                                      Greg Pfeil @sellout@2017-02-02T22:44:15.961Z
Holy crap, updating dependencies is a pain.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-02T23:10:42.669Z
Yup.

                                                                                                                                                      Konstantin Läufer @klaeufer@2017-02-06T14:55:22.000Z
Good morning...  I am converting some examples for my PL class from my own library to Matryoshka. Everything works great for functors based on case classes. But I am having trouble getting some of the implicit operations to work for bifunctors such as `case class NelF[A, B](head: A, tail: Option[B])`. Concretely, this works:
```RecursiveT[Fix].cataT[NelF[String, ?], Int](list1)(length)```
but not this:
```list1.cata(length)```
I am puzzled because I imported all the same stuff as for my simple `Expr` example. I am using 0.16.4, and the complete example is here: https://github.com/lucproglangcourse/matryoshka-examples-scala/blob/master/src/test/scala/NonEmptyList.scala#L98
Any help would be greatly appreciated.

                                                                                                                                                      Greg Pfeil @sellout@2017-02-06T15:45:36.625Z
@klaeufer Are you using something that has SI-2712 fixed? (Either the plugin, or some version of scalac that understands `-Ypartial-unification`?

                                                                                                                                                      Konstantin Läufer @klaeufer@2017-02-06T15:47:30.785Z
@sellout Probably not... Let me put that in place and try again in a little while. Thanks a lot!

                                                                                                                                                      Greg Pfeil @sellout@2017-02-06T16:08:18.098Z
@klaeufer Sure … one more thing that should be covered in the README …

                                                                                                                                                      Konstantin Läufer @klaeufer@2017-02-06T17:17:08.454Z
@sellout Maybe it's time to upgrade to 2.12.x. :anguished: 

                                                                                                                                                      Konstantin Läufer @klaeufer@2017-02-06T17:44:28.635Z
@sellout I set `scalaVersion := 2.12.1` and Matryoshka to `latest.integration` (0.16.5) and am getting this unresolved dependency: `org.scalacheck#scalacheck_2.12;1.14.0-861f58e-SNAPSHOT`. Same problem with 0.16.4 (though not with 2.11.8). Any ideas? Thanks again.

                                                                                                                                                      Konstantin Läufer @klaeufer@2017-02-06T17:44:51.650Z
Let me add the scalacheck snapshot resolver back...

                                                                                                                                                      Konstantin Läufer @klaeufer@2017-02-06T17:46:50.070Z
That didn't help either...

                                                                                                                                                      Konstantin Läufer @klaeufer@2017-02-06T17:47:00.587Z
Back later.

                                                                                                                                                      Greg Pfeil @sellout@2017-02-06T17:54:03.495Z
@klaeufer Yeah, ugh – see https://github.com/rickynils/scalacheck/pull/301#issuecomment-271103112 for why I need that snapshot (feel free to “upvote” that in some way). It’s a pain.

                                                                                                                                                      Greg Pfeil @sellout@2017-02-06T20:35:48.592Z
@klaeufer I _think_ you shouldn't need Scalacheck for only matryoshka-core. Are you also depending on matryoshka-scalacheck?

                                                                                                                                                      Konstantin Läufer @klaeufer@2017-02-06T21:46:56.124Z
Thanks a bunch, @sellout. My dependencies are now in sync with yours, and I just need to update my Scalacheck  code. (Yes, I do use matryoshka-scalacheck.)

                                                                                                                                                      Greg Pfeil @sellout@2017-02-06T21:47:27.337Z
Ok, I figured you probably were – just wanted to make sure I didn’t get the deps wrong somewhere :)

                                                                                                                                                      Konstantin Läufer @klaeufer@2017-02-06T21:54:03.368Z
:+1: 

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2017-02-06T23:48:05.709Z
Non technical question: Will someone bring a few matryoshka stickers to Scalar conference given that there are a few people from Slamdata speaking there?

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2017-02-06T23:50:50.096Z
I can offer Hascalator stickers in return :wink: 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-11T02:58:10.613Z
@sellout How is matryoshka-cats doing? Do you need any help?

                                                                                                                                                      Greg Pfeil @sellout@2017-02-11T23:23:26.117Z
@edmundnoble Hah! Yeah, I could probably at least bounce some ideas around to get it unstuck. But I'm in the mountains currently. Back on Tuesday morning.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-11T23:32:43.176Z
The mountains! Sounds awesome! :D

                                                                                                                                                      Paul Phillips @paulp@2017-02-12T03:16:37.778Z
literally

                                                                                                                                                      Valentin Kasas @vil1@2017-02-13T16:21:38.973Z
Hi there, I have a … thing, that looks rather recursive, but isn't really:
```scala
trait Lexer {
  def nextToken: Either[SyntaxError, (Token, Lexer)]
}
```


                                                                                                                                                      Valentin Kasas @vil1@2017-02-13T16:24:35.061Z
my idea is to start from a string, and recursive-scheme my way to a (non-recursive) data structure, parsing the string from JSON/CSV and validating its content along the way

                                                                                                                                                      Valentin Kasas @vil1@2017-02-13T16:25:13.690Z
as a bonus, I want to traverse the original string only once

                                                                                                                                                      Valentin Kasas @vil1@2017-02-13T16:26:43.755Z
I have a schema that will be used to build the validations I want to perform

                                                                                                                                                      Valentin Kasas @vil1@2017-02-13T16:29:52.970Z
so my idea is to do `String -ana-> Tokens -???-> JSON-like -???-> GenericData -cata-> Ouptut`

                                                                                                                                                      Valentin Kasas @vil1@2017-02-13T16:30:13.779Z
(the JSON-like step might be avoidable)

                                                                                                                                                      Valentin Kasas @vil1@2017-02-13T16:35:45.677Z
am I making any sense so far ? 

                                                                                                                                                      Greg Pfeil @sellout@2017-02-14T04:52:29.880Z
@vil1 I think so. But your `nextToken` implies an infinite stream of tokens, no? I think `nextToken: CoalgebraM[Either[SyntaxError, ?], ListF[Token,?], Lexer]` might be what you want.

                                                                                                                                                      Jonathan @b-studios@2017-02-14T10:33:53.383Z
@vil1 The difference between what you describe and the coalgebra suggested by @sellout is, that the first does not allow the lexer to indicate that the stream terminates without raising a syntax error. In @sellout's proposal on the other hand this is possible by choosing the Nil case of ListF.

                                                                                                                                                      Valentin Kasas @vil1@2017-02-14T10:37:10.192Z
well, I have a `RunningLexer` and an `ExhaustedLexer` lexer implementations, (basically, `RunningLexer#nextToken` ends up returning `Right((EOF, ExhaustedLexer))` eventually, while `ExhaustedLexer#nextToken` always returns `Right((EOF, ExhaustedLexer))`)

                                                                                                                                                      Valentin Kasas @vil1@2017-02-14T10:38:16.992Z
so the "stream" is indeed infinite, but I know that I can stop as soon as I encounter an `ExhaustedLexer`

                                                                                                                                                      Jonathan @b-studios@2017-02-14T11:19:01.874Z
@vil1 Ok, then @sellout's design makes sense. As a sidenote: Maybe you also want to look into iteratees (for instance this Scala implementation here: https://github.com/travisbrown/iteratee).

                                                                                                                                                      Valentin Kasas @vil1@2017-02-14T12:55:24.177Z
@sellout 's solution makes perfect sense (at least for the compiler) and yields something like : 

                                                                                                                                                      Valentin Kasas @vil1@2017-02-14T12:55:34.618Z
```scala
  val lexerCoalgebraM: CoalgebraM[Either[SyntaxError, ?], ListF[Token, ?], Lexer] = {
    case ExhaustedLexer => Right(NilF[Token, Lexer]())
    case l => l.apply.right.map((ConsF.apply[Token, Lexer] _).tupled)
  }
```

                                                                                                                                                      Valentin Kasas @vil1@2017-02-14T13:01:07.808Z
which (when I provide a `Corecursive.Aux[Lexer, ListF[Token, ?]]`) can in turn be used in a `lexer.ana[Lexer](lexerCoalgebraM)`, but that returns a `Either[SyntaxError, Lexer]` meaning that I "loose" my tokens list

                                                                                                                                                      Valentin Kasas @vil1@2017-02-14T13:01:46.797Z
OH !

                                                                                                                                                      Valentin Kasas @vil1@2017-02-14T13:03:34.499Z
but with a `listFToListAlgbera: AlgebraM[Either[SyntaxError, ?], ListF[Token, ?], List[Token]]` I can do `lexer.hyloM(listFToListAlgebra, lexerCoalgebraM)` and get back my `List[Token]`

                                                                                                                                                      Valentin Kasas @vil1@2017-02-14T13:03:56.166Z
(regardless of my poor naming skills)

                                                                                                                                                      Valentin Kasas @vil1@2017-02-14T13:36:45.530Z
So basically, I'm rather happy (and I got to use a hylo, which changes from my regular catas), now I *just* have to understand exactly what happens there, be right back in a week or two ;)

                                                                                                                                                      Jonathan @b-studios@2017-02-14T14:12:06.480Z
@vil1 I don't completely understand why you want to use lexer as a corecursive structure instead of using one for `ListF`? (disclaimer: I don't know the matryoshka api by heart) I would expect there already is an instance of Corecursive for List (or Stream, actually) that you could use to unfold into.

                                                                                                                                                      Jonathan @b-studios@2017-02-14T14:40:05.642Z
@vil1:
```scala
  import matryoshka.data.list._
  val l: Lexer = ???
  val r: Either[SyntaxError, List[Token]] = listCorecursive.anaM(l)(lexerCoalgebraM)
```


                                                                                                                                                      Valentin Kasas @vil1@2017-02-14T14:41:32.642Z
hmm I see (sort of)

                                                                                                                                                      Jonathan @b-studios@2017-02-14T14:42:29.405Z
You can understand `Lexer` as being the (internal) state of the coalgebra. You supply the initial one and then unfolding the coalgebra uses it internally to generate a list of tokens.

                                                                                                                                                      Valentin Kasas @vil1@2017-02-14T14:45:09.626Z
what I find disturbing is that I have two solutions to go from Lexer to List[Token] using two different schemes

                                                                                                                                                      Jonathan @b-studios@2017-02-14T14:45:10.966Z
@vil1 (btw. should `l.apply.` above in your implementation of `lexerCoalgebraM` be `l.nextToken`? 

                                                                                                                                                      Valentin Kasas @vil1@2017-02-14T14:46:01.841Z
you're right (I've renamed stuff along the way in my project)

                                                                                                                                                      Jonathan @b-studios@2017-02-14T14:46:47.652Z
I understand, that disturbance is perfectly normal. If you have a function like `coRec F -> coRec G` you can often choose whether you want to use the (co)recursive structure of F or G, either destructing F using a catamorphism or constructing G using an anamorphism.

                                                                                                                                                      Valentin Kasas @vil1@2017-02-14T14:58:41.045Z
Humm that's starting to make sense

                                                                                                                                                      Greg Pfeil @sellout@2017-02-14T14:58:56.477Z
@vil1 Also, if you `s/Lexer/String` in the coalgebra, then `type Lexer = CoalgebraM[Either[SyntaxError, ?], ListF[Token, ?], String]`.

                                                                                                                                                      Valentin Kasas @vil1@2017-02-14T15:00:10.121Z
corec F and corec G should be corec "in respect with" the same fix-point-thingy right  ? 

                                                                                                                                                      Valentin Kasas @vil1@2017-02-14T15:05:16.006Z
@sellout that would be even better, but right now my Lexer maintains a reference to the original String so I'm not sure it will be doable as it is. I might need a little more fidling to convince myself it is

                                                                                                                                                      Greg Pfeil @sellout@2017-02-14T15:15:06.049Z
@edmundnoble It _was_ awesome. https://twitter.com/sellout/status/831521196399292416

                                                                                                                                                      Jonathan @b-studios@2017-02-14T15:15:53.644Z
@vil1 what I tried to approximate by `corec F` would be the `FixF` in `Corecursive.Aux[FixF, F]`. e.g. FixF=List for F=ListF, etc.

                                                                                                                                                      Valentin Kasas @vil1@2017-02-14T15:19:55.321Z
(be right back, gotta do stuff for $work™)

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2017-02-17T20:23:53.007Z
Quick question in the definition of `hylo`:
```scala
 def hylo[F[_]: Functor, A, B](a: A)(f: Algebra[F, B], g: Coalgebra[F, A]): B =
    f(g(a) ∘ (hylo(_)(f, g)))
```
Why does `F` need to be a functor here?

                                                                                                                                                      Greg Pfeil @sellout@2017-02-17T20:52:55.180Z
@mgttlinger `g(a)` returns `F[A]`, which you then map over.

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2017-02-18T13:58:59.157Z
Ohhhh, is the `∘` a `map` call?

                                                                                                                                                      Greg Pfeil @sellout@2017-02-18T13:59:41.682Z
@mgttlinger Ah, yes – sorry, I Unicode all the things 😄

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2017-02-18T14:00:31.128Z
But why that symbol? Isn't that usually denoting function composition

                                                                                                                                                      Greg Pfeil @sellout@2017-02-18T14:01:17.372Z
@mgttlinger Composition is `map` on `A => ?`

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2017-02-18T14:02:59.515Z
I guess it is but I have never seen it used that way. Hence the confusion

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2017-02-18T14:03:24.332Z
Is that a thing to write it that way or just personal preference?

                                                                                                                                                      Torsten Scholak @tscholak@2017-02-18T14:03:48.699Z
It's a thing. I've seen it like that, too

                                                                                                                                                      Jonathan @b-studios@2017-02-18T14:45:22.728Z
I am also a bit confused. I do understand the argument of composition is map on the "reader" functor, but wouldnt you flip the arguments to the composition operator typically?

                                                                                                                                                      Jonathan @b-studios@2017-02-18T15:12:25.093Z
(Sorry, I appearently cant operate gitter on my mobile). For ´f: A -> B´ and `g: B -> C`, `f map g` would be equal to `g compose f`, right?

                                                                                                                                                      Greg Pfeil @sellout@2017-02-19T15:39:32.722Z
@b-studios I think you’re right. I remember asking about that in #scalaz ages ago, and not really getting much of a reasonable response …

                                                                                                                                                      Greg Pfeil @sellout@2017-02-19T15:40:30.743Z
But for composition, I tend to use the `Arrow` operators, `<<<` and `>>>`, because I find I often have to switch direction for inference to work, so having it be explicit is useful.

                                                                                                                                                      Jonathan @b-studios@2017-02-19T15:45:31.052Z
Inference wise, IIRC that was one reason (plus autocompletion) for a common use of the piping operator in F#.

                                                                                                                                                      Jonathan @b-studios@2017-02-19T15:45:34.103Z
http://stackoverflow.com/a/10096444

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-19T15:46:48.397Z
The lack of pipe operators in common usage in Scala is unfortunate, but this is what we get for separating methods and functions.

                                                                                                                                                      Jonathan @b-studios@2017-02-19T15:48:39.768Z
Regarding map: In ct literature, I also often encountered the circled semicolon which is reverse function composition. We just need to change the unicode of composition in Scalaz.

                                                                                                                                                      Jonathan @b-studios@2017-02-19T15:52:05.268Z
Obviously a pipe operator can be simulated using implicits. However, I don't know whether presentation compilers of IDEs are smart enough to give reasonable autocompletion in presence of the only half-baked implicit conversion.

                                                                                                                                                      Jonathan @b-studios@2017-02-20T12:14:41.641Z
@sellout I leisurely read a bit in the matryoshka code and stumbled about this comment on [`paraMerga`](https://github.com/slamdata/matryoshka/blob/master/core/shared/src/main/scala/matryoshka/Recursive.scala#L170)

```scala
// TODO: figure out how to represent this as a elgotHylo with mergeTuple
```

                                                                                                                                                      Jonathan @b-studios@2017-02-20T12:14:51.397Z
This triggered my ambition and so I thought about it a bit. In a nutshell: I think it is not possible.

                                                                                                                                                      Jonathan @b-studios@2017-02-20T12:15:07.711Z
Let's call `type Ctx[X] = (T, T, X)` the merging context.

It is not a problem to write an coalgebra `Coalgebra[Ctx ∘ Option ∘ Base, (T, T)]` using `mergeTuple`. But we cannot write it as an `ElgotCoalgebra[Ctx, Option ∘ Base]` since monadic return would need to make up two trees on the spot.

So I believe the only way one can massage the types into an ElgotHylo is `ElgotCoalgebra[Id, Ctx ∘ Option ∘ Base, (T, T)]` (and similarly for `ElgotAlgebra`), which just does not use the "Elgotiness" and hence corresponds to a standard hylo.


                                                                                                                                                      Jonathan @b-studios@2017-02-20T12:15:33.481Z
Sidenote: I could not find `elgotHylo` in the library and implemented it. Is it worth a PR?

                                                                                                                                                      Valentin Kasas @vil1@2017-02-20T19:04:23.385Z
Hi guys, guess who's stuck again :)

                                                                                                                                                      Valentin Kasas @vil1@2017-02-20T19:14:27.617Z
Previously in "Me trying to figure things out"… 
In S01E01, I managed to put together a `TypeF` pattern-functor that serves as a generic representation for schemas and `DataF` that does the same for data (instances of such schemas) and use algebras to `cata` those down to more "earthly" representations (parquet, avro, JSON, etc…)
In S01E02, I was able to tokenise a string representing a JSON-oid piece of data into a `List[Token]` using an hylomorphism that was later simplified to an anamorphism thanks to `matryoshka.data.list.listCorecursive`

                                                                                                                                                      Valentin Kasas @vil1@2017-02-20T19:23:03.587Z
Now S01E03 begins with me trying to find a way to use a `Fix[TypeF]` schema and parse my `List[Token]` in order to produce a `ValidationNel[TypeError, Fix[DataF]]`, and failing miserably so far…

                                                                                                                                                      Valentin Kasas @vil1@2017-02-20T19:56:53.005Z
My problem comes from the fact I (feel that I) need to "recurse" through two different structures at the same time

                                                                                                                                                      Valentin Kasas @vil1@2017-02-20T21:29:48.799Z
I've tried to `transAna` from `TypeF` to `DataF` but that would need to come up with an `AlgebraicTransform` that keeps track of what part of the `List[Token]` has already been consumed

                                                                                                                                                      Valentin Kasas @vil1@2017-02-20T21:34:11.202Z
Likewise, trying to find the right coalgebra to `ana` over the `List[Token]` while keeping track of  the stack of nested `TypeF` I am validating yields no result so far

                                                                                                                                                      Paul Phillips @paulp@2017-02-20T23:22:58.744Z
@vil1 unhelpful response, but are you publishing the episodes anywhere? I am interested in this season of figuring things out 

                                                                                                                                                      Greg Pfeil @sellout@2017-02-20T23:24:01.501Z
@b-studios Yeah, `elgotHylo` would be great … I’ll have to think for a bit longer to process the rest of your comments.

                                                                                                                                                      Jonathan @b-studios@2017-02-20T23:24:59.600Z
@sellout Don't worry, doesn't hurry -- And I will prepare a PR, as soon as I find the time. Btw, I used parts of the implementation of elgotHylo as motivating example in this blog post: https://gist.github.com/b-studios/b014cd52bf71aad14b033cb91d9e8fb7

                                                                                                                                                      Greg Pfeil @sellout@2017-02-20T23:26:19.846Z
@b-studios Heh, I had just opened that post from the link in typelevel/general. Cool.

                                                                                                                                                      Greg Pfeil @sellout@2017-02-20T23:26:42.452Z
@vil1 Do you have a gist or something with what you’re trying to do?

                                                                                                                                                      Jonathan @b-studios@2017-02-20T23:27:28.439Z
(Sorry for double posting, I just wanted to relate that to the elgotHylo :) )

                                                                                                                                                      Jonathan @b-studios@2017-02-21T00:12:16.951Z
@vil1 do I understand correctly, that your `Fix[TypeF]` serves as a domain specific grammar of the parser to parse `List[Token]`?

                                                                                                                                                      Jonathan @b-studios@2017-02-21T00:13:06.207Z
(Sorry, I missed episode 1)

                                                                                                                                                      Valentin Kasas @vil1@2017-02-21T09:05:21.684Z
@b-studios that's it, you can think of it as an extended JSON-schema against which I want to validate my input string (`List[Token]`)

                                                                                                                                                      Valentin Kasas @vil1@2017-02-21T09:10:29.788Z
( @paulp  I didn't write these down yet, but that sounds like a nice addition to my blog)

                                                                                                                                                      Jonathan @b-studios@2017-02-21T10:31:48.844Z
@vil1, so just to summarize again. There are three recursive datatypes involved, split by input-output in pseudo function notation: `(List[Token], Fix[TypeF]) => Fix[DataF]` (ignoring the `ValidationNel` which I don't understand, yet).

                                                                                                                                                      Valentin Kasas @vil1@2017-02-21T10:34:03.860Z
that's it ! (FTR `ValidationNel[TypeError, A]` is an `Applicative` version of  `Either[NonEmptyList[TypeError], A]` that allows accumulation of validation errors)

                                                                                                                                                      Valentin Kasas @vil1@2017-02-21T10:38:34.595Z
I will sum up things in a gist

                                                                                                                                                      Jonathan @b-studios@2017-02-21T10:38:36.483Z
Maybe you have heard of ["parsing-with-derivatives"](http://matt.might.net/papers/might2011derivatives.pdf), which might be relevant.

 In a nutshell, modulo technical details and adopted to the morphisms world, you can describe a parser as a coalgebra `parserCoalg: Fix[TypeF] => (Token => Fix[TypeF], ValidationNel[TypeError, A])`. That is, you can always retreive a result (which might be empty) or pass a new token to get an "updated grammar" which reflects the fact that a token has been consumed. You obtain the parser by unfolding `parserCoalg` and then folding the `List[Token]` using the first observation `Token => Fix[TypeF]`. Finally you extract the result using the second observation.

                                                                                                                                                      Jonathan @b-studios@2017-02-21T10:40:17.541Z
(I wrote a paper giving a Scala implementation of parsing with derivatives, which might be interesting for you: https://github.com/b-studios/fcd/blob/master/paper.pdf)

                                                                                                                                                      Valentin Kasas @vil1@2017-02-21T10:41:51.541Z
hmm that's rather mind-blowing, but makes sense (I guess)

                                                                                                                                                      Valentin Kasas @vil1@2017-02-21T10:42:32.889Z
a coalgebra giving another coalgebra (sort of)

                                                                                                                                                      Valentin Kasas @vil1@2017-02-21T10:46:29.880Z
hmm well, actually I don't get the meaning of the `Token => Fix[TypeF]`

                                                                                                                                                      Valentin Kasas @vil1@2017-02-21T10:49:52.310Z
shouldn't it be `Token => Fix[DataF]` ?

                                                                                                                                                      Jonathan @b-studios@2017-02-21T11:47:23.567Z
@vil1, It is much easier to first think about regular expressions (rather than CFGs) and recognizers (rather than parsers). The corresponding type then would be: `p: Regex => (Token => Regex, Boolean)`. 

Let's now take the regular expression `r: Regex` for the string `"abc"`.  The call `p(r)._1('a')` now returns an "updated" regular expression that only recognizes the remaining string `"bc"`, while `p(r)._2 == false`. In contrast,  `p(r)._1('x')` would yield the empty regular expression that can never recognize anything. Finally, `p(p(p(p(r)._1('a'))._1('b'))._1('c'))._2 == true`.

Unfolding the coalg (`unfold(p): Fix[(Token => ?, Boolean)]`) hides away the internal state, that is the updated description of the grammar. So we can have `unfold(p)._1('a')._1('b')._1('c')._2 == true`.

                                                                                                                                                      Valentin Kasas @vil1@2017-02-21T12:03:25.064Z
I see

                                                                                                                                                      Valentin Kasas @vil1@2017-02-21T12:05:56.003Z
That will make for a very good S01E03

                                                                                                                                                      Valentin Kasas @vil1@2017-02-21T12:18:45.865Z
I might need a little more time to digest all this though (including your paper)

                                                                                                                                                      Valentin Kasas @vil1@2017-02-21T12:23:52.931Z
Anyway, thanks a lot @b-studios  you'll definitely appear in the end credits for  "me trying to figure things out" series :)

                                                                                                                                                      Greg Pfeil @sellout@2017-02-21T13:49:31.796Z
@b-studios Oh, cool. I wrote a parsing-with-derivatives impl in Common Lisp after the original paper came out. Are you aware of @djspiewak’s new impl of it (http://parseback.io)? Do you think yours is “production-ready”?

                                                                                                                                                      Jonathan @b-studios@2017-02-21T13:53:00.367Z
Wow, thanks for the pointer to Daniel's implementation. I wasn't aware that he was working on a new implementation. To be fair, I would call my implementation not production ready as there are still way to many memory leaks. It is more serves as a proof of concept, that a notion of first-class-derivatives can be useful.

                                                                                                                                                      Olivier Mélois @Baccata@2017-02-22T09:05:41.939Z
Hey guys, I'm trying to get a feel for corecursivity.  Would it be possible to express the Pascal Triangle with one (or several) of the morphisms provided by matryoshka ? I don't feel it's possible, but I'd love to be proven wrong 

                                                                                                                                                      Paul Phillips @paulp@2017-02-22T09:56:08.686Z
@Baccata what makes you think it's not possible? Write it in terms of the rows, not the individual numbers. Then it's just a stream. 

                                                                                                                                                      Jonathan @b-studios@2017-02-22T09:57:08.588Z
... in addition every element in a row depends on the context which could be modeled using a comonad.

                                                                                                                                                      Olivier Mélois @Baccata@2017-02-22T10:17:02.958Z
@paulp the row modelling is pretty obvious indeed. I suppose my question wasn't precise enough, I was thinking about a model that would allow for exploring the graph in a downward | rightward manner. 
@b-studios yeah I guess keeping track of the context in some comonad is necessary, thanks for the tip 

                                                                                                                                                      Konstantin Läufer @klaeufer@2017-02-22T19:19:56.719Z
@sellout FYI, I have finished migrated my various F-algebra examples to Matryoshka. As I mentioned, these are for teaching (advanced undergrad + MS), so they are relatively basic. Any feedback would be appreciated. https://github.com/lucproglangcourse/matryoshka-examples-scala https://github.com/lucproglangcourse/expressions-algebraic-scala https://github.com/lucproglangcourse/simpleimperative-algebraic-scala

                                                                                                                                                      Valentin Kasas @vil1@2017-02-22T20:56:18.783Z
That looks extremely cool (from my noob POV)

                                                                                                                                                      Greg Pfeil @sellout@2017-02-22T20:59:12.901Z
@klaeufer I like that you’re using variance. I’ve been meaning to try that.

                                                                                                                                                      Greg Pfeil @sellout@2017-02-22T20:59:53.797Z
@klaeufer re: “Also gives rise to non-delayed Equal instance for ExprF but not Expr.” I think you _should_ get an `Equal[Expr]` instance from that … maybe just a missing import somewhere?

                                                                                                                                                      Valentin Kasas @vil1@2017-02-22T21:00:06.089Z
+1 for unicode-to-earthly-function-names

                                                                                                                                                      Valentin Kasas @vil1@2017-02-22T21:00:28.455Z
... Translation in comments

                                                                                                                                                      Konstantin Läufer @klaeufer@2017-02-22T21:03:43.296Z
@vil1 Are you OK with keeping the translations as comments? I really like the conciseness of the symbols but don't want to wade through slow-loading API docs...

                                                                                                                                                      Konstantin Läufer @klaeufer@2017-02-22T21:04:16.066Z
@sellout Thanks... I'll double-check on the Equal instance and let you know!

                                                                                                                                                      Valentin Kasas @vil1@2017-02-22T21:06:17.306Z
Yes absolutely, I'll get used to the unicode notation eventually, but having a cheat sheet in the comments is very handy

                                                                                                                                                      Konstantin Läufer @klaeufer@2017-02-22T21:57:50.724Z
@vil1 Excellent, I'll continue this practice.

                                                                                                                                                      Konstantin Läufer @klaeufer@2017-02-22T21:58:48.478Z
@sellout Confirmed! The derived instances are all good with 2.12.1 + partial unification. :smile: 

                                                                                                                                                      Greg Pfeil @sellout@2017-02-22T21:59:15.350Z
@klaeufer 🎉

                                                                                                                                                      Olivier Mélois @Baccata@2017-02-23T10:22:22.689Z
@sellout, I've pulled your PR for mutual recursion, and am trying to rebase it against master, but I'm having problems with the [Ctx](https://github.com/sellout/matryoshka/blob/56c2ce8343d43c4513d890511c60fda4fbe79085/core/shared/src/main/scala/matryoshka/mutu/Ctx.scala#L19) type (especially how pattern matching against `Hole`doesn't seem to work in 2.12. My knowledge of the compiler is very small, but according to your comment [there](https://github.com/sellout/matryoshka/blob/56c2ce8343d43c4513d890511c60fda4fbe79085/core/shared/src/main/scala/matryoshka/mutu/package.scala#L46), I assume that 2.11 was maybe transforming the unapply into a `instanceOf` call, which made it compile. 

Could you explain what you were trying through `Ctx`?  It somehow looks like a higher-order Free, but I'm not quite sure what the `H`type param is about . Could you enlight me on this ? 

                                                                                                                                                      Greg Pfeil @sellout@2017-02-23T14:44:31.063Z
@Baccata I have a bunch of updates to that branch that haven’t been pushed yet. I’ve had it `publishLocal`ed as I’ve worked on migrating work code to it, filling in useful bits. I’ll try to get that out today. Although I don’t know if it’s on 2.12 yet.

                                                                                                                                                      Olivier Mélois @Baccata@2017-02-23T14:45:57.921Z
@sellout cheers, looking forward to seeing it !

                                                                                                                                                      Greg Pfeil @sellout@2017-02-23T22:48:45.591Z
@Baccata So, I’m currently trying to figure out probably similar stuff to you 😆 I just asked some questions in #typelevel/scala. My use of GADTs seems to not work on the Typelevel fork … my guess is due to the SI-9760 fix.

                                                                                                                                                      Greg Pfeil @sellout@2017-02-23T22:49:59.095Z
Basically, I commented out the `free` bit, and everything else works except for tests. The problem is the tests use GADTs (as, I guess, Ctx does) and my current $work project doesn’t.

                                                                                                                                                      Olivier Mélois @Baccata@2017-02-24T09:39:26.857Z
opened a ticket with minimal example : typelevel/scala#137

                                                                                                                                                      Valentin Kasas @vil1@2017-02-24T18:22:31.718Z
Hi guys, I started to write a series of blog posts about "me trying to figure things out" in Matryoland. I intend to name the people who provided me we their help and advice (I especially think of @sellout, @edmundnoble and @b-studios), but I won't do so without your explicit agreement (FYI, my blog reaches a tremendous traffic of roughly 10 visitors a week :) )

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-24T18:23:38.287Z
@vil1 Go ahead, I'm here if you have any other questions while you're writing :)

                                                                                                                                                      Valentin Kasas @vil1@2017-02-24T18:24:23.778Z
I sure will ^^

                                                                                                                                                      Valentin Kasas @vil1@2017-02-24T18:25:55.577Z
(you'll have to wait a while for glory though, my plans for your character are for S01E02, and I've just published [the pilot](http://kanaka.io/blog/2017/02/24/Nesting-in-the-nest-of-Nesting-Dolls-pilot.html))

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-24T18:27:13.933Z
It's riveting reading, looking forward to it :)

                                                                                                                                                      Jonathan @b-studios@2017-02-24T18:27:43.774Z
I am also looking forward to it, agreement give :)

                                                                                                                                                      Jonathan @b-studios@2017-02-24T18:28:09.716Z
give -> given, sorry

                                                                                                                                                      Jonathan @b-studios@2017-02-24T18:32:07.798Z
Btw. I am thinking about giving a seminar at my university about morphisms and recursion schemes. I already have tons of interesting papers for that but still some that are "more approachable". Any good ideas?

                                                                                                                                                      Greg Pfeil @sellout@2017-02-24T18:32:52.927Z
@vil1 Fine by me :)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-24T18:33:06.832Z
@dispalt `transCata` is my second favorite recursion scheme because it lets you translate between fixpoints, which covers most "rewrite"-style recursion.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-24T18:33:22.808Z
@b-studios Show them a schema DSL ;)

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-24T18:33:36.309Z
yeah I am trying to do a tree simplification

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-24T18:33:52.192Z
or like collect all the leaves + one level up

                                                                                                                                                      Greg Pfeil @sellout@2017-02-24T18:33:53.166Z
@b-studios Have you seen Patrick Thomson’s stuff? http://blog.sumtypeofway.com

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-24T18:35:24.014Z
@dispalt Wait, so for tree functor `F` it's like `Fix[F] => Fix[F]`?

                                                                                                                                                      Jonathan @b-studios@2017-02-24T18:36:21.309Z
@sellout no, I have not. Thanks, will definitly look into it. But I am actually in search for easy to read papers published at some scientific conf.

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-24T18:36:23.788Z
more something like this, https://github.com/slamdata/matryoshka/blob/master/tests/shared/src/test/scala/matryoshka/spec.scala#L89

                                                                                                                                                      Jonathan @b-studios@2017-02-24T18:36:37.889Z
(since it is a seminar)

                                                                                                                                                      Greg Pfeil @sellout@2017-02-24T18:36:49.269Z
@b-studios I don’t _think_ I’ve found any accessible papers on the topic, unfortunately.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-24T18:37:24.196Z
@dispalt so as you can see that test uses `repeatedly` and `transCataT` to apply the `simplifyf` optimization.

                                                                                                                                                      Jonathan @b-studios@2017-02-24T18:37:43.543Z
Of course, there is Bananas and the like, but I would like to start a little slower.

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-24T18:37:50.285Z
ahh repeatedly

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-24T18:38:04.034Z
transCataT takes care of rewriting the bottom levels before rewriting the top levels, and repeatedly takes care of applying it until it doesn't apply anymore.

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-24T18:38:27.272Z
right, that's what I was missing

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-24T18:38:39.983Z
I have a ton of boilerplate to "keep going" right now

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-24T18:38:57.588Z
@b-studios Perhaps they've learned about less-generative kinds of recursion before, which you can appeal to? Tail-recursion, tail-recursion modulo cons, structural recursion...?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-24T18:39:25.489Z
@dispalt Yeah repeatedly will do that for you... unfortunately it's not tail-recursive, but it could be easily.

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-24T18:40:21.993Z
well I am not actually using matryoshka at the moment for simplicity-of-use sake, so if there is a simple tail recursive cats equiv I'd be happy to use that

                                                                                                                                                      Jonathan @b-studios@2017-02-24T18:41:54.330Z
@edmundnoble that might be an idea. I usually approach the topic with my students starting from the visitor pattern, going from internal visitors to catamorphisms.

                                                                                                                                                      Jonathan @b-studios@2017-02-24T18:44:03.078Z
But there is still the jump from recursive datatypes to functors. Maybe this could be closed with a paper on generic progr and pattern functors.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-24T18:44:30.254Z
Data types a la carte?

                                                                                                                                                      Greg Pfeil @sellout@2017-02-24T18:45:07.759Z
Yeah, I love that one.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-24T18:45:42.397Z
Perhaps when you say internal visitor you mean Boehm berarducci encoding? In that case that's another good angle to introduce pattern functors.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-24T18:46:32.561Z
@dispalt you can write it yourself in three lines or so. There's a copy in edmundnoble/slate.

                                                                                                                                                      Jonathan @b-studios@2017-02-24T18:47:12.578Z
Re Datatypes a la carte: thats a good one, yes. But now I remember: I once saw one introducing generic programming in Scala which was a kind of easy read.

                                                                                                                                                      Jonathan @b-studios@2017-02-24T18:49:01.140Z
@sellout in your talk (IIRC march) you allude to Datatypes ALC. Did you implement some compiler extension for your examples? Those look really cool

                                                                                                                                                      Greg Pfeil @sellout@2017-02-24T18:49:42.920Z
@b-studios Ahahaha – no, that was slide magic ;) It doesn’t actually work that nicely, and it haunts me because people ask.

                                                                                                                                                      Greg Pfeil @sellout@2017-02-24T18:49:52.370Z
I mean, the technique works, but the syntax is longer.

                                                                                                                                                      Jonathan @b-studios@2017-02-24T18:50:22.320Z
Hah, I see... Lesson learnt: never cheat on slides

                                                                                                                                                      Greg Pfeil @sellout@2017-02-24T18:50:40.428Z
It’s hard not to cheat on Scala slides, though!

                                                                                                                                                      Jonathan @b-studios@2017-02-24T18:51:54.923Z
Sad but true.

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-24T19:00:02.771Z
@edmundnoble thanks!

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-24T19:00:13.454Z
Very welcome :)

                                                                                                                                                      Greg Pfeil @sellout@2017-02-24T19:59:13.189Z
@edmundnoble So, would making `Option.fold` `@inline` fix the tailrec issue?

                                                                                                                                                      Valentin Kasas @vil1@2017-02-24T19:59:13.882Z
Some use `tut` to check their slides, like an anti-cheating warranty

                                                                                                                                                      Greg Pfeil @sellout@2017-02-24T19:59:33.872Z
@vil1 Yeah, I’ve started using tut (and org-babel) to keep me honest there.

                                                                                                                                                      Valentin Kasas @vil1@2017-02-24T20:01:23.615Z
(not sure about the problem with `Option.fold` but `@inline` is only a best-effort of the compiler)

                                                                                                                                                      Greg Pfeil @sellout@2017-02-24T20:01:51.568Z
@vil1 Right, but `@tailrec` would tell you if it didn't manage to inline in that case.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-24T20:08:48.545Z
@sellout Not that I know of.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-24T20:09:01.219Z
This is a common issue with `@tailrec` as far as I know.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-24T20:10:40.329Z
There is no "best-effort" when it comes to inlining.

                                                                                                                                                      Valentin Kasas @vil1@2017-02-24T20:18:49.345Z
Interestingly, the question was asked at our local meetup yesterday. Someone put forward the proposition that the compiler is not guarrantied to inline methods from libraries (but I speak without firm knowledge there)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-24T20:19:28.327Z
Well if you don't have the source, the compiler cannot inline *any* methods from a library.

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-24T22:08:15.311Z
@edmundnoble you haven't done histo anywhere right?

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-24T22:24:09.390Z
if I had a grammar like [this](https://gist.github.com/dispalt/b53b38572337c7c5aa703dbc7ae3f9e1) and wanted to pull out just constants (like the function below) what type would I use.  I was thinking `histo` since it'd be `Expr[Expr[A]]` => `A`

                                                                                                                                                      Greg Pfeil @sellout@2017-02-24T22:26:23.647Z
@dispalt I think you want `para` for that – `Expr[(Fix[Expr], List[(RuleKey, Interval[Num])])] => List[(RuleKey, Interval[Num])]`

                                                                                                                                                      Greg Pfeil @sellout@2017-02-24T22:26:49.876Z
Or a bit less noisily: `Expr[(Fix[Expr], A)] => A`

                                                                                                                                                      Greg Pfeil @sellout@2017-02-24T22:27:46.921Z
@dispalt `histo` would work, but that keeps the entire tree of intermediate results as well.

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-24T22:29:24.806Z
@sellout thanks Greg, Ill check that out

                                                                                                                                                      Greg Pfeil @sellout@2017-02-24T22:31:17.559Z
Oh, and the base case isn’t `Nil`, but `case x => x.fold`

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-24T22:36:46.565Z
`para` definitely seems like the right solution

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-24T22:37:06.669Z
Im using a `cofree` structure, but that shouldn't matter right?

                                                                                                                                                      Greg Pfeil @sellout@2017-02-24T22:51:50.229Z
@dispalt Not too much … it changes the shape of the function a bit … instead of `Expr` you have `EnvT[<whatever your annotation type is>, Expr, ?]` and instead of `Fix`, it’ll be `Cofree`. I’ve been considering adding a lower-priority `Recursive.Aux[Cofree[F, A], F]` instance (in addition to the current `Birecursive.Aux[Cofree[F, A], EnvT[A, F, ?]]` instance). Which would perhaps make your case simpler.

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-24T22:53:07.379Z
Im actually not really using the annotation part much at all, so I might just nuke it for simplicity sake and pull it it in to the ast

                                                                                                                                                      Greg Pfeil @sellout@2017-02-24T22:55:16.088Z
So, with the proposed instance, you _should_ be able to use the same algebra for Fix and Cofree … which is how it was in the bad old days of much less general fixed points.

                                                                                                                                                      jeremyrsmith @jeremyrsmith@2017-02-24T23:45:30.469Z
@edmundnoble I think they do inline bytecode from libraries in some cases (only with `-opt` IIRC)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-24T23:49:15.135Z
oooooo interesting @jeremyrsmith.

                                                                                                                                                      jeremyrsmith @jeremyrsmith@2017-02-25T00:05:17.564Z
I don’t know what those cases are, just like I don’t know what the cases are when `@inline` actually does something :)

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-25T00:13:46.663Z
how do you make a `Monoid` on a recursive type?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-25T00:14:16.574Z
@dispalt `Delay`?

                                                                                                                                                      Greg Pfeil @sellout@2017-02-25T02:36:22.906Z
@dispalt Yeah, if you want a Monoid on `Fix[F]`, you need to define `Delay[Monoid, F]`, and also define `(implicit T: Recursive.Aux[T, F], F: Delay[Monoid, F]): Monoid[T]` … at least, that’s a fairly generic way to go about it. I would put the latter definition into Matryoshka itself.

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-25T05:09:46.008Z
yeah interesting...

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-25T05:10:02.270Z
still kinda feeling my way around with braille, so thanks for the help

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-25T05:10:12.364Z
@edmundnoble what would this look like for cofree? https://github.com/edmundnoble/slate/blob/411a171167baf2337d9321b27e09f191320324b2/qq/shared/src/main/scala/qq/util/Recursion.scala#L77

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-25T05:10:29.739Z
Oh, `cata2M`?

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-25T05:10:37.045Z
yeah I am about to use it

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-25T05:10:42.407Z
and I see your comment

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-25T05:10:50.786Z
Hehehe I don't use it in my codebase I just wrote it to see if I could ;)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-25T05:11:04.374Z
With a cofree, hmmmm

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-25T05:11:34.849Z
would this be right? https://gist.github.com/dispalt/a21182a3ea2088feb5b52df4d48ad90b

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-25T05:11:49.480Z
or am I misinterpreting tailForced

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-25T05:12:00.515Z
Shame is I don't use matryoshka in here yet because there's no matryoshka-cats :'(

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-25T05:12:04.603Z
No you aren't, that looks right to me

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-25T05:12:22.878Z
If you are using that RecursiveFunction stuff

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-25T05:12:50.609Z
same for me =( its a good exercise to try to understand this stuff better 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-25T05:13:07.877Z
:cough: @sellout :cough: 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-25T05:13:26.691Z
;)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-25T05:13:42.824Z
What's cata2M being used for?

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-25T05:14:22.871Z
well I wanted to basically look inside a piece of the ast as I am interpreting it

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-25T05:14:36.674Z
Expr[Expr[A]] => A

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-25T05:14:50.847Z
it looks like para

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-25T05:17:43.554Z
Ah righto

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-25T05:18:01.049Z
It's cheeky-cata

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-25T05:20:11.666Z
Twice the unlayering, same price

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-25T05:21:26.208Z
"cheeky"

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-25T05:21:59.085Z
Yes, slightly disrespectable but still not primitive recursion ;)

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-25T05:22:09.105Z
=)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-25T05:23:00.852Z
All jokes aside, I think perhaps coming up with fancy names for recursion schemes has unfortunately taken priority over coming up with fancy *descriptors* for recursion schemes.

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-25T05:23:13.267Z
yeah

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-25T05:23:22.159Z
It'd be nice to know at a glance which are similar and how.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-25T05:23:43.655Z
Instead of like... it's `histo`! Of course it's got access to  *past* values!

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-25T05:24:23.241Z
I like the taxonomy aspect in that it gives concise wording to complex things

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-25T05:24:43.568Z
but it'd be nice to even more

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-25T05:35:06.151Z
Yeah. Maybe a couple more periodic tables ;) 

                                                                                                                                                      Greg Pfeil @sellout@2017-02-26T15:02:36.799Z
Two 3rd-party PRs within an hour of each other? Feels like Matryoshka is a thing now 😄

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2017-02-26T15:11:04.383Z
I feel like matryoshka is becoming the next thing now that free monads are considered somewhat "normal"

                                                                                                                                                      Jonathan @b-studios@2017-02-26T15:28:40.357Z
I am still waiting for the Cofree Comand hype:)

                                                                                                                                                      Valentin Kasas @vil1@2017-02-26T16:18:27.669Z
@mgttlinger I have the exact same feeling

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2017-02-26T16:19:58.358Z
@vil1 Is your scalar talk going in that direction?

                                                                                                                                                      Valentin Kasas @vil1@2017-02-26T16:22:18.258Z
Hmm well, not really. But recursion-schemes/matryoshka might be mentioned at some point

                                                                                                                                                      Valentin Kasas @vil1@2017-02-26T16:23:49.166Z
For the moment, it's more like "Lambda Man vs The Gang of Four (horsemen of Apocalypse)"

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2017-02-26T16:24:16.246Z
:smile:  Looking forward to that

                                                                                                                                                      Valentin Kasas @vil1@2017-02-26T16:28:04.755Z
I'll try not to disappoint you then, but do not expect anything very technical though

                                                                                                                                                      Greg Pfeil @sellout@2017-02-26T16:40:31.736Z
@Baccata I submitted a patch for SI-10208 last night … but Jira keeps giving me an error when I try to comment. The fix is at https://github.com/scala/scala/pull/5744

                                                                                                                                                      Olivier Mélois @Baccata@2017-02-26T16:55:52.791Z
@sellout awesome ! I'd be curious to know how you tracked it down, as I'm at total noob when it comes to the compiler's internals. In any case, cheers for that ! 

                                                                                                                                                      Greg Pfeil @sellout@2017-02-26T16:59:34.982Z
@Baccata I too am a noob at it – but I'm happy to write down what I did. I'll try to do it today before I forget everything :smile: 

                                                                                                                                                      Greg Pfeil @sellout@2017-02-26T17:26:10.319Z
Apparently Jira tells you that the server’s down if you try to submit a comment with an emoji in it …

                                                                                                                                                      dwhitney @dwhitney@2017-02-26T17:26:39.709Z
^^ not a bug

                                                                                                                                                      dwhitney @dwhitney@2017-02-26T17:26:46.290Z
;)

                                                                                                                                                      Greg Pfeil @sellout@2017-02-26T17:42:32.397Z
Wouldn't mind someone talking about recursion schemes at http://www.nescala.org/#cfs, since I can't go 😢 (submissions due tonight)

                                                                                                                                                      Valentin Kasas @vil1@2017-02-26T17:46:21.370Z
Hold my beer … (nah just kidding, that would be preposterous)

                                                                                                                                                      Jonathan @b-studios@2017-02-26T18:10:13.421Z
Does anyone have good examples for usages of elgotAna and elgotCata? I can only come up with contrived ones.

                                                                                                                                                      Jonathan @b-studios@2017-02-26T18:10:50.008Z
Bonuspoints: the example use the same Base functor so I can combine them with elgotHylo.

                                                                                                                                                      Jonathan @b-studios@2017-02-26T18:14:00.881Z
Especially the distributive laws restrict my example search space.

                                                                                                                                                      Greg Pfeil @sellout@2017-02-26T18:24:33.057Z
@b-studios The Quasar code base probably uses some elgot stuff somewhere.

                                                                                                                                                      Greg Pfeil @sellout@2017-02-26T18:25:19.424Z
@b-studios There must be _some_ elgot test in Matryosha, no? Since elgotCata is just a generalization of any elgot variant of a fold.

                                                                                                                                                      Jonathan @b-studios@2017-02-27T09:24:08.025Z
@sellout Yeah, you are right, though there are no usages of `elgotCata` at least I could find instances of `coelgot`as special cases in the tests.

                                                                                                                                                      Jonathan @b-studios@2017-02-27T16:56:27.460Z
In the end I couldn't come up with anything other then using the algebra distributive law as zygo and the coalgebra distr as gApo. 

                                                                                                                                                      Paul Phillips @paulp@2017-02-27T19:31:47.702Z
Trying to program with algebras I have a lot of trouble with the absence of any enforcement regarding where recursion is introduced. I wonder if a compiler plugin would be worth the trouble.

                                                                                                                                                      Jonathan @b-studios@2017-02-27T19:53:50.519Z
@paulp What you say sounds interesting, but I don't quite understand. Isn't the idea of recursion schemes to separate recursion from other code. Shouldn't that make it easier to track down recursion? 

                                                                                                                                                      Paul Phillips @paulp@2017-02-27T19:55:29.760Z
Indeed that is the idea. The problem is the language offers you zero support in this. There's nothing which distinguishes a thing which takes a single step from a thing which takes all the steps. It's like programming in an untyped language in that sense.

                                                                                                                                                      Paul Phillips @paulp@2017-02-27T19:55:45.172Z
Like, I don't want recursive references to even exist, except in the few circumstances where recursion is intentionally being introduced.

                                                                                                                                                      Paul Phillips @paulp@2017-02-27T19:55:59.253Z
Neither recursive calls nor recursive types.

                                                                                                                                                      Jonathan @b-studios@2017-02-27T20:00:09.179Z
Ah, I see. Originally the idea was actually to fully **replace** recursive definitions by x-morphisms as primitives. Too bad, Scala supports recursive definitions.

                                                                                                                                                      Paul Phillips @paulp@2017-02-27T20:19:14.435Z
And there's a similar problem with effects, and yet another with evaluation strategies, and yet another with data vs codata.

                                                                                                                                                      Valentin Kasas @vil1@2017-02-27T20:45:23.231Z
Couldn't this be circumvented with something like wart remover + `-X-fatal-warnings`  ? 

                                                                                                                                                      Greg Pfeil @sellout@2017-02-27T20:45:58.446Z
@vil1 You mean defining `org.wartremover.warts.Recursion`?

                                                                                                                                                      Greg Pfeil @sellout@2017-02-27T20:46:13.811Z
That’s a hell of a wart 😄

                                                                                                                                                      Paul Phillips @paulp@2017-02-27T20:52:03.322Z
@sellout with fatal warnings yeah, but I would gladly take the non-fatal one, at least if I could scope it a little.

                                                                                                                                                      Paul Phillips @paulp@2017-02-27T20:53:15.476Z
@vil1 but maybe you're right - I forget in what conditions the trees are when wart remover gets its hands on them, but at least direct recursion should be detectable if the trees are attributed. Indirect recursion is as always going to be a challenge.

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-28T15:23:10.643Z
@edmundnoble with your `cataM` from slate, how would you make something like `project` in matryoshka work?

                                                                                                                                                      Valentin Kasas @vil1@2017-02-28T16:38:45.639Z
@paulp I have no idea either. I was mostly thinking out loud. My guess was "if IDEA can detect recursion, some compiler plugin can too"

                                                                                                                                                      Greg Pfeil @sellout@2017-02-28T17:57:45.824Z
BTW, new releases of Matryoshka are published to sonatype automatically as soon as a PR is merged. It’s so nice. Thanks to @drostron.

                                                                                                                                                      Dave Rostron @drostron@2017-02-28T17:58:17.645Z
😃

                                                                                                                                                      Sukant Hajra @shajra@2017-02-28T18:48:16.508Z
sellout: in a SNAPSHOT dependency?

                                                                                                                                                      Sukant Hajra @shajra@2017-02-28T18:48:31.349Z
or do you use a git-describe version-bumping scheme?

                                                                                                                                                      Sukant Hajra @shajra@2017-02-28T18:48:39.766Z
(sorry, I could look it up... being lazy)

                                                                                                                                                      Greg Pfeil @sellout@2017-02-28T18:52:50.844Z
@shajra More like the latter – we use GitHub labels to indicate whether a PR should bump the major/minor/revision bits.

                                                                                                                                                      Sukant Hajra @shajra@2017-02-28T19:10:11.160Z
sellout: smart.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-01T18:22:52.354Z
@dispalt What do you mean?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-01T18:24:52.355Z
@paulp pretty please, we need a plugin that doesn't allow general recursion :D

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-03-01T22:22:35.763Z
@edmundnoble I was trying to figure out how to write `isLeaf` given your "slate" micro-matryoshka :smile:

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-01T22:25:13.026Z
This chestnut?

```scala
  def isLeaf(t: T)(implicit BF: Functor[Base], B: Foldable[Base]): Boolean =
    !Tag.unwrap(project(t).foldMap(_ => true.disjunction))
```


                                                                                                                                                      Dan Di Spaltro @dispalt@2017-03-01T22:25:29.529Z
yeah

                                                                                                                                                      Greg Pfeil @sellout@2017-03-01T22:25:48.618Z
I really don’t like that definition.

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-03-01T22:26:12.967Z
its by no means critical, I just don't really get `project` so I figured a real quest would help me unlock the understanding

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-01T22:26:16.565Z
Should it be possible to `cataM` to do it?

                                                                                                                                                      Greg Pfeil @sellout@2017-03-01T22:28:06.492Z
Well, you shouldn’t need Functor, at least – just `_.project.size ≟ 0` (size might not be the right name for that function …)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-01T22:28:20.962Z
Could we perhaps help more directly with your understanding of `project` (and dually `embed`)? There's a commutative square somewhere that explains their relationship with each other, `cata` and `ana`. 

                                                                                                                                                      Greg Pfeil @sellout@2017-03-01T22:28:36.941Z
Or you can do it with `_.foldRight(true)(_ => false)`

                                                                                                                                                      Greg Pfeil @sellout@2017-03-01T22:28:43.123Z
(still need project, though)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-01T22:29:03.834Z
I'd do that. `foldMap` doesn't handle laziness (in cats ;))

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-01T22:29:36.030Z
In essence `project` starts a recursive call, and `embed` finishes a recursive call.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-01T22:30:26.269Z
`cata(embed) == id` and `ana(project) == id`

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-03-01T22:30:49.387Z
interesting, yeah I think Ill try to play around with matryoshka to get a better grasp on it

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-03-01T22:36:40.263Z
that all makes sense, I guess I should just go through the code a bit more to understand

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T00:48:51.107Z
@edmundnoble well the basic mechanism is easy enough:  https://gist.github.com/paulp/de91a5eec027c128f6b28dfe5f563e78

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T00:49:16.937Z
But the question is what exactly to exclude.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-02T00:49:58.863Z
@paulp 🤗

                                                                                                                                                      Greg Pfeil @sellout@2017-03-02T00:50:02.808Z
Exclude nothing!

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-02T00:50:26.510Z
What would you exclude? Honestly I can't think of anything. Except maybe `@tailrec` annotated.

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T00:50:27.446Z
which got me pretty far

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T00:50:28.700Z
I suppressed warnings on (Co)Recursive(T) and the matryoshka package object

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T00:50:34.699Z
obviously that particular library would have special dispensation.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-02T00:52:26.882Z
@paulp honestly, we can eliminate a lot more general recursion there. E.g., the default impls of cata/ana can be moved to `RecursiveT[Fix]` … because `Fix` is a terrible thing ;)

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T00:52:48.849Z
Okay, I'll generate the whole list and you can see what if anything bears exclusion.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-02T00:53:18.565Z
I have noticed that I steal a bunch of adverbs from recent context – like, I wouldn’t have written “honestly” there if it wasn’t in my subconscious.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-02T00:53:33.681Z
What's wrong with `Fix`? `project` and `embed` actually have decent performance.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-02T00:53:50.475Z
@edmundnoble Just that it’s generally recursive.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-02T00:54:31.510Z
Ah right. May be reaching, but does that imply that `Nu` with `project` is stack-safe?

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T00:54:51.167Z
https://gist.github.com/paulp/3763704bdd57cdbc81625168ad483712

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T00:55:41.674Z
It's also entirely possible my mechanism for detecting recursive calls has both false positives and false negatives. All reports welcome.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-02T00:56:24.784Z
They all look legit to me. Could be moved to `CorecursiveT[Fix]`.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-02T00:56:56.478Z
We *should* be able to implement all of them in terms of `ana` I think but it won't be as performant.

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T00:58:20.749Z
@edmundnoble in case it's not apparent the amount gitter inlines into the room is only a small fraction of what's in the gist.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-02T00:58:43.234Z
Oh damn. I'll dive in for real :P

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-02T00:59:07.369Z
Aw with dupes :'(

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-02T00:59:25.824Z
Honestly we need someone to fix the scala.js plugin so that the same errors don't get emitted twice.

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T01:00:22.728Z
oh is that it - I can just run the compile on the jvm side.

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T01:00:31.343Z
I'm still not used to all the js inflicted pain.

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T01:02:04.366Z
@edmundnoble https://gist.github.com/paulp/3763704bdd57cdbc81625168ad483712

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-02T01:02:51.619Z
Thanks :D 

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T01:02:59.512Z
That loses the stuff in "shared", so there's a bit more

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T01:03:43.340Z
at least, I think it loses some stuff. There were mentions of CorecursiveT before, which seem no longer there.

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T01:03:56.161Z
no, there is one.

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T01:04:16.501Z
so that may be everything.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-02T01:09:35.942Z
This is very motivational.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-02T01:12:25.638Z
@paulp all of the occurrences look legit. Still included `@tailrec` methods though.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-02T01:13:42.243Z
(only one I know of is `repeatedly`, but it's in there)

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T01:13:59.343Z
Oh yes - I can exclude tailrec marked methods, though that will still warn about tail-recursive methods which aren't marked tailrec. There's no way to know which those are until the tail call transformation happens, much later.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-02T01:14:17.214Z
I think that's a good thing.

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T01:14:34.060Z
Sure, then you can mark them, as is useful.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-02T01:46:54.473Z
@paulp Why does the message say “unmarked”?

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T02:17:03.035Z
@sellout with the presumption that there could be a `@tailrec` style annotation, marking the method. It means nothing, basically.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-02T03:54:39.366Z
@sellout one day, we may introduce a recursion method with a reified stack that does not depend on the way a method is called. Then the annotation becomes more useful.

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T05:54:03.951Z
@edmundnoble just for comparison's sake, I ran it on the scala stdlib: https://gist.github.com/paulp/05482043c91c694923dfacf31fa1e5e6

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T05:54:11.269Z
still need to exclude `@tailrec` though.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-02T05:57:58.282Z
Oof. I didn't know `LongMap` wasn't stack-safe...

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T07:30:41.749Z
@edmundnoble Depends on what you're seeing.
```
  // Basically this uses a simple stack to emulate conversion over the tree. However
  // because we know that Longs are only 64 bits we can have at most 64 LongMap.Bins and
  // one LongMap.Tip sitting on the tree at any point. Therefore we know the maximum stack
  // depth is 65
```

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-02T21:45:48.777Z
Oof. Should've looked closer :P

                                                                                                                                                      Sumedh Mungee @smungee@2017-03-03T21:50:44.938Z
Not sure if this is relevant here, but given two trees of type Fix[Exp], is there some way to efficiently (or even not so efficiently, i'd settle for easily) find the longest subtree in common?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-03T21:57:29.372Z
@smungee Not efficiently (that I know of)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-03T22:00:37.607Z
Not even very easily. You'd have to roll your own recursive method that uses `Recursive.children`.

                                                                                                                                                      Sumedh Mungee @smungee@2017-03-03T22:05:07.377Z
Will `Recursive.universe` give me all possible subtrees? Can I sort that by length and find the longest match?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-03T22:05:34.083Z
Yes. Won't be fast.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-03T22:05:58.204Z
It's a combinatorial explosion.

                                                                                                                                                      Sumedh Mungee @smungee@2017-03-03T22:06:04.066Z
Yeah

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-03T22:06:56.202Z
I don't think you need to sort it.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-03T22:07:03.221Z
It will be in order of length already.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-03T22:07:17.585Z
Urgh actually never mind it won't.

                                                                                                                                                      Sumedh Mungee @smungee@2017-03-03T22:07:37.443Z
it's basically in top-down order, but not necessarily in order of length, i think

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-03T22:07:45.854Z
Yeah, exactly.

                                                                                                                                                      Sumedh Mungee @smungee@2017-03-03T22:08:47.332Z
hmm, thanks.. I'll use .universe for now, and if I find a more efficient way, will see if i can generalize it enough to contribute back

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-03T22:09:11.353Z
Should be able to count the length while traversing.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-03T22:09:13.212Z
Good luck :)

                                                                                                                                                      Sumedh Mungee @smungee@2017-03-03T22:39:11.545Z
btw, in general, i wonder if there's interest or value in implementing these sorts of standard tree algorithms on top of matryoshka. 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-03T22:39:34.274Z
@smungee I could see that being the case, if not in matryoshka itself in matryoshka-tree or something.

                                                                                                                                                      Sumedh Mungee @smungee@2017-03-03T22:40:53.165Z
Yeah, exactly. I'm sold on matryoshka just for the abstraction benefits, but I find that when I'm trying to sell it to my coworkers, they seem to expect that they will get all this for free..

                                                                                                                                                      Valentin Kasas @vil1@2017-03-06T14:10:32.972Z
I published [S01E01](http://kanaka.io/blog/2017/03/05/Nesting-in-the-nest-of-Nesting-Dolls-S01E01.html) of my series about matryoshka, any (negative/constructive) feedback would be much appreciated 

                                                                                                                                                      Torsten Scholak @tscholak@2017-03-06T15:29:10.818Z
well, I must congratulate you on your code font choice

                                                                                                                                                      Valentin Kasas @vil1@2017-03-06T15:30:19.269Z
Ah ah

                                                                                                                                                      Valentin Kasas @vil1@2017-03-06T15:30:33.119Z
PragmataPro  ? 

                                                                                                                                                      Valentin Kasas @vil1@2017-03-06T15:35:46.520Z
Actually, it's not served from the website so only the happy owners can enjoy it

                                                                                                                                                      Torsten Scholak @tscholak@2017-03-06T15:39:40.555Z
yeah, I'm using it in VIM and IntelliJ

                                                                                                                                                      Valentin Kasas @vil1@2017-03-06T15:41:01.384Z
I see. There is quite no going back once you tasted it

                                                                                                                                                      Torsten Scholak @tscholak@2017-03-06T15:41:57.241Z
agreed

                                                                                                                                                      Torsten Scholak @tscholak@2017-03-06T15:42:08.527Z
it's unfortuntate that many editors don't support ligatures yet

                                                                                                                                                      Valentin Kasas @vil1@2017-03-06T15:43:14.854Z
I might go through the hassle of encoding it to the web at some point, since the license seems to allow that

                                                                                                                                                      Valentin Kasas @vil1@2017-03-06T15:44:04.688Z
Haskell for Mac supports it (with manual config), Sublime Text too

                                                                                                                                                      Torsten Scholak @tscholak@2017-03-06T15:44:43.321Z
Sublime Text? Not for me :/

                                                                                                                                                      Torsten Scholak @tscholak@2017-03-06T15:46:04.042Z
I also have it configured in Haskell for Mac, but the ligatures don't work :/

                                                                                                                                                      Valentin Kasas @vil1@2017-03-06T15:47:35.691Z
hmm spoke too fast about Sublime

                                                                                                                                                      Valentin Kasas @vil1@2017-03-06T15:48:58.265Z
for Haskell for Mac I had to edit a file manually fo use PragmataPro rather than PragmataPro Mono

                                                                                                                                                      Torsten Scholak @tscholak@2017-03-06T15:49:38.518Z
oh, interesting

                                                                                                                                                      Valentin Kasas @vil1@2017-03-06T15:50:13.048Z
more precisely, I had to issue : 
```
defaults write com.haskellformac.Haskell.basic FontName PragmataPro
```

                                                                                                                                                      Torsten Scholak @tscholak@2017-03-06T15:50:38.841Z
that did it

                                                                                                                                                      Torsten Scholak @tscholak@2017-03-06T15:50:42.769Z
wow, thanks!

                                                                                                                                                      Valentin Kasas @vil1@2017-03-06T15:51:12.119Z
all credit goes to the support of H4M

                                                                                                                                                      Torsten Scholak @tscholak@2017-03-06T15:51:46.699Z
;) looking forward to reading your series

                                                                                                                                                      Valentin Kasas @vil1@2017-03-06T15:53:37.933Z
thx ! next instalment might come in a few weeks though

                                                                                                                                                      Greg Pfeil @sellout@2017-03-07T22:35:56.176Z
I’m implementing some of @ekmett’s suggestions. It’s simple enough for gcata, gana, and cataM, but anaM and both elgots are a bit more complicated, since they effectively operate over a different functor, and the functor is part of the type class in Matryoshka’s representation.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-07T22:49:03.702Z
@edmundnoble You can take another look at stack safety afterward 😆

                                                                                                                                                      Greg Pfeil @sellout@2017-03-07T23:17:46.645Z
BTW, this change also makes me more motivated to implement adjoint folds, since it’s now more glaring where the non-conforming cases are.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-07T23:37:47.386Z
@paulp Already fixing the warnings from your Recursion wart: https://github.com/sellout/matryoshka/commit/ac8da1cdd7bdfdc59a6a1ad15d98c9397aee0686

                                                                                                                                                      Paul Phillips @paulp@2017-03-07T23:39:33.571Z
@sellout nice. I'll run it again once you get this round merged.

                                                                                                                                                      Paul Phillips @paulp@2017-03-08T06:41:48.014Z
https://github.com/wartremover/wartremover/pull/341

                                                                                                                                                      Paul Phillips @paulp@2017-03-08T06:45:11.060Z
@sellout https://gist.github.com/paulp/86aeeb76bc3892e4d1e7de065ad7e5c8 running it agains that PR.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-08T14:04:01.302Z
Cool – slightly better than expected :smile: 

                                                                                                                                                      Olivier Mélois @Baccata@2017-03-08T15:28:05.280Z
so is there a plan to make hylo tailrec / stacksafe ? 

                                                                                                                                                      Greg Pfeil @sellout@2017-03-08T15:30:37.792Z
@Baccata There’s a _desire_ – I don’t think there’s a _plan_ yet, though 😆

                                                                                                                                                      Greg Pfeil @sellout@2017-03-08T15:35:27.027Z
*sigh* Gitter just loses messages when you’re on flaky wifi …

                                                                                                                                                      Greg Pfeil @sellout@2017-03-08T15:36:20.432Z
Anyway … Mu/Nu override cata/ana, so part of this refactoring is to use those overridden versions more often, avoiding the non-stack-safe hylo.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-08T15:36:50.677Z
That’s why things like `gcata` are implemented in terms of `cata` instead of `ghylo`, even though it means duplicating some of the `ghylo` complexity.

                                                                                                                                                      Olivier Mélois @Baccata@2017-03-08T15:38:05.443Z
and that's why Fix should be avoided in general I suppose 

                                                                                                                                                      Greg Pfeil @sellout@2017-03-08T15:48:12.290Z
Yeah – I don’t think you can implement Fix in Idris (without `partial`) 😄

                                                                                                                                                      Jonathan @b-studios@2017-03-08T20:17:33.122Z
@sellout RE [`elgotAna`](https://github.com/slamdata/matryoshka/pull/69#issuecomment-285141160) I think maybe could work like:

```scala
def elgotAna[N[_]: Monad, A](
  a: A)(
  k: DistributiveLaw[N, Base], ψ: ElgotCoalgebra[N, Base, A])(
implicit BF: Functor[Base]):
  T = {
    val f: N[Base[A]] => Base[N[Base[A]]] =
      nfa => {
        val fna = k(nfa)
        BF.map(fna) { na => na.flatMap {
          a => ψ(a)
        }}
      }
    ana(ψ(a))(f)
  }
```
Disclaimer: I haven't tested it myself, yet (and the code is quite sketchy).

                                                                                                                                                      Jonathan @b-studios@2017-03-08T21:20:22.545Z
@sellout Or a bit shorter:
```scala
... = ana(ψ(a)) { nfa => k(nfa) ∘ { _ >>= ψ } }
```
Just checked against the `MatryoshkaSpecs` test suite and it seems to work.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-08T21:23:16.167Z
@b-studios 💯

                                                                                                                                                      Jonathan @b-studios@2017-03-08T21:27:09.706Z
(`elgotCata` should be trivially dual :) )

                                                                                                                                                      Greg Pfeil @sellout@2017-03-08T21:29:50.840Z
@b-studios Clever approach, BTW – I just kept getting stuck on “how do I use an `F` that’s different than `Base`?”

                                                                                                                                                      Greg Pfeil @sellout@2017-03-08T21:30:33.708Z
We have the same problem with `anaM`, BTW, if you’re looking for work 😆

                                                                                                                                                      Greg Pfeil @sellout@2017-03-08T21:30:58.097Z
You’re planning to add the elgot bits to your current PR?

                                                                                                                                                      Jonathan @b-studios@2017-03-08T21:35:25.531Z
Yes, I am planning to do this. But I dont' manage before tomorrow, I fear.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-08T21:35:37.910Z
@b-studios Oh, no rush. Just curious.

                                                                                                                                                      Jonathan @b-studios@2017-03-08T21:57:05.827Z
@sellout I am pretty sure this can be expressed more concisely, but here is the code for `elgotCata`:

```scala
g(cata[W[Base[A]]](t) { fwfa => k(fwfa ∘ { _ cobind g }) })
```

                                                                                                                                                      Jonathan @b-studios@2017-03-08T21:57:43.256Z
Maybe I misunderstood you before: Should I add these as part of the PR?

                                                                                                                                                      Greg Pfeil @sellout@2017-03-08T22:06:05.573Z
@b-studios Yeah, feel free to add it, or open another one, or tell me to just do it myself 😄 as long as it gets in there somehow.

                                                                                                                                                      Jonathan @b-studios@2017-03-08T22:19:40.214Z
@sellout Ok, I'll try to do it tomorrow.

                                                                                                                                                      Jonathan @b-studios@2017-03-08T22:19:41.167Z
 Btw, I am not sure `anaM` is possible. How would you distribute the monad over base? The `coalgebraM` gives us `A => M[Base[A]]` but `ana` takes `B => Base[B]` (for some B). So somehow we need to get the monad into base. With the `elgot` variants we have the distributive law for that purpose.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-08T22:34:20.999Z
Yeah, exactly. ¯\\\_(ツ)_/¯ So for now (in my PR) I have it implemented in terms of `hyloM`. Better than nothing. Maybe it’s something that’ll work with adjoint folds, like pre/postpro and mutu.

                                                                                                                                                      Paul Phillips @paulp@2017-03-08T23:40:31.263Z
@b-studios I feel like it can be done. Given the `A => M[Base[A]]` you need to fuse `M` and `Base` into one functor e.g. `type MB[X] = M[Base[X]]` and then obtain a `Corecursive` instance for that, which I haven't worked out how to do but I think should be possible to derive from the functor and the monad. In other words when you call `ana` it will be on a different instance, and `Base` will mean a different type. In the new instance , what was here a `CoalgebraM` is just a `Coalgebra`.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-09T00:00:54.154Z
@paulp Yeah, I did implement `kleisliCorecursive` and manage to do that. The problem was then I couldn’t figure out how to get it to take advantage of the `Nu` definition of ana in that case. Like I now had a `Corecursive.Aux[M[T], (M ∘ F)]`, but I need it to use the ana from T somehow.

                                                                                                                                                      Paul Phillips @paulp@2017-03-09T00:02:54.341Z
@sellout Can we get back from Corecursive to CorecursiveT?

                                                                                                                                                      Greg Pfeil @sellout@2017-03-09T00:03:29.592Z
@paulp Nope. Not all things that are Corecursive are CorecursiveT.

                                                                                                                                                      Paul Phillips @paulp@2017-03-09T00:04:02.973Z
but, hypothetically for those that are, that would solve the problem you're describing?

                                                                                                                                                      Greg Pfeil @sellout@2017-03-09T00:05:13.591Z
I’m not sure. But if so, we could always have CorecursiveT override anaM in that way, and at least things that _are_ CorecursiveT would have anaM defined in terms of ana.

                                                                                                                                                      Paul Phillips @paulp@2017-03-09T00:06:18.350Z
I'll look at it s'more.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-09T00:06:48.850Z
That’s what I like to hear 😆

                                                                                                                                                      Alex Gryzlov @clayrat@2017-03-09T12:31:41.901Z
will https://github.com/slamdata/purescript-matryoshka be maintained in the longer run?

                                                                                                                                                      Alex Gryzlov @clayrat@2017-03-09T12:32:54.167Z
guess it's more of a question for @garyb

                                                                                                                                                      Jonathan @b-studios@2017-03-09T16:03:36.846Z
@sellout  I believe PR #69 is ready to be merged. I hope I took all your remarks into account.

                                                                                                                                                      Jonathan @b-studios@2017-03-09T16:10:43.265Z
Thanks for merging :)

                                                                                                                                                      Greg Pfeil @sellout@2017-03-09T16:11:15.532Z
Thanks for contributing! 0.17.2 should be on sonatype shortly.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-09T19:39:24.569Z
@clayrat I don’t see why it wouldn’t be. Not sure if SlamData is using it in production, but we maintain both it and the Scala version, and the Scala version is _definitely_ sticking around.

                                                                                                                                                      Alex Gryzlov @clayrat@2017-03-09T19:40:32.449Z
yeah, I'm not worried about the scala one, just curious about the ps one

                                                                                                                                                      Greg Pfeil @sellout@2017-03-09T19:41:16.672Z
I would probably support the PS one if it ended up abandoned somehow.

                                                                                                                                                      Alex Gryzlov @clayrat@2017-03-09T20:07:20.234Z
ok great!

                                                                                                                                                      Emrys Ingersoll @wemrysi@2017-03-11T00:35:29.018Z
So, I have a problem that would appear solvable via something like, for example,
```
def coalg: Coalgebra[CoEnv[Int, F, ?], Int] = ???
def grow(i: Int): Free[F, Int] = i.ana(coalg) >>= grow
```
and I am wondering if there is a way to avoid the direct monadic recursion in `grow`, I suspect there is but I haven't figured it out, any suggestions?

                                                                                                                                                      Greg Pfeil @sellout@2017-03-11T03:22:04.803Z
@wemrysi So, you could have to call `grow` an unbounded number of times, until there’s no `Int` left, right? Do you at least have some guarantee that the `Int` gets smaller?

                                                                                                                                                      Greg Pfeil @sellout@2017-03-11T03:24:42.066Z
The closest thing I can think of is `gapo`, which takes a `GCoalgebra[Int \/ ?, F, Int]` (`Int => Int \/ F[Int]`) and then takes a second `Coalgebra[F, Int]` to handle any `-\/` that was returned by the first one.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-11T03:25:05.423Z
But that only gives you one secondary step.

                                                                                                                                                      Emrys Ingersoll @wemrysi@2017-03-11T15:58:24.144Z
@sellout Yes, in practice the type isn't actually an `Int`, I should have just used a type parameter in my example as I was trying to minimize what I perceived the challenge to be, but I do have a guarantee that the recursion will stop. Maybe I'm looking for some sort of refold as the `Int` in my example is actually `(T, T)` where `Recursive.Aux[T, F]`. This may all be pointing to the fact I need to rethink the problem at hand, thanks for the `gapo` pointer, I'll have a look.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-11T16:10:50.455Z
I think my comments hold regardless of the type substituted for `Int` … in fact, “smaller” is easier to define for structural types than for `Int` :)

                                                                                                                                                      Germán Ferrari @gerferra@2017-03-16T01:03:31.811Z
Hi. Troubleshooting an error I found that matryoshka jvm artifact has scala.js dependencies ...

                                                                                                                                                      Germán Ferrari @gerferra@2017-03-16T01:04:08.703Z
The scala.js dependencies include .class files and are causing problems because sbt can't evict binary compatible versions of such libraries

                                                                                                                                                      Germán Ferrari @gerferra@2017-03-16T01:04:24.978Z
and sbt-assembly fails on merge because duplicated .class files are not equals ...  

                                                                                                                                                      Greg Pfeil @sellout@2017-03-16T01:21:23.901Z
@gerferra Ok, I don’t know much about scala.js … it seems like those deps shouldn’t be in the artifact at all, right?

                                                                                                                                                      Germán Ferrari @gerferra@2017-03-16T01:21:41.118Z
I think so

                                                                                                                                                      Germán Ferrari @gerferra@2017-03-16T01:21:56.890Z
Should I open an issue?

                                                                                                                                                      Greg Pfeil @sellout@2017-03-16T01:22:18.553Z
Sure. Thanks.

                                                                                                                                                      Germán Ferrari @gerferra@2017-03-16T01:38:02.586Z
Done :smile: 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-23T13:43:48.254Z
Don't scala.js dependencies always have .class files? Hmmmm...

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-23T13:44:10.216Z
Thought that was for autocomplete.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-23T13:47:29.483Z
@edmundnoble Issue has already been resolved – we were doing Scala.js cross-versioning wrong briefly.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-23T13:47:50.251Z
Ah righto :)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-23T13:47:55.646Z
Are you here in the crowd?

                                                                                                                                                      Greg Pfeil @sellout@2017-03-23T13:48:15.379Z
No 😢

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-23T13:48:47.936Z
Aw :'(

                                                                                                                                                      Greg Pfeil @sellout@2017-03-23T16:57:50.552Z
Was just discussing this elsewhere, but it seems like a good idea to bring up here …

                                                                                                                                                      Greg Pfeil @sellout@2017-03-23T17:00:21.245Z
We recently added `NelF[A, B] = Init(A, B) | Last(A)` (the pattern functor for `NonEmptyList`). It’s isomorphic to `(A, Option[B])`, which is a type SlamData uses elsewhere in Quasar, independently of Matryoshka. It would be great to come up with a better name for that particular functor, not so tied to `NonEmptyList` to use in both situations.

                                                                                                                                                      Valentin Kasas @vil1@2017-03-23T17:23:39.159Z
AtLeastOne  ? 

                                                                                                                                                      Greg Pfeil @sellout@2017-03-23T17:34:39.735Z
Hrmm, sounds like `OneAnd` … which could maybe be generalized to `OneAnd[F[_], A, B](head: A, tail: F[B])`? So, `OneAnd[Option, ?, ?]`

                                                                                                                                                      Valentin Kasas @vil1@2017-03-23T17:36:27.428Z
Isn't OneAnd a cats thing  ? 

                                                                                                                                                      Greg Pfeil @sellout@2017-03-23T17:36:53.661Z
But I feel like both `AtLeastOne` and `OneAnd` sound like “more of the same”, which is what I want to get away from. E.g., we have a case where it’s like `(JavaScript, Option[Expr])` where we _hopefully_ have an efficient expression to use in some contexts, but if not we can always fall back to JS.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-23T17:37:04.209Z
@vil1 Scalaz has it, too. But I _think_ it was in Cats first.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-23T17:37:31.102Z
Mmmm, in Scalaz 7.0.3 … so maybe that was first?

                                                                                                                                                      Valentin Kasas @vil1@2017-03-23T17:41:36.976Z
Well, that exceeds my ability to name things

                                                                                                                                                      Greg Pfeil @sellout@2017-03-23T17:43:19.013Z
`AndMaybe[JavaScript, Expr]` :D

                                                                                                                                                      Greg Pfeil @sellout@2017-03-23T17:43:35.288Z
`JavaScript AndMaybe Expr`

                                                                                                                                                      Greg Pfeil @sellout@2017-03-23T17:44:31.111Z
`NEL[A] = Mu[A AndMaybe ?]`

                                                                                                                                                      Valentin Kasas @vil1@2017-03-23T17:44:44.927Z
`Perhaps` Xb

                                                                                                                                                      Greg Pfeil @sellout@2017-03-23T17:49:04.544Z
Is the syntax I’m using there actually valid?

                                                                                                                                                      Valentin Kasas @vil1@2017-03-23T18:07:39.625Z
I think you can infix any type with two parameters

                                                                                                                                                      Torsten Scholak @tscholak@2017-03-23T18:07:49.805Z
yeah, this will work

                                                                                                                                                      Greg Pfeil @sellout@2017-03-27T19:23:57.005Z
@edmundnoble Did you have to make `repeatedly` a method for it to be tailrec?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-27T20:13:12.597Z
Uh... yes.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-27T20:15:14.139Z
Oh, right … because you can’t call the function returned by `repeatedly` after calling repeatedly …

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-27T20:15:45.941Z
The `tailrec` would just apply to constructing the function object otherwise, yeah.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-27T20:16:49.312Z
Well damn. It just broke a bunch of stuff in Quasar, where we do point free things with it.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-27T20:18:06.878Z
I wonder if it’s worth having `@tailrec def repeatedlyʹ` and `def repeatedly(f: A => Option[A]): A => A = repeatedlyʹ(f)(_)` 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-27T20:41:52.286Z
Hehehe is perhaps more worth it to change the parser so eta expansion is more inferrable ;)

                                                                                                                                                      Greg Pfeil @sellout@2017-03-27T20:53:59.540Z
@edmundnoble Indeed. That’d be nice.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-03T01:12:41.816Z
With a Cats port of Matryoshka, I want to change `Algebra[F, A]` from `F[A] => A` to `F[Eval[A]] => A`. Thoughts?

                                                                                                                                                      Greg Pfeil @sellout@2017-04-03T01:14:21.465Z
or `F[Eval[A]] => Eval[A]`

                                                                                                                                                      Greg Pfeil @sellout@2017-04-03T01:17:36.180Z
Actually, I guess we can leave that case up to the algebra definer …

                                                                                                                                                      Greg Pfeil @sellout@2017-04-03T02:07:36.426Z
Going through other cases, it seems that I don’t need to modify Matryoshka at all, which is good. I’ve wanted lazy algebras frequently, but without `Eval` it hasn’t really been an option (`=> A` is way too restrictive).

                                                                                                                                                      Greg Pfeil @sellout@2017-04-03T22:44:45.126Z
@edmundnoble I know you have Opinions on this – in Matryoshka, we prefer `Cord` for `Show` instances, since we may end up building big trees and don’t want to do naïve concatenation. But I know `scalaz.Cord` has problems, and there is no `cats.Cord`. So, should I just implement `Show` using `Strings` and not worry about it, or what?

                                                                                                                                                      Cody Allen @ceedubs@2017-04-03T22:53:17.398Z
take this with a grain of salt, but FWIW I suspect that for the foreseeable future strings will be faster than any sort of `Cord` on the JVM (so not specific to `scalaz.Cord`)

                                                                                                                                                      Greg Pfeil @sellout@2017-04-03T22:55:21.242Z
@ceedubs The other thing I was thinking was having a `ShowF` type class that returned something like a `List[String]`, and the show instance for `Recursive` types would require `ShowF` on the pattern functor.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-03T22:57:43.384Z
We already require a special formulation of `Show` (and `Eq`, etc.) on the pattern functors to avoid infinite recursion in implicit resolution. We currently do something like `Show ~> (Show ∘ F)`, but `Lazy[Show[A]]` and `ShowF` are other options.

                                                                                                                                                      Cody Allen @ceedubs@2017-04-03T22:58:25.207Z
would the `List` be used like a stack? You’d probably want to avoid appends

                                                                                                                                                      Greg Pfeil @sellout@2017-04-03T22:59:45.987Z
@ceedubs Oh, I imagine append would be the primary dealie.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-03T23:00:07.530Z
Look, I’ve made it this far without understanding anything about the JVM …

                                                                                                                                                      Cody Allen @ceedubs@2017-04-03T23:01:18.761Z
:)

                                                                                                                                                      Cody Allen @ceedubs@2017-04-03T23:01:36.391Z
well with `List` append it isn’t specific to the JVM, is it? append is O(n) for a singly-linked list

                                                                                                                                                      Greg Pfeil @sellout@2017-04-03T23:02:10.962Z
@ceedubs Oh, yeah, it doesn’t have to be `List` – could be `Vector` or whatever – I just didn’t want to write `Seq` 😆

                                                                                                                                                      Cody Allen @ceedubs@2017-04-03T23:02:28.276Z
gotcha :)

                                                                                                                                                      Greg Pfeil @sellout@2017-04-03T23:02:50.490Z
scalaz.Cord uses a FingerTree, right?

                                                                                                                                                      Cody Allen @ceedubs@2017-04-03T23:02:53.568Z
yeah

                                                                                                                                                      Greg Pfeil @sellout@2017-04-03T23:03:19.168Z
Is there a HAMT floating around somewhere? How does that do?

                                                                                                                                                      Cody Allen @ceedubs@2017-04-03T23:03:35.259Z
so is your collection vs straight `String` idea meant for performance reasons or to avoid stack overflows or what?

                                                                                                                                                      Cody Allen @ceedubs@2017-04-03T23:04:50.593Z
I think that the hash map in the scala std lib is a HAMT

                                                                                                                                                      Greg Pfeil @sellout@2017-04-03T23:05:13.706Z
Yeah, I just figured for performance. I don’t really mean to dive into this – was just wondering if a lot of String concatenation was the way to go for now.

                                                                                                                                                      Cody Allen @ceedubs@2017-04-03T23:05:43.934Z
sorry to send the conversation down a rabbit hole

                                                                                                                                                      Greg Pfeil @sellout@2017-04-03T23:05:54.253Z
AFAIK, you only `Show` things  for debugging anyway, right?

                                                                                                                                                      Cody Allen @ceedubs@2017-04-03T23:06:23.858Z
I just know that in some work code I used `scalaz.DList` for a log and it ended up being _pretty_ bad for performance

                                                                                                                                                      Cody Allen @ceedubs@2017-04-03T23:06:44.355Z
Are you asking about me specifically? :D

                                                                                                                                                      Greg Pfeil @sellout@2017-04-03T23:08:52.985Z
Heh, no – the, uh, general “you”.

                                                                                                                                                      Cody Allen @ceedubs@2017-04-03T23:09:26.050Z
that’s the direction that Cats attempts to steer people

                                                                                                                                                      Cody Allen @ceedubs@2017-04-03T23:10:52.123Z
a few people (including me) voted for not having it in cats at one point, but some people wanted it and it seemed to be fairly benign

                                                                                                                                                      Greg Pfeil @sellout@2017-04-03T23:12:00.787Z
Yeah, we actually tend not to use it much – for recursive stuff, we usually debug with a tree-renderer.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-03T23:15:22.715Z
@sellout Actually yes I have an opinion on this.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-03T23:15:29.906Z
Cord is not only incredibly slow, but not stack-safe.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-03T23:15:41.925Z
Vector[String] is the best solution until Steque is mainline.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-03T23:15:57.060Z
@edmundnoble And how long until Steque?

                                                                                                                                                      Greg Pfeil @sellout@2017-04-03T23:16:30.070Z
Because I already have to wait on PRs in Cats & Newts, before I can get Monocle updated, before I can get Matryoshka updated.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-03T23:16:33.146Z
2.13.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-03T23:16:36.931Z
Just Vector[String] it up.

                                                                                                                                                      Cody Allen @ceedubs@2017-04-03T23:17:04.098Z
and hopefully your users aren’t on scala 2.10 where vector concatenation is O(n^2) :cry: 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-03T23:17:11.820Z
Jesus. I really hope not.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-03T23:17:19.136Z
Didn't know that was the case.

                                                                                                                                                      Cody Allen @ceedubs@2017-04-03T23:18:25.203Z
there was a fix for 2.11. I’m not sure why it never got backported to 2.10. But I guess with pretty-printing you are _probably_ usually doing single-element appends as opposed to concatenation, which isn’t too bad

                                                                                                                                                      Greg Pfeil @sellout@2017-04-03T23:18:40.717Z
@ceedubs Oh, I tried to get Matryoshka to work on 2.10, but the compiler just silently crashes, so I gave up.

                                                                                                                                                      Cody Allen @ceedubs@2017-04-03T23:18:58.218Z
well I guess you don’t have to worry about that issue then :P

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-03T23:19:06.160Z
Eff crashes even on 2.11/2.12. Such is life.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-03T23:19:11.064Z
The compiler, that is.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-03T23:19:26.913Z
In *user code*, that is.

                                                                                                                                                      Aldo Stracquadanio @Astrac@2017-04-05T17:11:19.930Z
Hi, I am pretty curious about matryoshka and I was trying to play with it today; I boiled down my idea to a very simple example to get started, which is basically a tree defined as:

```
case class Level[T](output: String, sublevels: Seq[T])
```

Now I want to write an algebra to traverse this and create a string where the nesting is represented with indentation. My first attempt was just to run `cata` on this algebra:

```
val stringAlgebra: Algebra[Level, String] = {
  case Level(output, sublevels) => s"${output}\n${sublevels.map(l => s"\t$l").mkString("\n")}"
}
```

This didn't work because the output had at most one level of indentation; I found then the `attributeTopDown` function and I tried to use it to add the depth to each instance as in:

```
  def depth[T[_[_]], F[_]]: (Int, F[T[F]]) => Int = (i, _) => i + 1
  val x: Cofree[Level, Int] = example.attributeTopDown(0)(depth)
```

                                                                                                                                                      Aldo Stracquadanio @Astrac@2017-04-05T17:13:29.964Z
now the problem is that I have `Cofree` and I lost my `Fix[Level]`, so I can't use `cata` any more with the algebra I provided; I have an intuition that there should be some way to go from this `Cofree` to something like `Fix[LevelWithDepth]` where `LevelWithDepth` is defined as:
```
case class LevelWithDepth[T](depth: Int, output: String, sublevels: Seq[T])
```

                                                                                                                                                      Aldo Stracquadanio @Astrac@2017-04-05T17:13:49.293Z
and then define a proper algebra for this data type

                                                                                                                                                      Aldo Stracquadanio @Astrac@2017-04-05T17:14:01.268Z
does anyone have any advice on this?

                                                                                                                                                      Greg Pfeil @sellout@2017-04-05T17:18:48.542Z
@Astrac In your first example, you could “map” over all the _lines_ in each sublevel, adding `\t` to each one.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-05T17:21:23.336Z
You can also do the cata approach on your attributed Cofree, though – Just that the algebra is no longer `Level[String] => String`, but `EnvT[Int, Level, String] => String`, where `envt.run` will get you `(Int, Level[String])`, or you can extract the components with `envt.ask` and `envt.lower`, respectively.

                                                                                                                                                      Aldo Stracquadanio @Astrac@2017-04-05T22:20:19.568Z
thanks for the answer! I am not sure that I understand how to add the `\t` using map, when I build my data structure I do the following:

```
  val example = level(
    "foo",
    level("bar")
 :: level("baz",
         level("qix")
      :: level("qux") :: Nil) :: Nil)
```

This doesn't have a `map` function and if I use `unFix` I will need to do the recursion at the value level, which I would like to avoid.

                                                                                                                                                      Aldo Stracquadanio @Astrac@2017-04-05T22:22:56.487Z
about the `Cofree`, that seems to be exactly what I wanted but when I try to call `.cata` on it it seems that I can't find the proper implicit conversion. I have these imports:

```
import matryoshka._
import matryoshka.data.cofree._
import matryoshka.data.Fix
import matryoshka.implicits._
import scalaz._
import Scalaz._
```

am I missing something here?

                                                                                                                                                      Aldo Stracquadanio @Astrac@2017-04-05T23:05:50.156Z
OK, thanks to the pointer about the `EnvT` type I managed to track the missing `.cata` on cofree down to not having enabled the higher order unification flag on my build, many thanks for the help!

                                                                                                                                                      Greg Pfeil @sellout@2017-04-05T23:13:18.524Z
@Astrac Sorry, I didn’t mean a literal `map` – more `s/\n/\t\n/g`.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-05T23:14:43.050Z
I should also update the README to be clearer about the SI-2712 fix.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-05T23:16:57.256Z
Since these days most people don’t actually need the plugin, but the compiler flag.

                                                                                                                                                      Aldo Stracquadanio @Astrac@2017-04-06T16:43:06.201Z
yes, I didn't realise that even using the typelevel compiler on 2.12 it was still mandatory

                                                                                                                                                      Aldo Stracquadanio @Astrac@2017-04-06T16:44:06.158Z
I think that I have an intuition about `Cofree`, i.e. the fact that it is a generalised recursion where at each step we attach a label to the value we are recurring over

                                                                                                                                                      Aldo Stracquadanio @Astrac@2017-04-06T16:44:58.093Z
I am wondering, is there a way to get back to `Fix` from it by some algebra that takes the `EnvT`, runs it and creates some other recursive data type out of it?

                                                                                                                                                      Greg Pfeil @sellout@2017-04-06T16:47:40.681Z
@Astrac You can do `cofree.transCata(EnvT.lower)`, which is basically `cofee.cata(EnvT.lower >>> (_.embed))`

                                                                                                                                                      Greg Pfeil @sellout@2017-04-06T16:51:31.356Z
But … if you want to then do `cata` over your `Fix`, you could do `cofree.cata(deattribute(myFAlgebra))` – which is the fusion of `cofree.transCata(EnvT.lower).cata(myFAlgebra)`.

                                                                                                                                                      Aldo Stracquadanio @Astrac@2017-04-06T16:53:40.164Z
many thanks! I'll definitely need to do some research about the various bits involved, I'm sure that it's going to be fun :+1: 

                                                                                                                                                      Greg Pfeil @sellout@2017-04-06T16:54:16.656Z
It would be _really_ nice if we could automatically rewrite to get fusion (scala-meta?).

                                                                                                                                                      Paul Phillips @paulp@2017-04-07T20:07:33.624Z
@sellout https://github.com/paulp/fusion/blob/master/src/main/scala/Fusion.scala

                                                                                                                                                      Paul Phillips @paulp@2017-04-07T20:07:50.919Z
That's a demo doing it with collections map and filter. It could be put to much better use.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-08T01:21:52.769Z
@sellout people call that "final-tagless" :)

                                                                                                                                                      Greg Pfeil @sellout@2017-04-08T02:37:05.194Z
@edmundnoble I am waiting for a `matryoshka.tagless` PR 😄

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-08T02:37:19.583Z
It is actually just "remove the entire library from your dependency chain"

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-08T02:37:35.347Z
Final tagless subsumes recursion schemes and initial algebras.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-08T02:46:25.843Z
Right … so then a few questions: 1. why do you care about Matryoshka, then; 2. doesn’t final tagless make analysis more difficult; and 3. in a strongly normalizing language, would you still choose a tagless representation?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-08T02:49:21.601Z
1. is because of 2. Analysis is only made difficult by the lack of nested pattern matching, which is possible to systematically replace with stateful traversal... but is still less easy to read.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-08T02:50:06.600Z
Ok, good … as that was (probably obviously) my suspicion.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-08T02:50:10.359Z
With 3 you have an interesting question. I have personally never used tagless with anything that isn't strongly-normalizing.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-08T02:50:36.670Z
Is that not something like a termination guarantee?

                                                                                                                                                      Greg Pfeil @sellout@2017-04-08T02:50:55.708Z
Well, I meant _in_ a strongly normalizing language, not _for_ a strongly normalizing language.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-08T02:51:06.875Z
Like, Scala isn’t strongly normalizing.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-08T02:51:14.041Z
But you use tagless in Scala.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-08T02:51:45.281Z
Oh yes, I see.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-08T02:51:59.827Z
But my language “Fix” _is_ strongly normalizing. (“is” may be a stronger word than I should use 😆)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-08T02:52:00.109Z
Yes, finally tagless is also nice in that it means your programs obviously terminate.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-08T02:53:23.476Z
So I have not *used* it in a total setting, but at least that seems to be the case to me.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-08T03:06:07.225Z
Since finally tagless is just a church encoding and church encoding guarantees structural recursion or guarded corecursion terminate (i.e. see Morte)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-08T03:06:53.113Z
(http://www.haskellforall.com/2014/09/morte-intermediate-language-for-super.html)

                                                                                                                                                      Greg Pfeil @sellout@2017-04-08T03:08:36.868Z
Yeah, Morte is the target of Fix.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-08T03:08:46.045Z
OOOOOOOO

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-08T03:08:56.071Z
Sorry. Just got excited :D

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-08T03:09:01.186Z
That sounds awesome.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-08T03:30:34.346Z
I agree 😆 Need to find more time for it, though … maybe once everything is moved to Cats and I get my higher-kinded GADT PR merged into some version of scalac.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-14T23:55:59.481Z
Really wish someone would fix #44 … maybe interleaved implicits will do that.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-14T23:56:13.129Z
Yeah. Hope so.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-15T00:09:32.949Z
Ok, I thought I fixed it (at least got farther than before), but now I get a runtime `java.lang.NoSuchMethodError` …

                                                                                                                                                      Greg Pfeil @sellout@2017-04-15T00:37:24.145Z
I … I think I may have fixed it?

                                                                                                                                                      Greg Pfeil @sellout@2017-04-15T00:37:29.727Z
In a very terrible way.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-15T00:37:33.890Z
LOL

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-15T00:37:34.751Z
Oh no

                                                                                                                                                      Greg Pfeil @sellout@2017-04-15T00:37:35.351Z
Implicits everywhere!

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-15T00:37:42.912Z
Did you make an implicit which does subtyping's job?

                                                                                                                                                      Greg Pfeil @sellout@2017-04-15T00:37:53.678Z
Yes.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-15T00:37:58.437Z
A few.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-15T00:38:02.967Z
Maybe I don’t need them all …

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-15T00:38:07.167Z
Wow! And @paulp said it couldn't work! ;)

                                                                                                                                                      Greg Pfeil @sellout@2017-04-15T02:18:11.106Z
I kinda still don’t trust that it’s actually working … but it seems to be.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-15T02:18:22.555Z
This is nice. Cleans up a ton of constraints.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-15T02:18:51.925Z
And lets me override para/apo definitions for Birecursive types (i.e., almost all of them).

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-15T02:19:10.518Z
Aw *heck* yeah.

                                                                                                                                                      Paul Phillips @paulp@2017-04-15T08:14:12.869Z
I remember saying I couldn't make it work. I can't deny saying it couldn't work but I can't remember either. 

                                                                                                                                                      Greg Pfeil @sellout@2017-04-15T13:24:47.181Z
Well, today I should have a PR you can both take a look at, and _hopefully_ suggest some improvements.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-17T17:49:24.152Z
After my weekend hacking, Matryoshka only has six instances of general recursion left. Down from 40 before the weekend, and from 60+ before @paulp introduced the Recursion wart.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-17T19:42:27.721Z
**\[Jean-Remi Desjardins, SlamData Inc.\]** Only 6!? That's awesome!

                                                                                                                                                      Greg Pfeil @sellout@2017-04-18T03:28:58.753Z
@jr Hoping to get to one … or maybe zero, if I can get someone to magic me up the rewrite to auto-`hylo` `cata <<< ana`.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-18T04:12:16.761Z
**\[Jean-Remi Desjardins, SlamData Inc.\]** zero!? You’ll have to explain that one to me over lunch one of these days

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-18T06:04:08.719Z
Or perhaps even in this channel ;)

                                                                                                                                                      Greg Pfeil @sellout@2017-04-19T16:53:24.739Z
Or in the docs 😄

                                                                                                                                                      Greg Pfeil @sellout@2017-04-21T15:39:36.708Z
```scala
     def fill[N, L, A]
       (n: N)
       (elem: => A)
       (implicit N: Recursive.Aux[N, Option], L: Corecursive.Aux[L, ListF[A, ?]])
         : L =
       n.transAna[L](tuple(elem))
```

                                                                                                                                                      Greg Pfeil @sellout@2017-04-21T15:39:47.405Z
No, _you’re_ overabstracting!

                                                                                                                                                      Paul Phillips @paulp@2017-05-03T06:41:16.571Z
@sellout have you read https://pdfs.semanticscholar.org/b1a0/735cb001845c1f2c260e07f68acd0ea06e30.pdf  ? If you've never seen it, you'll thank me for the pointer.

                                                                                                                                                      Greg Pfeil @sellout@2017-05-03T16:42:11.152Z
@paulp Hah, nice! The title sounds familiar, but I’m certain I haven’t read this.

                                                                                                                                                      Paul Phillips @paulp@2017-05-03T18:43:38.008Z
@sellout Published in 2003.

                                                                                                                                                      Jonathan @b-studios@2017-05-09T13:44:13.277Z
Nice, Torsten sits in the office above me but I also haven't read that paper before :)

                                                                                                                                                      Torsten Scholak @tscholak@2017-05-09T14:59:43.466Z
? oh, right, different Torsten

                                                                                                                                                      Greg Pfeil @sellout@2017-05-09T15:37:03.365Z
@tscholak Heh, yeah, I had to check after @b-studios’ comment :D

                                                                                                                                                      Torsten Scholak @tscholak@2017-05-09T15:38:35.955Z
I trust you survived your mountainkayakbike adventure?

                                                                                                                                                      Greg Pfeil @sellout@2017-05-09T15:48:53.712Z
Heh, there was no adventure yesterday – got stormy right after I got it loaded up. But _maybe_ tomorrow if the weather is ok (which it probably won’t be). I have a rafting/foraging trip planned for Friday, too, which is supposed to be sunny.

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-12T18:17:42.479Z
I've started experimenting with recursion schemes and have found them pretty useful.
I'm trying to define a recursion scheme for a more complicated infinite recursive data structure:
```scala
object example {

  case class Foo[A](f: () => A)
  case class Bar[A](f: () => A)

  def recurseFoo = Foo(() => recurseBar) // Foo[Bar[Foo[Bar[Foo[...]]]]]
  def recurseBar = Bar(() => recurseFoo) // Bar[Foo[Bar[Foo[Bar[...]]]
}
```
Obviously, the code doesn't compile.
I can't use `Fix` for this, since I have an `F[G[F[...]]]` as opposed to a single recursive type.  Does anyone have pointers on what I could use?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-12T18:18:40.842Z
`type FooBar[A] = Foo[Bar[A]]`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-12T18:19:05.284Z
Unless this is what @sellout is talking about with his mutual recursion stuff.

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-12T18:19:33.855Z
In practice, I have lots of `Foo` `Bar` types

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-12T18:20:11.061Z
so I don't think it would work out

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-12T18:20:26.414Z
but I'll give it a go and see...

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-12T18:27:57.913Z
That doesn't work - `recurseFoo` may have the recursive type on `FooBar`, but `recurseBar` has the recursive type on `BarFoo`

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-12T18:30:06.857Z
I'm guessing [this pull request](https://github.com/slamdata/matryoshka/pull/28/files) is mutual recursion?  I'll take a look at it

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-12T21:09:25.175Z
Yeah my mistake, doesn't really make sense. You need to be able to embed both Foo *and* Bar, not Foo *of* Bar.

                                                                                                                                                      Greg Pfeil @sellout@2017-05-13T03:48:37.000Z
@zainab-ali Yep – sounds like you want that pull request.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-13T04:19:24.085Z
What about `Fix` over a `Coproduct`?

                                                                                                                                                      Greg Pfeil @sellout@2017-05-13T16:35:11.267Z
@edmundnoble @zainab-ali Ah, yeah, you can use Fix over Coproduct if you don’t care about the ordering. If you need it to alternate, you need mutual recursion (if you are ok with not tracking that alternation in the types, you can still get away with Coproduct).

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-13T20:22:52.989Z
In the end I managed to change my problem such that it didn't need mutual recursion, so it's all good there for now.  Coproducts are a good idea - I'll probably go with that later.

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-13T20:24:08.382Z
I've been playing around with para for educational purposes.  I'm trying to write a factorial like [this one](https://jtobin.io/practical-recursion-schemes).  I've got this far:

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-13T20:24:40.821Z
```scala
  val toNat: Int => Nat[Int] = {
    case 0 => Zero()
    case n => Succ(n - 1)  
  }

  val toInt: Nat[Int] => Int = {
    case Zero() => 0
    case Succ(n) => n + 1
  }

  val factorial: Nat[(Fix[Nat], Int)] => Int = {
    case Zero() => 1
    case Succ((n, i)) => cata(n)(toInt) * i
  }
  def para[F[_]: Functor, A](fix: Fix[F])(galgebra: F[(Fix[F], A)] => A): A = ???
  para(ana(5)(toNat))(factorial)
```

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-13T20:26:18.988Z
`para` is easy enough to write - the signature's the same as in Matryoshka with an explicit `Fix`.

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-13T20:27:33.103Z
The problem is with `factorial`.  I can't think of a way of writing it without relying on `cata`, but that defeats the point of it, doesn't it?  After all, the algebras are supposed to be completely separate from the recursive logic, aren't they?

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-13T20:30:12.538Z
For the record, the above code works, but from the article, `factorial` should be defined based on `toInt` alone.  I'm not sure how to achieve this.

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-13T20:32:41.458Z
Are my signatures wrong?  I have a gut feeling that `factorial` should have the signature `Nat[(Nat[Int], Int)] => Int`

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-13T21:16:32.852Z
It looks like my implementation was actually correct - I just misread the article

                                                                                                                                                      Greg Pfeil @sellout@2017-05-13T21:22:47.092Z
@zainab-ali I would consider factorial and toInt to be independent. I.e, factorial should be `Nat[(Fix[Nat], Fix[Nat])] => Fix[Nat]`  – then you can do `5.ana(toNat).para(factorial).cata(toInt)` (and fusion can simplify that a bit). But, even with that you’ll use `*` and `+` on `Nat` which are also defined as folds, so I don’t think you’ll get the recursion out of there easily.

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-13T21:48:51.129Z
I'll need some time to digest that  :persevere: 

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-13T21:49:55.989Z
but I get the point

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-13T21:49:59.607Z
thanks!

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-13T22:30:52.023Z
@sellout can we get a `matryoshka-refined` with a `RecursiveT` instance for positive integers?

                                                                                                                                                      Greg Pfeil @sellout@2017-05-13T22:33:26.231Z
@edmundnoble There's an open issue, I think.

                                                                                                                                                      Greg Pfeil @sellout@2017-05-13T22:35:00.574Z
#81

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-13T22:43:42.809Z
Ooooof I see. Nice.

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-15T21:31:06.294Z
I'm trying to map over the values in binary tree defined as follows:
```scala
sealed trait BTree[A, B]
case class Leaf[A, B](value: A) extends BTree[A, B]
case class Node[A, B](l: B, r: B) extends BTree[A, B]
```
I'm mapping over it using the catamorphism:
```scala
def mapValues[A, B, F[_[_]]](f: A => B)(implicit R: CorecursiveT[F]): BTree[A, F[BTree[B, ?]]] => F[BTree[B, ?]] = ???
```

Is there a better way of doing this?  I'm wondering if there's something that could map over a general recursive data structure given some natural transformation `BTree[A, ?] ~> BTree[B, ?]`

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-18T13:54:34.798Z
I'm a bit puzzled about catamorphism composition...

If a have a recursive structure `Foo[A]`, I can compose algebras of the form `Algebra[Foo, Fix[Foo]]` together and then `cata` using the result.
This is known as the *catamorphism compose law*.  I'm guessing that I can't compose the following catamorphisms:
```scala
val fooBar: Algebra[Foo, Fix[Bar]] = ...
val barBaz: Algebra[Bar, Fix[Baz]] = ...

val fooBaz: Algebra[Foo, Fix[Baz]] = ??? // I don't think this is possible
```

In my case,  the following is also true:
```scala
type Foo[A] = BTree[Int, A]
type Bar[A] = BTree[Double, A]
type Baz[A] = BTree[String, A]
```
And the algebras are created using `mapValues` referenced from above.
So I can actually compose using function composition, but not using the catamorphism compose law.

Is there an additional constraint I could apply to the algebras to make them compose in the same way that function composition would?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-18T14:03:24.751Z
```scala
eps :: f :~> g => 
cata phi . cata (In . eps) =
cata (phi . eps)
```

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-18T14:03:50.437Z
So you're going to have to add a `andThen(Fix(_))` somewhere in there.

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-18T14:12:12.882Z
I'm guessing that's Haskell?  My Haskell is conversational at best.  I'll give it a try, if it's as simple as that.


                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-18T14:19:40.549Z
I'm still having trouble :worried: 
```scala
  def fooBar: Foo[Fix[Bar]] => Fix[Bar] = ...
  def barBaz: Bar[Fix[Baz]] => Fix[Baz] = ...

  val fixFoo: Fix[Foo] = ..
  fixFoo.cata(fooBar).cata(barBaz)

  def fooBaz: Foo[Fix[Baz]] => Fix[Baz] = ???
```

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-18T14:20:52.165Z
I'm struggling to think of an implementation of `fooBaz` that will compile

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-18T14:33:22.271Z
I don't believe algebras compose.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-18T14:33:28.097Z
That `eps` seems to be a natural transformation.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-18T14:34:02.107Z
This "cata composition law" is not something I've heard of.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-18T14:34:15.171Z
`cata` is a consumer. Two consumers cannot be fused into one.

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-18T14:35:39.962Z
Tim Williams referred to it as that, but looking at the [Bananas and Lenses paper](https://pdfs.semanticscholar.org/fec6/b29569eac1a340990bb07e90355efd2434ec.pdf), it's called the fusion law.

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-18T14:35:53.986Z
I also don't think it's possible to compose two general algebras

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-18T14:36:09.832Z
I think it only works when they have exactly the same form

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-18T14:36:27.696Z
"The Fusion Law for catamorphisms can be used to transform
the composition of a function with a catamorphism into a single catamorphism, so that
intermediate values can be avoided."

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-18T14:36:40.009Z
"A function" is not very specific.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-18T14:38:32.263Z
Sorry, haven't read this paper.

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-18T14:39:15.602Z
As yet, I lack the technical expertise to understand it

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-18T14:39:25.207Z
But I think it means:

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-18T14:42:00.812Z
```scala
def foo0: Foo[Fix[Foo]] => Fix[Foo]] = ...
def foo1: Foo[Fix[Foo]] => Fix[Foo]] = ...
fixFoo.cata(foo0).cata(foo1) 
fixFoo.cata(foo0.andThen(fix => foo1(fix.unfix)))
```

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-18T14:42:10.500Z
Yeah that makes sense to me.

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-18T14:42:55.197Z
I also don't see how composing catas of other forms will work.  I'll try making sense of it with natural transformations.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-18T14:49:15.932Z
I don't either. Good luck :)

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-18T14:51:53.276Z
I see! I can just compose the natural transformations as normal.
```scala
  def fooBar: Foo ~> Bar = ...
  def barBaz: Bar ~> Baz = ...
  val fixFoo: Fix[Foo] = ...
  fixFoo.cata[Fix[Baz]](fix => Fix(fooBar.andThen(barBaz)[Fix[Baz]](fix)))
```

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-18T14:52:12.729Z
Thanks! I'm not sure why I missed that approach :smiley: 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-18T15:19:34.750Z
Ah yeah if you've got that :D

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-18T15:20:31.985Z
I don't know in general if you can substitute algebras into fixpoint types with natural transformations.

                                                                                                                                                      Greg Pfeil @sellout@2017-05-18T22:52:00.114Z
Well, that was neat – had a recursive function that I was trying to debug ∵ infinite loop. Got frustrated, basically copy/pasted it into an Algebra, just making it compile. As far as I could tell, I fixed nothing. But I ran the tests again, everything worked.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-19T05:21:47.649Z
Hehehehe

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-19T05:21:51.811Z
That's awesome

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:07:32.503Z
hi guys

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-22T19:07:44.994Z
Ohai

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:07:59.841Z
would matryoshka be good base to implement something similar to https://github.com/paularmstrong/normalizr 

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:08:07.285Z
which in essence

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:08:31.162Z
allows to take a general graph like structure comprised of uniform entities

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:08:49.482Z
and flatten it a bit with “references"

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:09:15.362Z
in essence

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:09:22.393Z
rewrite JSON of structure

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:09:26.050Z
```
{
  "id": "123",
  "author": {
    "id": "1",
    "name": "Paul"
  },
  "title": "My awesome blog post",
  "comments": [
    {
      "id": "324",
      "commenter": {
        "id": "2",
        "name": "Nicole"
      }
    }
  ]
}
```

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-22T19:09:29.821Z
I think you can do this, using the state or update monad to manage ID generation and Cofree as the data type annotating the nodes with id's.

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:09:34.378Z
to 

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:09:38.149Z
```
{
  result: "123",
  entities: {
    "articles": { 
      "123": { 
        id: "123",
        author: "1",
        title: "My awesome blog post",
        comments: [ "324" ]
      }
    },
    "users": {
      "1": { "id": "1", "name": "Paul" },
      "2": { "id": "2", "name": "Nicole" }
    },
    "comments": {
      "324": { id: "324", "commenter": "2" }
    }
  }
}
```

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-22T19:09:53.878Z
This seems very possible to me.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-22T19:10:07.030Z
Though you will have to use macros to generate the resulting case class.

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:10:28.458Z
id generation?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-22T19:10:49.024Z
Oh the id's are in the input. Never mind, no need to generate them.

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:10:52.481Z
the library does use schemas

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:11:13.124Z
which for me perhaps can be the defined case classes

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:11:23.027Z
so, with a given set of case classes 

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:11:34.446Z
which are the types of a normaliser

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:11:48.558Z
it can instantiate internally the marshalers 

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:11:54.361Z
(thinking circe here)

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:12:53.727Z
@edmundnoble "I think you can do this, using the state or update monad to manage ID generation and Cofree as the data type annotating the nodes with id’s."

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:13:16.560Z
can you elaborate a bit, it’s like you’re speaking martian here

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:13:18.479Z
:D

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-22T19:13:49.558Z
Yeah, disregard that. This looks to be possible without matryoshka.

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:13:59.518Z
and additionally, are you saying I don’t need matryoshka?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-22T19:14:17.503Z
Just make a schema type which represents this info at the type level. 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-22T19:14:35.926Z
There's no need to introduce matryoshka here, because there is really no recursion.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-22T19:14:49.868Z
You have a fixed data depth in, and fixed data depth out.

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:15:31.053Z
ok, but what if there are case classes which link to case classes or for example instances at different levels which can be reference only once in the entities bucket?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-22T19:15:45.826Z
The case classes do not refer to themselves, though?

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:15:52.580Z
not in this example

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-22T19:16:06.169Z
I don't think you need matryoshka here. What you need is shapeless.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-22T19:16:57.731Z
You need to construct new types which are the same as the original types but with references to other case classes removed. That, shapeless can do (actually, you may also need macros)

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:17:00.917Z
to generalise the case classes?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-22T19:17:08.969Z
Exactly.

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:18:04.257Z
ok, so I can then map on individual records and recurse at whatever level?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-22T19:35:47.574Z
Yeah, use type classes and recurse on the instances from other instances.

                                                                                                                                                      Andi Miller @andimiller@2017-05-23T23:55:21.482Z
are there any parser combinator libraries which play nicely with matryoshka?

                                                                                                                                                      Andi Miller @andimiller@2017-05-23T23:56:02.050Z
or does it rely on being defined at compile time?

                                                                                                                                                      Andi Miller @andimiller@2017-05-24T00:36:15.563Z
ah nice it worked with fastparse if I made all my parsers defs and added the T argument

                                                                                                                                                      Greg Pfeil @sellout@2017-05-24T02:03:44.582Z
@andimiller Yeah, and I’m writing some parsers that are more like `Parser ~> (Parser ∘ F)`, so you can then get a `Corecursive.Aux[T, F] => Parser[T]`

                                                                                                                                                      Greg Pfeil @sellout@2017-05-24T02:03:58.993Z
But that works with basically any parser combinators.

                                                                                                                                                      Greg Pfeil @sellout@2017-05-24T02:07:31.378Z
A nice (IMO) consequence of that is that it forces your parser to be pretty simple. I.e., you end up with an “outer” AST that aligns with your parser rules, and you can define that using a Coproduct, so you can desugar the more superficial components away.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-24T04:31:33.405Z
Or you can *pass your final tagless interpreter to your parser and fuse your parser with your compiler*

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-24T04:31:40.994Z
But that's none of my business :frog:

                                                                                                                                                      Alec Zorab @AlecZorab@2017-05-24T12:00:45.214Z
@edmundnoble come back when you can do nested pattern matches ;)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-24T13:40:41.208Z
My weakness!

                                                                                                                                                      Jonathan @b-studios@2017-05-24T15:07:40.261Z
RE: nested pattern matches. Just transform your algebra carrier to account for the match ;)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-24T15:07:55.697Z
I mean you *can* do it. It's just more complicated.

                                                                                                                                                      Jonathan @b-studios@2017-05-24T15:08:52.636Z
Yeah. I was once thinking about writing a matching language that results in a modified carrier.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-24T15:09:06.485Z
I'd use it. Just add StateT.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-24T15:09:34.731Z
(if you're doing HK-final-tagless)

                                                                                                                                                      Jonathan @b-studios@2017-05-24T15:20:15.821Z
Are you suggesting to store the pattern matching status in State?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-24T15:20:31.726Z
Yes, if you're using `F[_]`. Otherwise you'd just tuple it with your carrier.

                                                                                                                                                      Jonathan @b-studios@2017-05-24T15:21:50.985Z
Hmm, I guess I still don't fully get it. I assumed tupling would be enough since pattern matching can be performed bottom up.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-24T15:22:28.420Z
`trait FT[F[_]]` StateT over the F. `trait FT[A]` tuple with the A.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-24T15:22:35.151Z
Tupling doesn't form a monad.

                                                                                                                                                      Jonathan @b-studios@2017-05-24T15:26:24.482Z
Ah I see. Usually I don't assume apriori that F has to be a monad. Until it does :)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-24T15:29:55.690Z
True. But it also doesn't form an Applicative ;)

                                                                                                                                                      Jean-Rémi Desjardins @jedesah@2017-05-26T17:48:37.067Z
@sellout (or anyone else) What’s the recursion scheme I need in order to handle a `Let` statement in a expression language when trying to write an `eval` function. I’m thinking it’s something with an Elgot algebra but am a little stumped at what exactly I am likely to need so that I can handle the ` case Id` elegantly

                                                                                                                                                      Jean-Rémi Desjardins @jedesah@2017-05-26T17:49:27.735Z
Maybe also there is a much easier way :smile: 

                                                                                                                                                      Greg Pfeil @sellout@2017-05-26T20:24:14.030Z
Bindings are hard … it’s something that @wemrysi and I have talked about doing, with integrating the ABT and Matryoshka work.

                                                                                                                                                      Greg Pfeil @sellout@2017-05-26T20:25:21.761Z
Currently, with `Let`, I _think_ you need to use something `hylo`-y – collecting bindings on the way to the leaves, then substituting them on the way back down.

                                                                                                                                                      Greg Pfeil @sellout@2017-05-26T20:26:35.628Z
Maybe `hyloM` with `MonadState[M, Map[Identifier, Value]]`

                                                                                                                                                      Jean-Rémi Desjardins @jedesah@2017-05-27T03:51:19.672Z
@sellout @cristoph My friend Samuel has a proficiency with recursion schemes, not only was he able to explain to me what `futumorphism` probably does just by looking at the signature but he also came up with a really elegant solution to writing an `eval` function for a language AST with a `Let` binding

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-27T03:51:48.766Z
futumorphism just looks into the *future*

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-27T03:51:57.409Z
And histomorphism looks into *history*

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-27T03:52:20.216Z
The names are actually so obvious that they wrap back around and become confusing ;)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-27T03:53:10.557Z
(well, futumorphism more *creates* the future)

                                                                                                                                                      Jean-Rémi Desjardins @jedesah@2017-05-27T03:54:18.668Z
@edmundnoble Now that I am pretty sure I understand what futumorphism does I would’t say that it “looks into the future”, I find that somewhat misleading. I would formulate my intution more like it "allows you to build more then one level deep at any given step in the recursion"

                                                                                                                                                      Jean-Rémi Desjardins @jedesah@2017-05-27T03:54:45.073Z
Haha, okay, I like “create the future”  a little better :smile: 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-27T03:55:14.206Z
Hehe well, it works nicely when you combine them into a chronomorphism which can look into the past and create the future (because *time*)

                                                                                                                                                      Jean-Rémi Desjardins @jedesah@2017-05-27T03:59:22.579Z
@edmundnoble This all came about because @christoph and I were trying to wrap our heads around `chronomorphism` as a solution to this `Let` problem I mentioned earlier to @sellout  but it turns out a simple `cata` did the trick:

                                                                                                                                                      Jean-Rémi Desjardins @jedesah@2017-05-27T03:59:43.610Z
```scala
type Scope[A] = Reader[Map[Id[Nothing], Int], A]

def eval(expr: Fix[Expr]): Int =  {
  expr.cata[Scope[Int]]  {
    case NumLit(value)    => value.point[Scope]
    case Add(left, right) => (left |@| right)(_ + _)
    case Div(left, right) => (left |@| right)(_ / _)
    case Id(value)        => Reader(scope => scope(Id(value)))
    case Let(id, as, in)  => Reader(scope => in(scope + (id -> as(scope))))
  }.run(Map.empty)
}
```

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-27T04:02:00.992Z
Makes sense, though you could `cataM` it up I think as well with State and it might be clearer.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-27T04:02:09.990Z
Not sure what `Id[Nothing]` means in this case though.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-27T04:04:04.840Z
Got to admire the SlamData-style spacing.

                                                                                                                                                      Jean-Rémi Desjardins @jedesah@2017-05-27T04:04:46.655Z
@edmundnoble I don’t think you can use `cataM` because you need access to in the `Id` and `Let` case but I could be wrong

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-27T04:05:18.632Z
Not with Reader, I mean. State.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-27T04:05:35.254Z
Cause with Reader you need to be able to use `local` or some variety.

                                                                                                                                                      Jean-Rémi Desjardins @jedesah@2017-05-27T04:05:39.142Z
Also `Id[Nothing]` is just because `Id[A](value: String)` is part of the AST but for scope we really don’t care what `A`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-27T04:05:46.821Z
Ah right.

                                                                                                                                                      Jean-Rémi Desjardins @jedesah@2017-05-27T04:05:47.764Z
Ah, I see, ya perhaps!

                                                                                                                                                      Greg Pfeil @sellout@2017-05-27T05:27:23.421Z
@jedesah Ah, right – I had this discussion with @tpolecat at SBtB, too. But yeah, basically making your carrier be `B => A`  instead of `A` you can pass state top-down while folding bottom-up.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-27T05:36:28.152Z
Final-tagless style ;)

                                                                                                                                                      Rob Norris @tpolecat@2017-05-27T05:39:00.688Z
Oh great so you mention me and I show up just in time for Mr Tagless. 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-27T05:53:44.869Z
<3

                                                                                                                                                      Jean-Rémi Desjardins @jedesah@2017-05-27T13:45:34.881Z
A few people asked me after my workshop to post the solutions to the exercise problems somewhere online. I said I would upload a repo but then I was thinking I could create an `example` project in Matryoska and stick them there, seems that would be better than a random repo lying around. A few people I talked to yesterday were frustrated at the lack of examples. I’ll just go ahead and prepare a PR unless there is some strong objection

                                                                                                                                                      Greg Pfeil @sellout@2017-05-27T14:00:11.399Z
@jedesah How about adding them to the `docs` project, using tut?

                                                                                                                                                      Torsten Scholak @tscholak@2017-05-27T14:09:58.296Z
I'd be interested in the exercises without solutions :)

                                                                                                                                                      Greg Pfeil @sellout@2017-05-27T14:17:16.521Z
@tscholak Like scala-exercises (#50), or even more solution-less?

                                                                                                                                                      Torsten Scholak @tscholak@2017-05-27T14:25:51.150Z
You mean 47deg style?

                                                                                                                                                      Torsten Scholak @tscholak@2017-05-27T14:26:11.831Z
They are too easy.

                                                                                                                                                      Torsten Scholak @tscholak@2017-05-27T14:26:31.166Z
More like the red book

                                                                                                                                                      Greg Pfeil @sellout@2017-05-27T14:27:13.607Z
@tscholak Yeah, integrated with the 47deg tooling. Are they inherently easy, or are there just no “deep” exercises that have been written?

                                                                                                                                                      Greg Pfeil @sellout@2017-05-27T14:28:21.776Z
Like could red book style exercises be written using scala-exercises? If a successful answer is judged by some property tests, it seems like scale-exercises is a good mechanism (but I haven’t looked into how it works at all).

                                                                                                                                                      Torsten Scholak @tscholak@2017-05-27T14:35:06.961Z
I believe the 47deg scala exercises tend to be very easy because they give you already the right structure. You just have to prove that you understand the structure, usually by filling in a small gap in the code.

                                                                                                                                                      Torsten Scholak @tscholak@2017-05-27T14:35:54.157Z
It would be great if there were exercises that let you arrive at the structure eventually, step by step, by exploration and frustration

                                                                                                                                                      Torsten Scholak @tscholak@2017-05-27T14:38:30.942Z
I have something in mind, I can describe this later in more detail 

                                                                                                                                                      Torsten Scholak @tscholak@2017-05-27T14:38:40.384Z
I'm on my phone right now

                                                                                                                                                      Greg Pfeil @sellout@2017-05-27T14:38:41.104Z
Yeah – so is that not possible with scala-exercises? E.g., adding a new property test that needs to be satisfied at each step, forcing you to refine your implementation.

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-27T17:44:08.977Z
@jedesah I also ran a [recursion schemes workshop](https://github.com/to-ithaca/hack-the-tower-recursion-schemes/tree/master/src/main/scala/recursion) a while back :smiley:   
I'm also in the process of writing a fairly short tutorial, but it'll be more along the lines of a port of Jared Tobin's Haskell ones.  
Out of interest, what level was your audience?  I found that most people got stuck at `Fix` if they hadn't seen it before.

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-27T17:46:30.086Z
I'd also agree with having an `example` module to put these kinds of code snippets in.  

                                                                                                                                                      Raúl Raja Martínez @raulraja@2017-05-29T08:51:36.767Z
@tscholak @sellout If there is anything that need to change in Scala Exercises to adapt to a particular style that is better suited for Matryoshka let me know and we can look into it. Right now the supported style is `fill in this hole with an answer` where the answer can be any scala expression you expect a user to know based on a problem description.

                                                                                                                                                      jeremyrsmith @jeremyrsmith@2017-05-30T18:16:54.010Z
Is there any plan to allow cats instead of scalaz? Or is cats missing something that’s needed?

                                                                                                                                                      jeremyrsmith @jeremyrsmith@2017-05-30T18:17:40.861Z
finding myself in a situation with a fixpoint AST and thought I could avoid reinventing stuff

                                                                                                                                                      Valentin Kasas @vil1@2017-05-30T18:39:03.007Z
I know that a matryoshka-cats is on its way, but I've no idea of the ETA, perhaps you can find a way using https://github.com/djspiewak/shims

                                                                                                                                                      Valentin Kasas @vil1@2017-05-30T18:41:00.066Z
Dunno if anyone has attempted such thing before though

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-30T18:52:14.673Z
Fairly sure @sellout is working on it

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-30T18:52:19.672Z
It needs a couple things first

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-30T18:57:47.488Z
Cats I mean

                                                                                                                                                      Greg Pfeil @sellout@2017-05-30T20:03:00.858Z
@jeremyrsmith #74

                                                                                                                                                      Greg Pfeil @sellout@2017-05-30T20:03:44.010Z
@jeremyrsmith Ported versions of Monocle and Matryoshka are waiting for one last PR to get merged into Cats and released.

                                                                                                                                                      andy scott @andyscott@2017-05-31T05:09:01.514Z
I have a mini port of the core code to cats; its trivial to Port many missing pieces on an as needed basis

                                                                                                                                                      andy scott @andyscott@2017-05-31T05:10:27.604Z
Mini port = everything in one file, and just a few hundred lines 

                                                                                                                                                      andy scott @andyscott@2017-05-31T10:28:42.610Z
On that note… @sellout can you take a look at https://github.com/47deg/iota/issues/37 ? I want to ensure we properly attribue for the derived code we’re using.

                                                                                                                                                      Jean-Rémi Desjardins @jedesah@2017-05-31T16:44:24.498Z
I’m not good at keeping up with Gitter. I’ll try and do a better job.

@raulraja Last time I had a look at scala exercises the issue was that while you can insert an arbitrarly complex expression in the holes they are rendered very small making it awkward to expect big expressions in them or did I miss something and is the size of the input field configurable?

@sellout I'll try and add them to `docs` using `tut`.

@tscholak I can dump the exercises in `docs` (or in `examples` if that fails) with solutions. I’ll try and decouple somehow the problem statement from the solutions but if you have a better idea on how to do that, you will be more than welcome to make a PR to improve wtv I come up with.

                                                                                                                                                      Torsten Scholak @tscholak@2017-05-31T16:50:51.653Z
@jedesah that would certainly be helpful. It's hard to explain what I have in mind without reciting all of it. The thing is I have a wealth of scattered notes that I produced while I was learning this myself. I need to find the time to blog about this...

                                                                                                                                                      andy scott @andyscott@2017-06-03T12:55:23.075Z
I have a Cofree fixed point structure for `TreeF[A]` and I’d like to  transform the associated cofree value for certain nodes `FooF[A]` (and all child nodes of those nodes). Is there an obvious operation for this?

                                                                                                                                                      Greg Pfeil @sellout@2017-06-03T15:41:04.028Z
@andyscott on my phone, but you may want something like `Algebra[EnvT[Value, TreeF, ?], Boolean => Cofree[TreeF, Value]]`

                                                                                                                                                      Greg Pfeil @sellout@2017-06-03T15:41:41.525Z
Where the Boolean indicates whether you're at a child of FooF.

                                                                                                                                                      andy scott @andyscott@2017-06-04T14:39:14.408Z
@sellout Awesome. How would I apply that transformation?

                                                                                                                                                      andy scott @andyscott@2017-06-04T14:40:31.111Z
I’m still a Matryoshka/general recursion n00b.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-04T15:07:57.885Z
`_.cata(transformValue)(false)` – the `cata` returns a `Boolean => Cofree`, and at the root, you aren’t a child of FooF, so you apply it with `false`.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-04T15:11:52.825Z
@andyscott ↑

                                                                                                                                                      andy scott @andyscott@2017-06-04T15:13:26.893Z
Very cool. Conceptually this makes sense but it’s going to take me a bit to fully digest it :).

                                                                                                                                                      Yilin Wei @yilinwei@2017-06-10T11:47:15.181Z
Should I not be using the `BirecursiveT`/`RecursiveT` typeclasses and prefer writing `.Aux` per fix point structure instead?

                                                                                                                                                      Yilin Wei @yilinwei@2017-06-10T11:48:23.760Z
got the use case of doing a few `cata` transforming to different fix point data structures.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-10T15:03:08.004Z
@yilinwei Correct. The `…T` ones will eventually go away (once mutual-recursion is handled properly), and they’re much less general.

                                                                                                                                                      Yilin Wei @yilinwei@2017-06-10T15:07:52.378Z
@sellout gotcha, apologies for the question but I've got this algebra which feels wrong (it uses the stack per list element) and I was wondering if I should be using a different recusion scheme.

                                                                                                                                                      Yilin Wei @yilinwei@2017-06-10T15:07:53.856Z
https://gist.github.com/yilinwei/b2483fbf4b28b1a302169c86f73ca1ea

                                                                                                                                                      Yilin Wei @yilinwei@2017-06-10T15:09:03.987Z
The `Option` signals the root element of the list. I've got an alternate one which uses 2 cata's (one to convert to a `RoseTree`) and then a `Show` but not sure whether there's a better way of doing it.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-10T15:15:19.815Z
Ok, I see. I do tend to break things down into multiple algebras when possible – especially in the case where `A` is a function. Can you add the RoseTree version to the gist?

                                                                                                                                                      Yilin Wei @yilinwei@2017-06-10T15:16:38.079Z
https://gist.github.com/yilinwei/c1375c480b8af4e7c98670e946299883

                                                                                                                                                      Yilin Wei @yilinwei@2017-06-10T15:16:57.975Z
(hence the question about the `T` variants)

                                                                                                                                                      Yilin Wei @yilinwei@2017-06-10T15:17:38.833Z
I've got some inference headaches which is why the types are there; but it should just be embed

                                                                                                                                                      urosn @urosn@2017-06-12T18:21:44.747Z
Does anyone work with (Co)Elgot algebras?

                                                                                                                                                      Greg Pfeil @sellout@2017-06-12T18:45:46.123Z
Maaaaaaybe

                                                                                                                                                      Greg Pfeil @sellout@2017-06-12T18:46:17.958Z
Heh, I just saw the mention in scala/scala

                                                                                                                                                      urosn @urosn@2017-06-12T18:47:54.554Z
@sellout I would like to ask if you/anyone see advantages working with such structures?

                                                                                                                                                      Greg Pfeil @sellout@2017-06-12T18:49:51.218Z
@urosn Elgot in particular? They’re useful in some cases, but most of the advantages are applicable to any generalized folds. For one thing, we have fixed various bugs just by mechanically converting a directly-recursive operation to an algebra. When I was doing the conversion, I didn’t even notice the bugs, but when recompiling, suddenly pending tests were passing.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-12T18:49:59.029Z
So, not having to think about recursion is nice.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-12T18:51:27.014Z
And then there’s the composability/fusion stuff. Which, in addition to reducing number of passes over the data gives you somewhere to push some of the complexity that is removed from the algebras. E.g., if you want to compose a bunch of algebras and _one_ of them needs State, you handle lifting the others into state when you compose them. And it means the others can be used in more places.

                                                                                                                                                      urosn @urosn@2017-06-12T18:52:54.620Z
@sellout Your point is that code is cleaner, faster, and less error prone?

                                                                                                                                                      Greg Pfeil @sellout@2017-06-12T18:54:46.434Z
Yeah, although faster is with a grain of salt … in the talk I gave at Typelevel Philly last year, I kind of talked about some compiler approaches. A monolithic compiler is probably fastest, but the other aspects become much worse. Splitting it into many passes improves clarity, but loses performance. Recursion schemes, IMO, make it even cleaner than traditional many-pass, plus regains _some_ of the performance.

                                                                                                                                                      urosn @urosn@2017-06-12T18:57:06.262Z
@sellout So code is at the same speed but cleaner and less error prone?

                                                                                                                                                      Greg Pfeil @sellout@2017-06-12T18:57:58.987Z
Sure, I’ll take that :D

                                                                                                                                                      urosn @urosn@2017-06-12T18:58:00.255Z
@sellout BTW I like modular compilers because they will allow us to use macros better. You won't only develop code which will be compiled but code which will be executed during compilation.

                                                                                                                                                      urosn @urosn@2017-06-12T18:58:29.295Z
It will be new way of thinking about software development.

                                                                                                                                                      urosn @urosn@2017-06-12T19:08:10.527Z
@sellout You mentioned typelevel.org. To whom belongs that organisation (which company)?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-12T19:08:18.595Z
Typelevel

                                                                                                                                                      urosn @urosn@2017-06-12T19:09:03.847Z
@edmundnoble Typelevel company doesn'e exsist!

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-12T19:09:58.708Z
It's not part of a company. Just a community.

                                                                                                                                                      urosn @urosn@2017-06-12T19:10:20.676Z
@edmundnoble  But who is sponsoring?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-12T19:12:04.235Z
What do you mean? Typelevel is only a community. If you mean typelevel events, they all have different sponsors.

                                                                                                                                                      urosn @urosn@2017-06-12T19:13:50.366Z
@edmundnoble Ususally some community is being created/backed by one or more companies.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-12T19:15:03.729Z
Not this one. As far as I know.

                                                                                                                                                      urosn @urosn@2017-06-12T19:55:52.729Z
While I am here I would like to ask about using topological structures in software development? What do you think about it?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-12T20:02:42.651Z
I don't know of any that are useful; the notion of a monotone function and open set could be useful, but most of the applications that I encounter for topology in computer science involve reasoning about the termination of algorithms.

                                                                                                                                                      Alec Zorab @AlecZorab@2017-06-13T08:59:52.304Z
@urosn @edmundnoble more a conversation for typlevel/general, but there is actually a registered company behind typelevel, though it's only there for paperwork purposes.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-13T09:00:35.441Z
Ah, makes sense. Thanks for the info.

                                                                                                                                                      urosn @urosn@2017-06-14T21:05:40.418Z
Hi all, Is there some book explaining GRS and Trav . (ideally with examples) where I can learn from? Thanks!

                                                                                                                                                      Greg Pfeil @sellout@2017-06-15T23:37:32.906Z
I almost bought one of these today, simply for the name: http://www.aboutorchids.com/blog/2016/05/23/purple-zygo-orchids/

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-15T23:38:55.087Z
Oooooo I would

                                                                                                                                                      Greg Pfeil @sellout@2017-06-15T23:41:35.423Z
Maybe next time. I have trouble with more than one plant at a time.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-15T23:42:59.632Z
I had a Darwin orchid that I killed pretty quickly (https://en.wikipedia.org/wiki/Angraecum_sesquipedale)

                                                                                                                                                      Greg Pfeil @sellout@2017-06-15T23:43:23.750Z
I loved that story long before I cared about orchids.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-16T00:45:46.261Z
@urosn Sorry – I don’t know of any book. The matryoshka README mentions a few papers and talks.

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-06-28T17:39:32.864Z
@edmundnoble btw, I've been using your micro-matryoshka with great success =)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-28T17:39:58.272Z
Wonderful :) what exactly was in there? Just cata and Fix?

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-06-28T17:42:00.092Z
cata/M, fix, cofree (yours in cats), and transAna 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-28T17:42:43.075Z
Nice, that's one of the benefits of recursion schemes; it's one of those libraries you can use without depending on it, like lens ;)

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-06-28T17:45:03.626Z
totally

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T21:41:22.833Z
o/

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T21:41:45.931Z
Hey, I hope what's remaining of this conversation reinvigorates @sellout's efforts to add mutual recursion ;)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T21:42:28.175Z
Heh... Maybe it will :p give me a minute to mess with this `Fix2` doohickey and see what happens

                                                                                                                                                      Emrys Ingersoll @wemrysi@2017-06-29T21:42:34.803Z
 I _think_ he's blocked on scalac...

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T21:42:42.170Z
Oh crap

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T21:42:49.679Z
Gotta rewrite `cata`. Should I change it to `cata2` or something?

                                                                                                                                                      Emrys Ingersoll @wemrysi@2017-06-29T21:42:51.364Z
As we have all sorts of motivation in quasar

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T21:43:08.211Z
Also @edmundnoble I checked about 2 hours ago.  He's blocked by scalac.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T21:43:11.205Z
@Jacoby6000 I would rename it to that, yes

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T21:43:13.123Z
Aw

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T21:43:33.230Z
Well, I suppose this is just another usecase

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T21:44:16.700Z
Well, this doesn't feel right at all.
`    def cata2[B, C](f: QueryValue[A, B, C] => (B, C)): (B, C) =`

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T21:44:48.672Z
Oh... will it take two algebras now?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T21:45:40.793Z
I think one algebra returning (B, C) and two algebras returning respectively a B and a C are going to work out the same here

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T21:46:18.792Z
ah, i see.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T21:46:36.989Z
glad my intuition was correct, even if it felt wrong :) 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T21:49:09.653Z
No, two separate algebras definitely makes more sense

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T21:49:17.428Z
(at least, here)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T21:49:45.484Z
maybe... I'm not sure what the return type would be

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T21:51:27.118Z
Either?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T21:55:59.981Z
I think (B, C) makes sense here

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T21:56:07.040Z
Actually

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T21:56:16.863Z
Uh actually yes, I'd say Either makes more sense

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T21:59:56.818Z
Problem seems to be that you end up with `F[A, Either[A, B]]` or `F[Either[A, B], Either[A, B]]` From there, you can't really do anything, so the function cant run recursively

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T22:00:01.540Z
I'm not sure if the first or second one is right, but neither are really useful

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T22:04:12.990Z
Yeah

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T22:04:18.433Z
I think the mutual recursion stuff is needed :/

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T22:04:27.602Z
If you're willing to look at the PR for ideas

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T22:04:34.834Z
I'll do that

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T22:04:55.938Z
In any case, I've probably multiplied my understanding of ASTs, Free, Fix, and CoFree about 10 fold in the last few days.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T22:05:17.536Z
:+1: :+1: :+1: :+1: 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T22:14:27.619Z
I don't think I'll ever stare insanity in the eyes so closely ever again

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T22:14:34.898Z
this mutually recursive stuff is mind-boggling

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T22:20:00.554Z
LOL

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T22:20:02.574Z
I agree

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T22:24:03.624Z
@sellout's name must be alluding to the way he sold his soul to the devil to be able to parse and understand these things. 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T22:26:42.962Z
I think he studied under Robert Harper, which *may* be analogous ;)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T22:31:34.873Z
does there exist a type equality for `F[_] =:= G[_]` ?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T22:31:44.911Z
Not in the stdlib

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T22:32:38.363Z
:thumbsup: 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T22:32:58.684Z
You can make one

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T22:33:12.240Z
fs2 has one


                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T22:33:13.009Z
I'm going to make sure it's necessary first.. I might not need it

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T22:33:18.283Z
Okeys

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T22:33:33.175Z
```scala
trait Sub1[F[_], G[_]] {
  def subst[T[_[_]](tfa: T[F]): T[G]
}
```

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T22:46:54.621Z
Alright, so I think I've almost got something.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T22:46:58.914Z
I have 
```scala
  trait Foo[A, B, C]
  implicit def hax[A, B, C](implicit ev: B =:= QueryComparison[B, C], ev2: C  =:= QueryValue[A, B, C]) =
    new Foo[A, QueryComparison[B, C], QueryValue[A, B, C]] {}
```

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T22:47:19.217Z
meaning, I've got the mutual recursion proof.. Now I just need to figure out how to expand B and C.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T22:48:32.149Z
ehh. gotta through fix in there

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T23:15:40.255Z
@edmundnoble I think it's going to work... For some reason, scala is okay with this
```
  type QC[A] = Fix[QueryComparison[A, ?]]
  type QV[A] = Fix[QueryValue[A, QC[QV[A]], ?]]
```

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T23:15:48.564Z
Before I thought that would just fail..

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T23:15:54.953Z
Working on getting types to infer

                                                                                                                                                      Emrys Ingersoll @wemrysi@2017-06-29T23:22:15.615Z
I didn't think you could construct a recursive alias like that...

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T23:22:39.304Z
I didn't either. Maybe I'm going crosseyed reading this weird errors

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T23:23:17.455Z
oh, yup.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T23:23:24.548Z
```
[error] /Users/jacobbarber/projects/scoobie/core/src/main/scala/scoobie/ast.scala:282: illegal cyclic reference involving type QV
[error]   type QV[A] = Fix[QueryValue[A, QC[QV[A]], ?]]
```

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T23:23:32.002Z
I thought something was weird.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T23:24:21.700Z
There's gotta be a way to trick the compiler

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T23:31:35.012Z
Make a new datatype?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T23:31:42.064Z
To wrap QV

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T23:35:26.682Z
Can you give me an example?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T23:35:56.627Z
Also, admire my error https://hastebin.com/uzupohihad.rb

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T23:36:01.200Z
```scala
case class QV[A](unwrap: Fix[QueryValue[A, QC[QV[A]], ?]])
```

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T23:36:28.347Z
ah

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T23:37:54.895Z
So, why is that supported at the value level, but not the type level?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T23:39:38.161Z
Equirecursive vs isorecursive types

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T23:51:29.939Z
Doesn't seem to work, because Fix isn't wrapped in QV in the third parameter :/ 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T23:53:28.015Z
Oh wait, maybe I'm just dumb

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T01:16:46.927Z
WOO I THINK I DID IT

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T01:16:54.918Z
It's a bit different though

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T01:16:58.109Z
let me double check

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-30T01:17:48.450Z
Ooooo

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T02:11:55.696Z
Of all the days to not be logged into Gitter …

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T02:12:13.453Z
@Jacoby6000 Is there a beginning of this conversation somewhere else?

                                                                                                                                                      Emily Pillmore @emilypi@2017-06-30T02:12:40.132Z
nice @Jacoby6000 

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T02:13:17.980Z
And yeah, mutual recursion is blocked on Scala. I need to get back to my Scala PRs … hopefully soon. As @wemrysi mentioned, it would be very nice at work to have it.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T02:14:34.693Z
@edmundnoble I wish I’d studied under Harper. I only went to programmer trade school and dropped out.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T02:37:36.110Z
@sellout the conversation is a bit spread around #scalaz, typelevel/cats, and here :p 

@edmundnoble I think I've got a thing working, provided I can figure out how to prove this:
```scala
                    toFixedComparison: B =:= Fix[QueryComparison[C, ?]],
                    toFixedValue: C =:= Fix[QueryValue[A, B, ?]],
                    toC: Fix[QueryValue[A, B, ?]] =:= C,
                    toB: Fix[QueryComparison[C, ?]] =:= B) = {
```

I was able to get scala to be okay with the mutual recursion by never explicitly saying that things are mutually recursive, and just implying it.

Here's what I have... It's ugly and it's bad and I'm sorry.

I got around mutual recursion by replacing `Fix` for one of my ASTs with this `ANSIValue` case class (which can probably be generalized further)

```scala
  case class ANSIValue[A](unfix: QueryValue[A, Fix[QueryComparison[ANSIValue[A], ?]], ANSIValue[A]]) extends AnyVal {
    def fixed[B, C](implicit
                    toFixedComparison: B =:= Fix[QueryComparison[C, ?]],
                    toFixedValue: C =:= Fix[QueryValue[A, B, ?]],
                    toC: Fix[QueryValue[A, B, ?]] =:= C,
                    toB: Fix[QueryComparison[C, ?]] =:= B) = {

      type AST = Fix[QueryValue[A, B, ?]]
      type CMP = Fix[QueryComparison[C, ?]]

      def fixComparison(cmp: Fix[QueryComparison[ANSIValue[A], ?]]): CMP =
        Fix(cmp.f.leftMap(x => fixValue(x)).rightMap(v => fixComparison(v)))

      def fixValue(v: ANSIValue[A]): C =
        v.unfix match {
          case QueryFunction(path, args) => toC(Fix(QueryFunction(path, args.map(x => toFixedValue(fixValue(x))))))
          case QueryPathValue(p) => toC(Fix(QueryPathValue[A, B, AST](p)))
          case QueryValueBinOp(l, r, op) => toC(Fix(QueryValueBinOp(toFixedValue(fixValue(l)), toFixedValue(fixValue(r)), op)))
          case QueryParameter(p) => toC(Fix(QueryParameter[A, B, AST](p)))
          case _: QueryNull[_, _, _] => toC(Fix(QueryNull[A, B, AST]))
          case QuerySelect(table, values, joins, filter, sorts, groupings, offset, limit) =>
            toC(Fix(QuerySelect(
              QueryProjectOne(fixValue(table.selection), table.alias),
              values.map(_.map(x => toFixedValue(fixValue(x)))),
              joins.map(
                _.leftMap(x => toFixedValue(fixValue(x)))
                  .rightMap[B](x => toB(fixComparison(x)))
              ),
              fixComparison(filter),
              sorts,
              groupings,
              offset,
              limit
            )))
          }

      val fixedStuff = fixValue(this)
      toFixedValue(fixedStuff)
    }

  }
```

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T02:38:47.499Z
Now my problem is 
```
Cannot prove that B =:= scoobie.ast.Fix[[β$2$]scoobie.ast.QueryComparison[C,β$2$]].
[error]   simpleSelect.fixed.cata[String] {
```

So my efforts are still probably for nothing :p 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T02:41:07.692Z
if I can get `fixed` to work, then I'll be back in a standard mutually recursive fixed point scenario, and I can just use `cata` to start collapsing things.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T02:42:49.961Z
I'm about 99% sure that all i did was move the problem

                                                                                                                                                      Emily Pillmore @emilypi@2017-06-30T02:43:38.278Z
hahaha

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T02:47:01.887Z
I think at this point it'd be easier to just go hack on scalac >.> 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T02:47:14.890Z
That thing I made is a mess

                                                                                                                                                      Emily Pillmore @emilypi@2017-06-30T02:48:13.760Z
ANTLR plugins for mutually recursive types

                                                                                                                                                      Emily Pillmore @emilypi@2017-06-30T02:48:15.853Z
lol

                                                                                                                                                      jeremyrsmith @jeremyrsmith@2017-06-30T04:27:00.637Z
To understand recursive types, you first must understand recursive types

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T17:33:07.378Z
Damn this recursive type thing is really erking me. It's like I'm THIS CLOSE || to a solution, and the compiler just won't let me do it.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T17:33:37.886Z
@Jacoby6000 goes and looks at the scalac issues and tries to help or something

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T17:33:46.891Z
@Jacoby6000 What are you trying to do? I see a bunch of solution attempts, but no description of the problem.

                                                                                                                                                      Emily Pillmore @emilypi@2017-06-30T17:33:50.494Z
does Eta support mutually recursive types?

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T17:34:16.764Z
@emilypi In fixed-point style? If it supports GADTs, then it should.

                                                                                                                                                      Emily Pillmore @emilypi@2017-06-30T17:34:54.062Z
That’s what I’m wondering - if it supports GADTs and rankN type extensions

                                                                                                                                                      Emily Pillmore @emilypi@2017-06-30T17:36:20.938Z
i don’t know how comfy @Jacoby6000 is with it, but it might be worth it if your PR’s in aren’t going to approved anytime soon (i think they are, but if it’s teh case…)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T17:36:39.819Z
@sellout I have two structures  `QueryValue[A, B, C]`, and `QueryComparison[A, B]`.  
I want them to be mutually recursive like:

```scala
type ANSIQueryValue[A] = Fix[QueryValue[A, ANSIQueryComparison[A], ?]]
type ANSIQueryComparison[A] = Fix[QueryComparison[ANSIQueryValue[A], ?]]
```

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T17:38:19.492Z
`QueryComparison[A, B]` takes structures with shape `B` and compares values of type `A`.
`QueryValue[A, B, C]` takes values of type `A` and composes them with structures of type `C`.   type `B` is in there, because my AST has a case where a comparison can be represented in the tree.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T17:38:32.077Z
Ok, so … you mean you want them to have both _alternating_ and _self_ recursion?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T17:38:48.465Z
I suppose so.. if that's what the above implies.  That sounds right.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T17:39:12.818Z
What do the constructors from QueryValue and QueryComparison look like?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T17:40:01.717Z
https://github.com/Jacoby6000/scoobie/blob/feature/%2340-adjust-ast-to-support-fixpoint/core/src/main/scala/scoobie/ast.scala

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T17:40:12.225Z
that's the whole definition

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T17:40:26.915Z
they're both ADTs

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T17:42:14.144Z
type `B` in `QueryValue` is only used on the `QuerySelect` node

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T17:46:01.198Z
I want a type where QueryComparisons compare values of type QueryValue, and I want a QueryValue where the where/filter clauses are represented by QueryComparisons.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T17:47:33.280Z
Ok, yeah, just get my PR merged 😆

                                                                                                                                                      Emily Pillmore @emilypi@2017-06-30T17:47:52.205Z
that was a beast of a PR

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T17:47:57.256Z
@emilypi I think you misread that ;)

                                                                                                                                                      Emily Pillmore @emilypi@2017-06-30T17:48:10.809Z
aw shit

                                                                                                                                                      Emily Pillmore @emilypi@2017-06-30T17:48:12.690Z
hahaha

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T17:48:39.200Z
Might be able to play with it _next_ weekend. We’ll see.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T17:49:01.915Z
The worst part is, there was a time when it worked. Perhaps Scala 2.11.7?

                                                                                                                                                      Emily Pillmore @emilypi@2017-06-30T17:49:01.034Z
I’m in space i’m so tired - and at work haha

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T17:49:01.915Z
The worst part is, there was a time when it worked. Perhaps Scala 2.11.7?

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T17:49:35.251Z
But then Miles fixed some other piece of GADT handling, and it broke a piece of it we needed.

                                                                                                                                                      Emily Pillmore @emilypi@2017-06-30T17:49:50.720Z
was it a 2712 problem?

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T17:50:09.412Z
No – actually, Matryoshka needs the 2712 fix in order to do almost anything.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T17:51:09.785Z
If I had been more prompt in 1. getting mutual-recursion merged into Matryoshka and 2. getting Matryoshka into the community build, it would have been noticed.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T17:51:43.506Z
So you're saying that it's impossible for now :/ Is there any more work that needs to be done with the PR, or do we just need to yell at some people to merge it?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T17:51:51.645Z
Is it available in the typelevel fork?

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T17:52:05.060Z
@Jacoby6000 Well, not impossible, but impossible in a purely fixed-point approach.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T17:52:21.588Z
We hack around the lack of mutual-rec at work a bunch. There are a few techniques, each painful in their own way.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T17:52:45.396Z
If I stared at yours for a while, I could _probably_ figure out how to apply some of them.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T17:52:54.718Z
But I should really just fix scalac …

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T17:53:19.052Z
There’s some more work on the PR, but Jason has given some useful pointers. I just have to apply them.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T17:53:34.852Z
I just want it to work now :cry:  lol 

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T17:53:58.292Z
No, it’s similarly broken in the Typelevel fork. I was hoping Miles would include it, but I guess he figured there was to much left to do for it to be considered acceptable in its current state.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T17:54:28.342Z
I see.

So, after the PR, what will change that will make it possible?   If I can't have cyclic references in types, how do I even define the type?

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T17:59:14.603Z
You need to use higher-order functors, basically. Which means, roughly, instead of `QueryValue[A, B, C]`, you would have `Query[A[_], I]` and would do something like `case class QueryNot[A[_]](value: A[Value]) extends Query[A, Comparison]`

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T17:59:53.763Z
I.e., you have one big AST, and you use the `I` position in `Query` to indicate which subset of the AST can be used in each recursive position.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T18:00:56.249Z
So, `QueryNot` is a `Query[_, Comparison]`, `QueryFunction` would `extend Query[A, Value]`.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T18:01:21.704Z
Where `Value`/`Comparison`/etc. is a simple enumeration.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T18:03:54.111Z
Does that make sense at all?

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T18:08:29.647Z
In `QueryNot[A[_]](value: A[Value]) ` that means that `value` can only hold AST nodes that `extend Query[A, Value]`, so rather than having a homogenous AST, you partition it into pieces depending on which nodes are valid where. And you can actually make nodes flexible, too. Like, you could do `QueryBinOp[A[_], I](left: A[I], right: A[I], op: I) extends Query[A, I]` – so, if you build that node with Comparisons, then it’s a node of type `Query[A, Comparison]`, but if you build it with Values, then it’s of type `Query[A, Value]`, and you’ve just combined both of your BinOp nodes into one.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T18:12:28.717Z
BTW, in that case, `Value` is `QueryValueArithmeticOperator` and `Comparison` is `QueryComparisonValueOperator `. So the type does double duty both as an actual type and the partitioner.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T18:12:52.717Z
I am probably just digging a deeper hole …

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T18:14:42.085Z
This seems obvious to me now, but I know I was super-lost when I first started trying to figure it out.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:18:37.284Z
I think it makes sense. Will doing this afford me the flexibility to extend the AST? My current AST represents ANSI SQL, that's sufficient for now... but I'd like to be able to extend it at some point, so that there are supersets for postgres or mysql.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:23:39.461Z
If I were to take your suggestion about using operands as the partitioner, would that mean that the operands would just have to be subtypes of their respective trees?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:23:50.031Z
so `ArithmeticOperator` would extend `Value`?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:27:12.458Z
also, would these new `Comparison`, and `Value` classes just be traits that do nothing?

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T18:37:46.186Z
On my phone now. Can answer better later, but yes – you can use Coproduct to extend your ADT in a way that's orthogonal to the type partitioning.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:38:03.079Z
awesome :)

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T18:39:15.231Z
They could be traits that do nothing, but I was thinking you could just rename the operator traits to Value/Comparison. I think there are better options, but that was quick & dirty.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:40:23.384Z
Ah okay, so that would _work_ but I don't think I want it to behave that way. I'll start with what you've given me and refine it as my understanding improves

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:41:22.840Z
Funny thing about this is that a little ahile ago, I had the shape `F[G[_], A]` representing QueryValue and QueryComparison :p 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:41:53.665Z
Granted, I didn't do it the same way you suggested.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T18:42:11.764Z
Like, if you just made Value/Comparison unused traits, then you could define a single `sealed trait Operator[I]` with the specific objects extending `Operator[Value]` or `Operator[Comparison]`, and you would use `Operator[I]` as the parameter type in `QueryBinOp`.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:42:50.662Z
Oooooh I like that

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T18:43:15.618Z
Type indexes are fun 😄

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:43:36.446Z
That was my next question... why is it called `I`. You just answered that :p 

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T18:43:54.018Z
👍🏾

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:44:33.896Z
Should I define the Index as covariant? That makes sense in my head but I'm unsure

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T18:47:49.773Z
Heh – good question. That's on my list of things to experiment with.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:48:06.316Z
:thumbsup:  

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:48:12.424Z
I think I've ran in to my first issue

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:49:06.833Z
I've got `QueryParameter[A[_]] `, but `QueryParameter` is a leaf node that should be able to accept some other type, not an AST.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T18:49:11.425Z
We want to index using the type system for our language, so you can't construct incorrectly-typed ASTs, but we can either have a limited form of our type system, or have it be covariant.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:49:53.888Z
ah I see

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T18:51:42.136Z
You can just add another type param in that case, so you have `sealed trait Query[PARAM, REC[_], INDEX]`

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:51:47.888Z
Ah alright

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:51:51.904Z
makes senes

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:52:17.048Z
This is a new structure to me, so I'm not sure where it makes sense to tack things on just yet. I think I'm getting it though

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T18:52:53.047Z
Then with mutual recursion you would do `HFix[Query[Int, ?[_], ?]]` (for Int-typed parameters)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:53:04.959Z
HFix?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:53:12.153Z
oh i see

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T18:53:20.452Z
That's like Fix for mutual recursion.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:55:10.291Z
it's like  `case class HFix[F[_[_], _](f: F[HFix[F], F])` or something...  ( i know that's wrong, but maybe it's close. lol)

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T18:55:15.796Z
Technically, `HFix[Query[Int, ?[_], ?], Value]`, because you need to tell it what the final type of the Recursive expression will be.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:55:22.548Z
OH

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:55:28.979Z
that's what I was missing :D

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T18:55:43.121Z
Yeah, sorry. I blame my phone ;)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:55:53.299Z
`case class HFix[F[_[_], _], A](f: F[HFix[F], A])`

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T18:56:01.841Z
Boom!

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T18:57:07.546Z
You need `F[HFix[F, ?], A]`, but clearly you get it.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:57:20.278Z
:thumbsup: 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T19:02:50.981Z
Once I do all this legwork, I understand that it still wont work, because scalac.. but, are there proper ways to build catamorphisms for these shapes?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T19:33:01.763Z
What wonderful compiler errors I have!

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T19:45:04.600Z
I think I've got it. 
```scala
  type ANSIQuery[A] = HFix[Query[A, ?[_], ?], A]
```
compiles and stuff.
Updated [here](https://github.com/Jacoby6000/scoobie/blob/feature/%2340-adjust-ast-to-support-fixpoint/core/src/main/scala/scoobie/ast.scala)


                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T19:47:47.081Z
Going to try to tackle cata

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T19:53:32.898Z
You can find `cata` etc. here: https://github.com/slamdata/matryoshka/pull/28/files

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T19:53:46.581Z
Note that basically all the folds, etc. are now NaturalTransformations.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T19:54:37.762Z
kind-projector has a nice syntax for defining them, like `λ[F ~> G](fa => ???)` rather than actually having to define a new instance and declare the apply method, etc.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T19:55:09.976Z
I have a ton of changes to that PR that I should push, but I’ve hesitated just because I can’t really verify that it works now.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T19:55:29.282Z
Instead of λ I can just use `Lambda`, right? I haven't figured out how to type λ yet.  lol

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T19:55:38.029Z
Yep, I think that works.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T19:55:48.596Z
Definitely there is _some_ ASCII name that works.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T19:57:07.153Z
This is my second time looking at that PR, and none of it is any more clear than last time :sweat_smile:  I need to learn my vocab so I don't have to jump around a whole bunch.  All I know right now is `Algebra[F, A] === F[A] => A`. lol

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T19:58:15.719Z
Right, except for higher-kinds, it’s `Algebra[F[_[_], _], A[_]] === F[A, ?] ~> A` :D

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T19:58:46.107Z
Wouldnt that be AlgebraF then?

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T19:58:47.264Z
Same thing, but each type moves one step up the functor ladder, leaving room for the type index.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T19:58:51.589Z
or AlgebraM.. 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T19:58:55.894Z
I don't know how to name things

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T19:59:07.114Z
Yeah, we could call it that. `AlgebraM` is `F[A] => M[A]`

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T19:59:30.306Z
Isn't that just a natural transformation O_o 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T19:59:31.694Z
oh wait no

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T19:59:39.623Z
Right now it’s `matryoshka.Algebra` vs `matryoshka.mutu.Algebra` ;) It probably should have a different name.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T19:59:41.699Z
That'd just be `F ~> M`

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:00:18.219Z
AH I SEE NOW. So in my case, cata takes this higher kinded algebra, rather than the non-mutu algebra

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T20:00:29.867Z
Right – it’s still the same `F[A] => A`, but the result can be in a monad, and the fold takes care of flat mapping over it at each step.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:00:37.040Z
right, got it :)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-30T20:01:01.692Z
`T[F, ?] ~> (M of F)#l` or something?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-30T20:01:11.360Z
Where `of` is your magical compose symbol

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T20:01:14.233Z
Yeah, exactly. There should be more distinct names. Some of them are distinct, like `HFix`, but a lot just trample on the “regular” names.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:01:16.663Z
And now I see that the Algebra type parameters essentially mimics the version of Fix that you're using.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T20:01:42.280Z
@edmundnoble Yeah, that’s the higher-kinded version of `AlgebraM`.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T20:02:13.626Z
From the PR: `type AlgebraM[M[_], F[_[_], _], E[_]] = F[E, ?] ~> (M ∘ E)#λ`

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T20:03:02.576Z
You know … maybe I should revisit this PR, taking advantage of PolyKinds …

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T20:03:12.540Z
That was definitely the plan at some point.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:04:33.024Z
```scala
type of[F[_], G[_] {
  type λ[A] = F[G[A]]
}
```
correct?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-30T20:04:46.322Z
Si

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-30T20:04:57.373Z
I always just use `l` though, might change given my new unicode aliases

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:05:23.751Z
what do you mean by that?

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T20:05:30.591Z
@Jacoby6000 Did you just learn how to type lambdas? 😄

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-30T20:05:31.642Z
`type l[A]`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-30T20:05:52.256Z
(oh you need another equals sign up there to the right of `G[_]`)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:05:55.237Z
@sellout nah, I have spent years practicing, training, and honing my abilities to copy and paste.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T20:05:57.293Z
🙄

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:06:19.865Z
I can't figure it out on a mac keyboard for the life of me

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:06:31.590Z
I always want to do alt+y , but that's just yen. ¥

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T20:06:39.037Z
@Jacoby6000 The cheaty way is Cmd-Ctrl-Space

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:06:52.782Z
ƛ

                                                                                                                                                      Tristan Lohman @gatorcse@2017-06-30T20:07:05.690Z
𝝀

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T20:07:11.512Z
Actually, Unicode doesn’t know how to spell, so it’s “lamda”

                                                                                                                                                      Tristan Lohman @gatorcse@2017-06-30T20:07:18.684Z
trick is just figuring out which one works

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-30T20:07:28.906Z
Lambor λ

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:07:41.555Z
when I do cmd-ctrl-space, it gives me... "capital lambda" it looks like.  lol

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:07:54.814Z
ƛ

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-30T20:07:58.415Z
You want *lamda*

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:08:14.196Z
𝝀

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:08:21.683Z
why do I keep thinking it's a sheep?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:08:31.585Z
where did that "B" come from?

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T20:08:36.035Z
@Jacoby6000 You’re right, Unicode is wrong.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:08:39.371Z
oh

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:08:45.891Z
now i see what you're saying

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:08:48.234Z
lol

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:09:34.658Z
And now I see what you mean by you have to figure out which one works...  there's 5 or 6

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-30T20:09:54.398Z
λ this is the one true lambda

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:10:08.329Z
and what's the right way to type it?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:10:22.240Z


                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-30T20:10:46.859Z
Second from the left, on the top

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:10:49.607Z
If I don't figure it out, I'm just gonna use ¥ everywhere, and do a find/replace after. lol

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-30T20:10:50.253Z
[![image.png](https://files.gitter.im/slamdata/matryoshka/wHhj/thumb/image.png)](https://files.gitter.im/slamdata/matryoshka/wHhj/image.png)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:11:48.399Z
@Jacoby6000 does this thing https://apple.stackexchange.com/questions/230422/type-lambda-%CE%BB-on-a-mac

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T20:12:28.683Z
“greek small letter lamda”

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:25:41.873Z
So.. For my specific case, I have

```scala
  trait ~>[F[_], G[_]] {
    def apply[A](fa: F[A]): G[A]
  }

  type Algebra[F[_[_], _], E[_]] = F[E, ?] ~> E

  implicit class FixedQueryCata[T](val fixed: FixedQuery[T]) extends AnyVal {
    def cata[A[_]](f: Algebra[Query[T, ?[_], ?], A]): HFix[Query[T, ?[_], ?], ?] ~> A = {

    }
  }
```

Which means I have to define something that will, when given an Algebra, generate a natural transformation that will convert a recursive HFix'd AST to just an AST containing some values?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:26:57.644Z
I'm defining it in a funky way (inside that implicit class) just for while I learn.. It's easier for me to wrap my head around it this way

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:38:17.926Z
Ahhhh and to do that, I'm now having to pattern match on a higher order ADT, which is where the scalac patches come in

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:38:19.119Z
I see now.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:38:30.418Z
unfortunate :/ 

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T20:39:01.462Z
Bingo.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:40:11.253Z
This error is bizarre though
```
[error] /Users/jacobbarber/projects/scoobie/core/src/main/scala/scoobie/ast.scala:150: pattern var p in method apply is never used; `p@_' suppresses this warning
[error]         case p @ Parameter(_) => f(p)
```
My implementation is probably wrong, but that's definitely the wrong message

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:41:15.229Z
I'm going to try to implement it how I think it should be done, regardless of scalac's yelling

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-30T20:45:48.854Z
That is *so* bizarre.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-30T20:46:03.287Z
In all of the GADT breakage cases I know of I could make one or two casts to fix it

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:50:02.912Z
I guess that's technically a warning.. Here's everything that was wrong when I got that:

```
[error] /Users/jacobbarber/projects/scoobie/core/src/main/scala/scoobie/ast.scala:150: type mismatch;
[error]  found   : scoobie.ast.Parameter[T,[A(in class HFix)]scoobie.ast.HFix[[β$13$[_$5], γ$14$]scoobie.ast.Query[T,β$13$,γ$14$],A(in class HFix)]]
[error]  required: scoobie.ast.Query[T,A(in method cata),U]
[error]         case p @ Parameter(_) => f(p)
[error]                                    ^
[info] scoobie.ast.Parameter[T,[A(in class HFix)]scoobie.ast.HFix[[β$13$[_$5], γ$14$]scoobie.ast.Query[T,β$13$,γ$14$],A(in class HFix)]] <: scoobie.ast.Query[T,A(in method cata),U]?
[info]   A(in method cata)[_] <: scoobie.ast.HFix[[β$13$[_$5], γ$14$]scoobie.ast.Query[T,β$13$,γ$14$],_]?
[info]   false
[info] false
[error] /Users/jacobbarber/projects/scoobie/core/src/main/scala/scoobie/ast.scala:150: pattern var p in method apply is never used; `p@_' suppresses this warning
[error]         case p @ Parameter(_) => f(p)
[error]              ^
[error] two errors found
```

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-30T20:50:28.528Z
I think the first is probably the most helpful error... the second error is `false`?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:50:56.528Z
That other stuff is logs coming from the compiler AST. i think some debugging stuff.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:51:07.262Z
at least, the `info` parts are

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:51:48.387Z
I think it's because of 
```
        "-explaintypes",                     // Explain type errors in more detail.
```

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T21:00:10.327Z
@sellout am I on the right track here?
```scala
  implicit class FixedQueryCata[T](val fixed: FixedQuery[T]) extends AnyVal {
    def cata[A[_]](f: Algebra[Query[T, ?[_], ?], A]): HFix[Query[T, ?[_], ?], ?] ~> A = new (HFix[Query[T, ?[_], ?], ?] ~> A) {
      def apply[U](fixed: HFix[Query[T, ?[_], ?], U] ): A[U] = fixed.unfix match {
        // leaves
        case param @ Parameter(_) => f(param)
        case path @ PathValue(_)  => f(path)
        case _: Null[_, _]        => Null[T, U]

        case ValueBinOp(l, r, op) => f(ValueBinOp(l.cata(f), r.cata(f), op))
        case Function(path, args) => f(Function(path, args.map(_.cata(f))))
      }
    }
  }
```

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T21:01:40.004Z
feels right.. because each parent node needs to recursively call cata(f) until you've gotten to the leaf nodes, and then you apply the algebra to the leaf nodes to transofrm them.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T21:06:39.733Z
@Jacoby6000 Yes, except that the apply will be an algebra, so it should look like ```

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T21:07:22.551Z
```
def apply[U](fa: Query[T, A, U] ): A[U] = fa match {
```

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T21:08:34.319Z
Wait … maybe I’m missing what you’re doing here … what is `f`?

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T21:08:50.026Z
Because it looks like `f` is your algebra.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T21:09:00.337Z
yeah it is.. Sorry, I left out some context

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T21:09:04.596Z
editing..

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T21:09:13.476Z
Ok, so this apply is really your `cata`?

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T21:09:20.072Z
But specialized on this particular functor.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T21:09:45.922Z
I updated it.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T21:09:52.844Z
If you define an `HFunctor` class, like in the Matryoshka PR, then you can make an instance of it for Query, and then define a generic cata.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-30T21:10:11.375Z
Then HTraverse for cataM ;)

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T21:10:13.854Z
But yeah, that looks like a specialized cata.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T21:10:19.956Z
@edmundnoble Indeed :D

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T21:10:56.128Z
For now I'm just trying to wrap my head around things.. As long as the concrete case looks good, I suppose I'll go and work on HFunctor.  That'll break it down a bit and probably make it simpler, too

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T21:11:13.313Z
I'm just glad that my stuff is properly fitting together :D

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T21:19:28.783Z
It seems like to get the fullest out of this, I'd really just end up re-implementing large chunks of the mutu branch of matryoshka. lol

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T21:26:24.160Z
Yeah …

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T21:26:43.462Z
I mean, you can probably clone that branch, use it on Scala 2.11.7, and be fine.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T21:37:02.000Z
Ehhhh.... I'm trying to write a lib with crossbuilds. that'd be less than ideal.  :/ 

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T21:38:02.499Z
Yeah :/

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T21:38:31.110Z
Well, if there's some way I can help with the scalac issues, I'd love to.  Obviously I'm not expert here though :sweat_smile: 

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T21:42:12.640Z
Yeah, if you see that issue (I forget the number off the top of my head), Jason has like his own branch with an alternative approach that may be solid already – it at least needs more tests.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T21:43:11.981Z
I'll see what I can do :)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T21:44:57.554Z
Do the slamdata people get to work with stuff like this all the time?

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T21:47:27.004Z
Yup.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T21:47:56.004Z
One of my coworkers just submitted a change to Matryoshka today. Hard to find a place in our code that doesn’t depend on it.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T21:49:48.720Z
That's awesome :o I'm glad that  there are places out there that work like this.  

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T22:01:12.072Z
I'm building retronym's branch. I'll see if my usecase works with his stuff. If it does/doesn't, I'll look in to building a minimal failing case scenario that I can try to work in to a PR for his branch or something... I've never messed with scalac directly though, so I'm not sure how all that works.  I'll dig through the contributors guide and whatnot and see what I can do


                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T22:21:15.378Z
@Jacoby6000 Awesome, thanks!

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T22:21:39.503Z
Yeah, and Miles has a great post called something like “from zero to Scalac PR in an hour”

                                                                                                                                                      Tristan Lohman @gatorcse@2017-06-30T22:50:30.853Z
Know of any companies in the Seattle area that are doing this stuff?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T23:00:07.029Z
Or the Portland area?


                                                                                                                                                      Torsten Scholak @tscholak@2017-06-30T23:13:57.870Z
Or the Toronto or Montreal area?

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T23:15:07.897Z
😂

                                                                                                                                                      andy scott @andyscott@2017-06-30T23:22:59.325Z
@gatorcse 47 degrees is in Seattle

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-01T03:17:40.296Z
@sellout, so.. if I am able to get this to work using either your fork, or retronyms, is it binary compatible with other 2.12 versions? Meaning, could I build it and then publish it to maven and let users just use regular ol 2.12.2?   This is of course assuming I have a dsl in place for building the queries, so they don't have to worry about that. 

                                                                                                                                                      Greg Pfeil @sellout@2017-07-01T04:47:32.198Z
@Jacoby6000 Yeah, it should be.

                                                                                                                                                      Zainab Ali @zainab-ali@2017-07-01T19:20:19.313Z
Does anyone know of a recursion scheme that picks out a trail in a recursive structure, from top down?  A bit like this:
```scala
  def extract[F[_], A](f: Fix[F] => Fix[F] Either A)(fix: Fix[F]): A = {
    f(fix) match {
      case Left(fix) => extract(f)(fix)
      case Right(a) => a
    }
  }
```

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-01T21:09:10.330Z
I'm not an expert.. but I think you're looking for a catamorphism (or cata). Given a Fix[F] and an algebra F[A] => A, you'll get back an A. 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-01T21:10:55.480Z
cata will traverse your tree til if finds leaf nodes, and then it'll run your algebra on it recursively to collapse the structure. 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-01T21:11:09.935Z
I think this will not fit into the shape of cata

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-01T21:11:13.646Z
@zainab-ali ^

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-01T21:12:06.361Z
This is a sort of "explore" function, which follows a "path" made of "steps" formed by `f` calls and returns the value at the end

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-01T21:13:28.111Z
I think you'd need a semigroup or something to do that, right? Because there could be multiple leafs. 

                                                                                                                                                      Zainab Ali @zainab-ali@2017-07-01T21:13:56.268Z
The key difference between this and a `cata` is that it starts at the root, and only follows a single path.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-01T21:15:18.214Z
@Jacoby6000 It returns only a single value, not a leaf

                                                                                                                                                      Zainab Ali @zainab-ali@2017-07-01T21:16:25.307Z
Is there a recursion scheme for this kind of thing?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-01T21:23:03.288Z
Not AFAIK, no.

                                                                                                                                                      Zainab Ali @zainab-ali@2017-07-01T21:25:47.289Z
I guess it doesn't need use any properties of recursion schemes whatsoever:
```scala
  def explore[B, A](f: B => B Either A)(b: B): A =
    f(b) match {
      case Left(b) => explore(f)(b)
      case Right(a) => a
    }
```
`f` then needs to know it's acting on `Fix[F]`, but I can't see a way of implementing it without that knowledge anyway

                                                                                                                                                      Zainab Ali @zainab-ali@2017-07-01T21:26:52.809Z
thanks for the insights though :smiley: 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-01T21:27:21.107Z
I think this may be related to some kind of comonad

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-01T21:27:31.969Z
Or monad

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-01T21:27:50.921Z
Oh LOL

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-01T21:27:54.230Z
This is just `tailrec`

                                                                                                                                                      Zainab Ali @zainab-ali@2017-07-01T21:28:03.886Z
yep

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-01T21:28:12.353Z
Like `tailrecM` without the `M`

                                                                                                                                                      Zainab Ali @zainab-ali@2017-07-01T21:33:49.957Z
So I can just use `tailRecM` with `Id` and it does the trick.  Thanks!

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-01T21:34:18.373Z
Welcome :)

                                                                                                                                                      Zainab Ali @zainab-ali@2017-07-01T21:42:38.304Z
@sellout any thoughts on having an examples module #86?  I have a ton of examples gathering dust

                                                                                                                                                      Greg Pfeil @sellout@2017-07-01T22:56:08.017Z
@zainab-ali Oh, I thought there was discussion on that … maybe just in my head. Yes, please!

                                                                                                                                                      Greg Pfeil @sellout@2017-07-01T23:00:57.265Z
@zainab-ali That looks like an anamorphism with `A / ?` as the functor. Aka, a partial function – check Matryoshka.instances.fixedpoint

                                                                                                                                                      Greg Pfeil @sellout@2017-07-01T23:01:30.792Z
`A \/ ?`

                                                                                                                                                      Zainab Ali @zainab-ali@2017-07-02T12:04:36.744Z
So I can use `Either` to represent a path through the data structure, with `Right` representing another node and `Left` being the leaf, and then extract the final value by folding over it.  The whole thing reduces to a hylo:
```scala
  def explore: Fix[F] => A Either Fix[F] = ???
  def merge: A Either A => A = ???
  val a: A = fix.hylo(merge, explore)
```
That's a really interesting way of thinking about it

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-03T16:44:41.263Z
@Jacoby6000 decides he's going to hang around this channel to lurk. Lots of cool stuff to learn


                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-03T16:54:20.214Z
Hm.. I just realized something. 

@sellout, if I have a mutually recursive AST, and I write a catamorphism for it, I end up with a natural transformation. From there, how do I fold it in to a single value?  I think I'm caught up in type-soup and I'm having trouble processing how that natural transformation is useful in the context of a mutually recursive AST.


                                                                                                                                                      Greg Pfeil @sellout@2017-07-03T18:49:36.947Z
@Jacoby6000 You can use `Const` – `F ~> Const[Int, ?]`. There should be an example in the tests on that branch somewhere.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-03T19:05:39.366Z
:thumbsup: 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-04T04:53:49.684Z
-snip-
I went and commented on the scala PR.

                                                                                                                                                      andy scott @andyscott@2017-07-06T05:16:24.205Z
I have a parser implemented as an unfold with using a `CoalgebraM`. I’d like to augment the parser to include some meta information— such as source positions. I was thinking of unfolding into `Cofree` instead of `Fix`. Is this a good idea? And if so, what’s the appropriate way to ammend my code?

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T14:09:53.516Z
@andyscott Yeah, that sounds right … You basically want to change from `F` to `EnvT[Pos, F, ?]` as your functor.

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T14:10:27.167Z
There is a `Birecursive.Aux[Cofree[F, A], EnvT[A, F, ?]]` instance.

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T14:12:11.861Z
@Jacoby6000 Thanks for the PR comment.

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T14:12:53.303Z
`EnvT` is in `matryoshka.patterns`.

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:04:48.476Z
@sellout awesome, thanks!

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:04:52.645Z
Naturally I have more questions, though.

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T16:05:02.432Z
@andyscott I was hoping you would :D

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:06:13.636Z
How can I go from `Fix[NodeF]` to `Cofree[NodeF, …]` where I have some constant value I want to assign to every node?

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:06:59.121Z
After that I need to select nodes of a certain type an then assign values similar to how you’ve implemented `attributedTopDown`. Except I just want to attribute down from certain nodes in the tree.

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:07:25.638Z
(Also I got the above code working from last night, but I wound up staying up a bit late :) )

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T16:08:03.990Z
for the first case: `_.transCata[Cofree[F, A]](fa => EnvT((constantVal, fa)))`

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-06T16:09:08.530Z
When building a DSL for a mutually recursive AST, should the DSL return values of `A[I]` or `AST[A[_], I]`?

                                                                                                                                                      Emily Pillmore @emilypi@2017-07-06T16:09:10.269Z
Hello, Matryoshka

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T16:11:04.960Z
@Jacoby6000 I _think_ the latter, and then you would fold that down to `A[I]`, for some `A` like `Id` or `Const[B, ?]`

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-06T16:11:45.819Z
So then the DSL should also accept values of `AST[A[_], I]`, and then do the intermediate lifting required during compositions?

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T16:12:03.509Z
@Jacoby6000 You can see the latest discussion in #typelevel/general for some related stuff.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-06T16:12:08.876Z
Oh okay :)

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T16:12:11.682Z
@Jacoby6000 I might need to see some code. I’m not sure.

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:12:54.204Z
@sellout How can I translplant all the matroyshka knowledge from your brain into mine?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-06T16:15:29.436Z
@sellout [this file](https://github.com/Jacoby6000/scoobie/blob/feature/%2340-adjust-ast-to-support-fixpoint/plugins/dsl/mild-sql-dsl/src/main/scala/scoobie/snacks/mild/sql/primitives.scala) is pretty small and represents what I'm currently doing pretty well.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-06T16:15:48.519Z
I still need to reduce the footprint of my binary operators, I know :p

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-06T16:17:49.586Z
`QueryProjection[T, A[_]]` `QueryComparison[T, A[_]]` and `QueryValue[T, A[_]]` are type aliases for `Query[T, A, IDX]`

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T16:23:23.892Z
@andyscott Hah! That is something I am trying to figure out. Maybe I can get @davegurnell to write a book on it …

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:24:36.561Z
Ha, yeah :).

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:25:13.085Z
I’m amazed at how impossibly hard this stuff is (maybe because it’s kinda hard, and encoding in Scala is ugly). But once you “get it”, it isn’t too bad.

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:25:39.326Z
The problem for me right now is I only “get” …. 15% or some other arbitrarily low percent of the codebase.

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T16:26:13.375Z
Yeah, encoding in Scala is tough, but getting better. (and there are other compiler features that will help – like interspersed implicit lists, etc.)

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T16:27:56.129Z
I really need to sit down and write some better introductory material, because you can see that basically everything in `Recursive` is defined in terms of `cata` – it’s just a matter of pushing around the extra {co}monads, and `cata` is done in terms of `hylo` by default. So you only need to understand `hylo` and the rest is free ;) It took me two years to get to that point, though 😆

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:28:34.749Z
On that note— what is the reasoning for `[Co|Bi][Rr]ecursiveT` transformers? The source mentions inference I believe, but doesn’t say much more than that.

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:30:00.929Z
It took me a 9 hour plane ride to understand the fundamentals. Maybe half of that I spent rewriting Matroshka from scratch (for Cats, making sure I understood everything) and the other half watching dumb movies as relief for my brain.

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T16:30:38.879Z
Oh, they’re not really “transformers”, that is just an abuse of the `T` suffix. Basically, `Recursive` used to be defined the way `RecursiveT` is now, and it basically allows Quasar to keep faking mutual recursion the way we have been for ages. We could fake it differently and get rid of the `*T` types, but I’d rather just get the mutual recursion stuff in and then use that for real.

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T16:30:54.121Z
So, all the `T` stuff should be ignored by other users, basically.

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:30:56.832Z
And the whole time I was reflecting back to your talk at the TL Summit in Philly.

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:31:40.024Z
Aah. And uhh… an example of my partial knowledge: what’s mutual recursion in the context of matroyshoka?

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T16:32:55.007Z
@andyscott Heh, I regret a bunch of the shortcuts I took in that talk. Was done to fit stuff in slides, but I’ve been talking people back from the fake syntax of it ever since.

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:33:37.688Z
Don’t worry, I _didn’t understand anything you said_ during that talk because I was just getting started down the FP route.

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:34:31.291Z
I should have been sitting in a basic FP talk and instead I was learning about general recursion :)

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:36:53.947Z
Returning to my question from earlier, how can I statefully top down modify the attributes of certain branches of my tree? I can select the first node in a branch just by the type of that node.

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:39:23.647Z
`attributeTopDownM` the whole tree? or is there a way to select branches before switching to some other fold?

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T16:39:40.604Z
@andyscott So, mutual recursion lets you restrict which nodes can occur in which locations in a tree. E.g., expressions vs statements, so you can have a type like
```scala
sealed abstract class AST[A[_], I]
final case class BinOp[A](op: Operator, l: A[Expression], r: A[Expression]) extends AST[A, Expression]
final case class Assign[A](name: String, A[Expression]) extends A[Statement]
final case class Block[A](stmts: List[A[Statement]], result: A[Expression]) extends A[Expression]
```

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T16:40:01.472Z
So now you have a type index that indicates whether expressions or statements can occur at each point in the tree.

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:40:10.747Z
Aah

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:40:30.049Z
That makes sense

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T16:42:51.734Z
Ok, so yeah … I would do `attributeTopDownM` over the whole tree, probably – and you might even just start that with your `Fix[F]` and have `case _ => constantValue` rather than first converting to Cofree, then updating some attributes.

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T16:45:56.412Z
`attributeTopDown` isn’t something I use, so I’m curious to see your use case. It predates Matryoshka as a recursion scheme library. I.e., I wonder if after I see what you do with it, there might be a different approach using more of the “core” transformations.

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:46:15.626Z
I can explain my exact use case and show you all the code

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T16:46:36.895Z
And you can see that even `attributeTopDown` is defined using `ana`.

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:46:58.091Z
Yep

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:51:25.000Z
Semi related— is there any chance I could get you to comment on https://github.com/frees-io/iota/issues/37 regarding proper attribution of the Matroyshka based source code we’ve put together?

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T17:04:03.229Z
@andyscott Oh, thanks for mentioning. I missed that.

                                                                                                                                                      andy scott @andyscott@2017-07-06T17:10:24.108Z
Yep. Thanks @sellout.

                                                                                                                                                      andy scott @andyscott@2017-07-06T17:10:52.512Z
Everything I’ve been asking about in here has been related to work for that project :)

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T17:15:08.793Z
@andyscott Well, that’s exciting :D

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-08T19:23:19.645Z
Woo! got my DSL working. Thanks for all your help so far :) Tonight I'm going to re-build the interpreters to use `cata`, and then I'm going to work on trying to extend the AST to be able to include more nodes. I think the shape for that would be... 

```scala
type MutuCoproduct[F[_[_], _], G[_[_], _]] = {
  type 𝝀[A[_], I] = HFix[F[A, I] :+: G[A, I]]
}
```

or something... The `F[A, I] :+: G[A, I]` is wrong for sure. I think that the mutu branch includes `+^+` which might be what I need.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-08T19:38:00.654Z
And then the new AST nodes would extend their respective indexes from the base tree, and then create any new indexes that are necessary. 

                                                                                                                                                      Greg Pfeil @sellout@2017-07-08T19:39:44.545Z
Yeah, I think `^+^` is what you want. As a mnemonic, I just used `^` instead of other delimiters to mean “higher-kinded”. And glad to hear you’ve actually gotten this working :D

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-08T19:46:51.582Z
It's still a POC til the interpreters work and I can successfully extend the AST p

I'm not completely happy with the way that the DSL works, because it's got far too many implicit conversions, and the current state of retronyms branch forced me to make some architectural sacrifices (easy to undo once things are more stable). Only the core had to be built with the experimental version so far though, and that's good. I suspect my interpreters (things invoking cata) might also need it. I'm gonna try to fix the compiler myself if it causes me much more grief :sweat_smile: 

                                                                                                                                                      Greg Pfeil @sellout@2017-07-08T19:49:34.563Z
@Jacoby6000 I’ll have some time around the 16th to put some work into my Scala PRs again.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-08T21:54:04.972Z
I'll still probably poke around. I'd like to get to the point where I can at least comprehend what scalac is doing :) 

                                                                                                                                                      Greg Pfeil @sellout@2017-07-08T21:55:18.873Z
@Jacoby6000 I definitely won’t complain if you get it sorted out before I get to it 😄

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-09T00:22:30.635Z
@sellout I've started to write my interpreter, and I'm not sure this is right.

```scala
  def interpretQuery[I, F[_[_[_], _], _]]
                    (query: F[Query[T, ?[_], ?], I])
                    (implicit queryFunctor: HFunctor[QueryAST[T]#of],
                              hRecursive: HRecursive[F]): T = {
```
That's my signature.  What I don't like about it, is I don't know how I'll be able to compose this interpreters with other interpreters (interpreters for the extended versions of the AST), because I have `F[Query[...], I]`. Unless there is some way to go from `F[A ^+^ B] => F[A]`, I'm not sure how this would work.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-09T00:29:33.645Z
Ah I see. I've gotten too specific too quickly.  In the tests, you combine an algebra for both types to create an `Algebra[A ^+^ B]`

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-09T00:29:54.785Z
This is so cool. Just a week ago I said this was all madness but it's making sense :D 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-09T00:46:38.602Z
so really then... my `interpretQuery` function should be called something like `ansiAlgebra`, and it should return an `Algebra[Query[T, ?[_], ?], A]`

                                                                                                                                                      Greg Pfeil @sellout@2017-07-09T01:58:50.903Z
@Jacoby6000 👍🏾 Right on the money.

                                                                                                                                                      Greg Pfeil @sellout@2017-07-09T02:00:06.913Z
@Jacoby6000 An early mistake I made often was to immediately define `def foo = _.cata(fooAlgebra)`, rather than just exposing the algebra and composing it like that.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-09T02:31:54.586Z
sounds like the mistake I was about to make :sweat_smile: Good to know that I'm not the only one who went there first.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-09T04:12:29.923Z
Alright, ran in to a fun problem. 

So.. in SQL, whenever you have a `NULL`, you gotta do `IS NULL` rather than `= NULL`.  The way I was handling this before was checking if the left or right side of an equals comparison contained null, and then generating the query accordingly..  So the structure 
```
BinOp(left, Null, Equal)
```
would become
```
$left IS NULL
```
Now, those constructs are gone because cata works from the bottom up.  Do I just accept some parameter to define null equality so that I can do `if(isNull(right))` ? Or is there a way to define a `cata` algebra whose behavior changes based on nested constructs? 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-09T04:13:15.654Z
Bust out `para`?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-09T04:13:25.808Z
@Jacoby6000 looks up para

                                                                                                                                                      Greg Pfeil @sellout@2017-07-09T04:14:08.356Z
Yeah, funny, this same conversation came up at SlamData this week.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-09T04:14:55.920Z
Why can't I ever have new and unique problems?! :laughing: 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-09T04:15:10.971Z
Is `para` the way you guys started handling it?

                                                                                                                                                      Greg Pfeil @sellout@2017-07-09T04:17:13.540Z
Basically, if pattern-matching on your representation is easy enough, you can still use cata and just match on the already-folded bits. But if not, then para lets you match on the original AST while you fold.

                                                                                                                                                      Greg Pfeil @sellout@2017-07-09T04:17:33.416Z
So we do it both ways, depending on the structures.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-09T04:18:48.560Z
ah. my case needs para then. I'm assuming I'll need to define some sort of unapply for anything with an `HProject` instance?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-09T04:19:27.160Z
Since I don't know anything about my output representation (besides that it's semigroupal)

                                                                                                                                                      Greg Pfeil @sellout@2017-07-09T04:19:27.918Z
Ah, yes.

                                                                                                                                                      Greg Pfeil @sellout@2017-07-09T04:19:52.747Z
There is one (called `Embed`) in the non-mutu part of Matryoshka.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-09T04:20:04.471Z
:thumbsup: 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-09T04:21:16.830Z
So then.. from what I understand, para will provide you with a tuple where one side is the node currently being "visited", and the other side is the cata result from the underlying nodes?

                                                                                                                                                      Greg Pfeil @sellout@2017-07-09T04:21:57.945Z
Yep.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-09T04:22:21.197Z
Woo! This stuff gets more intuitive as you learn more of it.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-09T04:58:59.713Z
Ah dang.  I think that the compiler stuff starts to fall apart whenever you try to build the GAlgebra for it.  

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-09T05:43:36.493Z
Interestingly enough, it seems like this stuff actually didn't work even before the regression that occured. In 2.11.8, you can't define `cata`.

```
[error] /home/jbarber/projects/scoobie/core/src/main/scala/scoobie/ast.scala:216: no type parameters for method hmap: (f: scoobie.cata.~>[F,G])scoobie.cata.~>[[β$11$]F[F,β$11$],[β$12$]F[G,β$12$]] exist so that it can be applied to arguments (scoobie.cata.~>[[β$14$]T[F,β$14$],A])
[error]  --- because ---
[error] argument expression's type is not compatible with formal parameter type;
[error]  found   : scoobie.cata.~>[[β$14$]T[F,β$14$],A]
[error]  required: scoobie.cata.~>[?F,?G]
[error]           φ(HFunctor[F].hmap(cata(φ))(hproject(t)))
[error]                         ^
```

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-09T07:18:23.925Z
Yeah, definitely stuck now. Going to have to dig in to the compiler.
```
[error] /home/jbarber/projects/scoobie/plugins/dialects/ansi-sql/src/main/scala/scoobie/doobie/doo/ansi/SqlInterpreter.scala:85: constructor cannot be instantiated to expected type;
[error]  found   : scoobie.ast.Parameter[T(in class Parameter),A(in class Parameter)]
[error]  required: scoobie.ast.Query[T(in class SqlInterpreter),[β$1$](F[[A(in type of)[_], I]scoobie.ast.Query[T(in class SqlInterpreter),A(in type of),I],β$1$], T(in class SqlInterpreter)),?I1] where type ?I1 <: I (this is a GADT skolem)
[error]           case Parameter(param) => param
[error]                ^
```

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-10T19:52:43.175Z
When learning to hack on the compiler, I managed to learn how to write type lambdas.   Dear lord, thank the Heavens for Kind Projector. 

                                                                                                                                                      Greg Pfeil @sellout@2017-07-10T20:19:02.907Z
@Jacoby6000 Right?

                                                                                                                                                      Valentin Kasas @vil1@2017-07-12T08:40:20.193Z
Hi there,  before I proceed with dumber questions, here's a slightly interesting one : is there a `para <<< ana` kind of refold ?

                                                                                                                                                      Greg Pfeil @sellout@2017-07-12T13:45:48.123Z
@vil1 I don't think so, but you can use ghylo with Id and (T, ?) as N and W.

                                                                                                                                                      Greg Pfeil @sellout@2017-07-12T13:46:35.792Z
The others are basically just aliases to that, for combinations that have been given a name.

                                                                                                                                                      Valentin Kasas @vil1@2017-07-12T13:46:40.781Z
Oh yeah, of course

                                                                                                                                                      Valentin Kasas @vil1@2017-07-12T13:49:50.738Z
(modulo some `DistributiveLaw`s)

                                                                                                                                                      Valentin Kasas @vil1@2017-07-12T13:58:51.715Z
That's what I love with this channel : I spend literally hours trying to achieve something on my own, then @sellout or @edmundnoble comes up saying "you should look at XYZ" and it seems so obvious  *afterwards*

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-12T17:32:36.834Z
@vil1 preach

                                                                                                                                                      Emily Pillmore @emilypi@2017-07-12T19:47:17.070Z
Muh troeskuh

                                                                                                                                                      Valentin Kasas @vil1@2017-07-12T21:16:48.682Z
@vil1 is not sure what that meant

                                                                                                                                                      Valentin Kasas @vil1@2017-07-12T21:21:15.230Z
I'm not sure I can provide a `DistributiveLaw[(T, ?),F]` either, so I might keep my current two-step solution for the moment

                                                                                                                                                      Greg Pfeil @sellout@2017-07-12T21:21:38.255Z
@vil1 Why not? `distPara` and `distAna` already exist.

                                                                                                                                                      Valentin Kasas @vil1@2017-07-12T21:22:22.807Z
Hu

                                                                                                                                                      Valentin Kasas @vil1@2017-07-12T21:22:56.672Z
@vil1 frantically opens his laptop again

                                                                                                                                                      Valentin Kasas @vil1@2017-07-12T21:35:39.743Z
ok, so now this is like magic and I'll have a hard time sleeping on this

                                                                                                                                                      Valentin Kasas @vil1@2017-07-12T21:35:46.037Z
but thanks a lot !

                                                                                                                                                      Torsten Scholak @tscholak@2017-07-18T16:48:39.763Z
@sellout removed as member?

                                                                                                                                                      Torsten Scholak @tscholak@2017-07-18T16:55:53.505Z
https://twitter.com/sellout/status/885927741895450625

                                                                                                                                                      Torsten Scholak @tscholak@2017-07-18T16:56:10.802Z
I guess it's the truth

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-18T16:59:35.694Z
In this day and age, it's a wonder somebody as brilliant as Greg stayed at the same place for 3 years :p 

                                                                                                                                                      Sumedh Mungee @smungee@2017-07-19T01:12:00.263Z
I recently updated matryoshka from 0.19.0 and 0.21.0, and some code that used to work earlier is now broken. Here's the error

                                                                                                                                                      Sumedh Mungee @smungee@2017-07-19T01:13:42.092Z
```
SyntaxParserTree.scala:206: matryoshka.repeatedly.type does not take parameters
[error]     def translation[T[_[_]]: RecursiveT: CorecursiveT]: Expr[T[Expr]] ⇒ Expr[T[Expr]] = repeatedly(translationOpt)
```
`translationOpt` has the signature:
```
     def translationOpt[T](implicit TR: Recursive.Aux[T, Expr],
                           TC: Corecursive.Aux[T, Expr]): Expr[T] ⇒ Option[Expr[T]] = {
```

                                                                                                                                                      Sumedh Mungee @smungee@2017-07-19T01:14:04.216Z
this code works fine in 0.19.0 ^^

                                                                                                                                                      Greg Pfeil @sellout@2017-07-19T02:15:03.237Z
@smungee Ah yes – `repeatedly` changed – it now requires a type parameter for the result type, like `repeatedly[matryoshka.instances.fixedpoint.Partial[Expr[T[Expr]]]](translationOpt)`, and since it’s now properly defined as a partial function, you’ll need to either propagate that `Partial`, or use `.unsafePerformSync` on it.

                                                                                                                                                      Greg Pfeil @sellout@2017-07-19T02:18:15.613Z
Also, in v0.21, `Birecursive` should now work, so you might want to do
```scala
def translation[T](implicit T: Birecursive[T, Expr]): Expr[T] ⇒ Expr[T] =
  repeatedly[Partial[Expr[T]]](translationOpt).unsafePerformSync
```
and
```scala
def translationOpt[T](implicit T: Birecursive.Aux[T, Expr]): Expr[T] ⇒ Option[Expr[T]] = {
```

                                                                                                                                                      Sumedh Mungee @smungee@2017-07-19T04:41:03.117Z
@sellout Great, adding the `Partial` types worked. WIll also try `Birecursive`

                                                                                                                                                      Greg Pfeil @sellout@2017-07-19T04:41:16.575Z
Nice!

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:07:14.518Z
If you have a bijection on two separate ASTs, what kinds of things can you do with that?  I can imagine maybe using CoFree to annotate one of the ASTs with what its bijection with the other might be, but that only makes sense if your nodes basically have a 1:1 mapping. What kind of morphisms would you use to go between the two? 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:07:32.176Z
And how might you map the relevant parts of each AST to the nodes of the other?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:07:53.835Z
s/map/associate/g

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:17:12.081Z
A bijection means a 1:1 mapping, if I'm not mistaken.

                                                                                                                                                      Emily Pillmore @emilypi@2017-07-28T07:17:19.410Z
You probably can't do much with it, since working with a bijection would forget the structure of the syntax tree. Interested to see what others have to say

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:17:44.914Z
Bijections can't forget structure because they're invertible though, I thought

                                                                                                                                                      Emily Pillmore @emilypi@2017-07-28T07:18:14.196Z
But it's a bijection on the set of nodes, he said

                                                                                                                                                      Emily Pillmore @emilypi@2017-07-28T07:18:29.791Z
Bijections don't in general preserve structure. Isomorphisms do.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:18:56.492Z
Yeah, this definitely isn't an isomorphism, but bijection might be the wrong word. 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:19:23.772Z
Right but what structure? That'd be a property shared in common in a category you're working in

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:19:31.180Z
What do you mean by bijection then?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:19:34.404Z
Maybe give a type to it?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:20:52.654Z
I'm working on building some ASTs related to music. The AST representing a score isn't super useful to a computer, because it's all absolutes and that's painful to work with. So I'm going to make a thing to convert it in to relative pitches, where it's easier to work with. Also, chords go from being some number of independent nodes to being a single node which represents the shape of the chord.  Stuff like that 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:21:38.116Z
What do the branches in your AST look like?

                                                                                                                                                      Emily Pillmore @emilypi@2017-07-28T07:21:49.531Z
I'm sleep, will check in in the morning

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:22:14.738Z
I haven't fully developed the AST yet. I just started tonight and got in bed a few minutes ago. Right now I'm just interested in the theory 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:24:18.135Z
I think what I'm getting at is, I have two completely unique structures, however, given one you can derive the other. 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:25:50.958Z
In a recursive AST, what would the morphism between these two structures be called?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:26:12.023Z
Well, can you go the other way?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:26:45.475Z
Yes 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:27:30.411Z
Well, you have to be provided one extra piece of information (the key) but yeah given that input you can. 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:27:47.244Z
So I think what @emilypi was getting at is that if you have an isomorphism that given a single node of one AST gives you a single node of another AST that would be a... maybe isomorphism in some category, or perhaps that's the bijection

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:27:56.716Z
But overall you have an isomorphism between AST types

                                                                                                                                                      Emily Pillmore @emilypi@2017-07-28T07:29:52.867Z
it'd just end up looking like a graph automorphism i'd think

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:31:30.980Z
It's a tree, though, is there a more specific category to work in?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:31:42.334Z
Also how could it be an automorphism when it's between two different types?

                                                                                                                                                      Emily Pillmore @emilypi@2017-07-28T07:32:46.108Z
wouldn't it just be Ast -> Ast?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:33:16.527Z
From what I understand it's more a information-rich AST on the relative pitch side

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:33:23.826Z
"chords go from being some number of independent nodes to being a single node which represents the shape of the chord"

                                                                                                                                                      Emily Pillmore @emilypi@2017-07-28T07:34:14.090Z
ah shit i missed that

                                                                                                                                                      Emily Pillmore @emilypi@2017-07-28T07:35:01.406Z
I'll give it some more thought tomorrow

                                                                                                                                                      Emily Pillmore @emilypi@2017-07-28T07:35:03.205Z
it's 3am

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:35:12.851Z
`Fix[AST1] -> (key, Fix[AST2])` and `(key, Fix[AST2]) -> Fix[AST1]`

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:35:38.585Z
(On mobile so my symbols and whatnot aren't accurate because I cba)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:35:47.580Z
Yeah I mean you could consider the key and AST2 as separate, but I don't know how useful that is

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:36:24.167Z
You could annotate an AST1 with lazily evaluated subtrees converted to AST2 or something

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:36:31.995Z
The implication is that you can provide any key given the relative AST and generate an absolute AST for that key :p

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:36:40.377Z
Actually no you can't, because the key requires the entire tree if I'm not mistaken

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:37:51.611Z
Not sure what you mean by that 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:38:08.159Z
Well, do you need to see the whole absolute AST to find its key?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:39:04.855Z
Oh, no. Only the initial key matters, and that can be found in a node that should be almost surface level 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:39:35.938Z
Ohhh I see. Then yes, you could if you like annotate every node's subtrees with the subtrees converted to relative

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:39:48.594Z
But I don't see how that would be useful really

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:40:26.732Z
I mean you also have a `(AST1[Fix[AST2]], key) => Fix[AST2]`, no?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:40:27.085Z
:thumbsup: so then.. I guess this really is just a function A => B and B => A? 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:41:21.123Z
Did you mean to put AST2 inside of the AST1 Fix?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:41:31.322Z
Yeah.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:41:35.608Z
I'm not sure if I'll be able to do that yet. Intuition tells me no 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:41:53.497Z
Like you can flatten a single layer of `AST1` into the `Fix[AST2]`, given the surface key

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:42:24.803Z
Oh nvm turn that all around, that wouldn't make sense

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:43:06.021Z
`(AST2[Fix[AST1]], key) => Fix[AST1]`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:43:28.177Z
You can flatten a single layer of `AST2` because it contains enough info to give you multiple layers of `AST1`

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:43:36.960Z
Ahhhhhhhhh yes. 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:44:37.448Z
Yeah so this I think reifies the notion of "viewing" an `AST2` tree as a bunch of `AST1` layers lazily, without performing the conversion upfront

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:45:00.565Z
Lazily assuming you're not using `Fix`

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:45:13.867Z
So CoFree then? 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:45:16.738Z
You can look at currying things with `transCata` for inspiration if interested here

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:45:19.586Z
No, Mu or Nu

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:45:24.463Z
Ah okay :h 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:45:51.229Z
Cofree is just mu or nu over a pattern functor, I just don't yet understand the difference enough

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:46:25.717Z
I think you're supposed to use one to express folds and another for unfolds, and then annihilate them together and what executes at runtime is effectively a hylomorphism

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:46:32.189Z
But I would need... some verification there ;)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:46:46.617Z
:thumbsup: thanks for the insight! I'm sure I'll be back with more whenever I've solidified the ASTs. For now I need to sleep.  

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:46:54.906Z
I got some things to go look up in the morning 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:46:57.652Z
Yeah jeez me too

                                                                                                                                                      Juan Pablo Santos @jsantos17@2017-07-29T00:46:31.322Z
For each scheme that take a GAlgebra, could we have  an equivalent scheme that takes an ElgotAlgebra instead?

                                                                                                                                                      Greg Pfeil @sellout@2017-07-29T08:07:58.505Z
@jsantos17 Yep. They've been added on-demand, but they’re basically all specializations of elgotCata/elgotAna.

                                                                                                                                                      Sumedh Mungee @smungee@2017-07-31T23:44:50.321Z
Are there any examples on using trampolining with `cata`?

                                                                                                                                                      Sumedh Mungee @smungee@2017-07-31T23:45:13.458Z
Like for this test case, if I had a really huge tree, how would I make it work with trampolining?

                                                                                                                                                      Sumedh Mungee @smungee@2017-07-31T23:45:43.294Z
```
       val exp = mul(mul(num(12), mul(num(12), num(8))), mul(num(12), num(8)))
       exp.cata(height) must equal(3)
```


                                                                                                                                                      Greg Pfeil @sellout@2017-08-01T06:53:53.473Z
  @smungee I think you want to use `cataM` with `Free.Trampoline` as the M.

                                                                                                                                                      Sumedh Mungee @smungee@2017-08-01T07:07:19.600Z
@sellout Yeah I sort of guessed that, but I wasn't able to get the types to work.. Two main issues 1) cataM needs an AlgebraM, and I'm not sure how I can "lift" height to be an AlgebraM. and 2) What's the second type parameter to cataM (I guessed it should be the A that the Algebra produces, in this case height produces an Int?)

                                                                                                                                                      Sumedh Mungee @smungee@2017-08-01T07:09:48.994Z
like I tried ```exp.cataM[Trampoline, Int](f => Trampoline.delay(f.height))``` but that's obviously wrong

                                                                                                                                                      Greg Pfeil @sellout@2017-08-01T07:48:29.214Z
@smungee It’s a little awkward because of the way `height` is defined, but I think `exp.cataM(f => Trampoline.delay(height[Expr](f)))` (maybe you also need the type annotation on `cataM`, but I’d hope not).

                                                                                                                                                      Greg Pfeil @sellout@2017-08-01T07:50:07.480Z
If `height` was `def height[F[_]: Foldable](fa: F[Int]): Int`, you could do `Trampoline.delay(height(f))`, but then there might be other contexts that need to explicitly convert `height` to a function.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-01T11:06:11.474Z
Hmm, does that mean that matryoshka's schemes are stack-safe iff the target effect is stack-safe? 

                                                                                                                                                      Greg Pfeil @sellout@2017-08-01T12:16:28.242Z
@tscholak Now that you mention it … I think that it’s not. I’ve only poked at it a little, but I think you actually need to do something like `exp.hyloM(f => Trampoline.delay(height(f)), a => Trampoline.delay(a.project))` for it to be stack-safe. It was something I was waiting on the switch to Cats/Eval to experiment with more.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-01T12:36:18.615Z
Interesting, ok. Ok, cataM is implemented in terms of cata and not hyloM

                                                                                                                                                      Greg Pfeil @sellout@2017-08-01T12:37:11.813Z
Yeah … and even if it was using `hyloM`, I think it still wouldn’t work, because `Monad[Trampoline].pure` isn’t `delay` … is it?

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-01T12:37:42.388Z
Hmmm

                                                                                                                                                      Greg Pfeil @sellout@2017-08-01T12:38:39.242Z
And the reason it’s implemented in terms of `cata` is so that a Recursive instance (e.g., `Mu`) can override `cata` and that override cascades over all (well, most) folds.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-01T12:41:12.422Z
I think the monad instance for trampoline is that of Free

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-01T12:41:22.552Z
So no, it's not delay

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-01T12:50:45.164Z
This overriding is an interesting choice

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-01T12:51:25.996Z
Since cata is not the most general fold

                                                                                                                                                      Greg Pfeil @sellout@2017-08-01T12:54:21.605Z
You mean rather than say defining `gElgotCataM` and then defining all the other folds by supplying `Id` for some of the types?

                                                                                                                                                      Greg Pfeil @sellout@2017-08-01T12:54:44.101Z
But `cata` is just as general as that, it turns out.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-01T13:03:25.507Z
Hah

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-01T13:03:28.535Z
Ok

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-01T14:16:40.498Z
@sellout I guess this is witnessed by code which I could check out, but is there any deeper reason for it? for cata being as general as gElgotCataM and other monstrosities?

                                                                                                                                                      Juan Pablo Santos @jsantos17@2017-08-01T16:19:59.053Z
@sellout so we could have a function to convert a ElgotAlgebra to GAlgebra? Same with AlgebraicGTransform? I mostly ask because I'm finding the elgot generalized algebras much nicer to work than with generalized algebras. But that might be because I'm still learning Matryoshka

                                                                                                                                                      Juan Pablo Santos @jsantos17@2017-08-01T16:58:22.497Z
Also, wouldn't the be an alternative to adding more elgot generalized schemes on demand?

                                                                                                                                                      Greg Pfeil @sellout@2017-08-01T21:38:19.762Z
@jsantos17 Well, you could, but it probably wouldn’t work the way you were hoping. First, you could lower `ElgotAlgebra[W, F, A]` to `Algebra[F, W[F[A]]]`, then that could be treated as a `GAlgebra[Id, F, W[F[A]]]` … so yes – you could pass something to `gcata` that would behave the same as what you were originally passing to `elgotCata`, but it loses clarity along the way.

                                                                                                                                                      Greg Pfeil @sellout@2017-08-01T21:40:12.446Z
If we had better inference, I’d toss away most of the specialized things like `_.elgotFutu(alg)` and just use `_.elgotCata(distFutu, arg)`, but in Scala that leads to way too many type annotations (at least so far).

                                                                                                                                                      Sumedh Mungee @smungee@2017-08-02T07:24:44.649Z
@sellout Thanks!! Getting closer to getting `cataM` working with `Trampoline`, but I can't figure out the type annotations for `cataM`

                                                                                                                                                      Sumedh Mungee @smungee@2017-08-02T07:25:40.530Z
```
[error] missing parameter type
[error]         x.cataM(f ⇒ Trampoline.delay(height[Expr](f)))
[error]                 ^
```


                                                                                                                                                      Sumedh Mungee @smungee@2017-08-02T07:26:21.356Z
`cataM[Trampoline, Int]` doesn't work.. Nor does `cataM[Trampoline, Algebra[Expr, Int]]`..

                                                                                                                                                      Greg Pfeil @sellout@2017-08-02T08:03:08.289Z
@smungee What error do you get with `[Trampoline, Int]`? Same one?

                                                                                                                                                      Sumedh Mungee @smungee@2017-08-02T08:05:55.281Z
```
[error]  found   : Expr[Int]
[error]  required: scalaz.Foldable[Expr]
[error]         x.cataM[Trampoline, Int](f ⇒ Trampoline.delay(height[Expr](f)))
[error]                                                                    ^
```


                                                                                                                                                      Sumedh Mungee @smungee@2017-08-02T08:06:28.982Z
x is a `Fix[Expr]`

                                                                                                                                                      Greg Pfeil @sellout@2017-08-02T08:06:50.552Z
@smungee Ah, sorry! I think you need `height[Expr].apply(f)`.

                                                                                                                                                      Greg Pfeil @sellout@2017-08-02T08:08:54.581Z
I should really change the definition of `height`. That constraint really gets in the way if you try to call `height` directly.

                                                                                                                                                      Sumedh Mungee @smungee@2017-08-02T08:09:55.625Z
aha! that compiles, but i still see the stack overflow error.. 

                                                                                                                                                      Sumedh Mungee @smungee@2017-08-02T08:10:18.447Z
do I need `hyloM`? You said earlier, `I think you actually need to do something like exp.hyloM(f => Trampoline.delay(height(f)), a => Trampoline.delay(a.project)) for it to be stack-safe."`

                                                                                                                                                      Greg Pfeil @sellout@2017-08-02T08:10:51.741Z
@smungee Yeah, I think that’s necessary 😕

                                                                                                                                                      Sumedh Mungee @smungee@2017-08-02T08:11:01.368Z
ok let me try that

                                                                                                                                                      Sumedh Mungee @smungee@2017-08-02T08:11:22.797Z
i have a tree of height 1900, which wont really happen in production, but I'm trying to understand trampolining :)

                                                                                                                                                      Sumedh Mungee @smungee@2017-08-02T08:15:01.859Z
yep, `hyloM` works great! 

                                                                                                                                                      Greg Pfeil @sellout@2017-08-02T08:31:12.659Z
Yeah, as @tscholak said, I was hoping to figure out how to make it so “schemes are stack-safe iff the target effect is stack-safe,” but I’m not sure how to make that happen, so there may need to be trampolines everywhere, or a parallel set of folds (hey, what’s one more dimension of duplication?), or something. Or Trampoline/Eval needs to delay on `pure` …

                                                                                                                                                      Edmund Noble @edmundnoble@2017-08-02T13:55:00.770Z
I think this is a bit of a fundamental issue, unfortunately. `ContT` is in the exact same situation.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-08-02T14:01:09.768Z
So a parallel set of folds would likely be the solution.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-08-02T14:01:56.010Z
I also think there may be a stack-machine variant of `cata` which works if you have a `Traverse` instance as well and is more efficient than trampolining.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-02T17:39:27.188Z
btw @sellout I took a few swings at working on scala/scala#5744, but I'm just not familiar enough with the enigma that is scalac. Most I achieved was figuring out where the changes need to happen. I just don't really know what those changes are, and  scalac is nigh on impossible to debug..  Add to that the fact that no IDEs seem to understand it, and without getting really familiar with the codebase I'm surprised anybody gets anything done in there.  lol

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-03T22:21:23.750Z
Does Matryoshka provide anything for something like a stateful unfold?

                                                                                                                                                      Greg Pfeil @sellout@2017-08-03T22:23:38.070Z
@Jacoby6000 You can do `_.anaM[T](coalg: A => State[B, F[A]])`

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-03T22:23:57.577Z
Yup, that looks about right

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-03T22:24:00.618Z
thanks!

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-03T23:38:56.185Z
Hm... So will I just call this function and pass in the new state after every iteration? I think I may have misunderstood

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-03T23:39:38.682Z
```scala
  def unfoldMidi[F[_[_]], G[_]: Traverse](file: MidiFile)(implicit corecursive: Corecursive.Aux[F[Segment], G]) =
    file.anaM[F[Segment]].apply[State[UnfoldState, ?], G]{ file =>
      ??
    }
```
I got that so far



                                                                                                                                                      Edmund Noble @edmundnoble@2017-08-04T04:37:17.253Z
Your coalgebra will return a stateful computation (with `CoalgebraM` specialized to `State`, `A => S => (S, F[A])`)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-08-04T04:37:20.990Z
They're all chained together

                                                                                                                                                      Edmund Noble @edmundnoble@2017-08-08T12:33:19.538Z
Does it make sense to come up with a version of `Mu` and `Nu` with `para` and `apo` as primitives, like a Scott encoding?

                                                                                                                                                      Greg Pfeil @sellout@2017-08-08T12:36:18.994Z
@edmundnoble Yeah, that seems totally reasonable.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T17:47:47.150Z
Can somebody explain to me how an unfold works? I get `cata` and how an `F[A] => A` becomes useful given a recursive `F[G[F]]`, but I can't understand how an `A => F[A]` comes to be a recursive `F[G[F]]`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-08-10T18:44:54.414Z
`F[G[F]]` isn't how it looks though, it's `F[F[F[F[F[F[......]]]]]`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-08-10T18:45:02.256Z
`hylo` can be used to implement either

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T19:08:46.709Z
@edmundnoble don't you have to have a Fix or CoFree or Free or something between each of those Fs?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T19:08:52.093Z
that's why I used F[G[F]]

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T19:09:04.110Z
In any case, I still don't understand how that works :p 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-08-10T19:17:09.665Z
Oh right

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T19:20:10.599Z
@Jacoby6000 But you usually talk about `G[F]`, not `F[G[F]]` (where G is some fixed-point operator). So, when you think about `cata(alg: F[A] => A): G[F] => A`, that can be implemented as `hylo(alg, project)` (and is, in Matryoshka).

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T19:20:38.100Z
:thumbsup: 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T19:20:43.385Z
got it

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T19:20:52.507Z
So, `project` is actually a `Coalgebra[F, G[F]]` itself (`G[F] => F[G[F]]`)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T19:21:07.629Z
interesting

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T19:21:19.076Z
(coalgebra being what you use for an unfold)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T19:22:02.011Z
right... I'm trying to write an `anaM` right now, and I'm struggling to understand how `A => M[G[A]]` can wind up yielding `M[F[G]]`

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T19:22:05.575Z
Another example in Matryoshka is `Nat.fromInt: Coalgebra[Option, Int]` (ok, that’s a little more complicated because of negative numbers)

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T19:22:56.222Z
So, when you do 3.ana(Nat.fromInt), it’s actually `3.hylo(embed, Nat.fromInt)`

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T19:23:35.224Z
guess I should go try to figure out how hylo works then :p 

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T19:23:36.060Z
So, first, it does `3 => Some(2)`, then `2 => Some(1)` then `1 => Some(0)`, then `0 => None`

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T19:24:07.156Z
So you end up with a tree that looks like `Some(Some(Some(None)))` at the “halfway point” of the hylomorphism.

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T19:24:49.072Z
Then, you walk back up the tree, using `embed` at each step, so then you have `Fix(Some(Fix(Some(Fix(Some(Fix(None)))))))`

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T19:24:59.256Z
Which is `Fix[Option]`

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T19:26:45.009Z
Ah... So it takes what's inside and then performs the hylo again on whatever was inside the previous result

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T19:26:55.957Z
Yeah.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T19:27:50.604Z
hm... maybe I won't need `State` like i had thought, then. As long as I can do `F[CurrentUnfoldState]` basically.

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T19:28:25.090Z
And you end up with a tree _without_ any fixed point operator in it yet – but you can’t actually return it, because you might have some branches that are of type `F[F[Nothing]]` and others that are `F[F[F[F[Nothing]]]]` … or something like that, so you gotta use the fixed-point operator to unify all those trees of arbitrary depth before you actually return from each nested call.

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T19:28:58.160Z
@Jacoby6000 Yeah, that sounds likely.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T19:29:05.884Z
right, that part actually makes sense to me.. It was the building of a tree from an `A => F[A]` that confused me

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T19:35:04.014Z
@sellout is there some kind of convention for dealing with errors during unfolds?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T19:35:33.747Z
I'm guessing you'd use an anaM with an Either

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T19:35:44.275Z
@Jacoby6000 Yeah, exactly.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T19:35:51.530Z
:thumbsup: 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T19:37:04.433Z
Cool. This seems simple enough, now that I get it :) 

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T19:37:16.051Z
💃🏽

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T20:27:09.150Z
Oh boy. this is harder than I thought.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T20:27:12.927Z
think I actually need an apo

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T20:27:38.668Z
I need to be able to partially construct branches and then finish them off later when I get more information

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T20:27:53.972Z
also, i need to continue building partially constructed branches before they're complete

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T20:28:06.665Z
@Jacoby6000 You mean you want to emit more than one node at a time, but still have `A`s nested at some depth?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T20:30:14.382Z
No.. for example, I'll see a `NoteOn` event for a note, say.. `F`. Then after awhile, I'll receive another `NoteOn` event for `G`. A while later, I get a `NoteOff` for `G` and then after that I get `NoteOff` for `F`. I can't fully construct my node for `F`, until after the note off event, but I need that to come before the `G`. However, my `G` was ready to be fully constructed before my `F` was.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T20:31:15.535Z
Maybe I need an intermediate tree or soemthing

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T20:33:19.556Z
I'm trying to turn [this](https://github.com/Jacoby6000/maestro-midi/blob/master/core/src/main/scala/com/github/jacoby6000/maestro/midi/data.scala) in to [this](https://github.com/Jacoby6000/music-asts/blob/master/src/main/scala/com/github/jacoby6000/music/core/ast.scala)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T20:33:54.357Z
The big problem is that, one is a format which is just a stream of events with delta times, and the other has no notion of time.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T20:56:24.308Z
I was hoping an unfold would do what I want, but it seems that I was wrong :p 

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T20:57:22.082Z
@Jacoby6000 So, you have a MIDI stream, and are turning it into an AST. You see `NoteOn(F)`, and create an (incomplete) `LeafNote(F)`, then you see `NoteOn(G)` and actually want to _replace_ the `LeafNote(F)` with `Together(LeafNote(F), LeafNote(G))` (with still-undefined durations for those leaves)?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T20:57:50.328Z
essentially 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T20:57:51.797Z
yeah

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T20:57:53.604Z
Ok, cool.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T20:58:51.429Z
if they have different delta times for note on, then it'd be Sequence(LeafNote(F), LeafNote(G)) but still the same idea.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T20:59:26.680Z
I'm not 100% sure my music AST is sufficient yet.  This is the ultimate test.  lol

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T20:59:30.467Z
I mean, I don’t have a solution for you off the top of my head, but at least I see what you’re trying to do. And is this actually a _stream_ – I.e, you’re trying to handle it as it’s coming in, or are you post-processing some complete sequence of events?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T20:59:46.701Z
No, I've got a file that i've already parsed and I have all the data.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T20:59:53.275Z
so post-processing

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T21:00:05.099Z
streaming comes..... maybe never. lol

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T21:02:00.648Z
Ok, so one thing that is an option in that case is handling it as a _fold_ (which I’m not sure fixes any of your issues, but maybe gives you a new direction to think in) – a List is already recursive, so you could fold from the end of the list, making a completely subtree from each node.

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T21:02:31.353Z
But I don’t think that particularly helps either, since you start with a NoteOff and still might run into other things before you have a NoteOn for the same note.

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T21:03:34.454Z
Definitely having some other intermediate representation is an option – doing something that creates a new List with atomic note values first.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T21:03:54.033Z
yeah, that's what I'm starting to lean toward..

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T21:04:51.812Z
Not that Matryoshka supports it (yet), but once you try dealing with streaming, there is an approach called a metamorphism that might be a good fit.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T21:06:00.761Z
If i annotate those with delta times, then I can filter the List[Event] to remove all note on/off events, and then I can build a single track using `(List[(Note, Time)], List[Event]) => Music[(List[(Note, Time)], List[Event])]`, where i trim off notes and events as i go.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T21:06:34.356Z
I didn't even know you could fold partially complete structures.  that's cool

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T21:07:10.757Z
I used to work on https://opusmodus.com, so this kind of problem _should_ be in my wheelhouse.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T21:07:31.171Z
OOoooooH looks cool

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T21:07:56.716Z
that's basically what I'm trying to make, but with scala DSLs 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T21:07:58.343Z
 \>.>

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T21:08:39.606Z
had no idea it existed

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T21:11:12.139Z
Well, there is definitely a lot of odd stuff in that project that I’m pretty sure I would do very differently now (and if I had had more control). But it was the brainchild of this composer and it has a lot of that Lispy DWYM magic that should have been transformed away into a nice AST but never was.

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T21:11:17.093Z
But it was pretty fun, though.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-14T08:35:08.729Z
I've got a basic question. I have a structure, `T[F]` (with `T[_[_]]` a fixed point type and `F[_]` a pattern functor), that I want to transform into another structure, `T[G]`.  The rules for that transformation are such that the number of layers in the resulting structure are not necessarily the same as in the source structure. Furthermore, some rules require the inspection of not only one layer of the original structure, but two. Right now I don't know how to proceed. I'd be glad if I could get some advice.

                                                                                                                                                      Greg Pfeil @sellout@2017-08-14T11:32:12.699Z
@tscholak It might depend on a few other things, but I think you might want `futu` or `transFutu(f: F[T[F]] => G[Free[G, T[F]]]): T[F] => T[G]`.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-14T12:53:32.002Z
Ah, I'll look into that. What I need to do does neither fit the algebra nor the coalgebra pattern

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-14T12:53:36.497Z
Thank you

                                                                                                                                                      Greg Pfeil @sellout@2017-08-14T12:59:42.700Z
Something that tripped me up a lot early on is that you can treat your tree as an “atomic” type. I.e., the `A` in `A => F[A]` (or its dual). In your case, the “number of layers are not the same” (`Free`) aspect of `futu` sounds the most critical. I.e., it sounds like you can traverse the structure in either direction, and if you traverse top-down, you get the “require the inspection of not only one layer” (`histo`) aspect for free.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-14T13:00:24.404Z
would it help if I told you what the rules are?

                                                                                                                                                      Greg Pfeil @sellout@2017-08-14T13:00:44.952Z
This is one of those cases where I wonder if metamorphisms would help, but that isn’t part of Matryoshka’s general approach, and I haven’t put much work into figuring out how to implement them yet.

                                                                                                                                                      Greg Pfeil @sellout@2017-08-14T13:01:15.887Z
@tscholak I couldn’t hurt …

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-14T13:01:51.413Z
`F` contains something called `PartialF`...

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-14T13:01:57.642Z
`G` doesn't.

                                                                                                                                                      Greg Pfeil @sellout@2017-08-14T13:02:08.930Z
I should try to make up some decision tree for finding schemes that work in different situations :D

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-14T13:03:06.700Z
the function that I'm looking for will evaluate `PartialF` by calculating the partial derivative of the structure (an expression tree) with respect to a variable.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-14T13:04:43.452Z
that means I have to implement things like the product rule 

                                                                                                                                                      Greg Pfeil @sellout@2017-08-14T13:09:19.218Z
So, you’d rewrite something like `PartialF(x, ProdF(a, b))` to `ProdF(PartialF(x, a), PartialF(x, b))`?

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-14T13:11:02.327Z
not quite, but yeah: `SumF(ProdF(a, PartialF(x, b)), ProdF(PartialF(x, a), b))`

                                                                                                                                                      Greg Pfeil @sellout@2017-08-14T13:11:34.499Z
Ah, right … /me brushes up on calc.

                                                                                                                                                      Greg Pfeil @sellout@2017-08-14T13:12:48.440Z
Anyway, yeah, this idea of pushing something toward the leaves fits well with the unfolding of `futu`, so I think that’s probably a good bet.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-14T13:13:09.284Z
so, yeah, I have to match on two layers, e.g. `PartialF(x, ProdF(a, b))`, and I'll produce one or more layers 

                                                                                                                                                      Greg Pfeil @sellout@2017-08-14T13:13:49.259Z
Yeah, `futu` works as long as you produce _at least_ one layer of `G` at each step.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-14T13:14:27.118Z
do I need the variant with `Free`?

                                                                                                                                                      Greg Pfeil @sellout@2017-08-14T13:14:56.463Z
I think `transFutu` is a good fit (just a bit of sugar over `futu` to make writing the coalgebra easier).

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-14T13:16:20.539Z
cool, that is great advice

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-14T13:16:22.828Z
:)

                                                                                                                                                      Greg Pfeil @sellout@2017-08-14T13:17:46.746Z
Yeah – futu implies Free. In the product case, you would return something like `Free.roll(SumF(Free.roll(ProdF(Free.point(a), Free.point(PartialF(x, b).embed))), Free.roll(ProdF(Free.point(PartialF(x, a).embed), Free.point(b))))` (the syntax there isn’t the nicest, but basically you `roll` the `G` nodes and `point` the remaining `T[F]` on each branch).

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-14T13:19:12.593Z
yes! that should work. I'm happy :D

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-14T13:28:33.185Z
does futu go bottom up or top down?

                                                                                                                                                      Greg Pfeil @sellout@2017-08-14T13:28:39.114Z
top-down

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-14T13:29:25.480Z
thx

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-14T18:35:09.614Z
@sellout I still haven't been able to come up with a solution i'm happy with (in my music thing). Would it be easier if I turned my MidiFile datastructure in to a recursive one somehow and then did a refold?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-14T18:51:23.328Z
Eh. Gonna make a recursive intermediate format.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-14T18:55:13.027Z
@Jacoby6000 https://www.youtube.com/watch?v=WWaLxFIVX1s

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-14T18:55:50.354Z
That's about how I feel on the inside :sweat_smile: 

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-14T18:56:09.039Z
good.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-14T18:58:58.000Z
I wonder if this is normal... You take a size-efficient yet un-principled binary format, parse it in to a concrete structure, and then fold the concrete structure in to a principled structure, then you can work with it.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-14T19:59:49.641Z
Am I reading Futu correctly in that it requires your AST to have a Traverse instance?

                                                                                                                                                      Greg Pfeil @sellout@2017-08-14T20:04:49.122Z
@Jacoby6000 Hrmm, are you looking at `futuM`?

                                                                                                                                                      Greg Pfeil @sellout@2017-08-14T20:05:41.567Z
Only the monadic {un}folds should require Traverse (but, in general, having a Traverse instance for your AST is reasonable).

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-14T20:06:34.776Z
Ah yeah, it is futuM

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-14T20:07:02.659Z
And futu will always end up as a Free encoding, right?

                                                                                                                                                      Greg Pfeil @sellout@2017-08-14T20:08:28.738Z
Well, when the unfold is complete, you should have just `T[G]`, the Free will be gone. It’s only needed for the individual steps of the algebra.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-14T20:10:18.236Z
Alright that's what I figured... for some reason I thought that I didn't see a spot for a recursive encoding in the signature.. when I get back to the computer I'll squint at it some more. I'm sure I'll get it now that I understand the Traverse part. 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-08-14T20:14:06.145Z
Are there any recursion schemes that require a monad instance for your pattern functor?

                                                                                                                                                      Greg Pfeil @sellout@2017-08-14T20:15:05.492Z
I don’t think so.

                                                                                                                                                      Tristan Lohman @gatorcse@2017-08-15T00:00:04.976Z
I’m reading the Matryoshka README (again). Is it possible to get a simple explanation/examples of the differences between `Fix`/`Mu`/`Nu`?

                                                                                                                                                      Greg Pfeil @sellout@2017-08-15T03:23:09.083Z
@gatorcse `Fix` is the “direct” recursive definition – which makes it good for explanation, but not stack-safe or anything. `Nu` is lazy, so useful for potentially-infinite structures (streams, etc.), and `Mu` is the dual of `Nu`. In Scala, `Fix` is similar to `Mu`, in Haskell, `Fix` is similar to `Nu`, because it uses the default evaluation (eager/lazy) of the language.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-15T18:02:24.797Z
@sellout dunno if you're interested, but Dotty seems to support mutually recursive ASTs. 

https://scastie.scala-lang.org/XbNz8MJ5TFycluoKETPl1A

This explodes if you make the index covariant, though.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-15T18:03:30.853Z
(I've found covariant indexes to be helpful... but evil)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-15T18:04:42.360Z
I was able to get around the variance by defining an invariant type alias when building the HFunctor.. Like 

```
  type InvariantExpr[A[_], I] = Expr[A, I]
```

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-15T18:04:55.970Z
Since the HFunctor can't change the Index type, this works out perfectly.

                                                                                                                                                      Greg Pfeil @sellout@2017-08-15T19:06:13.505Z
@Jacoby6000 nice. I should try out dotty at some point.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-15T19:31:22.356Z
Be careful if you do.  I definitely wouldn't say it's at a stable point. Especially with this kind of generic programming... A lot of times compiler errors manifest as unhelpful exceptions. 

                                                                                                                                                      Tristan Lohman @gatorcse@2017-08-15T21:48:34.777Z
@sellout Thanks!

                                                                                                                                                      Greg Pfeil @sellout@2017-08-15T22:26:24.790Z
@gatorcse Please feel free to ask more if that doesn’t clear it up. Like, I definitely missed mentioning that `Nu` and `Mu` are defined without recursion.

                                                                                                                                                      Tristan Lohman @gatorcse@2017-08-15T22:40:08.640Z
Combining your comment with some Stuff-I-Read-On-The-Internet, specifically about `Mu` representing a fold, and `Nu` representing an unfold: `Mu` represents data that can be reduced to a value (folded), where `Nu` represents a value that can build up a data structure, sort of like a generator. In Scala, they can actually share a lot of behavior due to typey stuff, but that is there base semantic definition.

                                                                                                                                                      Tristan Lohman @gatorcse@2017-08-15T22:40:15.928Z
Feel free to red pen all over that

                                                                                                                                                      Tristan Lohman @gatorcse@2017-08-15T23:04:21.951Z
Also, to any newcomers reading the above statement, that is a wildly uneducated guess describing my current understanding of the data types, not an authoratative explanation by any means

                                                                                                                                                      Greg Pfeil @sellout@2017-08-15T23:04:57.497Z
@gatorcse Sounds good to me 👍🏾

                                                                                                                                                      Tristan Lohman @gatorcse@2017-08-15T23:06:01.223Z
woah, really?

                                                                                                                                                      Tristan Lohman @gatorcse@2017-08-15T23:07:05.954Z
@gatorcse Unlocked achievement: Initial grokking of Matryoshka

                                                                                                                                                      Greg Pfeil @sellout@2017-08-15T23:07:24.779Z
👏🏽

                                                                                                                                                      Tristan Lohman @gatorcse@2017-08-15T23:07:55.917Z
Anyone experiment with implementing event-sourcing as `Mu`?

                                                                                                                                                      Tristan Lohman @gatorcse@2017-08-15T23:08:57.804Z
I feel like there’s a nice parallel with event-sourcing/cqrs, with the event stream represented as a recursive data structure, and various algebras/folds as the queries

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-16T08:55:07.751Z
Hi, I've been looking into the quasar source code, specifically the Json/EJson parts. My ADTs have a similar makeup; there's a common ADT, `CommonF`, and an extension to it, `ExtensionF`. I'd like to write explicit open recursive expressions with the coproduct of these types, `ExprF`, `type ExprF[A] = Coproduct[ExtensionF, CommonF, A]`. Currently, this leads to very awkward code, because I have to wrap `ExtensionF` instances in `TC.embed(Coproduct.left[CommonF](e))` and `CommonF` instances in  `TC.embed(Coproduct.right[ExtensionF](e))`, where `TC: Corecursive.Aux[T, ExprF]`. Is there a better way?

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-16T08:58:03.616Z
I was hoping that there's some implicit magic that I can pull into scope because I have the following injections:
```scala
val commonExprF: CommonF :<: ExprF = implicitly[CommonF :<: ExprF]
val extendedExprF: ExtensionF :<: ExprF = implicitly[ExtensionF :<: ExprF]
```

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-16T09:13:31.554Z
hm, I just saw that, in quasar, there are these helper functions:
```scala
    def fromCommon[T](c: Common[T])(implicit T: Corecursive.Aux[T, EJson]): T =
      CommonEJson(c).embed

    def fromExt[T](e: Extension[T])(implicit T: Corecursive.Aux[T, EJson]): T =
      ExtEJson(e).embed
```

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-16T09:22:57.924Z
yay, making these `implicit def`s is a win

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-16T10:35:18.244Z
@sellout I have a first prototype now, https://github.com/tscholak/autodiff

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-16T10:35:47.269Z
it works, but only for first derivatives.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-16T10:36:35.185Z
that's because the futu goes from top to bottom. if it were the bottom-up, the current code would already work for higher order derivatives.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-16T10:37:16.604Z
I don't see a way of fixing this without introducing recursion in the `CoalgebraicGTransform`, https://github.com/tscholak/autodiff/blob/master/src/main/scala/autodiff/evaluate.scala#L12

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-16T10:53:26.981Z
as you can see, the case `PartialF(PartialF(...))` is not handled yet

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-16T11:04:48.644Z
neither is `PartialF(PartialF(PartialF(...)))` ;)

                                                                                                                                                      Greg Pfeil @sellout@2017-08-16T16:36:31.675Z
@tscholak I'm on the beach, but I would recommend defining your algebra as a type class with instances for Common, Extension, and Coproduct[F, G, ?].

                                                                                                                                                      Greg Pfeil @sellout@2017-08-16T16:36:44.121Z
More later 😄

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-17T06:51:59.934Z
:D

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-19T12:53:54.816Z
:palm_tree: 

                                                                                                                                                      Greg Pfeil @sellout@2017-08-19T14:05:57.971Z
@tscholak Sorry, back 😃

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-19T14:06:25.942Z
np, I'm on vacation, too :D

                                                                                                                                                      Greg Pfeil @sellout@2017-08-19T14:07:13.519Z
So, anyway, doing that type class approach makes it so you can use the algebra for arbitrary coproducts, as long as each component has an instance. And Matryoshka (or _something_) should allow the Coproduct instance to be derived (as is commonly done in Haskell).

                                                                                                                                                      Greg Pfeil @sellout@2017-08-19T14:09:16.535Z
So yeah, `PartialF(PartialF` is a problem … not sure this is a great solution, but if you could collapse `PartialF(x, PartialF(y, z))` to `PartialF(List(x, y), z)` …

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-19T14:09:41.370Z
yeah, so that's the thing. I can't do that.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-19T14:11:01.834Z
or, rather, let's say, that just postpones the problem

                                                                                                                                                      Greg Pfeil @sellout@2017-08-19T14:12:39.989Z
So, in the abstract, what is the solution?

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-19T14:13:14.523Z
I'd like to go bottom up

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-19T14:14:17.643Z
I think that bottom-up will also have some advantages for other things like `SimplifyF` that simplifies expressions

                                                                                                                                                      Greg Pfeil @sellout@2017-08-19T14:14:21.287Z
That’s possible … but then what do you do about `Partial(Prod`?

                                                                                                                                                      Greg Pfeil @sellout@2017-08-19T14:14:38.712Z
Because you’ll hit the `Prod` first, not knowing that it has a `Partial` outside it.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-19T14:14:53.003Z
I'd leave the `Prod` as is in that case

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-19T14:15:15.175Z
when I hit the `Partial` eventually, I'll do something about it

                                                                                                                                                      Greg Pfeil @sellout@2017-08-19T14:16:19.505Z
And what if there is no `Partial` outside it?

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-19T14:16:27.377Z
it stays

                                                                                                                                                      Greg Pfeil @sellout@2017-08-19T14:16:41.355Z
Oh! So Prod is in both the input and output functor.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-19T14:16:44.115Z
the futu trafo is just supposed to eliminate the Partials from the tree

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-19T14:16:48.425Z
yes :)

                                                                                                                                                      Greg Pfeil @sellout@2017-08-19T14:17:05.650Z
Right, right … so the algebra on the Common part is basically identity.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-19T14:18:31.773Z
correct

                                                                                                                                                      Greg Pfeil @sellout@2017-08-19T14:22:07.383Z
Ok, cool. So yeah, you can do bottom-up, make a type class with an operation of type `Transform[Fix[Common], F, Common]`, and the instance where `F = Common` is literally identity.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-19T14:23:09.811Z
hmm, can I still emit more than one layer with `Transform`? I'm using `Free.roll` right now to do that.

                                                                                                                                                      Greg Pfeil @sellout@2017-08-19T14:23:54.479Z
Yep – just have to use `.embed` instead of `Free.roll`.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-19T14:25:04.663Z
cool. I'll try that.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-19T14:25:07.871Z
:D

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-19T14:25:10.100Z
thank you!

                                                                                                                                                      Greg Pfeil @sellout@2017-08-19T14:25:19.163Z
And you could generalize it further,  with `Transform[Fix[G], F, G] ` given `Common :<: G`. That becomes useful if you have a bunch of variations of the Coproduct and you only care about a subset of it (as Quasar often does).

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-19T14:25:53.927Z
oh, I guess I can have a look there to get an idea

                                                                                                                                                      Greg Pfeil @sellout@2017-08-19T14:26:31.905Z
Yeah … although Quasar often has extra complexity, so clarity is lost. Need more examples.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-19T14:28:38.776Z
hm, I'm happy to provide what I'm working on right now as an example.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-19T14:29:04.870Z
it's just a little exercise

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-19T14:32:19.626Z
I'd like to add "backpropagation" to the code eventually. That means I need an algebra / a cata with memoization.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-26T19:31:19.975Z
@sellout you were right. doing it bottom-up introduced other problems which were even greater than what I had encountered with the top-down approach.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-26T19:33:10.001Z
I ended up exploring the collapse idea, `PartialF(PartialF(...))` to `PartialF(..., 2)`, which works elegantly.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-26T19:34:08.806Z
thank you for suggesting it. I didn't believe initially that it would be helpful, but it is :)

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-26T19:35:39.355Z
it's here, https://github.com/tscholak/autodiff/blob/09e607a9f4dff9560e493ed1e3eaaa9877594e1c/src/main/scala/autodiff/manipulate.scala#L41, if you want to check it out

                                                                                                                                                      Greg Pfeil @sellout@2017-08-26T20:21:16.454Z
@tscholak 💯

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:00:31.240Z
Hi there

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:01:25.612Z
Is there a way/scheme that allows one to simultaneously got through two recursive structures (provided the two share a similar … structure) ?

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:03:12.601Z
concretely, I have a spark `Row` + `StructType` and I'd want to transform that to an avro `GenericRecord` +  `Schema`

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:04:33.870Z
I have internal functors `DataF[A]` and `SchemaF[A]` that mimic `Row/GenericRecord` and `StructType/Schema` respectively

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:05:59.504Z
more precisely, I have a `Birecursive.Aux[Schema, SchemaF]` and a `Birecursive.Aux[StructType, SchemaF]` instances

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T13:06:10.157Z
Hi Valentin, is this related to your old gist, https://gist.github.com/vil1/493c6c5cc8d236d7dcf42a350fe5ab7a ?

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:06:27.171Z
definitely ^^

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:06:57.801Z
although things might have evolved a bit since then, but that's part of the same adventure

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:09:26.585Z
(BTW, we're about to ship some of that to production!)

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T13:17:22.657Z
I don't have an answer for you, @sellout might know immediately. but let me think about this quickly...

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:18:07.953Z
my first idea was something like `type DataWithSchema[A] = (DataF[A], SchemaF[A])`

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:18:22.062Z
but that doesn't look very tractable

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T13:18:27.781Z
so your rows are adhering to the structtype, but they may not fully specify it implicitly

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:19:36.024Z
that's it, thanks to these super-javay-untyped API, I cannot decompose a `Row` (or a `GenericRecord`) without the aid of the associated schema

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T13:19:38.111Z
same for the avro records, they adhere to the schema, but their "hull" defines the schema in general only partially

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T13:20:04.181Z
oh, I see

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:20:08.008Z
that's it

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:20:34.503Z
a `Row` is basically an `Array[Any]`

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T13:20:43.162Z
ah, right, it's totally untyped

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T13:24:39.451Z
ok

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T13:26:38.622Z
you can unfold the structtype into a recursive structure in the SchemaF and then fold that structure into the avro schema

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T13:28:04.956Z
and, in principle, this transformation should contain all you need to transform any spark row into an avro record

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:30:32.679Z
struttype -> schemaf -> avro is done already

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:30:59.222Z
but row and genericrecord are different flavours of untyped

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:31:26.568Z
so i need to convert them as well

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T13:31:48.595Z
yeah, so the first, the coalgebra for structtype -> schemaf, is there a way to use it to define the row -> dataf coalgebra?

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T13:34:21.451Z
I want a whiteboard ^_^

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:34:34.762Z
^^

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:35:33.855Z
well there is no way to (properly) define the row -> dataf coalg, because you need a schema (structtype) in order to unpack the row structure

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T13:47:01.108Z
ok, does a schemaf instance define the row -> dataf coalg?

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:55:59.638Z
ow, that's a neat idea! having a `def rowToData: Coalgebra[DataF, Row]` inside of `SchemaF`

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:56:58.642Z
I'll try that, thx !

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T13:57:16.087Z
seems that could work

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:58:01.792Z
hmm, well

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:59:24.897Z
actually `SchemaF` is just a trait, what I'd need would rather be an `Algebra[SchemaF, Coalgebra[?, Row]]` 

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T13:59:29.598Z
I thought actually more like `Algebra[SchemaF, Coalgebra[DataF, Row]]`

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:59:48.727Z
yep likewise, modulo the my typos

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:00:00.604Z
that's double the fun

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:00:18.994Z
yes, exactly

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:01:35.290Z
doubles the fun, halves the "coworker-friendliness" 

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:02:17.610Z
let's do that

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:05:04.511Z
:+1:

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:15:24.435Z
wait a minute, `SchemaF` is just a trait, nothing extends from it?

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:16:17.191Z
it's an ADT

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:16:35.394Z
ok, so there are case classes that extend from it?

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:16:36.808Z
a recursive one

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:16:39.774Z
yep

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:17:22.718Z
like `final case class ArrayF[A](elements: A) extends SchemaF[A]` and so on

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:18:12.174Z
what's the relationship between SchemaF and DataF? SchemaF should be expressive enough to represent all possible spark structtypes and avro schemas.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:22:49.722Z
in particular, I'm confused about the duplication of type information that you might have when you have both a SchemaF and a DataF instance.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:23:19.022Z
is DataF untyped?

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:23:20.291Z
schemaf represents the structures

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:23:34.473Z
dataf represents the "instances" of such schemas

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:24:51.502Z
on the same principle, it's `DataF[A]` with subclasses like `ArrayData[A](elements: List[A]) extends DataF[A]`

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:25:25.908Z
(the main structural difference is that schemaf has also some metadata attached)

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:25:27.679Z
how do you represent, say, an array of ints?

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:25:47.498Z
a value of such? 

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:25:55.682Z
both, schema and data

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:26:42.002Z
ow, I miss-typed earlier, lemme fix that ArrayF definition

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:27:38.583Z
so, schema would be:` ArrayF(IntF().embed).embed` or smth?

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:27:44.803Z
so `ArrayF(IntType()))` and `ArrayData(List(IntValue(1), IntValue(2)))` (eluding the fixpoint)

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:27:56.214Z
yep that's it

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:29:10.586Z
ah, I see. ok

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:30:41.098Z
so, simply spoken, you are building the type info of `List[Int]` in the schemaf structure, and the values in the dataf structure, got it

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:31:08.948Z
you're right

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:31:09.200Z
do you even need `IntValue`? can't you just use `Value(v: Any)`?

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:31:29.974Z
hmm nope

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:31:30.322Z
since the type is in the SchemaF

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:32:01.946Z
I have another layer of complexity I didn't mention

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:33:08.134Z
I also use the SchemaF + DataF to produce a validation (in term of  `jto.validation.Rule`) and I therefore need leaf values to be correctly typed

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:34:37.747Z
hmmm

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:35:26.386Z
I'm just seeing this leaf type info as some sort of duplication

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:36:07.157Z
you have to make sure that this is consistent

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:37:06.758Z
oh sorry, I've said wrong things (I don't even remember my own code ...) 

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:37:33.352Z
:D

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:37:38.378Z
in the schema tree, leaves are of type `ValueF`, with a field telling which type the value is

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:38:20.188Z
a string?

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:38:20.973Z
but on the data part, I'll definitely need specific leaves for each value type (int, bool, etc)

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:38:42.457Z
yes, a string (should be some kind of enum though)

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:40:24.892Z
ok

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:41:22.387Z
have you by chance explored the option of annotating each DataF node with its schema?

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:43:12.946Z
let's say, in the case of `ArrayData`, it would have an additional field that contains a recursive structure describing the schema of the children

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:44:44.743Z
I'm actually in the process of defining `DataF` (we have a working version, but not "functorized" and which doesn't use recursion schemes)

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:46:19.867Z
I've considered the idea of having some kind of data+internal-schema product, but it didn't seem really practical 

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:46:38.064Z
(I may be wrong about that last statement)

                                                                                                                                                      Greg Pfeil @sellout@2017-08-30T14:59:47.300Z
@vil1 I haven’t entirely caught up yet, but I’m surprised you have two Birecursive instances with the same functor. At a minimum, that implies that Schema and StructType are isomorphic. Are they?

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T15:01:55.836Z
God how can I say so much s**t

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T15:02:13.597Z
so let's correct myself

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T15:03:28.375Z
(the (only) birecursive instance I have is irrelevant, it's between my old, mundane-recursive representation and my new, recursive-scheme compliant one)

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T15:03:59.572Z
and I have algebras from SchemaF to StructType and to avro.Schema

                                                                                                                                                      Greg Pfeil @sellout@2017-08-30T15:04:14.237Z
Ok, cool – that makes sense.

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T15:04:16.101Z
sorry I mixed that up

                                                                                                                                                      Greg Pfeil @sellout@2017-08-30T15:04:57.290Z
No worries, sorry for being pedantic 😄

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T15:05:41.023Z
being right isn't isomorphic to being pedantic in my book ^^

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T15:08:06.944Z
anyway, I'm still trying @tscholak's idea : writing a `Algebra[SchemaF, Coalgebra[DataF, Row]]`

                                                                                                                                                      Greg Pfeil @sellout@2017-08-30T15:11:02.857Z
Yeah, that idea seems neat. I like it :D

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T15:15:30.131Z
I called that the  "double the fun" solution

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T15:16:16.960Z
but I had the intuition that, given a Row+StructType, I could get a GenericData+Schema with a single hylo

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T15:16:38.261Z
which will not be the case with that solution

                                                                                                                                                      Greg Pfeil @sellout@2017-08-30T15:35:40.660Z
@vil1 Yeah, I don’t think that is very easy. Since you need the Schema before you can determine how to handle the Row, right?

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T15:36:09.636Z
that's the essence of the problem yes

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T15:36:28.064Z
(same goes for genericRecord/avro.Schema)

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T15:55:13.229Z
recursing through the schema should be fast, no?

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T15:55:45.031Z
it would not be that much of an efficiency benefit if you rolled that -- both rows and structtype -- in one attempt

                                                                                                                                                      Greg Pfeil @sellout@2017-08-30T16:03:24.333Z
Right, if you actually did Schema and Data in parallel, you’d re-traverse Schema for each row, no? Rather than traversing it once to generate the function that transforms any row.

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T16:14:38.437Z
you're right: I have one schema on startup, and many data afterwards

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T16:15:28.245Z
so "making a plan" first and using that to then transform the incoming data makes perfect, operational sense

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T16:17:39.826Z
but conceptually it felt more compelling to have a single hylo

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T16:20:32.614Z
Anyway, I think I'll need more time to think about all that

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T16:20:48.569Z
You both gave me good lead though, thanks

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T16:21:16.151Z
let us know what you come up with :)

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T16:21:31.117Z
I surely will

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T16:55:56.480Z
Hi! I'm trying to implement a simple nanopass compiler using recursion schemes. I've worked out the mechanics of ana, cata, and para. I can modify the AST in place using cata and Algebra[AST, AST[_]]. I can also collect information about the AST using cataM and AlgebraM[Writer[...], AST, AST[_]]. Haven't really figured out what I'd want to use ana and para for, but I got some stuff to compile with them.

I've got some other operations I'm not really sure how to encode. I'd like to make sure that class declarations only occur on the top level. I think histo would be the tool for that, because I want to see the node's ancestors in the tree, but I haven't figured out the mechanics of that.

I'd also like to construct hierarchical symbol tables (I think I can manage that with cata - I'm coming to think I should extend my AST in some way to be able to embed the tables in the AST), and then somehow make those tables available during recursion. It feels like that might be achievable with zygo, but I haven't been able to assemble anything that quite makes sense

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T16:56:42.142Z
AST is here https://github.com/DanielPorter/fno/blob/master/src/main/scala/prestwood/PrestwoodAST.scala

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T16:56:58.503Z
any pushes in the right direction would be appreciated

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T17:38:59.671Z
If you want to have a heterogeneous type for your tree you need mutual recursion

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T17:39:50.975Z
is that in reference to my comment about embedding the tables in the AST?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T17:40:08.812Z
No, the invariant "class declarations only occur on the top level"

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T17:43:51.501Z
okay, either i'm not understanding, or i didn't phrase that well. likely both. i'm not saying class declarations must be the top node, i just want them to have only AndThen ancestors. I'm not grokking how that would make them heterogeneous

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T17:44:13.423Z
Oh my bad. Top-level should be fine.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T17:45:06.771Z
I don't see what histo would have to do with that, you'd just have `case class ClassDecl[T[_[_]]](name: String, mods: Modifiers, tree: T[AndThen])` 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T17:45:11.668Z
What is `AndThen`?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T17:45:18.560Z
Looking at your link now

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T17:46:05.633Z
AndThen is just a node in a balanced tree

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T17:46:27.993Z
named AndThen because i find it easier to think about

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T17:47:35.550Z
Right so class declarations being at the top level means an entire program is just a list of class declarations

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T17:47:40.750Z
Is that correct?

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T17:49:09.504Z
Ahh, no. I think introducing "top level" was a mistake.  Lines 11 and 12 would constitute a valid program:

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T17:49:09.866Z
https://github.com/DanielPorter/fno/blob/master/src/test/scala/PrestwoodParserSpec.scala

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T17:49:24.293Z
top level in the sense of the program, not in the AST

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T17:49:47.096Z
class declarations must be top level, however it is not the case that every top level expression must be a class declaration

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T17:50:05.372Z
Right, so it depends how many invariants here you want to capture in the AST type.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T17:50:48.359Z
If you want it to be impossible to include class declarations at any level other than the top level you're going to have to do runtime checking.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T17:50:58.929Z
Which you're going to have to do anyway to type check this.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T17:51:46.973Z
So what you need here is a) a method to remove non-top-level class declarations and b) a method to collect all of your class declarations, yes?

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T17:52:53.562Z
Well, I've managed to achieve (b) here, https://github.com/DanielPorter/fno/blob/master/src/main/scala/prestwood/PrestwoodAST.scala#L107

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T17:53:10.107Z
using cataM with a writer monad

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T17:53:16.537Z
Right that's the way I would do it too

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T17:54:02.482Z
regarding A, i'm not sure i want to remove them, i do however want to locate them

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T17:54:16.810Z
Locate them as top-level or not top-level?

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T17:54:23.799Z
as not-top level

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T17:54:50.570Z
Sorry that was ambiguous, I mean you want to detect whether or not there are non-top-level class decls?

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T17:55:31.437Z
yes. i would like to ascertain for each class declaration if it is "top level" or not, and for ones which are, i'd like to generate an error message for them

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T17:55:44.912Z
ahh

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T17:55:51.658Z
for ones which are not top level*

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T17:56:03.548Z
i.e. you can't place a class declaration in a block

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T17:56:27.556Z
(because scoping is hard and it sounds like a lot of work)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T17:56:40.903Z
Yeah

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T17:57:45.588Z
I'd say maybe look at `transCataTM`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T17:59:13.376Z
Use Either as your error monad, inspect two layers into the structure to find if you have a `ClassDeclaration` inside another layer which is not an `AndThen`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T18:00:35.516Z
That may not work. Maybe use the `Env` comonad with a boolean in your environment which determines "top-level" and a generalized catamorphism

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:03:29.616Z
would either short circuit?

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:03:39.373Z
i.e. only report the first failure?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T18:15:51.262Z
Yes

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T18:16:14.096Z
You could try something without an `M` on the end, then you can convert it to `Validated` for multiple-branch levels of the tree and accumulate errors

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:16:49.188Z
that sounds like a plausible approach

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:17:30.072Z
the type signature of transCataTM has this Corecursive.Aux business

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:17:58.218Z
unclear to me what i need to do to create one of those

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T18:18:08.386Z
Recursive means "I can pull an F[_] out of a T[F], to make a F[T[F]]"

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T18:18:23.285Z
Corecursive means "I can push an F[_] into an F[T[F]], to make a T[F]"

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T18:18:34.165Z
You're using Fix

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T18:18:36.791Z
Which has both

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:19:31.326Z
alright, so it's a freebie

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:23:58.225Z
okay. so i'm working through trying to use just the plain transCata, and i'm getting confused

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:32:39.030Z
when i try to call `ast.transCata(someplausiblefunction)` it tells me that transCata doesn't take parameters. looking at the definition, that looks true - it's an object whose apply method takes only a type parameter U. But there is another function transCata that takes (t: T)(f: Base[U] => G[U]). don't really understand the function or signature

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:33:34.946Z
Greg Pfeil's talk on matroyshka has an example of doing... i think the thing i'm trying to do: `val desugar: Fix[Let :+: If :+: Lambda] => Fix[Lambda] =
  _.transCata(expandIf <<< expandLet)`

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:33:55.072Z
but i don't know what the :+: symbols mean. i've gathered that <<< is function composition

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:44:08.445Z
haha, well, i got transCataTM working

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:44:11.655Z
so there's that

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T18:44:25.397Z
:+: means "or"

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T18:44:44.521Z
In that `(F :+: G)[A]` is an `F[A]` or `G[A]`

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:46:07.412Z
gotcha. is that importable? it's a hard operator to google for

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T18:46:24.741Z
I'm not sure actually where it's from, it may be in matryoshka

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:47:12.553Z
hm. git search doesn't find it in the codebase

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:47:37.646Z
nor in scalaz's

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:48:49.234Z
so i think that transcataTM is not what i want. If I use transcataTM, i have to write this invariant (if i'm using that word correctly) in terms of every AST node type which is *not* a class declaration

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T18:49:02.693Z
Why is that?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T18:49:16.564Z
Btw it's from Quasar, a project which uses matryoshka

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:49:24.606Z
ahhh, thanks

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:49:44.282Z
well you're talking about checking the children, right?

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:49:56.294Z
so if i have an andThen, i need to check the children

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:50:00.813Z
or if i have a block, i need to check the children

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:51:18.308Z
but have to write code for each node that can contain subnodes

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:52:26.152Z
whereas if i can express it in terms of parents of the Class Declaration, i only have to write it for class declarations, and as i expand my AST, i don't have to go expand my function

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T18:52:53.079Z
I don't see how that would be possible

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T18:52:57.320Z
Here's my recommendation

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T18:53:10.435Z
Come up with a "children" function that returns all of the `A`'s in a `PrescottAST[A]`

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:55:14.975Z
wouldn't histo allow you to see the parents?

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:57:12.289Z
haven't figured out the mechanics of how to use it, but if you use something like case x => Monad(x) for all of the non-ClassDeclarations, you could grab the lineage for the ClassDeclaration case?

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:57:23.179Z
or am i misunderstanding what histo gets you

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T18:59:02.911Z
`histo` gives you the earlier results of the fold

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:59:32.644Z
ahh, but it still traverses from bottom to top

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:59:49.549Z
so you still can't see

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T18:59:50.240Z
I mean if you want top to bottom you have some other options

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T18:59:59.632Z
`transAna` in particular

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T19:00:04.287Z
Which is just `transCata` but top to bottom

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T19:01:50.352Z
okay, that might do the trick

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T19:03:15.222Z
an aside - is there a way to get intellij to recognize these implicits for syntax highlighting? it suggests transCata etc but then after a while decides they're not valid methods

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T19:03:42.673Z
Nope

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T19:03:43.459Z
I wish

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T19:04:01.449Z
dang. that's pretty goofy

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T19:04:16.123Z
IntelliJ only gets goofier the more you use implicits and type members

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T19:04:50.712Z
haha. it's also been slaughtering my battery since i started using matroyshka

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T19:05:11.414Z
the price we pay for java interop, i guess

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T19:05:13.839Z
Yeah I bet. This is why a lot of people use vim and stuff

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T19:05:25.428Z
It's not Java interop really, a lot of scala's problems have nothing to do with Java interop

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T19:05:31.699Z
And Scala/Java interop is... not great, anyway

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T19:08:39.702Z
so what i really want is top to bottom *and* history

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T19:09:06.893Z
it looks like `futumorphism` might be the thing

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T19:09:13.504Z
Futumorphism gives you the *future*

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T19:09:21.873Z
So it may not be what you want

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T19:09:25.335Z
But not sure

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T19:10:16.203Z
hm. looks worth checking. i'm noting that it requires a `GCoalgebraM[Free[F, ?], M, F, A]`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T19:10:35.683Z
Yeah a coalgebra, so that's constructing a structure, not tearing it down

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T19:11:27.299Z
hm. right. so my target structure is the same as the structure i'm consuming

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T19:11:45.037Z
i have an AST, i don't really care about the target

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T19:12:03.042Z
i just want to capture some information in a monad

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T19:12:23.619Z
I'd really recommend coming up with a `children` function and doing this bottom-up

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T19:12:25.808Z
so if i can recurse from

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T19:12:34.070Z
haha. alright.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T19:13:00.434Z
I'm not an expert by far, I'm really still a novice, so I apologize if my advice is in general insufficient

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T19:13:41.368Z
is cool. my opposition to the children function is that i end up recursing the AST multiple times that way

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T19:13:55.752Z
The children function is only for a single layer

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T19:14:15.011Z
ah, not so bad, then

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T19:15:17.403Z
Yeah it's just `F[A] => List[A]`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T19:15:22.521Z
Not `Fix[F] => List[F[_]]`

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-02T20:52:18.784Z
Hey Edmund, can you tell me if histo can be used to efficiently evaluate recursive structures via memoization?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T20:52:32.770Z
Evaluate?

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-02T20:53:13.676Z
Yeah, as in fold

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T20:55:10.437Z
I think that could have a lot of meanings

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T20:55:23.153Z
Histo keeps around every answer to earlier calls to the algebra

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T20:55:38.648Z
So if you need that info then histo can prevent you from recalculating it

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-02T20:57:20.490Z
Let's say you have an Ast for mathematical operations like sum, multiply, negate, sine, etc. and you like to fold over an algebra that evaluates these. Can histo reuse results from identical subtrees hat have already been evaluated?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T20:57:33.840Z
Not in a simple way.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T20:57:50.476Z
I'd use a state monad over a map from subtrees to results.

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-02T20:58:46.129Z
Yeah, state monad was my first thought, too. When I read about histo, though, i thought this sort of thing comes for free with it. Guess not

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T20:59:17.451Z
Well you'd have to retraverse the Cofree finding subtrees equivalent to the one under consideration

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T20:59:46.057Z
I think you could come up with a recursion scheme which generally just memoizes an extant one

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T21:00:09.754Z
But that means using something like `transCata`, because you need to view the entirety of the tree under you

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T21:00:20.573Z
Maybe even `transAna` because that's top-down

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-02T21:04:17.502Z
Hmmm, ok. With coffee the idea is then to annotate each node of the tree with the results of the cata applied to the their sub trees?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T21:17:50.966Z
Yep

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T21:03:07.817Z
so i can use the transCata etc methods, but i can't run anything that's defined in idOps

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T21:04:07.379Z
not enough value parameters provided

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T21:04:13.320Z
i think it's the corecursive instance

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:23:21.793Z
if i had to guess i'd guess i'm missing some important typeclass

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:23:44.646Z
clicking around the source for how corecursive auxes come into being is unilluminating, though

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T22:25:34.866Z
Fix has a Birecursive instance

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T22:25:46.650Z
Birecursive is a subtype of Recursive and Corecursive

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:26:14.790Z
okay, lemme recreate it real quick here

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:30:20.508Z
``` 
 type FAST = Fix[PrestwoodAST]
  def coab: Coalgebra[List, FAST] = {
    case x => List(x)
  }

  def coabfail(ast: FAST) = ast.ana[FAST](coab)
```

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:31:25.071Z
"Error:(219, 42) could not find implicit value for parameter T: matryoshka.Corecursive.Aux[prestwood.PrestwoodAST.FAST,slamdata.Predef.List]
  def coabfail(ast: FAST) = ast.ana[FAST](coab)"

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:31:41.286Z
"Error:(219, 42) not enough arguments for method apply: (implicit evidence$19: scalaz.Functor[slamdata.Predef.List], implicit T: matryoshka.Corecursive.Aux[prestwood.PrestwoodAST.FAST,slamdata.Predef.List])prestwood.PrestwoodAST.FAST in class PartiallyApplied.
Unspecified value parameter T.
  def coabfail(ast: FAST) = ast.ana[FAST](coab)"

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T22:33:06.412Z
You need a Coalgebra[FAST, List[FAST[_]]] I think

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:35:31.080Z
fast doesn't have any holes

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:40:12.634Z
looking around at the exp implementation in the docs, i see that they're creating a couple of implicits - arbitrary, equal

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:40:22.418Z
that i'm not. i've just implemented map and traverse

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:40:30.172Z
i don't grok what those are for

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T22:40:46.090Z
Oh not FAST

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T22:40:50.488Z
I mean `PrestwoodAST`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T22:40:56.424Z
`Fix` does not belong in the `Coalgebra`

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:44:15.129Z
```
  def coab: Coalgebra[List, PrestwoodAST[_]] = {
    case x => List(x)
  }


  def coabfail(ast: FAST) = ast.ana[FAST](coab)
```

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:44:26.926Z
Error:(220, 43) type mismatch;
 found   : matryoshka.Coalgebra[slamdata.Predef.List,prestwood.PrestwoodAST[_]]
    (which expands to)  prestwood.PrestwoodAST[_] => List[prestwood.PrestwoodAST[_]]
 required: matryoshka.Coalgebra[?,prestwood.PrestwoodAST.FAST]
    (which expands to)  matryoshka.data.Fix[prestwood.PrestwoodAST] => ?
  def coabfail(ast: FAST) = ast.ana[FAST](coab)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T22:44:32.341Z
Wait, what are you trying to do?

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:44:34.897Z
adamant that it doesn't like that, either

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:44:43.708Z
i am just trying to get this coalgebra to compile

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T22:44:43.957Z
Coalgebras build structures, they don't take them down

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:45:10.661Z
the compiler seems to like the coalgebra okay

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:45:31.414Z
sorry, i'm working on just getting ana to compile

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T22:45:50.070Z
Okay but what is ana supposed to do

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T22:45:52.692Z
Describe it to me

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:45:56.520Z
what i believe that should do is wrap every element of the AST in a list

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:46:01.020Z
and then only return one of them

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:46:32.063Z
presumably one of the tails, because it goes top to bottom

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T22:46:46.950Z
ana does not consume a structure at all

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:46:59.993Z
not really, no

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:47:14.213Z
just going for a "okay this compiles, now let's make it dance" approach

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:48:23.154Z
(also, you were right about the children method yestereday. thanks for the help :).)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T22:49:57.433Z
Your type annotations are wrong because `ana`'s type argument should be a `Fix[F]` which it can recursively build

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T22:50:03.995Z
And that's what it will return, too

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T22:50:28.540Z
And the coalgebra it wants will be a `Coalgebra[F, A]`, where `A` is the type of `x` in `x.ana`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T22:51:07.585Z
All `ana` will give you is a recursive structure, that is an entire `Fix[F]` or similar

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:52:13.523Z
hm. FAST is Fix[PrestwoodAST]

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T22:52:22.966Z
So you're constructing a `FAST`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T22:52:37.963Z
So there's no List in there, right, because you're using a `FAST` as the argument to construct another `FAST`

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:53:58.822Z
Okay, so it can't return a List[Fix[..]]

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:56:16.514Z
ahhh. okay. that kinda makes sense. so it's just not a well-formed operation - starting with the type i'm trying to end with dorks it up

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:57:39.079Z
Well then. I'll stop trying to do that.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T22:57:56.897Z
You've got it exactly

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:58:43.340Z
much obliged.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:00:10.671Z
so towards my goal of having writing a compiler - i'd like to be able to arbitrarily annotate the AST. the internet says histo might be good for that, but the examples i've got are a little too haskell for my consumption

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:00:57.234Z
does that sound like the right direction to head in? Cofree?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:02:52.170Z
Cofree yes, histo no

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:03:11.611Z
Histo is also destructive, it takes `Cofree` as a parameter and doesn't have it as a result

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:04:10.347Z
So you want to take your `Fix[F]` and make it a `Fix[Lambda[X => (A, F[X])]]`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:05:32.196Z
The relationship with cofree here is that `Cofree[F, X]` is the same as `Fix[Lambda[A => (X, F[A]]`

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:05:54.558Z
hm.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:10:23.153Z
So you want to deconstruct your `Fix[F]` and reconstruct a `Fix[G]`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:11:36.457Z
`Lambda[A => (X, F[A])` is the same as `EnvT[F, X, ?]` btw

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:12:48.844Z
hm. okay. i don't recognize lambda or EnvT

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:13:40.111Z
Oh okay

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:13:45.445Z
https://github.com/non/kind-projector

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:14:01.924Z
I recommend getting familiar with this compiler plugin, you need it to write any complex type constructors in Scala

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:14:17.857Z
will do

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:14:49.395Z
so i don't see anything that really hints at that operation in the "recursion scheme" cheat sheet

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:15:06.637Z
`meta` is the same thing there

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:15:09.270Z
If you're on the Kmett one

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:16:43.025Z
the one on the metroyshka github? i see ana followed by cata there

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:18:03.170Z
That should be cata followed by ana

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:19:02.967Z
[![image.png](https://files.gitter.im/slamdata/matryoshka/SnDD/thumb/image.png)](https://files.gitter.im/slamdata/matryoshka/SnDD/image.png)

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:20:01.898Z
okay, noted. might need to fix that cheat sheet :)

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:20:16.427Z
i'm also noting that meta doesn't seem to be implemented?

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:20:26.612Z
is there some more general scheme i want to use?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:20:31.568Z
The thing is there's two ways to define meta

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:20:33.873Z
That aren't equivalent

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:20:38.091Z
transCata and transAna

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:23:21.971Z
so transCata takes F[U] => G[U]

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:23:44.610Z
Yeah, so I'm assuming what you need to label an `F[_]` is the `F[_]` itself

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:24:15.425Z
i think so. just going to label based on info in the AST

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:24:37.709Z
You don't need all of the `Fix[F]` children, right?

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:25:20.464Z
erm, oh. i'm not sure. i was leaning towards yes, i do

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:25:38.402Z
i wanted to do the annotation based on children to build up a local symbol table in blocks

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:29:09.715Z
I have an idea which may make this easier for you

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:29:24.885Z
i am all ears

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:30:30.775Z
Actually wait, is there no scoping by `{ }` in your language?

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:30:56.553Z
well, since we last talked, i decided, yeah, i do want that within function blocks

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:31:28.645Z
Right so that means you're going to have some kind of representation of `{ }` occurrences in your AST if you're gonna have enough information in your symbol table

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:31:50.423Z
ya, and i have a Block node

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:31:56.981Z
i could attach it there

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:33:07.790Z
ideally i'd like to make it visible to the children, though. if i'm invoking a function in a particular context, i'd like to know if the parameters have been defined

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:33:34.566Z
Right so your annotation calculation needs to be aware of the annotation directly above

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:33:46.348Z
at least, yes

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:38:14.007Z
Well actually the annotation directly before

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:38:32.688Z
I'm kind of stuck on this, I don't see how this would work for a statement-oriented language

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:39:24.811Z
so... here's what i'm imagining

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:41:11.041Z
```
class DigitalOcean(apikey: String) {
    def createVM() {
        CMD("curl digitalocean.com?$apikey")
    }
}
```

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:41:32.619Z
ahh. lemme edit that

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:43:10.917Z
so when i'm looking at the function definition, i'd like to verify whether or not apikey is a valid identifier

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:43:58.409Z
the class's declaration block would have apikey as a symbol

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:44:11.759Z
but the function definition would need access to the table

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:44:48.795Z
idk. i could probably encode it differently. that's just how i've been thinking about doing it

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:46:09.618Z
i am decidedly just making this up as i go along :)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:46:27.144Z
Right so I think what you want here is bottom-up, which means you're going to have to start with `ana`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:47:44.333Z
You're going to have to calculate a `(SymbolTable, F[SymbolTable]) => SymbolTable` which produces the "next" SymbolTable from the current one and the ones below

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:48:42.612Z
Actually it's going to have to produce the *new current* `SymbolTable` as well as the *next* `SymbolTable`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:49:20.039Z
So `(SymbolTable, F[SymbolTable]) => (SymbolTable, SymbolTable)`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:50:31.726Z
The method that you use needs to take as parameters a `Fix[PrescottAST]` and a starting `SymbolTable` (which will be the empty table), and that function above

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:51:04.367Z
It will return `Fix[EnvT[PrescottAST, SymbolTable, ?]]`

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:53:09.115Z
hmm. okay. i... kind of see it

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:55:03.937Z
what's the hole at the end about?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:55:27.915Z
`Fix(EnvT(PrescottAST, SymbolTable, _))` kind of thing

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:56:13.178Z
Unnamed lambda

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:56:30.056Z
```scala
type ETP[A] = EnvT[PrescottAST, SymbolTable, A]
Fix[ETP]
```

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:56:42.393Z
ah, gotcha.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:59:34.357Z
so transAna takes a function from F[T]=>G[T]. Does that mean I need a function that looks like
```
def f:((SymbolTable, F[SymbolTable]) => (SymbolTable, SymbolTable), SymbolTable) => (Fix[PrestwoodAST] => Fix[EnvT[PrescottAST, SymbolTable, ?]])
```

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T00:00:19.322Z
Whoa

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T00:00:22.374Z
I don't think so

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T00:00:33.042Z
Wait uh

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T00:01:14.557Z
I believe so

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T00:01:55.518Z
haha, alright. then i am going to charge ahead in that direction and see what falls out

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T00:02:54.759Z
thanks again for the help, edmund!

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T00:04:32.618Z
You're welcome :)

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T00:42:58.654Z
are there any conveniences for constructing cofree values?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:01:34.613Z
A `Corecursive[F, Cofree[F, A]]`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:01:50.570Z
Also some methods on `Cofree` itself

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:05:44.568Z
man i am confused

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:06:49.459Z
so i decided to momentarily ditch the symbol table - annotating the tree with anything at all would be sufficient for the moment

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:07:04.485Z
```
  type ETP = Lambda[A => (Int, PrestwoodAST[A])]

  def ta: (Fix[PrestwoodAST] => Fix[ETP])= {
    case a @ Fix(Assignment(x, y)) => EnvT()
      Fix(Cofree.apply(0, StringLiteral[Cofree[PrestwoodAST, Int]]("asdf")))
      //Fix(EnvT(f(0), Assignment[Cofree[PrestwoodAST, Int]](x, Cofree(f(1), PrestwoodAST.StringLiteral[Cofree[PrestwoodAST, Int]]("asdf")))))
  }
```

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:07:29.697Z
^^ confused scribbles

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:07:32.468Z
What you're doing with `type ETP` doesn't work, because the only types that exist in Scala are fully-applied to their arguments

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:07:49.184Z
So like, `type ETP[A] = (Int, PrestwoodAST[A])` works

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:11:27.804Z
hm

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:15:16.073Z
so cofree and envt are interchangeable here?

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:25:45.017Z
ahhh. okay. so i think we were making at least one error here. The type of transAna is G[U] => T[U], i.e. we would be losing the fix

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:26:01.340Z
What is the type of `transAna`?

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:26:33.044Z
oh, sorry. the type of the function it accepts - (f: F[T] => G[T])

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:26:59.454Z
So the function can't observe any full trees, just a single layer of the tree's structure

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:27:35.503Z
But ultimately what it returns is still a full tree

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:28:43.561Z
but so... is having in that function signature correct?

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:28:52.222Z
i was able to make the red squigglies go away when i removed it

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:28:59.468Z
```
  def ta: Fix[PrestwoodAST] => Cofree[PrestwoodAST, Int] = {
    case Fix(Assignment(x, y)) =>
      Cofree.apply(0, Assignment[Cofree[PrestwoodAST, Int]](Id[Cofree[PrestwoodAST, Int]]("String"), Cofree(0, StringLiteral[Cofree[PrestwoodAST, Int]]("okay"))))
  }
```

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:29:29.322Z
So your function should be `PrestwoodAST ~> ETP`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:30:05.435Z
Er wait sorry

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:31:10.915Z
`PrestwoodAST[Cofree[PrestwoodAST, Int]] => (Int, Cofree[PrestwoodAST, Int])`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:31:31.560Z
So you peel off one layer and put it back on as a new `Int`

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:32:54.129Z
and it's accumulating all of the results within the cofree structure (~magically)?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:33:38.692Z
Well you have a `Fix[PrestwoodAST]` right

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:33:47.788Z
right

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:33:50.236Z
not so much magic

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:33:55.243Z
You `unFix` that to a `PrestwoodAST[Fix[PrestwoodAST]]`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:34:25.388Z
Then you reach in that `PrestwoodAST` level using `map`, and you feed that `Fix[PrestwoodAST]` inside to the function you're defining right now

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:34:30.801Z
Recursively

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:34:43.643Z
Now you have a `PrestwoodAST[Cofree[PrestwoodAST, Int]]`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:35:14.992Z
Crap okay my other type is still not right :P

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:35:27.998Z
`PrestwoodAST[Cofree[PrestwoodAST, Int]] => (Int, PrestwoodAST[Cofree[PrestwoodAST, Int]])`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:35:58.115Z
Because you're keeping that structure around, right, you're just adding some extra structure on top (the `(Int, ?)`)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:36:11.068Z
So you take that `PrestwoodAST[Cofree[PrestwoodAST, Int]]` you had, right

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:36:17.970Z
Apply the function the user provided to that

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:36:28.329Z
Now you have an `(Int, PrestwoodAST[Cofree[PrestwoodAST, Int]])`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:37:11.718Z
Cofree has this instance of `Corecursive`, but the `G` it has which you can "put inside" a `Cofree[F, A]` is `(Int, F[?])`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:37:34.359Z
So it uses that method to get back out a `Cofree[PrestwoodAST, Int]` and you're done!

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:39:12.929Z
hahaha. easy peasy.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:39:53.623Z
so just as a test of that, tried to compile this

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:40:06.128Z
```
  def omfg: PrestwoodAST[Cofree[PrestwoodAST, Int]] => (Int, PrestwoodAST[Cofree[PrestwoodAST, Int]])= {
    case a @ Assignment(x, y) => (0, a)
  }

  def plzwork(ast: FAST) = ast.transAna[FAST](omfg)

```

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:40:35.320Z
Error:(209, 47) type mismatch;
 found   : prestwood.PrestwoodAST[scalaz.Cofree[prestwood.PrestwoodAST,slamdata.Predef.Int]] => (slamdata.Predef.Int, prestwood.PrestwoodAST[scalaz.Cofree[prestwood.PrestwoodAST,slamdata.Predef.Int]])
    (which expands to)  prestwood.PrestwoodAST[scalaz.Cofree[prestwood.PrestwoodAST,Int]] => (Int, prestwood.PrestwoodAST[scalaz.Cofree[prestwood.PrestwoodAST,Int]])
 required: prestwood.PrestwoodAST[prestwood.PrestwoodAST.FAST] => ?
    (which expands to)  prestwood.PrestwoodAST[matryoshka.data.Fix[prestwood.PrestwoodAST]] => ?
  def plzwork(ast: FAST) = ast.transAna[FAST](omfg)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:41:02.541Z
`transAna[Cofree[PrestwoodAST, Int]]`

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:42:00.257Z
okay, so i need to make that initial Fix[Prestwood] that gets passed in into a Cofree before i can do this

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:42:54.670Z
Yeah, isn't that `ast`?

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:43:23.194Z
ast is Fix[PrestwoodAST], or FAST

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:43:39.736Z
need to transform that somehow

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:44:04.550Z
Not `transAna`?

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:44:20.557Z
i don't follow

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:44:31.042Z
I don't follow what you're saying

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:44:57.480Z
```
  def plz: PrestwoodAST[Cofree[PrestwoodAST, Int]] => (Int, PrestwoodAST[Cofree[PrestwoodAST, Int]])= {
    case a @ Assignment(x, y) => (0, a)
  }

  def plzwork(ast: FAST) =  ast.transAna[Cofree[PrestwoodAST, Int]](plz)
```

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:45:02.568Z
is no bueno

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:45:17.726Z
Error:(209, 69) type mismatch;
 found   : prestwood.PrestwoodAST[scalaz.Cofree[prestwood.PrestwoodAST,slamdata.Predef.Int]] => (slamdata.Predef.Int, prestwood.PrestwoodAST[scalaz.Cofree[prestwood.PrestwoodAST,slamdata.Predef.Int]])
    (which expands to)  prestwood.PrestwoodAST[scalaz.Cofree[prestwood.PrestwoodAST,Int]] => (Int, prestwood.PrestwoodAST[scalaz.Cofree[prestwood.PrestwoodAST,Int]])
 required: prestwood.PrestwoodAST[prestwood.PrestwoodAST.FAST] => ?
    (which expands to)  prestwood.PrestwoodAST[matryoshka.data.Fix[prestwood.PrestwoodAST]] => ?
  def plzwork(ast: FAST) =  ast.transAna[Cofree[PrestwoodAST, Int]](omfg)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:45:18.101Z
what is `omfg` here

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:46:13.979Z
sorry, was renaming it

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:46:17.041Z
plz=omfg

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:48:03.719Z
so i'm trying to transform my Fix[PrestwoodAST] by using the transAna function, and traversing it with "plz", a function from Prestwood[Cofree etc] to (Int, Prestwood[Cofree etc])

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:48:26.143Z
i don't really understand where the initial cofree value is supposed to come from

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:48:36.667Z
or if i'm creating one on each level

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:49:43.476Z
or if i should have already converted the AST from Prestwood[Fix[Prestwood]] to Prestwood[Cofree[Prestwood, Int]]

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:50:12.259Z
No, this is the recursion in `transAna` doing this

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:50:38.992Z
So the problem here is I made a mistake, you have to use `EnvT` and not `(A, F[?])`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:50:46.958Z
They're the same, just different types

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:51:18.143Z
> You `unFix` that to a `PrestwoodAST[Fix[PrestwoodAST]]`
Then you reach in that `PrestwoodAST` level using `map`, and you feed that `Fix[PrestwoodAST]` inside to the function you're defining right now
Recursively
Now you have a `PrestwoodAST[Cofree[PrestwoodAST, Int]]`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:51:32.302Z
This part is in `transAna`

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:52:07.432Z
ahhh.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:54:26.869Z
So `PrestwoodAST[Cofree[PrestwoodAST, Int]] => EnvT[PrestwoodAST, Int, Cofree[PrestwoodAST, Int]]`

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T02:01:26.441Z
man, still no dice.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T02:01:37.401Z
?

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T02:01:47.549Z
The first type parameter to EnvT is E, and doesn't have any holes

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T02:01:53.800Z
Oh okay

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T02:01:56.220Z
Put Int first 

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T02:02:09.729Z
i swapped them, that looked okay

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T02:02:31.455Z
but didn't compile - 

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T02:02:37.362Z
```
  def plz: PrestwoodAST[Cofree[PrestwoodAST, Int]] => EnvT[Int, PrestwoodAST, Cofree[PrestwoodAST, Int]] = {
    case a @ Assignment(x, y) => EnvT((0, a))
  }

  def plzwork(ast: FAST) =  ast.transAna[Cofree[PrestwoodAST, Int]](plz)
```

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T02:02:51.592Z
Error:(211, 69) type mismatch;
 found   : prestwood.PrestwoodAST[scalaz.Cofree[prestwood.PrestwoodAST,slamdata.Predef.Int]] => matryoshka.patterns.EnvT[slamdata.Predef.Int,prestwood.PrestwoodAST,scalaz.Cofree[prestwood.PrestwoodAST,slamdata.Predef.Int]]
    (which expands to)  prestwood.PrestwoodAST[scalaz.Cofree[prestwood.PrestwoodAST,Int]] => matryoshka.patterns.EnvT[Int,prestwood.PrestwoodAST,scalaz.Cofree[prestwood.PrestwoodAST,Int]]
 required: prestwood.PrestwoodAST[prestwood.PrestwoodAST.FAST] => ?
    (which expands to)  prestwood.PrestwoodAST[matryoshka.data.Fix[prestwood.PrestwoodAST]] => ?
  def plzwork(ast: FAST) =  ast.transAna[Cofree[PrestwoodAST, Int]](plz)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T02:04:50.363Z
You need some more type arguments I think

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T02:05:49.199Z
Add `[EnvT[Int, PrestwoodAST, ?]]` after the first set of type arguments to `transAna`

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T02:07:06.548Z
hm, says wrong number of type parameters

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T02:07:12.293Z
```
  def plzwork(ast: FAST) =  ast.transAna[Cofree[PrestwoodAST, Int], EnvT[Int, PrestwoodAST, ?]](plz)
```

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T02:08:03.668Z
oh. placed them after, got a different error

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T02:08:11.220Z
looks more promising

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T02:08:12.459Z
Error:(209, 97) type mismatch;
 found   : prestwood.PrestwoodAST[scalaz.Cofree[prestwood.PrestwoodAST,slamdata.Predef.Int]] => matryoshka.patterns.EnvT[slamdata.Predef.Int,prestwood.PrestwoodAST,scalaz.Cofree[prestwood.PrestwoodAST,slamdata.Predef.Int]]
    (which expands to)  prestwood.PrestwoodAST[scalaz.Cofree[prestwood.PrestwoodAST,Int]] => matryoshka.patterns.EnvT[Int,prestwood.PrestwoodAST,scalaz.Cofree[prestwood.PrestwoodAST,Int]]
 required: prestwood.PrestwoodAST[prestwood.PrestwoodAST.FAST] => matryoshka.patterns.EnvT[Int,prestwood.PrestwoodAST,prestwood.PrestwoodAST.FAST]
    (which expands to)  prestwood.PrestwoodAST[matryoshka.data.Fix[prestwood.PrestwoodAST]] => matryoshka.patterns.EnvT[Int,prestwood.PrestwoodAST,matryoshka.data.Fix[prestwood.PrestwoodAST]]
  def plzwork(ast: FAST) =  ast.transAna[Cofree[PrestwoodAST, Int]][EnvT[Int, PrestwoodAST, ?]](plz)

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T02:30:28.089Z
Ahhhh! It worked! 
```
  type envt[A] = EnvT[Int, PrestwoodAST, A]
  def maybe2: PrestwoodAST[Fix[PrestwoodAST]] => EnvT[Int, PrestwoodAST, FAST] = {
    case x => EnvT(0, x)
  }

    def plzwork(ast: FAST) =  ast.transAna[Cofree[PrestwoodAST, Int]][envt](maybe2)
```

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T02:55:00.030Z
It's so good! thanks so much for your help, @edmundnoble Cofree still wigs me out, and figuring out how to do anything with it is gonna take a minute, but it feels great to have that running. putting arbitrary integers on all of the things!

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T02:55:39.852Z
You're so welcome :) hopefully Cofree doesn't elude you for too long, it's very similar to Fix

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T03:04:56.122Z
oh, also - it looks like we had the type signature right, but for transCata, and not transAna

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T03:05:08.214Z
Oh wow did I flip it

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T03:05:09.951Z
```
  def maybe3: PrestwoodAST[Cofree[PrestwoodAST, Int]] => EnvT[Int, PrestwoodAST, Cofree[PrestwoodAST, Int]] = {
    case b @Block(a) => EnvT(a.length, b)
    case at @ AndThen(_, _) => EnvT(2, at)
    case x => EnvT(1, x)
  }
  def plzwork2(ast: FAST): Cofree[PrestwoodAST, Int] =  ast.transCata[Cofree[PrestwoodAST, Int]][envt](maybe3)
```

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T03:05:26.332Z
yeah, that one compiles :D

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T03:05:38.628Z
Oh wow, interesting

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T03:05:47.317Z
i... i'm going to figure out how to  make a gist

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T03:06:21.412Z
seems silly not to have a cookbook for these things

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T03:06:46.001Z
IMO most of them might not need to exist, they're all just cata or ana anyway

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T03:07:27.805Z
very possible.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T03:07:47.447Z
but also, i'm at about the 30 hour mark on reading/writing recursion schemes

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T03:08:05.601Z
I'd recommend writing the schemes yourself in terms of cata and ana

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T03:08:16.293Z
Writing cata and ana themselves first

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T03:08:26.337Z
sounds like a very useful exercise

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T03:08:58.702Z
less fun if it's not magic, tho

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T03:09:08.613Z
lmao

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T03:27:00.221Z
alright. hard won lessons of this holiday weekend, immortalized: https://gist.github.com/DanielPorter/460ff5e4c5246ef680e053d95bd5a010

                                                                                                                                                      Valentin Kasas @vil1@2017-09-04T15:05:23.440Z
Hi. I managed to allocate some time for my data+schema traversal problem.
reminder: I have two carrier functors, namely `SchemaF` and `DataF`. `SchemaF`, along with the respective (co)algebras, allows me to transform spark's `StructType` to avro's `Schema` and vice versa. I want to to the same for data and transform spark's `GenericRowWithSchema` to avro's `GenericContainer`. 

                                                                                                                                                      Valentin Kasas @vil1@2017-09-04T15:06:52.388Z
Last time, I mistakenly thought that I needed the schema while, eg, destructing a `GenericContainer` to make a `DataF`. That was a mistake since `GenericContainer` embeds a schema

                                                                                                                                                      Valentin Kasas @vil1@2017-09-04T15:07:58.969Z
So I was able to write an instance of `Recursive.Aux[GenericContainer, DataF]` without any serious trouble

                                                                                                                                                      Valentin Kasas @vil1@2017-09-04T15:08:58.946Z
But I still have a problem when I want to go the other way around, namely implementing an `Algebra[DataF, GenericContainer]`

                                                                                                                                                      Valentin Kasas @vil1@2017-09-04T15:10:58.526Z
I could infer the schema from the data in most cases, but there are some edge cases where this is impossible. For example when I have an empty array in my data, I cannot infer the schema for that array from the data alone

                                                                                                                                                      Valentin Kasas @vil1@2017-09-04T15:12:01.363Z
So I'm back to my initial problem : traversing a `DataF`and the corresponding `SchemaF` at the same time

                                                                                                                                                      Valentin Kasas @vil1@2017-09-04T15:16:05.490Z
I've tried to implement a `Algebra[SchemaF, Algebra[DataF, GenericContainer]]` which sounded promising at first, but failed since at each level of my `SchemaF` I cannot use the `Algebra[DataF, GenericContainer]` I've built bellow to make a "bigger" `Algebra[DataF, GenericContainer]`

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T15:35:02.803Z
@vil1 don't think i have anything constructive to add, but i'm interested in seeing what other people are doing/hitting their heads on. any chance your code is in a repo somewhere i could see?

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T15:36:10.127Z
if i'm understanding correctly, it sounds a lot like you're facing the same problem that i'm facing - i want to aggregate information from root nodes up to child nodes of my AST, but there's no clear mechanism to do that

                                                                                                                                                      Valentin Kasas @vil1@2017-09-04T15:36:12.598Z
for the moment that's proprietary work I'm afraid

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T15:36:19.753Z
fair :)

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T15:36:50.572Z
i keep wanting to accumulate the information in a writer monad, but there's no way to let each successive layer see that writer monad, you don't get access to it until after the traversal is complete

                                                                                                                                                      Valentin Kasas @vil1@2017-09-04T15:37:57.515Z
that's indeed similar

                                                                                                                                                      Valentin Kasas @vil1@2017-09-04T15:38:51.328Z
FWIW, I know that both instances of DataF and SchemaF ought to share a common (or at least very similar) structure

                                                                                                                                                      Valentin Kasas @vil1@2017-09-04T15:40:37.727Z
I've also considered building an intermediate DataWithSchema that would hold the same fields as DataF plus a Fix[SchemaF], but in hindsight it's just restating the same problem 

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T15:48:27.519Z
hm. so i've started working with cofree, which has coflatmap, which lets you apply a function to each node in the tree. I'm not completely sure if this buys me anything, but i'm imagining i could annotate each node with the entire structure, thereby giving it access to the parents

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T15:48:34.490Z
it seems horribly inefficient

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T15:49:21.260Z
the idea is stemming from http://blog.higher-order.com/ where he talks about doing a graph decomposition in a similar way

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T15:50:06.013Z
i've been idly contemplating if what i really want is a graph and not an AST

                                                                                                                                                      Valentin Kasas @vil1@2017-09-04T16:18:57.048Z
idly contemplating, that's what I do best

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T17:14:09.392Z
trying is the first step towards failure

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-04T17:20:08.274Z
Ha, I've been reading the comonadic graph decomposition post last week, too :D

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-04T17:26:40.272Z
I don't know if my recent adventures with open recursion are useful to you, but just in case, you can find them here: https://github.com/tscholak/autodiff

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T17:26:57.348Z
can't hurt

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T17:27:32.193Z
don't see a readme - would you be so generous as to give me a high level of what you're doing?

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-04T17:47:26.396Z
Very briefly, it's an attempt to do computer algebra using open recursion. The Ast is a set of simple mathematical operations like negation, summation, multiplication, etc. Autodiff refers to automatic differentiation. I am able to compute (higher order) derivatives of recursive expressions over the operation.

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-04T17:49:17.195Z
Later I am going to implement optimization algorithms like gradient descent that need the first derivatives (gradients) of a mathematical function

                                                                                                                                                      Valentin Kasas @vil1@2017-09-04T17:56:23.880Z
I'll try to digest Runar's post, see you in a month ^^

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-04T18:03:18.425Z
Lol

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T18:06:37.352Z
@DanielPorter I think a graph may be useful for some operations, consider that Ensime uses a graph database internally

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T21:44:31.092Z
So i've been wrestling with this all day, and while i haven't solved it, i think i have distilled the issue i keep running into into a simple case.

Given an AST, how can i annotate the depth of each node, starting from zero?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T21:56:48.057Z
```scala
type PrescottASTInt[A] = EnvT[Int, PrescottAST, A]
type FASTI[A] = Fix[PrescottASTInt]
def annotateDepth(fast: FAST, depth: Int = 0): FASTI = fast.unFix match {
  case Block(b) => Fix[PrescottASTInt](EnvT(depth, Block(annotateDepth(b, depth + 1))))
}
```

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T21:59:34.044Z
so that's general recursion. is this unachievable with recursion schemes?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T21:59:43.957Z
No, it's not

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T21:59:53.049Z
I'm just showing you what it will be when you've inlined the scheme ;)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T22:00:20.836Z
There are a couple of things you can abstract over, here

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T22:00:55.269Z
ahh, alright :) in that case, yes, that definitely looks like what i'm after.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T22:01:38.984Z
I would take a look at `gana` or `gcata` maybe

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T22:02:21.642Z
how does one generate a distributive law?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T22:02:38.977Z
Look in the `matryoshka` package for some you may want

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T22:03:40.212Z
ahhhh. okay

                                                                                                                                                      Greg Pfeil @sellout@2017-09-04T23:03:32.441Z
@DanielPorter For _height_ it’s already there as `_.transCata(attributeAlgebra(height))`. You could then map over that, converting height to depth. Doing depth directly is a bit more complicated, as it’s corecursive. So you might have to do it with `Coalgebra[EnvT[Int, PrescottAST, ?], FAST]` as in @edmundnoble’s example.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T23:07:24.748Z
oh, cool. hadn't run across that.

I'm really using this as the simple case for how to see information from ancestors

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T23:08:36.051Z
so coalgebra's probably the path forward

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T00:15:23.498Z
Hm. still fairly befuddled. 

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T00:16:56.695Z
Wrote a dumb little coalgebra. this is obviously not fit for purpose, as i'm just wrapping it with an integer
```
  type FAST = Fix[PrestwoodAST]
  type PrestwoodASTI[A] = EnvT[Int, PrestwoodAST, A]
  def x: Coalgebra[PrestwoodASTI, FAST] = {
    case Fix(x) => EnvT(1, x)
  }
```

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T00:19:05.927Z
Wrote a GCoalgebra, but i'm not grokking the mechanics, and i'm getting a no implicit monad found for PrestwoodASTI
```
  type FASTI[A] = Fix[PrestwoodASTI]
  type FAST = Fix[PrestwoodAST]
  type PrestwoodASTI[A] = EnvT[Int, PrestwoodAST, A]
  def x: GCoalgebra[PrestwoodASTI, FASTI, FAST] = {
    case Fix(Assignment(Id(id), expr)) => Fix[PrestwoodASTI](EnvT(1, Id[Fix[PrestwoodASTI]]("")))
  }

  def dl = new DistributiveLaw[PrestwoodASTI, FASTI] {
    def apply[A](fa: PrestwoodASTI[FASTI[A]]): FASTI[A] = {
      Fix(fa)
    }
  }

  def ganarun(ast: FAST) = ast.gana[FASTI[FAST]][PrestwoodASTI, FASTI](dl, x)
```

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T00:22:48.582Z
which... looking at EnvT's definition, it says it's the tuple comonad, not a monad, so that makes sense

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T00:34:03.696Z
how does the value get carried from parent to child here?

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-05T00:44:15.735Z
hey @DanielPorter, trying to read your code. can you turn on scala syntax highlighting for your snippets? you can do that by adding the word "scala" immediately after the initial three accents

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T00:45:03.102Z
Okay! Won't let me edit it now, will repost:
```scala
  type FASTI[A] = Fix[PrestwoodASTI]
  type FAST = Fix[PrestwoodAST]
  type PrestwoodASTI[A] = EnvT[Int, PrestwoodAST, A]
  def x: GCoalgebra[PrestwoodASTI, FASTI, FAST] = {
    case Fix(Assignment(Id(id), expr)) => Fix[PrestwoodASTI](EnvT(1, Id[Fix[PrestwoodASTI]]("")))
  }

  def dl = new DistributiveLaw[PrestwoodASTI, FASTI] {
    def apply[A](fa: PrestwoodASTI[FASTI[A]]): FASTI[A] = {
      Fix(fa)
    }
  }

  def ganarun(ast: FAST) = ast.gana[FASTI[FAST]][PrestwoodASTI, FASTI](dl, x)
```

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-05T00:45:12.799Z
cool, thx

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T00:54:04.816Z
and so if the context isn't clear, my goal here is something that will annotate the AST with depth, as a jumping off point for being able to implement more interesting things which require access to information supplied by ancestors

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-05T00:54:49.829Z
I'll try to do the same with my ast tonight, maybe we can figure out together what's going on

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T00:55:09.376Z
:)

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T00:55:17.856Z
gonna be up for a couple more hours

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-05T00:55:51.486Z
me too. can I suggest you get the kind projector plugin? add `addCompilerPlugin("org.spire-math" %% "kind-projector" % "0.9.4")` to `build.sbt`.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T00:56:27.297Z
yeah, did so as per edmund's suggestion, but i guess it's not that useful if you don't use it..

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-05T00:56:28.514Z
then you can just write `Coalgebra[EnvT[Int, ExprF, ?], ...etc]`

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-05T00:56:43.408Z
`ExprF` is my ast

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-05T00:57:19.161Z
you can basically inline the type definition, and holes become `?`

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-05T00:57:35.666Z
I'll be back after dinner.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T00:57:42.532Z
okay! i'll be around

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-05T01:52:48.425Z
k, I'm back

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T01:52:59.776Z
so i've been staring at hylo hoping some meaning will fall out, and it... kind of has. I at least think i grok what hylo does, now. 

Hylo accepts a:A, psi, and phi. It applies psi to a which yields a functor, F[A]. It then maps over that functor, and applies hylo(a, psi, phi) to each a that gets returned, or in my case, each child. Eventually the mapping over the functor stops yielding results, and the results all have phi applied to them. 

So if you were going to encode passing information from one invocation of psi to the next, that functor's map function would have to yield that information. So that's where something like EnvT would come in, but its' map isn't sufficient -
```scala
  def map[B](f: A => B)(implicit W: Functor[W]): EnvT[E, W, B] =
    envT((run._1, run._2.map(f)))
}
```
it simply preserves the first value, and in the case where i'm just setting 1 for everything, you just recursively assign 1 to everything. So ideally then you'd want a functor that when mapped over returns an EnvT.



                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T01:53:17.743Z
ah, just collecting my thoughts here

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-05T01:55:54.232Z
hylo is a fusion of fold and unfold

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T01:56:47.692Z
Yeah, understood. I'm trying to use gana, but I got to hylo by recursively following the definitions

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-05T01:57:58.532Z
semantically hylo should be the same as doing cata and ana in succession

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-05T01:59:01.310Z
cf.
```scala
  def ana[A](a: A)(f: Coalgebra[Base, A])(implicit BF: Functor[Base]): T =
    hylo(a)(embed, f)
```
and
```scala
  def cata[A](t: T)(f: Algebra[Base, A])(implicit BF: Functor[Base]): A =
    hylo(t)(f, project)
```

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T02:00:57.914Z
hm, okay, so you're just passing in project and embed to make the corresponding traversal no-op-ish

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-05T02:01:29.099Z
yes, it's how `ana` and `cata` are defined in the `Recursive`/`Corecursive` traits

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T02:30:19.817Z
so reading how gana is implemented - you pass in a value A, which gana lifts into monad N, and passes to ana. It also passes an anonymous psi function, which maps over that monad, and applies the GCoalgebra to it that you passed in. This presumably yields N[Base[A]], where base is some functor, perhaps the Fix[AST] in my case? It applies the distributive law k to N[Base[A]], which should yield Base[N[A]]. It then maps over Base[N[A]] and calls join, which.. i'm a little confused about. the definition seems to be that it's doing liskov substitution, but i don't know what that means in this context

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T02:32:57.532Z
i looked around at your AST. my math background is a little lacking so it's rather intimidating

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-05T02:34:37.275Z
I'm trying to figure out what one is supposed to do with the GCoalgebra... not much luck yet, there are only two occurrences in Quasar, and they are both convoluted

                                                                                                                                                      Greg Pfeil @sellout@2017-09-05T02:34:43.805Z
@DanielPorter Sorry, I think I led you a bit astray – I accidentally dropped the depth counter when showing the coalgebra made from @edmundnoble’s example.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-05T02:35:13.701Z
You want perhaps:
```scala
def depth[T, F[_]: Functor](implicit T: Recursive.Aux[T, F])
    : Coalgebra[EnvT[Int, F, ?], (Int, T)] = {
  case (i, t) => EnvT(i, t.project strengthL (i + 1))
}
```

                                                                                                                                                      Greg Pfeil @sellout@2017-09-05T02:35:41.329Z
Then you would do `(0, myTree).ana[Cofree[F, Int]](depth)`

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T02:36:33.021Z
Ahhhh. Okay.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-05T02:42:08.534Z
You could also do the dual …
```scala
def depth[F[_]]: Algebra[F, Int => Cofree[F, Int]] =
  f => i => Cofree(i, f.map(_(i + 1)))
```

                                                                                                                                                      Greg Pfeil @sellout@2017-09-05T02:42:33.809Z
Which you then call as `myTree.cata(depth)(0)`

                                                                                                                                                      Greg Pfeil @sellout@2017-09-05T02:43:15.506Z
And that could also be generalized from Cofree to anything Corecursive with `EnvT` as its functor.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-05T02:45:23.488Z
In this case, it doesn’t matter much, but there are other times when you’re forced to go one direction or the other, so this shows you how to pass data from the root to the leaves regardless of which direction you traverse the nodes.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T02:46:10.272Z
okay, thanks so much. #1 isn't compiling, getting an implicit divergence error, and i need to spend some more time with these to make sense of them

                                                                                                                                                      Greg Pfeil @sellout@2017-09-05T02:47:02.694Z
Yeah … I didn’t try to compile either of them. Unlike Knuth I have neither proved it correct nor tried it.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T02:47:08.289Z
will have to pick this back up later, though. glad to know this is possible

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-05T02:47:21.033Z
I just got #1 working. Needed to add some type annotation:
```scala
  def expr[T](implicit T: Corecursive.Aux[T, ExprF]): T = ???

  def depth[T, F[_]: Functor](implicit T: Recursive.Aux[T, F]): Coalgebra[EnvT[Int, F, ?], (Int, T)] = {
    case (i, t) => EnvT((i, t.project strengthL (i + 1)))
  }

  val tmp: Nu[EnvT[Int, ExprF, ?]] = (0, expr[Nu[ExprF]]).ana[Nu[EnvT[Int, ExprF, ?]]](depth[Nu[ExprF], ExprF])

```

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T02:48:08.911Z
haha. yeah, not looking for copypasta. i've hit the 40 hour mark on trying to grok recursion schemes, though. glad to know that this simple thing is simply achievabl

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T02:48:11.537Z
achievable*

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T02:49:08.280Z
one question which has remained mysterious - how does EnvT become cofree?

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-05T02:49:57.926Z
to answer that I can recommend @tpolecat's talk from last year

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-05T02:50:36.682Z
https://github.com/tpolecat/cofree

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T02:51:25.338Z
okay! :) thanks @greg, @tscholak , and @edmundnoble for all of your help

                                                                                                                                                      Greg Pfeil @sellout@2017-09-05T02:51:56.794Z
@DanielPorter So, aside from the “explicit” fixed-points, `Fix`, `Mu`, and `Nu`, any structure can have Recursive/Corecursive instances simply by defining the mapping between the recursive type and its pattern functor. For Cofree, it’s https://github.com/slamdata/matryoshka/blob/master/core/shared/src/main/scala/matryoshka/data/cofree.scala#L25

                                                                                                                                                      Greg Pfeil @sellout@2017-09-05T02:52:13.707Z
And yes - @tpolecat’s talk is fantastic.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-05T02:52:26.783Z
It's a 10/10

                                                                                                                                                      Rob Norris @tpolecat@2017-09-05T02:53:26.382Z
:heart: 

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-05T02:53:49.140Z
:clap: 

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T02:55:06.037Z
hm, pattern functor is a new concept for me, but that's clear as far as it goes

                                                                                                                                                      Greg Pfeil @sellout@2017-09-05T02:57:22.817Z
@DanielPorter Yeah, it’s “just” a functor where the normally recursive references in a structure are replaced by an additional type parameter. For `List a = Nil | Cons a (List a)`, the pattern functor is `ListF a r = Nil | Cons a r`, so `List[A] = Fix[ListF[A, ?]]` (to mix some Haskell & Scala).

                                                                                                                                                      Greg Pfeil @sellout@2017-09-05T02:57:41.387Z
So it represents a single step of a recursive structure.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T13:30:47.317Z
Okay, gotcha. So the thing we stick in fix, mu, cofree etc

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T15:11:28.393Z
Ahh, alright. So a question I had was "what would I want to use Ana for", and... parsers came to mind. But as it is "creating" something, you could also frame it as "lifting" (if im allowed to use that word here) a structure into a recursive data type. It could already be a recursive data type that you're lifting into another one, e.g. 

                                                                                                                                                      Greg Pfeil @sellout@2017-09-05T15:12:11.754Z
Yes to both.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T15:13:10.165Z
a simple recursive data type into a pattern functor. Neat.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T15:18:18.768Z
Is that a common usage?

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T15:18:46.921Z
Ahh, gitter keeps sending messages I'm not done with

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-05T15:19:10.836Z
yeah, the mobile version does that sometimes

                                                                                                                                                      Greg Pfeil @sellout@2017-09-05T15:24:13.888Z
@DanielPorter Yeah, I think it’s pretty common – the `Transform` types and `trans` operations are basically some sugar to make that a bit easier.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-05T15:25:47.275Z
Where you can go, say `F[Fix[G]] => G[Fix[G]]` rather than `F[Fix[G]] => Fix[G]`

                                                                                                                                                      Greg Pfeil @sellout@2017-09-05T15:26:59.017Z
Although I guess it tends to be _more_ useful for the unfolds, where, with `Fix[F] => G[Fix[F]]` the first thing you do in the coalgebra is `project` so you get `F[Fix[F]]` to match on.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T15:51:11.452Z
@vil1 hey, if i'm understanding your problem correctly, i think greg and torsten came up with a solution - a working way to allow nodes to see information generated by their ancestors

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T15:57:39.083Z
But there's an important difference

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T15:58:51.361Z
I want to label the nodes of a tree A with the nodes of another tree B

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T15:59:38.210Z
More precisely, with subtrees of B

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T16:01:24.715Z
I want to label the root of A with B, its leftmost child with the subtree of B starting at its leftmost child an so on

                                                                                                                                                      Greg Pfeil @sellout@2017-09-05T16:02:15.773Z
@vil1 Sorry, can you link back to your problem? I missed a ton of stuff this weekend.

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T16:02:30.963Z
That resembles what Runar describes somwhere in the post mentioned above

                                                                                                                                                      Greg Pfeil @sellout@2017-09-05T16:02:34.582Z
(Which is so amazing to me – that there was too much discussion over a couple days for me to keep up with it!)

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T16:03:01.669Z
Ransom of success

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T16:03:38.151Z
I m currently on my phone and commuting, so expect me to be slow

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T16:03:40.786Z
But

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T16:04:28.872Z
I've two carrier functors, SchemaF and DataF

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T16:06:19.880Z
I need to "label" each "node" of DataF with the "subtrees" of the corresponding SchemaF

                                                                                                                                                      Greg Pfeil @sellout@2017-09-05T16:09:43.472Z
Oh, so you want to show which part of the schema each part of the data matches?

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T16:26:06.751Z
That's it

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T16:26:50.762Z
I need that to transform my DataF to an avro GenericContainer

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T16:27:09.825Z
(among other things)

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T16:59:04.042Z
hm. It still seems pretty similar -

```scala
def zipWithSubtrees[something goes here]: Coalgebra[EnvT[SchemaF, F, ?], (SchemaF, T)] = {
    case(schema, data) => EnvT(i, t.project zip (schema.toList))
}
(SchemaF, DataF).cata(zipWithSubtrees)
```



                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T17:01:20.809Z
(incidentally, as i better understand what you're doing - adding schemas to unstructured data, i think - i am getting a much better understanding of why slamdata would want matroyshka for their nosql analytics)

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T17:04:03.704Z
I don't see how a cata could destruct both SchemaF and DataF simultaneously  : /

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T17:04:54.165Z
(nota, I'm now on a train, I might loose service at some point)

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T17:08:15.164Z
I can try to define `type Pair[A] = (SchemaF[A], DataF[A])` with the relevant Functor instance

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T17:10:05.358Z
hm. must be a subtlety i'm not seeing there

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-05T17:10:53.142Z
Label with how many "subtrees"? A list of them?

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T17:11:56.674Z
@DanielPorter eg when there is an empty array of structs in the data

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T17:12:51.402Z
@edmundnoble only the one that describes the schema of the data represented by each node 

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T17:14:42.571Z
I'll try to be more specific

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T17:17:40.391Z
I have (eluding the fixpoint and simplifying schemas by removing metadata and stuff) :
```
val schema = StructF(List( "foos" -> ArrayF(StructF(List("qux" -> ValueF(Types.Int)))), "bar" -> ValueF(Types.String)))
val data = StructDataF(List( "foos" -> ArrayDataF(Nil), "bar" -> StringDataF("I'm a bar!")))
```

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T17:19:11.454Z
and I want to be able to "merge" both trees into a single one

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T17:19:47.335Z


                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T17:22:09.861Z
I ultimately want to use both `schema` and `data` to produce an `org.apache.avro.generic.GenericContainer` 

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T17:22:40.017Z
which looks roughly like this : `case class GenericContainer(datum: GenericContainer, schema: org.apache.avro.Schema)` (the real stuff is much more ugly and involves `java.lang.Object`)

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T17:23:42.273Z
I've already an algebra that allows me to cata a `SchemaF` into an `avro.Schema`

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T17:26:58.335Z
could the empty array of structs issue be solved by representing the array as a data type? 
```scala
ArrayF[A](array: Array[A]) extends DataF[A]
```

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T17:29:12.095Z
but in that case, `A` will be `Nothing` when the array's empty right ?

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T17:29:38.249Z
and empty arrays are just one of many problems

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T17:29:56.901Z
there can also be "unions" in the schema

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T17:30:32.969Z
like "Int or String or Boolean", that I cannot deduce from the data alone

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T17:32:44.378Z
i don't think it will be. I think you can parameterize it - 
```scala
ArrayF[Cofree[SchemaF, DataF]](Nil)
```

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T17:35:50.866Z
i'm not sure how the union would affect things, but I'm imagining it would just be another type of SchemaF, and you'd be able to see as you traverse the tree

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-05T17:38:14.838Z
You're forgetting a type argument for `DataF`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-05T17:39:20.894Z
I think the pattern functor you're looking for here @vil1 is something like this:
```scala
type Pat[A] = (DataF[A], Fix[SchemaF])
```

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-05T17:39:29.522Z
So you're making a `Fix[Pat]`

                                                                                                                                                      Greg Pfeil @sellout@2017-09-05T17:40:03.415Z
@edmundnoble And that looks exactly like `EnvT[Fix[SchemaF], DataF, A]`

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T17:40:08.841Z
hmmm

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-05T17:40:51.481Z
Well yeah, it does ;)

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T17:41:07.288Z
so I'd need to ana that rather than cata it right ? and along the way, peel off layers of that `Fix[SchemaF]` as I go down my `DataF` ?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-05T17:41:33.608Z
That sounds like it would work

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T17:42:53.832Z
lemme digest that while I'm traversing France at 225 km/h

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T17:43:06.424Z
BRB

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T17:44:54.384Z
still convinced it looks isomorphic to the depth annotation, so you could also use cata as in the example that greg gave

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T18:08:06.858Z
re

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T18:24:09.697Z
okay, I'm clearly missing something here

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T18:25:18.670Z
```scala
  type Pat[A] = (DataF[A], Fix[SchemaF])

  def label(schema: Fix[SchemaF]): Coalgebra[Pat, Fix[DataF]] = { 
    case Fix(data) => (data, schema)
  }

```

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T18:56:18.570Z
```scala
def expr[T](implicit T: Corecursive.Aux[T, DataF]): T = ???

def zipTogether[T, F[_]: Functor](implicit T: Recursive.Aux[T, F]): Coalgebra[EnvT[SchemaF, F, ?], (SchemaF, T)] = {
	case (schemaf, dataf) => EnvT((i, t.project zip (schemaf.getchildren))
}

val tmp: Nu[EnvT[SchemaF, DataF, ?]] = (0, expr[Nu[DataF]]).ana[Nu[EnvT[SchemaF, DataF, ?]]](depth[Nu[DataF], DataF])
```

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T18:58:42.499Z
put that together copying torsten's code, as he indicated he got that to compile. swapped out the ExprF for DataF, and the ints for SchemaF. you'll need a function to get the chilldren of the schema F to zip into the thing.

also many or all of those SchemaFs should be Fix[SchemaF], just accidentally omitted them again

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T19:00:09.927Z
i feel like a pattern functor's "map" could be implemented in terms of getChildren. i suspect i'm not the only person to make that observation. i noted there was some typeclass that autommatically derives a children and toList, but can't remember which one

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T19:38:31.184Z
(sorry I'm about to loose internet connection for a while)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T01:06:38.098Z
What's a good haskell library that does the mutual recursion (HFix and friends) stuff?

                                                                                                                                                      Greg Pfeil @sellout@2017-09-08T01:55:00.740Z
@Jacoby6000 compdata, in the Multi module.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-08T01:55:14.708Z
https://github.com/pa-ba/compdata/tree/master/src/Data/Comp/Multi

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-08T02:45:37.409Z
Oh, this is great stuff, thanks for the link! I dug around a bit and found http://dl.acm.org/citation.cfm?doid=2678015.2682539. This seems very relevant to my interests. I'll try to find the PDF.

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-08T02:47:16.833Z
It's here: http://bahr.io/pubs/files/bahr17scp-paper.pdf

                                                                                                                                                      Greg Pfeil @sellout@2017-09-08T02:57:47.414Z
I think another lib … maybe recursion-schemes also has some mutual recursion stuff … or maybe not, maybe I’m just thinking about HFunctor, etc.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-08T02:58:08.166Z
@tscholak Ah, yeah, that paper’s been on my to-read for a while.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-08T03:15:05.413Z
@Jacoby6000 Ah yeah, category-extras … but much less than compdata – https://hackage.haskell.org/package/category-extras-0.53.0/docs/Control-Functor-HigherOrder.html

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T15:35:48.146Z
@sellout Data/Comp/Multi looks like what I need. I'm new to haskell, and googling around for this stuff pointed me at other libs. This one looks the best

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T15:35:52.880Z
thanks!

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-08T16:08:40.934Z
@Jacoby6000 what are you going to do with this? there is still no way of getting mutual recursion to work with scala, is there? it's either dotty or another language. has anyone tried idris or ocaml? what about purescript?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-08T16:53:22.036Z
All you need is higher-kinded GADTs afaik


                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T17:10:33.988Z
@tscholak Yeah, what @edmundnoble said.  Idris is cool if you like dependent typing. Purescript is just haskell -> js IIRC. ETA looks promising for JVM stuff.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-08T17:11:19.103Z
Purescript has no GADTs, but they have leibniz, but they don't have roles
 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T17:12:06.290Z
Right now I'm going to try implementing [lambdapi](https://www.andres-loeh.de/LambdaPi/LambdaPi.pdf) and making an AST first programming language.. I'm going to try to throw in mutual recursion stuff to try to make the AST arbitrarily extensible. We'll see if it works out (it probably wont)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T17:15:40.698Z
I'm mostly doing it to teach myself about how compilers and type systems work

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T17:20:01.133Z
Oh also, dotty seems to work okay with GADTs, breaks with any variance and is actually just hard-coded to fail with variance. https://github.com/lampepfl/dotty/issues/2985 (which is fine by me). Biggest problem is that working with it currently isn't very friendly, and you'll run in to compiler crashes quite a bit.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-08T17:21:06.622Z
So, I _think_ that I could get the mutu branch working if I used type patterns for the algebras instead of “real” patterns.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-08T17:21:51.168Z
@nuttycom Definitely has some hand-written mutual recursion stuff that I _think_ works. Although we just hacked on a bunch of it today, so it probably doesn’t compile any more.

                                                                                                                                                      Rintcius Blok @rintcius@2017-09-08T17:54:15.348Z
@tscholak I have played with https://github.com/slamdata/purescript-matryoshka a bit - works quite nice I think

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-08T17:59:59.883Z
@Jacoby6000 I just had a better look at https://scastie.scala-lang.org/XbNz8MJ5TFycluoKETPl1A. It seems that, in dotty, you need that `Out` type to encode GADTs as described, e.g., in https://en.wikibooks.org/wiki/Haskell/GADT#GADTs. With this technique, are you also able to write and fold over algebras?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T18:32:24.536Z
@sellout I was experimenting in my [scoobie branch](https://github.com/Jacoby6000/scoobie/blob/dotty/plugins/dialects/ansi-sql/src/main/scala/scoobie/doobie/doo/ansi/SqlInterpreter.scala#L86).. I think it's possible, but I kept crashing the compiler, and my internal type-checker isn't good enough to tell if I'm wrong or if the compiler is just not good enough yet. 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T18:37:08.521Z
My syntax is definitely broken in there currently

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T18:37:24.684Z
I mucked about with it until I gave up. left it in disrepair

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T18:39:15.516Z
got the core AST compiling though, with its HFunctor.

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-08T18:44:54.643Z
HFunctor is from here: https://personal.cis.strath.ac.uk/neil.ghani/papers/ghani-popl08.pdf ?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T19:17:21.368Z
@sellout you made me want to poke more.  So far so good as far as writing an algebra

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T19:20:50.302Z
I'll dig in to this over the next few days and see if I can compose algebras for a fold.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-08T19:35:55.815Z
I still want to see kind polymorphism show up, so we can have a functor that is specialized to `F[_]` or `F[_[_], _]`, etc.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-08T19:36:06.368Z
@tscholak Yes.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T19:37:40.486Z
Paramorphism algebras seems to fail, because I can't use this HProject thing I made:

```scala
    object HProject {
      def unapply[X](f: F[ANSIAST, X]): Option[AST[X]] = Some(f.hproject)
    }
```
Those 3 lines crash the compiler.  `F` is `HRecursive` and `ANSIAST` is an `HFunctor`.  
A cata algebra should work fine though.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T19:38:01.360Z
If I can't match on sub-nodes, then para isn't much use without a bunch of clunkiness :/

                                                                                                                                                      Greg Pfeil @sellout@2017-09-08T19:39:26.109Z
@Jacoby6000 I’ve implemented `para` for higher-order recursion schemes. But I haven’t pushed it anywhere …

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T19:39:35.626Z
in dotty?

                                                                                                                                                      Greg Pfeil @sellout@2017-09-08T19:40:05.083Z
In Scala 2.11/12

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T19:40:26.741Z
eh. won't help then. Can't write my algebras in scala :/

                                                                                                                                                      Greg Pfeil @sellout@2017-09-08T19:40:34.148Z
```scala
  def para[A[_]]
    (φ: GAlgebra[Prod[T, ?[_], ?], HBase, A])
    (implicit HF: HFunctor[HBase])
      : T ~> A =
    λ[T ~> A](t =>
      φ(hproject(t).hmap(λ[T ~> (T :*: A)#λ](t => Prod((t, para(φ)(HF)(t)))))))
```

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T19:41:40.906Z
here's that in dotty (roughly)

```scala
    def para[F[_[_], _]: HFunctor, A[_]](
      φ: GAlgebra[[γ[_], α] => (T[F, α], γ[α]), F, A]):
    ([B] => T[F, B]) ~> A =
      new (([B] => T[F, B]) ~> A) {
        def apply[Q](t: T[F, Q]) =
          φ(HFunctor[F].hmap[[B] => T[F, B], [B] => (T[F, B], A[B])](
            new (([B] => T[F, B]) ~> ([B] => (T[F, B], A[B]))) {
              def apply[P](t: T[F, P]) = (t, para(φ).apply(t))
            })(hproject[F, Q](t)))
      }
```

                                                                                                                                                      Greg Pfeil @sellout@2017-09-08T19:41:44.131Z
Oh, `HProject` is an extractor for deep pattern matching on fixed points?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T19:41:50.315Z
@sellout yeah

                                                                                                                                                      Greg Pfeil @sellout@2017-09-08T19:42:06.382Z
I would call that `HEmbed`, actually, because the _apply_ is embed, and the unapply is project.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T19:42:26.793Z
Ah alright. I've hand written most of this, so most of it could be better, for sure.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-08T19:42:35.722Z
And you can specify (at least it Scala) that it returns `Some` not `Option`, so you don’t lose exhaustivity when you use it.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T19:42:38.426Z
I'll change the name, still doesn't fix it though :/ 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T19:45:22.053Z
let me tell you..writing some matryoshka subtitutes in dotty without KP is an amazing exercise, in the worst way.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T20:41:26.638Z
Got past the HEmbed thing. Removing the type annotation fixes it.  Now It's failing to compile a recursive call back to it's own algebra :/

                                                                                                                                                      Alex Gryzlov @clayrat@2017-09-10T11:20:37.272Z
@tscholak for Idris there's https://github.com/vmchale/recursion_schemes

                                                                                                                                                      andy scott @andyscott@2017-09-11T15:14:54.287Z
Is there any material available with examples on how to do general recursion with more complicated fixed point trees, where I have contraints on sub forests (that could typically be expressed as a simple type hierarchy for a traditional tree)?

                                                                                                                                                      andy scott @andyscott@2017-09-11T15:29:04.798Z
Mutual recursion. I saw some open/pending issues/PRs. But also I recall seeing a working example somewhere.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-11T15:43:42.796Z
@andyscott Yeah, there’s the PR for that, and I have much more locally to push to that PR. The problem is that scalac currently doesn’t like the way it uses GADTs. There is a workaround, and also an (in-progress) PR against scalac, but not finished. I know @nuttycom has some hand-written stuff to do the same, and someone else (sorry, I forget who) does as well.

                                                                                                                                                      andy scott @andyscott@2017-09-11T15:44:35.130Z
Yeah, there’s the open scalac PR about GADT pattern matching that’s needed, per the PRs to Matryoshka.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-11T15:45:37.744Z
Yeah, and I think that issue only affects defining algebras (which means it’s the test code that breaks in the Matryoshka PR) – you need to use `x: FooF` patterns instead of `FooF(a, b c)` patterns, IIRC.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-11T15:45:44.762Z
That‘s the workaround, I mean.

                                                                                                                                                      andy scott @andyscott@2017-09-11T15:46:05.909Z
Makes sense.

                                                                                                                                                      Valentin Kasas @vil1@2017-09-12T10:57:58.734Z
Hi guys, thank to your advice, I managed to solve my problem

                                                                                                                                                      Valentin Kasas @vil1@2017-09-12T10:58:52.792Z
@DanielPorter 's snipped helped a lot and now I think I understand how to work with `EnvT`, thanks !

                                                                                                                                                      Valentin Kasas @vil1@2017-09-12T10:59:41.238Z
(although it took me quite long to wrap my head around that)

                                                                                                                                                      Simon Hafner @reactormonk@2017-09-13T16:01:52.251Z
I've got a Fix[F], and a Foldable[F], any way to create a List[F] with all the elements?

                                                                                                                                                      Greg Pfeil @sellout@2017-09-13T16:41:20.108Z
@reactormonk What do you want the list to look like? There is a `toTree`. Do you want a list of all subtrees?

                                                                                                                                                      Greg Pfeil @sellout@2017-09-13T16:43:22.386Z
If so, you could do a paramorphism, like
```scala
fa => fa.map(_._1).embed :: fa.foldMap(_._2) :
    GAlgebra[(Fix[F], ?), F, List[Fix[F]]]
```

                                                                                                                                                      Greg Pfeil @sellout@2017-09-13T16:54:59.941Z
@reactormonk Re-reading your question – what are the “elements”?

                                                                                                                                                      Simon Hafner @reactormonk@2017-09-13T17:39:31.437Z
@sellout did a paramorphism in the end, pretty much that way.

                                                                                                                                                      Simon Hafner @reactormonk@2017-09-13T17:39:43.595Z
Except with only one `foldMap` ^^

                                                                                                                                                      andy scott @andyscott@2017-09-14T16:46:27.587Z
I previously had a `Coalgebra[Tree, TreeF]`, but I’ve adjusted my `TreeF` to be a mutually recusive structure. The mutally recursive coalgebra is defined as `A ~> F[A, ?]`, so what’s the proper way to convert my original coalgebra and treat values of Tree as functors `A[_]`? This is based off of the mutual recursion branches open against Matryoshka.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-14T17:56:59.566Z
I feel like I'm doing something wrong with my paramorphism.. I'm essentially requiring it to do the same work twice in this case:

```scala
case Not((ComparisonValueBinOp(HEmbed(_: Null[_, in]), right, Equal), _)) => 
  hRecursive.para[ANSIAST, Const](alg).apply(right) |+| litSql"IS NOT NULL "
```

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-14T17:57:01.552Z
Any ideas?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-14T17:57:55.900Z
I could get rid of this by duplicating the operator for equal, and making a NotEqual, but then I lose out on the composability of my Not node.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-14T19:10:41.928Z
@sellout By the way, I got dotty compiling my algebra for a paramorphism.

Here's the final result: https://github.com/Jacoby6000/scoobie/blob/dotty/plugins/dialects/ansi-sql/src/main/scala/scoobie/doobie/doo/ansi/SqlInterpreter.scala#L82

This is much simpler (aside from some of the match cases) than what I had back whenever I wasn't using GADTs.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-14T19:11:31.296Z
The parts of the code where I set up HFix/HRecursive and all that needs to be cleaned up, and the AST code could be a bit nicer. Overall I'm happy, though.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-14T19:37:55.226Z
Thanks for all your help :)

                                                                                                                                                      Greg Pfeil @sellout@2017-09-14T20:09:29.197Z
@Jacoby6000 💯 That’s awesome.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-14T20:10:11.105Z
re: your para problem … you might want a `histo` instead, which contains all the intermediate results.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-14T20:10:51.408Z
So then you can just `Cofree.head(right)` to get the value you had created when you first processed `right`.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-14T20:37:22.723Z
@sellout that's probably what I want. Having the algebra call back on itself feels dirty :p 

                                                                                                                                                      Greg Pfeil @sellout@2017-09-16T00:09:03.429Z
@Jacoby6000 Having the algebra call back on itself should trigger the `Recursion` wart if you enable it 😄

                                                                                                                                                      Emily Pillmore @emilypi@2017-09-16T17:14:34.480Z
@Jacoby6000 that is one hell of a pattern match

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-16T17:58:23.095Z
@emilypi most of that is because of the special cases for null. I have a feeling it'll get better whenever I change to histo. 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-16T20:49:57.250Z
@Jacoby6000 thinks about doing a dotty branch for matryoshka

                                                                                                                                                      Rintcius Blok @rintcius@2017-09-17T12:23:51.222Z
While updating #53  I encountered constructions like `Recursive[Arithmetic].cata(expr)(pprint)` (see https://github.com/slamdata/matryoshka/pull/91/files#diff-a4cfb0a5e406d01b98912565a0f83fbdR99 ). While I like the conciseness of these, I also found them a bit confusing, since it hides an `ana` (and also because there's another `cata` method that has a `T[F]` as first argument).  I would find something like this easier to understand (pseudo-code alert):  `expr.ana[ArithmeticF].cata(pprint)` or `Something.ana(expr).cata(pprint)`.  Do others share this or should I upgrade my mental model of this in some way?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-17T12:48:55.418Z
Is an ana followed by a cata not hylo?

                                                                                                                                                      Rintcius Blok @rintcius@2017-09-17T13:42:48.183Z
right... using just `hylo` would also unconfuse me

                                                                                                                                                      Rintcius Blok @rintcius@2017-09-17T13:59:08.918Z
so my confusion is about this: https://github.com/slamdata/matryoshka/blob/master/core/shared/src/main/scala/matryoshka/Recursive.scala#L34-L35 being named `cata` (need to forget about the first parameter here to make the name of this method  match up correctly)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-17T14:01:38.894Z
That is a cata, though

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-17T14:02:17.517Z
Cata is a version of hylo with the coalgebra set to project

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-17T14:02:22.665Z
`hylo(t)(f, project)` is `cata(t)(f)` and `hylo(t)(embed, g)`is `ana(t)(g)`

                                                                                                                                                      Rintcius Blok @rintcius@2017-09-17T14:07:33.826Z
hmm.. I find something like this intuitive: `exprF.cata(someAlgebra)` but not the above usage

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-17T14:09:11.405Z
you mean rather than `cata(expr)(someAlgebra)`?

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-17T14:09:50.873Z
where `cata` comes from a `Recursive` instance

                                                                                                                                                      Rintcius Blok @rintcius@2017-09-17T14:09:54.789Z
no I mean  I'd also find this ok: `Recursive[Arithmetic].cata(exprF)(pprint)`

                                                                                                                                                      Rintcius Blok @rintcius@2017-09-17T14:10:05.528Z
but it's an `expr` not an `exprF`

                                                                                                                                                      Rintcius Blok @rintcius@2017-09-17T14:11:42.796Z
(so it does the conversion of `expr` to `exprF` implicitly)

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-17T14:11:57.060Z
not sure I follow

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-17T14:12:01.876Z
what are the types of these?

                                                                                                                                                      Rintcius Blok @rintcius@2017-09-17T14:13:09.176Z
It's the example here: https://github.com/slamdata/matryoshka/pull/53/files#diff-a4cfb0a5e406d01b98912565a0f83fbdR98

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-17T14:14:30.580Z
ah, so you want to unfold `expr` into `exprF` and then fold it using `pprint`?

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-17T14:14:39.162Z
that's a hylo

                                                                                                                                                      Rintcius Blok @rintcius@2017-09-17T14:18:48.366Z
well.. if that method would have been called `hylo` I wouldn't have found it confusing, but it's called `cata`

                                                                                                                                                      Rintcius Blok @rintcius@2017-09-17T14:55:11.958Z
maybe I can better phrase my confusion as being: the conversion `expr` -> `exprF` happens implicitly, but it feels to be too important a conversion to do implicitly, since it hides that it does something like an `ana` 

                                                                                                                                                      Greg Pfeil @sellout@2017-09-17T15:28:54.190Z
@rintcius more later, but it's not hiding an Ana … that is just `expr.cata(pprint)`, but the implicit conversion isn't found in that case, so you have to write it using the `cata` method on the typeclass.

                                                                                                                                                      Rintcius Blok @rintcius@2017-09-17T20:54:04.295Z
Right, it's the fact that it's using a conversion implicitly that I find confusing.
I mean if we were to write `Recursive[Arithmetic].cata(expr)(evalAlgebra)` without implicit magic then it would be written as: `hylo[ArithmeticF, Arithmetic, Double](expr)(evalAlgebra, arithCoalgebra)`. 
The latter uses `hylo`, the function name that I would search for given the type I'm coming from and the type I want to end up with. You also have to explicitly provide all the important components `expr`, plus an algebra and a coalgebra.
However, the first uses the coalgebra implicitly and as a consequence you now have to use `cata` instead.
Similarly (but even more confusing), I could also have chosen to make the algebra implicit and have written: `Corecursive[Double].ana(expr)(arithCoalgebra)`.
All 3 examples give the same result, but the `ana` and `cata` seem to contain too much magic (for me anyway).

                                                                                                                                                      Greg Pfeil @sellout@2017-09-17T20:56:16.540Z
@rintcius Where is the implicit magic in `Recursive[Arithmetic].cata(expr)(evalAlgebra)`?

                                                                                                                                                      Rintcius Blok @rintcius@2017-09-17T20:58:03.933Z
that it uses `arithCoalgebra` to convert from `expr` to `exprF` implicitly

                                                                                                                                                      Greg Pfeil @sellout@2017-09-17T20:59:03.049Z
What is `arithCoalgebra`? It just uses `project`. That is how `cata` is defined.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-17T20:59:33.735Z
Strictly speaking, `cata(alg)` is _not_ `hylo(alg, project)`, though.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-17T21:00:04.388Z
Look at the implementation for `Mu` – `cata` has a definition that can’t be replaced with `hylo`.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-17T21:01:11.769Z
I have been tempted to not give `cata` a default definition, but that just means that making instances for directly-recursive types (like List, Free, Tree, etc.) is harder. Most of the time, the `hylo(…, project)` is what you want.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-17T21:03:59.811Z
`Corecursive[Double].ana(expr)(arithCoalgebra)` can’t give you the same result as `Recursive[Arithmetic].cata(expr)(evalAlgebra)`

                                                                                                                                                      Greg Pfeil @sellout@2017-09-17T21:05:24.745Z
The first can be seen as
```scala
hylo(_)(embed, arithCoalgebra): Double => Arithmetic
```
and the latter is
```scala
hylo(_)(evalAlgebra, project): Arithmetic => Double
```

                                                                                                                                                      Rintcius Blok @rintcius@2017-09-17T21:07:42.906Z
Hmm.. it _does_ give me the same result (by adding an implicit `Birecursive.Aux[Double, ArithmeticF] = Birecursive.algebraIso(evalAlgebra, dontcare)`)

                                                                                                                                                      Greg Pfeil @sellout@2017-09-17T21:08:15.410Z
Oh, yikes – you don’t want to be defining instances like that.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-17T21:08:32.850Z
First, I doubt whatever that is will pass the laws that are required.

                                                                                                                                                      Rintcius Blok @rintcius@2017-09-17T21:08:47.389Z
Yeah, that's true - it's ugly

                                                                                                                                                      Rintcius Blok @rintcius@2017-09-17T21:09:25.040Z
but hiding the other way around is almost as ugly

                                                                                                                                                      Greg Pfeil @sellout@2017-09-17T21:09:35.781Z
There’s no hiding. I don’t know what you mean.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-17T21:11:26.508Z
For that implicit to work, you’re claiming there’s an isomorphism between `Double` and `ArithmeticF[Double]` – which there isn’t.

                                                                                                                                                      Rintcius Blok @rintcius@2017-09-17T21:20:13.686Z
Also true, but I only need half of that "algebraIso", isn't it?

                                                                                                                                                      Greg Pfeil @sellout@2017-09-17T21:24:16.498Z
Well, you need half for `Recursive` operations (the `project` coalgebra), and you need the other half for `Corecursive` operations (the `embed` algebra). And `Birecursive` operations use both.

                                                                                                                                                      Rintcius Blok @rintcius@2017-09-17T21:28:48.556Z
As for that hiding, I mean it's hidden behind an implicit and for me it's hard to match up the use of `cata` together with an `expr` (I would expect it to work with an `exprF` instead) - I can see that `expr -> exprF` is taken care of by the implicit but it's not intuitive to me

                                                                                                                                                      Greg Pfeil @sellout@2017-09-17T21:29:49.667Z
@rintcius But the way you’re using it, there’s no implicit (other than the Functor constraint on ArithmeticF) – that’s what I’m confused about.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-17T21:30:50.870Z
Oh, I guess there is the implicit `Birecursive[Algebra]` that resolves to `Arithmetic.birecursive`. Sorry.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-17T21:32:09.253Z
@rintcius But that’s exactly what `cata` is defined to do – it takes a recursive structure and a function that applies to a single step of that structure and applies it over the entire tree.

                                                                                                                                                      Rintcius Blok @rintcius@2017-09-17T21:33:03.580Z
yes indeed, was just trying out without  that implicit :)

                                                                                                                                                      Greg Pfeil @sellout@2017-09-17T21:33:30.429Z
Well, you can just do `Arithmetic.birecursive.cata(expr)(evalAlgebra)`, and the implicit is gone now.

                                                                                                                                                      Rintcius Blok @rintcius@2017-09-17T21:43:49.286Z
Hmm... right... _something_ is dawning now - in my mind `cata` implied the use of a value like `exprF` as source, but that's wrong it works on directly recursive structures too

                                                                                                                                                      Rintcius Blok @rintcius@2017-09-17T21:48:53.400Z
Thanks for you explanations @sellout, much appreciated!

                                                                                                                                                      Greg Pfeil @sellout@2017-09-17T22:57:54.059Z
No problem! Happy to talk it through … sorry if it seemed disjointed … lots of interruptions on the weekend :D

                                                                                                                                                      andy scott @andyscott@2017-09-17T23:56:53.920Z
When doing mutual recursion, is there any way to constrain the “functor” I had to lift my values to? In my case, I have Scalameta trees that I convert to/from fixed point representations. If I do a hylo, I wind up with a `Id ~> Id` even though the natural transformation is really only valid for `Id[A]` such that `A = Tree`.

                                                                                                                                                      andy scott @andyscott@2017-09-17T23:59:57.838Z
Or related… what’s the appropriate way to define a Coalgebra to handle going from some type `A` to a mutually recusive structure `H[_[_], _]`? I have just defined it as `Coalgebra[Tree, Id]` in my specific case… where `A` is `Tree` and gets plugged into `Id` at some point.

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:01:17.564Z
And also… please excuse my terrible terminology… and by all means corrections are welcomed.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T00:07:05.570Z
@andyscott If you're doing what I think you are, I've had to fudge my algebras. I just do 
```scala
case class Result[A](a: A)
type MutuResult[A] = {
  type x[I] = Result[A]
}
```

And then I make an NT that does something like
```scala
Tree ~> MutuResult[A]#x
```

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:07:41.657Z
Here’s what I’m doing: https://github.com/andyscott/archetype/blob/master/modules/scalameta-fixedpoint/src/test/scala/scala/meta/fixedpoint/TreeChecks.scala#L28

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:08:07.108Z
And yeah… fudging has been required

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:09:22.821Z
I have also looked at redefining everything to allow bounds on the natural transformation. All my type classes would need to be adjusted accordingly, to take into account the world:
```
  class World[⊥, ⊤ >: ⊥] {
    trait BoundFunctionK[F[_ >: ⊥ <: ⊤], G[_ >: ⊥ <: ⊤]] {
      def apply[A >: ⊥ <: ⊤](fa: F[A]): G[A]
    }
    type ~|>[F[_ >: ⊥ <: ⊤], G[_ >: ⊥ <: ⊤]] = BoundFunctionK[F, G]
  }

  val treeWorld = new World[Nothing, Tree]
  import treeWorld._

  val foo: Id ~|> Id = ???

  foo(null: Tree) // compiles
  // foo(null: String) // doesn't

  type TreeId[A <: Tree] = A
  val bar: TreeId ~|> TreeId = ???

  bar(null: Tree) // compiles
  //bar(null: String) // doesn't
```

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:11:02.150Z
@Jacoby6000 In your case above, doesn’t that mean that each value has to be wrapped and unwrapped in the additional `Result` type as you traverse the recursive structure?

                                                                                                                                                      Greg Pfeil @sellout@2017-09-18T00:14:16.231Z
@andyscott `Tree` is of kind `*`?

                                                                                                                                                      Greg Pfeil @sellout@2017-09-18T00:15:16.907Z
Which muturec, you have like a `type HCoalgebra[F[_[_], _], A[_]] = A ~> F[A, ?]`

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:15:49.694Z
Yes

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:16:10.364Z
`Tree` is a `scala.meta.Tree` :)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T00:16:35.863Z
@andyscott yeah. Another way I've done it is by doing
```
type MutuResult[A] = {
  type x[I] = A
}
```

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:16:40.873Z
My algebras/coalgebras are defined as you described

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T00:16:43.396Z
It feels dirty no matter what I do

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:17:08.701Z
Do you use kind projector?

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:17:32.677Z
I was using `λ[a => A]` for a while, or a type `Const` defined like you have above.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T00:18:04.049Z
I used it whenever I could... scalac chokes whenever I try to write algebras, so now I just use dotty which doesn't get KP :( 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T00:18:13.062Z
but yeah, that's the same

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:18:18.180Z
I’ll have to try Dotty

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:18:26.030Z
I have crashed Scalac way too many times to count :)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T00:18:35.566Z
You'll crash dotty more ;)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T00:18:53.963Z
Dotty works when you get it right, usually... but when you get it wrong, you're on your own a lot of the time.

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:19:56.179Z
Heh. Well, it’s good to know that I am not the only one running into a host of issues. Comfort in collective discomfort I suppose.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T00:20:45.644Z
Yeah... It was great whenever I finally figured out how to get the extensibility I wanted in my lib... Not so great whenever I discovered scalac couldn't handle it.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T00:21:35.114Z
What I'm messing mutual recursion for is [this](https://github.com/jacoby6000/scoobie). 

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:22:10.665Z
Yep. I have been tracking your changes ever since @peterneyens pointed me to them.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T00:22:33.041Z
Well, at least maybe some people are getting some use from it then..

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:22:44.461Z
heh

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T00:23:00.277Z
Today i started work on making a basic FP lib, and I'm going to make a watered down version of matryoshka for dotty, so I can pull out the ugly from there.

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:23:51.357Z
you may be able to rip https://github.com/frees-io/iota/blob/master/modules/core/src/main/scala/iota/internal/catryoshka.scala as a base

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T00:24:37.784Z
Ooh nice

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:24:38.072Z
rip out all the cats stuff and use your own TCs for Dotty

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T00:24:39.846Z
I probably will

                                                                                                                                                      Greg Pfeil @sellout@2017-09-18T00:26:25.929Z
@andyscott So, if you want your `A` to be some proper type like `Tree`, you would use `HCoalgebra[F, Const[Tree, ?]]`

                                                                                                                                                      Greg Pfeil @sellout@2017-09-18T00:27:10.676Z
Using `HCoalgebra[F, Id]` would mean that you’re using values of the same type as your index.

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:28:43.159Z
`type Const[F[_[_], _], I] = F[K[Unit, ?], I]` ?

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:29:15.701Z
Tree is `*`, though

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T00:31:42.340Z
Have you successfully written an algebra with mutual recursion in scalac?  For me pattern matches don't work (scala/scala#5744)

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:31:57.172Z
yes

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:32:15.119Z
the first repo I linked to you has it working, albeit with `Id` and a hackey cast

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:33:04.689Z
https://github.com/andyscott/archetype/blob/master/modules/scalameta-fixedpoint/src/main/scala/scala/meta/fixedpoint/algebras.scala

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:34:13.703Z
cheating across the board to get it to work

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T00:38:58.430Z
That implicit def is the most genius piece of sadness I've laid my eyes on.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T00:39:14.903Z
it's so obvious

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T00:39:22.118Z
@Jacoby6000 tries it

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:39:37.557Z
lol

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T00:40:38.964Z
If this works, I'm gonna scream

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:40:58.628Z
I don’t know if obvious is the right word for it… behind that piece of sadness is probably several hours of painful tinkering spread out over a week or so.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-18T00:47:47.769Z
@andyscott No, just regular `type Const[A, B] = A`

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:48:12.165Z
I think I tried that. But I will try again :)

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:53:30.341Z
Aah yea

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:53:32.504Z
That doesn’t work

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:54:56.132Z
In `type Const[A, B] = A`, I need to establish that `B <: A` otherwise I invalidate the invariatns in my ASTs

                                                                                                                                                      Greg Pfeil @sellout@2017-09-18T00:55:20.596Z
But B is the type index …

                                                                                                                                                      Greg Pfeil @sellout@2017-09-18T00:55:41.483Z
Sorry, I’m running in-and-out. I can sit down and look in ~90 minutes.

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:56:03.879Z
err wait

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:56:09.080Z
hold on… again

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:56:15.960Z
I forgot to update one spot

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:57:18.738Z
No worries @sellout.

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:57:30.257Z
```
val lowerTree2 = new (Algebra[TreeF, Const[Tree, ?]]) {
    def apply[A](tree: TreeF[Const[Tree, ?], A]): Const[Tree, A] = tree match {
      case t: SourceF[Const[Tree, ?]]           => Source(t.stats)
      case t: TermF.ApplyInfixF[Const[Tree, ?]] => Term.ApplyInfix(t.lhs, t.op, t.targs, t.args)
      case t: TermF.NameF           => Term.Name(t.value)
      case t: LitF.IntF             => Lit.Int(t.value)
      case t: DefnF.ValF[Const[Tree, ?]]        => Defn.Val(t.mods, t.pats, t.decltpe, t.rhs)
      case t: PatF.VarF[Const[Tree, ?]]         => Pat.Var(t.name)
      case _                        => ???
    }
  }
```
is my updated algebra.

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:58:02.243Z
The problem is that when constructing the result, I get tons of errors along the lines of:
```
[error]  found   : scala.meta.Tree
[error]  required: scala.meta.Term
```
where `scala.meta.Term <:< scala.meta.Tree`

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T01:00:27.777Z
subtyping destroys everything on the index type (assuming that's what that is)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T01:00:39.841Z
even in dotty. 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T01:01:01.268Z
In fact, dotty is hard-coded to just fail if it sees variance on the index.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-18T01:03:21.082Z
@Jacoby6000 oh, that's too bad.

                                                                                                                                                      andy scott @andyscott@2017-09-18T01:04:31.740Z
@andyscott grumbles

                                                                                                                                                      andy scott @andyscott@2017-09-18T01:05:13.928Z
My fixed point structure has leaf nodes that are 1 to 1 with scala meta tree leaf nodes.

                                                                                                                                                      andy scott @andyscott@2017-09-18T01:05:31.002Z
Instead of defining my own indicies, I just used the original scalameta node types as the index markers.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T01:06:01.680Z
You might have to fall back on that and use composition to get something resembling subtyping.

                                                                                                                                                      andy scott @andyscott@2017-09-18T01:06:21.229Z
How so?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T01:06:23.039Z
(maybe... your hacks might make it all work out)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T01:07:06.240Z
`case class TreeTerm[A[_]](tree: A[Tree]) extends TreeF[A, Term]`

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T01:07:09.509Z
stuff like that.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T01:09:01.408Z
Also your trick seems to not work with a paramorphism :/

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T01:09:29.107Z
Assuming I'm doing it right here:
```scala
        implicit def `y u no typecheck?`[I](ast: Query[T, (AST :*: Const)#l, Indicies.Value]): Query[T, (AST :*: Const)#l, I] =
          ast.asInstanceOf[Query[T, (AST :*: Const)#l, I]]
```

                                                                                                                                                      andy scott @andyscott@2017-09-18T01:10:53.884Z
you probably need to rename it from `y u no typecheck?` to `y u no typecheck? PLEASE WORK PLEASE` to get it work for paramorphisms

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T01:11:38.826Z
Good call. I'll let you know if it works out

                                                                                                                                                      andy scott @andyscott@2017-09-18T01:23:02.337Z
I am currently writing things that should not be written in Scala.

                                                                                                                                                      andy scott @andyscott@2017-09-18T01:23:15.288Z
`type X[HH[_[_ >: ⊥ <: ⊤], _ >: ⊥ <: ⊤], FF[_ >: ⊥ <: ⊤]] = { type λ[A >: ⊥ <: ⊤] = HH[FF, A] }`

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T01:24:55.372Z
Well, be comforted knowing you're not alone

                                                                                                                                                      andy scott @andyscott@2017-09-18T01:26:32.153Z
variance on HK type params is rough

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T01:30:26.854Z
I think you can make your `y u no compile` thing a little bit more effective. Instead of making it only work on terms of type `Tree` as it is now, you could move it inside the `apply` definition, and replace `Tree` with the index that gets passed in on the `apply` method.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T01:31:35.876Z
I shouldn't be giving advice though, since I couldn't get it to work :p 

                                                                                                                                                      andy scott @andyscott@2017-09-18T01:31:45.144Z
lol

                                                                                                                                                      andy scott @andyscott@2017-09-18T01:32:06.654Z
You mean drop the type param `A` and instead use the existing param `A` bound by the apply definition?

                                                                                                                                                      andy scott @andyscott@2017-09-18T01:32:33.156Z
Not sure how to say that in a more confusing, or less confusing manner….

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T01:34:01.297Z
```scala
def apply[I](tree: ...) { 
  def y-u-no[X](tree: TreeF[Id, I]): TreeF[Id, X]
```

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T01:34:07.981Z
approximately

                                                                                                                                                      andy scott @andyscott@2017-09-18T01:39:18.699Z
yeah

                                                                                                                                                      andy scott @andyscott@2017-09-18T01:39:47.850Z
I only had it outside to avoid having to put additional brackets around my case statements

                                                                                                                                                      andy scott @andyscott@2017-09-18T01:53:17.498Z
I think I sorted out how to make this work while preserving sufficient type info. I’ll share a PR later, when I get a chance to implement it.

                                                                                                                                                      andy scott @andyscott@2017-09-18T06:08:33.617Z
@sellout @Jacoby6000 If you are curious: https://github.com/andyscott/archetype/pull/2

                                                                                                                                                      andy scott @andyscott@2017-09-18T06:09:33.703Z
```
  val roundTripTree: Id ~> Id = hylo(algebras.lowerTree, algebras.liftTree)

  roundTripTree(null: Tree) // compiles
  roundTripTree(null: String) // compilation error: inferred type arguments [String]
  //  do not conform to method apply's type parameter bounds [A >: scala.meta
  //  .fixedpoint.TreeChecks.roundTripTree.⊥ <: scala.meta.fixedpoint.TreeChecks.roundTripTree.⊤]
```

                                                                                                                                                      andy scott @andyscott@2017-09-18T06:09:52.274Z
which is the behavior I want

                                                                                                                                                      andy scott @andyscott@2017-09-18T06:10:48.791Z
Feel free to comment on the PR if there’s anything interesting to comment on

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T22:32:26.830Z
I still think it's weird to be tied to be using their nodes as index types. :p 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T22:32:57.910Z
Looks nice though. I might actually write macros if you manage to make it not-terrible.

                                                                                                                                                      andy scott @andyscott@2017-09-19T00:23:15.520Z
 use my own index type how would I write my lift/lower algebras?

                                                                                                                                                      andy scott @andyscott@2017-09-19T00:23:26.391Z
If I*

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-19T00:33:35.726Z
`Foo ~> Const[?, Tree]` or something 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-19T00:33:58.006Z
where `type Const[I, A] = A`

                                                                                                                                                      Greg Pfeil @sellout@2017-09-19T00:44:40.673Z
@Jacoby6000 the args to Const are reversed, but yes.

                                                                                                                                                      andy scott @andyscott@2017-09-19T01:23:02.492Z
Const is a constant and I need to vary the type with the index type

                                                                                                                                                      andy scott @andyscott@2017-09-19T01:23:56.086Z
I'll have to dig into the code and see if I can rewrite it to make that work

                                                                                                                                                      Greg Pfeil @sellout@2017-09-19T01:23:59.019Z
@andyscott You need to make a type-level function from the Indices to the types you want.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-19T01:24:50.142Z
Foo ~> TreeFrom

                                                                                                                                                      andy scott @andyscott@2017-09-19T01:26:14.073Z
How do I do that?

                                                                                                                                                      Greg Pfeil @sellout@2017-09-19T01:26:57.085Z
I don’t know exactly – I think I’ve seen it done … with type members somehow?

                                                                                                                                                      Greg Pfeil @sellout@2017-09-19T01:27:42.073Z
If you figure it out, that is a very important example for mutu-rec to document somewhere.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-19T01:30:32.698Z
Maybe something like a type class?
```scala
@typeclass TreeFrom[From] { type To }
implicit def meh: TreeFrom.Aux[Int, Bool] = new TreeFrom.Aux[Int, Bool] { }
Foo ~> TreeFrom[?]#To
```
😆

                                                                                                                                                      andy scott @andyscott@2017-09-19T01:30:33.690Z
Hahaha. Okay good. I had this thought earlier about needing type level functions but not knowing how to actually implement one cleanly.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-19T01:30:58.291Z
I mean, `Aux` is the closest I’ve gotten to Haskell type families, so ¯\\\_(ツ)_/¯

                                                                                                                                                      andy scott @andyscott@2017-09-19T01:31:04.663Z
Yeah you could use hackey implicits to compute the type 🤣

                                                                                                                                                      andy scott @andyscott@2017-09-19T01:31:58.121Z
I'd probably need to redefine Nat Trans to support this

                                                                                                                                                      andy scott @andyscott@2017-09-19T01:32:55.757Z
In my repo I had to redefine nat trans to achieve my goal by containing the top and bottom types.

                                                                                                                                                      LukaJCB @LukaJCB@2017-09-19T10:08:18.514Z
Hey guys, is there any ETA on a cats version of Matryoshka? Or anything we can do to help towards that goal? 🙂

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-19T10:29:55.589Z
I wouldn't bet on a cats version at all. The last thing I heard was that there's an idea to submit matryoshka to scalaz 

                                                                                                                                                      LukaJCB @LukaJCB@2017-09-19T10:35:36.887Z
Oh that’s too bad, I didn’t know https://http4s.github.io/fp-ecosystem/ was out of date

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-19T20:46:26.035Z
I'm trying to make sense out of the definition of hyloM. Got a couple of questions -
```scala
  def hyloM[M[_], F[_], A, B]
    (a: A)
    (f: AlgebraM[M, F, B], g: CoalgebraM[M, F, A])
    (implicit M: Monad[M], F: Traverse[F])
      : M[B] =
    hylo[(M ∘ F)#λ, A, M[B]](a)(_ >>= (_.sequence >>= f), g)(M compose F)
```
1. What does the expression `(M ∘ F)#λ` do? I think I've ascertained that the dot is the map operation, but i'm not entirely sure what mapping  over a monad with an instance of traverse means. 
2. What is the >>= operator?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-19T20:46:44.399Z
Dot is compose

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-19T20:46:56.664Z
Circle, rather

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-19T20:47:00.336Z
\>>= is flatMap

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-19T20:47:30.636Z
what's the difference between circle and the compose used farther down the expression?

                                                                                                                                                      Greg Pfeil @sellout@2017-09-19T20:47:45.262Z
@DanielPorter Type vs value level.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-19T20:48:52.144Z
`M compose F` composes the Monad[M] and Traverse[F], giving a Functor[M ∘ F]

                                                                                                                                                      Greg Pfeil @sellout@2017-09-19T20:53:46.026Z
So, you end up creating a hylo that first unfolds `A => M[F[A]]`, then folds `M[F[M[B]]] => M[B]`.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-19T20:54:29.529Z
 in the definition of hylo, circle is being used, but it seems to be operating at the value level.
```scala
  @SuppressWarnings(Array("org.wartremover.warts.Recursion"))
  def hylo[F[_]: Functor, A, B](a: A)(φ: Algebra[F, B], ψ: Coalgebra[F, A]): B =
    φ(ψ(a) ∘ (hylo(_)(φ, ψ)))
```

                                                                                                                                                      Greg Pfeil @sellout@2017-09-19T20:54:53.352Z
@DanielPorter That is the map operator 😄

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-19T20:54:57.451Z
lol

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-19T20:55:52.884Z
still undecided on whether FP is just really intellectual trolling or not. stuff like that tilts the scales towards yes

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-19T20:56:58.982Z
i suspect there must be some deeper relationship between compose and map that makes the circle operator applicable in both cases

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-19T21:01:57.962Z
i'm imagining that porting matroyshka to cats would mostly be a mechanical exercise, yeah?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-19T21:04:18.630Z
> still undecided on whether FP is just really intellectual trolling or not. stuff like that tilts the scales towards yes

Stuff like this only exists because they're commonly used things which have a single correct definition.  We don't go around writing `5 multiply 5`, for example.  Similarly, in the context of general recursion, you'll find yourself writing `compose` a lot, `A => F[A]`, etc;  I can't speak  for the unicode symbols though. I can probably correctly assume they come from mathematics.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-19T21:04:56.828Z
I don't think there is some deeper relationship, may be wrong


                                                                                                                                                      Greg Pfeil @sellout@2017-09-19T21:06:10.620Z
Well, function composition is `Functor[A => ?].map`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-19T21:06:16.673Z
Fair

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-19T21:06:21.707Z
Well

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-19T21:06:23.811Z
Kind of

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-19T21:28:14.227Z
@Jacoby6000 sure. i'm being tongue in cheek. but specifically what i'm being tongue in  cheek about is the (apparent) overloading of symbol meaning.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-19T21:28:28.374Z
This isn't a functional programming thing really

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-19T21:28:31.366Z
This is a matryoshka thing

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-19T21:29:17.168Z
oh. i had assumed those operators were scalaz, not from matroyshka

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-19T21:29:29.136Z
Right yes a scalaz thing

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-19T21:33:27.326Z
Overloading isn't something functional languages have in general, and type operators are mostly not used

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-19T21:39:50.994Z
Oh my bad, I didn't read the whole conversation, and thought you were talking about the whole definition of hylo

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T05:36:23.108Z
any chat for Kmett's recursion schemes or purescript matryoshka?

                                                                                                                                                      Greg Pfeil @sellout@2017-09-20T15:25:43.076Z
@xgrommx I don't know of anything dedicated, but SlamData also wrote the Purescript library and I use Kmett's at work, so this seems like a reasonable enough place.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T16:25:38.738Z
@sellout oh) do u use recursion-schemes from Kmett?

                                                                                                                                                      Greg Pfeil @sellout@2017-09-20T16:31:32.357Z
@xgrommx Yep. But we’re considering switching to compdata – the latter has more in the way of mutual-recursion, which we _might_ need.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-20T16:34:26.649Z
+1 for compdata. worked great for the mutual recursion stuff I did. All the auto derivation is good too

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T16:42:29.163Z
@sellout any interesting examples on haskell?)

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T16:43:41.779Z
do u mean https://hackage.haskell.org/package/compdata ?

                                                                                                                                                      Greg Pfeil @sellout@2017-09-20T16:45:11.873Z
Yep, that’s the one. I don’t have anything public in Haskell, and actually I’m _removing_ some uses, because apparently someone got really excited about recursion schemes (who wouldn’t be?!) and represented a lot of simple data types into complicated recursive ones.

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-20T16:47:42.492Z
lol

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-20T16:48:40.468Z
@tscholak I have a really simple example of using comp-data here. https://github.com/jacoby6000/extensible-ast-poc  
I write the AST for lambda calculus, and then extend it with primitive ints.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-20T16:48:48.468Z
er.. I meant @xgrommx 

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T16:49:04.961Z
https://hackage.haskell.org/package/recursion-schemes-ext-0.1.0.1/docs/Data-Foldable-Functor-Extensions.html

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-20T16:49:45.775Z
@Jacoby6000 I didn't ask for the example, @xgrommx did. I take it nonetheless.

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-20T16:50:14.095Z
I'm reading the compdata paper these days, and I'll be using it soon. Thanks!

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-20T16:51:01.950Z
My example is extremely basic.. I made it mostly to understand how to use compdata, and I'm still learning haskell.
All my algebra does is convert the ASTs to strings

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-20T16:51:40.436Z
my compdata project will be my first haskell project ;)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-20T16:52:29.470Z
Theoretically you could break it down where primitives have operations that only work on certain types of primitives, and then actually evaluate those things in an alg. 

Once I understand typed lambda calculus better, and then lambdapi calculus, I hope to make a language in lambdapi with an arbitrarily extensible ast using these ideas.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-20T16:52:57.638Z
@tscholak oh nice. It was my first haskell project too :p 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-20T16:53:14.786Z
The `Eval.hs` file gets a little hairy. feel free to ask questions.

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-20T16:54:05.791Z
cool, thank you

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T16:54:16.142Z
@Jacoby6000 this is phantom and I think it will be `Const` https://github.com/Jacoby6000/extensible-ast-poc/blob/master/src/AST/Alg/Eval.hs#L15

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-20T16:54:53.095Z
@xgrommx yeah, I figured as much. I couldn't get const to work the way i wanted to IIRC. I should try again now that I know more.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T16:56:10.337Z
I never use compdata. I only experimented with recursion-schemes

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-20T16:57:54.493Z
Oh something else to note, is I'm deriving a ton of stuff for my ASTs. All I need in these examples is an HFunctor

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T16:59:05.772Z
@Jacoby6000 from free-functor?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-20T16:59:14.913Z
From CompData

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-20T16:59:39.138Z
https://hackage.haskell.org/package/compdata-0.11/docs/Data-Comp-Multi-HFunctor.html

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T16:59:49.148Z
@Jacoby6000 I mean this https://github.com/sjoerdvisscher/free-functors

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-20T17:02:43.342Z
Huh that's interesting. I've never seen that before, but it looks like it'd sit along side the mutual recursion stuff really well

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T17:04:36.016Z
also https://github.com/sjoerdvisscher/algebraic-classes

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-20T17:05:54.566Z
I think compdata provides anything with algebras that you might need

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T17:06:51.570Z
about mutumorphism I wrote it
```hs
mutu :: Recursive t => (Base t (a, a) -> a) -> (Base t (a, a) -> a) -> t -> a
mutu = go where go f g = g . fmap (go g f &&& go f g) . project

evenOdd :: Nat -> Bool
evenOdd = mutu f g where
  f ZeroF = False
  f (SuccF (b, _)) = b
  g ZeroF = True
  g (SuccF(b, _)) = b
```

                                                                                                                                                      Greg Pfeil @sellout@2017-09-20T17:09:15.519Z
@xgrommx That’s not general enough to be mutu – should be https://github.com/slamdata/matryoshka/blob/master/core/shared/src/main/scala/matryoshka/Recursive.scala#L143

                                                                                                                                                      Greg Pfeil @sellout@2017-09-20T17:09:51.583Z
I.e. `F (A, B) -> B` and `F (B, A) -> A`

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T17:10:54.969Z
@sellout why?

                                                                                                                                                      Greg Pfeil @sellout@2017-09-20T17:11:34.123Z
I mean, it’s basically the same, right? You just need to generalize the types a bit.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-20T17:12:41.803Z
Should still work. Nothing other than the type signature is constraining your tuples.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-20T17:21:58.184Z
As for the “reason” … `zygo` is a special case of `mutu` where the “helper” algebra never refers to the result of the “primary” algebra. But that’s only true with the `(a, b)` tuple. Unfortunately, the comonadic model of recursion schemes can only encapsulate `zygo`, so `mutu` ends up being a bit hacky. Hence #46 which would bring `mutu` into the fold (pun intended).

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T17:32:59.217Z
zygo is dualism for apo?

                                                                                                                                                      Greg Pfeil @sellout@2017-09-20T17:33:29.738Z
Well, for a “generalized” apo – apo is dual to para (which is a further specialization of zygo).

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T17:33:47.976Z
oh

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T17:33:58.162Z
gapo

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T17:34:02.213Z
I forgot

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T17:34:35.003Z
maybe somebody know how will be `zygoM` on haskell?

                                                                                                                                                      Greg Pfeil @sellout@2017-09-20T17:34:51.471Z
If it weren’t for terrible type inference, I’d recommend just using `gcata` all the time, and passing in the distributive law you want.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-20T17:35:11.958Z
Oh, but in Haskell that would be fine :D

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T17:35:48.236Z
I cannot to write `zygoM` in haskell

                                                                                                                                                      Greg Pfeil @sellout@2017-09-20T17:35:55.611Z
I feel like the `zygo`/`apo`/etc. names are generally only useful to tie them to work from before there was a generalized model.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-20T17:36:08.682Z
@xgrommx Do you have a `gcataM`?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T17:37:32.645Z
looks like yes
```hs
gcataM :: (Recursive a1, Traversable w, Traversable (Base a1), Comonad w, Monad m) => (Base a1 (w (w a)) -> w (m b)) -> (m b -> m a) -> a1 -> m a
gcataM k g t = g $ extract =<< loop t where
  loop t = k <$> traverse (fmap duplicate . traverse g <=< loop) (project t)
```

                                                                                                                                                      Greg Pfeil @sellout@2017-09-20T17:38:58.307Z
@xgrommx That doesn’t look like the `gcataM` I know.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-20T17:40:08.152Z
You should have a signature like https://github.com/ekmett/recursion-schemes/blob/master/Data/Functor/Foldable.hs#L402 but just with `-> a` converted to `-> m a`

                                                                                                                                                      Greg Pfeil @sellout@2017-09-20T17:41:38.836Z
(and a couple new constraints – `Monad m` and `Traversable (Base t)`)

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T17:42:25.874Z
@sellout https://github.com/slamdata/purescript-matryoshka/blob/master/src/Matryoshka/Fold.purs#L80-L82

                                                                                                                                                      Greg Pfeil @sellout@2017-09-20T17:44:48.239Z
@xgrommx That one has an unnecessary `Traversable w` (I think), but otherwise looks like the one in Kmett’s. Yours looks different.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-20T17:45:23.765Z
Like, what is `m b -> m a`?

                                                                                                                                                      Greg Pfeil @sellout@2017-09-20T17:46:01.774Z
And the algebra should look like `Base a1 (w a) -> m a`, but you have an extra `w` on both sides.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T17:46:44.199Z
also `mutu :: Recursive t => (Base t (a, b) -> b) -> (Base t (b, a) -> a) -> t -> a` doesn't work

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T17:47:03.352Z
```
    • Couldn't match type ‘b’ with ‘a’
      ‘b’ is a rigid type variable bound by
        the type signature for:
          mutu :: forall t a b.
                  Recursive t =>
                  (Base t (a, b) -> b) -> (Base t (b, a) -> a) -> t -> a
        at src/Nat.hs:79:9
      ‘a’ is a rigid type variable bound by
        the type signature for:
          mutu :: forall t a b.
                  Recursive t =>
                  (Base t (a, b) -> b) -> (Base t (b, a) -> a) -> t -> a
        at src/Nat.hs:79:9
      Expected type: (Base t (a, b) -> b)
                     -> (Base t (b, a) -> a) -> t -> a
        Actual type: (Base t (a, a) -> a)
                     -> (Base t (a, a) -> a) -> t -> a
    • In the expression: go
      In an equation for ‘mutu’:
          mutu
            = go
            where
                go f g = g . fmap (go g f &&& go f g) . project
    • Relevant bindings include
        mutu :: (Base t (a, b) -> b) -> (Base t (b, a) -> a) -> t -> a
          (bound at src/Nat.hs:80:1)
```

                                                                                                                                                      Greg Pfeil @sellout@2017-09-20T17:48:41.126Z
@xgrommx Do you need to add `NoMonomorphismRestriction`?

                                                                                                                                                      Greg Pfeil @sellout@2017-09-20T17:49:13.410Z
Or, an explicit polymorphic type on `go`?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T19:05:42.661Z
yes, I have ScopedTypeVariables and NoMonomorphismRestriction

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T19:58:36.122Z
@sellout looks like commented type doesn't work with my `mutu`
```hs
mutu :: Recursive t => (Base t (a, a) -> a) -> (Base t (a, a) -> a) -> t -> a
-- mutu :: Recursive t => (Base t (a, b) -> b) -> (Base t (b, a) -> a) -> t -> a
mutu = go where go f g = g . fmap (go g f &&& go f g) . project
```

                                                                                                                                                      artjomg @artjomg@2017-09-25T19:52:25.782Z
Hi where is the repo https://github.com/slamdata/slamdata.git ? How can I install and use the open source version?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-26T01:16:10.713Z
@artjomg See my answer in slamdata/slamdata.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-26T03:51:39.574Z
so i'm assuming the answer to this question is yes, but worth asking - has anyone investigated using macros to create pattern functors from an AST? I'm looking at the intellij macro code and if I squint a little I think I see how you could define the pattern functor on a companion object with your macro and then let intellij know about it.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-26T03:54:17.839Z
@DanielPorter Haskell does it (https://github.com/ekmett/recursion-schemes/blob/master/Data/Functor/Foldable/TH.hs#L68), but I don’t think anyone has tried with Matryoshka.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-26T04:27:12.570Z
oh, neat.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-26T04:30:20.309Z
also - i'm back on this depth thing. started trying to implement typechecking on arangodb's language, AQL, want to do arbitrary annotations.

I got the example we worked out to compile with the prestwood AST:
```scala
  def tmp(ast: FAST): Nu[EnvT[Int, PrestwoodAST, ?]] = (0, ast).ana[Nu[EnvT[Int, PrestwoodAST, ?]]](depth[Fix[PrestwoodAST], PrestwoodAST])
```
but with this other SchemaF, it doesn't compile:
```scala
  def tmp(ast: Fix[SchemaF]): Fix[EnvT[Int, SchemaF, ?]] = (0, ast).ana[Fix[EnvT[Int, SchemaF, ?]]](depth[Fix[SchemaF], SchemaF])
```
I get a couple of type mismatch errors, and then a "implicit evidence not found" error, which I suspect is key -
`Error:(118, 100) could not find implicit value for evidence parameter of type scalaz.Functor[F]
  def tmp(ast: Fix[SchemaF]): Fix[EnvT[Int, SchemaF, ?]] = (0, ast).ana[Fix[EnvT[Int, SchemaF, ?]]](depth[Fix[SchemaF], SchemaF])`

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-26T04:31:47.444Z
If i didn't know any better, i'd think i didn't have a functor instance defined for SchemaF.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-26T04:33:07.169Z
figure there's some incantation i'm not doing, but not sure which one. the compiler gods are unappeased

                                                                                                                                                      Greg Pfeil @sellout@2017-09-26T04:39:11.783Z
@DanielPorter My guess, without looking at the code, is that `EnvT` is missing a `Functor` instance.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-26T04:39:41.898Z
I bet if you defined `Traverse[SchemaF]` instead of `Functor[SchemaF]`, it’d work.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-26T04:44:57.255Z
hm. actually have both of those defined

                                                                                                                                                      Greg Pfeil @sellout@2017-09-26T04:46:53.953Z
@DanielPorter Is one lower priority than the other? Also, there’s no need to also have a Functor instance for it, is there? You can always override `map` in the Traverse instance.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-26T04:47:58.265Z
no, there's no need for functor

                                                                                                                                                      Julien Truffaut @julien-truffaut@2017-09-27T09:54:01.040Z
does matryoshka has an implementation of loeb / moeb? (still trying to put my head around the haskell definition)

                                                                                                                                                      Greg Pfeil @sellout@2017-09-27T14:47:49.379Z
@julien-truffaut Damn you, sniper.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-27T14:51:31.624Z
Lmao

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-27T14:51:37.930Z
I think you need laziness for that to make sense

                                                                                                                                                      Greg Pfeil @sellout@2017-09-27T14:52:14.374Z
Definitely.

                                                                                                                                                      Julien Truffaut @julien-truffaut@2017-09-27T14:56:08.601Z
you mean lazy data structures like list in haskell?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-27T17:22:17.063Z
Like, pervasive laziness

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-27T17:22:19.163Z
Everything is lazy

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-27T17:22:54.578Z
Your functions aren't ever applied eagerly

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-27T17:23:20.211Z
As in, programs just construct graphs and drive their evaluation via case statements

                                                                                                                                                      Greg Pfeil @sellout@2017-09-27T17:32:09.674Z
@edmundnoble I’m thinking you could achieve that with `Partial` somehow, though. But I can’t afford to think about it today 😆

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-27T17:32:20.095Z
Maybe you can do it with a lazy comonad? Not sure

                                                                                                                                                      Valentin Kasas @vil1@2017-09-28T15:02:20.475Z
Hi there. I'm currently working on a scala meta annotation that generates a pattern-functor from a simple recursive ADT, along with a `Birecursive` instance and a `Traverse` one (when possible, that's WIP and looks bit tricky)

                                                                                                                                                      Valentin Kasas @vil1@2017-09-28T15:04:02.176Z
given 
```scala
@pattern
sealed trait Tree
object Tree {
  final case class Node(label: String, children: List[Tree]) extends Tree
  final case class Leaf(label: String)                       extends Tree
  case object EmptyTree                                      extends Tree
}
```
it expands to 
```scala
  sealed trait Tree
  object Tree {
    final case class Node(label: String, children: List[Tree]) extends Tree()
    final case class Leaf(label: String) extends Tree()
    case object EmptyTree extends Tree()
    sealed trait TreeF[A]
    final case class NodeF[A](label: String, children: List[A]) extends TreeF[A]
    final case class LeafF[A](label: String) extends TreeF[A]
    final case class EmptyTreeF[A]() extends TreeF[A]
    implicit val TreeTraverse: _root_.scalaz.Traverse[TreeF] = new _root_.scalaz.Traverse[TreeF] {
      import scala.language.higherKinds
      def traverseImpl[G[_], A, B](fa: TreeF[A])(f: A => G[B])(implicit ev: _root_.scalaz.Applicative[G]): G[TreeF[B]] = fa match {
        case NodeF(label, children) => ???
        case LeafF(label) => ???
        case EmptyTreeF() => ???
      }
    }
    implicit val TreeBirecursive: _root_.matryoshka.Birecursive[Tree] = new _root_.matryoshka.Birecursive[Tree] {
      type Base[A] = TreeF[A]
      def project(t: Tree)(implicit BF: _root_.scalaz.Functor[TreeF]): TreeF[Tree] = t match {
        case Node(label, children) =>
          NodeF(label, children)
        case Leaf(label) =>
          LeafF(label)
        case EmptyTree =>
          EmptyTreeF[Tree]()
      }
      def embed(t: TreeF[Tree])(implicit BF: _root_.scalaz.Functor[TreeF]): Tree = t match {
        case NodeF(label, children) =>
          Node(label, children)
        case LeafF(label) =>
          Leaf(label)
        case EmptyTreeF() =>
          EmptyTree
      }
    }
  }
```

                                                                                                                                                      Valentin Kasas @vil1@2017-09-28T15:06:41.778Z
I took that mainly as a way to get my hands dirty a learn a little scala.meta, but I wonder if wouldn't end up being something useful

                                                                                                                                                      Valentin Kasas @vil1@2017-09-28T15:06:47.445Z
what do you think?

                                                                                                                                                      Greg Pfeil @sellout@2017-09-28T15:09:16.654Z
@vil1 Wow, I was just talking to @Voltir about this yesterday. You’re magic. I think it would be great. Kmett’s recursion-schemes has something like this.

                                                                                                                                                      Valentin Kasas @vil1@2017-09-28T15:09:42.123Z
kewl

                                                                                                                                                      Valentin Kasas @vil1@2017-09-28T15:15:01.981Z
The traverse bit looks rather tricky to work out at the purely syntactic level (in the scala.meta world), but a limited version seems doable 

                                                                                                                                                      Valentin Kasas @vil1@2017-09-28T15:16:11.098Z
also I'm not a big fan of the subclasses of `Tree` defined in the companion object , but it seems to be the only way to see them during the annotation expansion

                                                                                                                                                      Valentin Kasas @vil1@2017-09-28T15:27:28.165Z
I've another question. There is a tut documentation module, but it is not published on `ghpages`, is that on purpose?

                                                                                                                                                      Greg Pfeil @sellout@2017-09-28T15:29:08.275Z
Not on purpose. Until like a week ago, it didn’t even have actual Matryoshka docs (@tpolecat had supplied the boilerplate), so having it published wasn’t a priority. Someone with access should publish it, I guess. (@edmundnoble?)

                                                                                                                                                      Valentin Kasas @vil1@2017-09-28T15:30:27.647Z
ok

                                                                                                                                                      Valentin Kasas @vil1@2017-09-28T15:30:57.013Z
I might PR some stuff there in a relatively near future

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-28T15:34:15.601Z
I can try, sure

                                                                                                                                                      Nick Childers @Voltir@2017-09-28T16:31:31.317Z
@vil1 If the limited semantic capabilities of scala.meta turn out to be to problematic, I think something similar could be done using the macro paradise plugin and whitebox macros - with the added advantage of having all the semantics of the context and types also available. 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-28T22:08:52.665Z
Scala meta macros will not be the official macro API and in fact have already been removed from master

                                                                                                                                                      ritschwumm @ritschwumm@2017-09-28T23:18:30.817Z
eh, what will be the official macro api then?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-28T23:31:52.022Z
It's not announced yet

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-28T23:31:56.205Z
Olaf is working on a roadmap

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-28T23:32:07.346Z
It's going to be similar to scala.meta but scala.meta is going to be for tooling and that's it

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-28T23:33:17.212Z
that's... unexpected

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-29T00:28:09.622Z
I was bringing this up in the scala/scala channel yesterday

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-29T00:28:19.873Z
Along with the fact that there's a distinct possibility that dotty will not be the new scalac

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-29T00:28:26.668Z
As things which apparently nobody knows

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-29T00:31:55.339Z
you are the vanguard of knowledge

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-29T00:49:04.908Z
I'm only passing on things I keep hearing from people, honestly some people need to start talking more

                                                                                                                                                      Valentin Kasas @vil1@2017-09-29T08:52:03.771Z
hmm that's unfortunate. I'm already quite deep down that rabbit's hole

                                                                                                                                                      Valentin Kasas @vil1@2017-09-29T08:53:22.214Z
so deep I'm dreaming of a "patternized" version of scala(meta/macro) ASTs I would be able to `cata` and stuff

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-29T14:06:48.250Z
i think we will have reached critical recursion when you can implement macros with recursion schemes using macros written with recursion schemes.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-29T14:07:22.839Z
i'm rooting for you, valentin :)

                                                                                                                                                      Valentin Kasas @vil1@2017-09-29T14:11:59.013Z
Dependency graphs of scala.macros and matryoshka becoming mutualy recursive 😁

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-29T14:36:35.324Z
@vil1 Andy Scott seems to be working on that

                                                                                                                                                      Valentin Kasas @vil1@2017-09-29T14:40:54.561Z
Holly Molly! Do you know where/how I can get involved?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-29T14:41:45.862Z
I'd look at his GitHub, @andyscott 

                                                                                                                                                      Valentin Kasas @vil1@2017-09-29T14:42:40.306Z
fair enough ;)

                                                                                                                                                      andy scott @andyscott@2017-09-29T15:29:06.745Z
Slowly working on it

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-29T15:29:47.011Z
seems to support mutual recursion :)

                                                                                                                                                      andy scott @andyscott@2017-09-29T15:30:40.479Z
My code or somewhere else?

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-29T15:30:57.698Z
yours, no? I see HFunctor, HFix, etc.

                                                                                                                                                      andy scott @andyscott@2017-09-29T15:32:49.243Z
I was hoping you saw more somewhere else, so I'd have more reference material

                                                                                                                                                      andy scott @andyscott@2017-09-29T15:33:18.851Z
But yeah-- I have hacked up mutual recursion working 

                                                                                                                                                      Valentin Kasas @vil1@2017-09-29T15:34:00.656Z
there are plenty of HThings in there https://github.com/nuttycom/xenomorph

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-29T15:34:12.449Z
was just going to post that

                                                                                                                                                      Valentin Kasas @vil1@2017-09-29T15:34:20.257Z
hehe

                                                                                                                                                      andy scott @andyscott@2017-09-29T15:35:09.842Z
Awesome, thanks!

                                                                                                                                                      Valentin Kasas @vil1@2017-09-29T15:41:23.407Z
there's also https://github.com/nuttycom/scala_world-2017

                                                                                                                                                      Valentin Kasas @vil1@2017-09-29T15:42:01.952Z
which I'm yet to completely understand, but I'm usually rather slow XD

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-29T16:28:28.747Z
It's a DDL

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-29T16:28:52.077Z
Not sure if you were at scala world, I got to see that talk but I was really, really tired

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-29T16:29:10.594Z
It's mostly for codec generation from what I saw

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-02T22:41:39.671Z
can someone help me?) https://stackoverflow.com/questions/46525571/an-example-for-chronomorphism

                                                                                                                                                      Greg Pfeil @sellout@2017-10-03T01:17:17.684Z
@xgrommx Is there something in particular on that page?

                                                                                                                                                      Greg Pfeil @sellout@2017-10-03T01:18:10.837Z
Oh weird … I clicked your link, but it took me to a different question …

                                                                                                                                                      Greg Pfeil @sellout@2017-10-03T01:57:18.946Z
@xgrommx I commented on ekmett/recursion-schemes#42 – I don’t think I have a StackOverflow account.

                                                                                                                                                      Torsten Scholak @tscholak@2017-10-03T02:30:19.983Z
That was a good question though. I learned something :)

                                                                                                                                                      Greg Pfeil @sellout@2017-10-03T02:31:12.063Z
Yeah, I don’t mean to criticize the question at all! Definitely don’t feel like it was a duplicate of that other one (which SO confusingly auto-redirected me to).

                                                                                                                                                      Greg Pfeil @sellout@2017-10-03T02:32:53.554Z
@xgrommx And I elided a lot of stuff in that comment – so please follow-up if it’s not clear what I mean (and I wouldn’t be surprised if Kmett or someone shows up and smacks me down, either 😄).

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-03T03:06:24.168Z
Kmett agrees about just using distributive laws

                                                                                                                                                      Greg Pfeil @sellout@2017-10-03T03:06:36.757Z
Noice!

                                                                                                                                                      Greg Pfeil @sellout@2017-10-03T03:06:56.418Z
But in Scala this all goes out the window, because then you need to provide a dozen type annotations.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-03T03:07:08.814Z
Yep :P

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-03T08:19:58.303Z
@sellout I answered you in github issue =)

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-03T08:21:57.612Z
Also I know about time traveling morhisms like a `futu` and `histo` but I don't know how can I create example with `chrono` :smile: 

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-03T08:48:30.946Z
and looks like `chrono` should be like a Tardis monad) (but this is only my opinion)

                                                                                                                                                      Daniel Porter @DanielPorter@2017-10-03T20:27:50.640Z
Hi, back once again on this depth-annotation-won't-compile thing - I've put together a  minimum example

                                                                                                                                                      Daniel Porter @DanielPorter@2017-10-03T20:27:51.060Z
https://gist.github.com/DanielPorter/b8adca7a35e8d1d50e2a3fccdd4e9cc3

                                                                                                                                                      Daniel Porter @DanielPorter@2017-10-03T20:33:32.864Z
it seems like it's failing to generate a corecursive instance for Fix[EnvT[etc]], EnvT

                                                                                                                                                      Daniel Porter @DanielPorter@2017-10-03T20:38:36.331Z
```scala
Error:(100, 95) could not find implicit value for parameter T: matryoshka.Corecursive.Aux[matryoshka.data.Fix[[γ$1$]matryoshka.patterns.EnvT[Int,rasit.migrateit.MoveITF,γ$1$]],[γ$2$]matryoshka.patterns.EnvT[Int,rasit.migrateit.MoveITF,γ$2$]]
  def tmp(ast: Fix[MoveITF]) = (0, ast).ana[Fix[EnvT[Int, MoveITF, ?]]][EnvT[Int, MoveITF, ?]](appld)
Error:(100, 95) not enough arguments for method apply: (implicit evidence$19: scalaz.Functor[[γ$2$]matryoshka.patterns.EnvT[Int,rasit.migrateit.MoveITF,γ$2$]], implicit T: matryoshka.Corecursive.Aux[matryoshka.data.Fix[[γ$1$]matryoshka.patterns.EnvT[Int,rasit.migrateit.MoveITF,γ$1$]],[γ$2$]matryoshka.patterns.EnvT[Int,rasit.migrateit.MoveITF,γ$2$]])matryoshka.data.Fix[[γ$1$]matryoshka.patterns.EnvT[Int,rasit.migrateit.MoveITF,γ$1$]] in class PartiallyApplied.
Unspecified value parameter T.
  def tmp(ast: Fix[MoveITF]) = (0, ast).ana[Fix[EnvT[Int, MoveITF, ?]]][EnvT[Int, MoveITF, ?]](appld)
```

                                                                                                                                                      Daniel Porter @DanielPorter@2017-10-03T21:13:20.815Z
Ohhhhhh. Doh. Swap that fix envt type parameter on Ana to a cofree and it works

                                                                                                                                                      Greg Pfeil @sellout@2017-10-04T00:09:13.274Z
@xgrommx Re: the `mutu` problem you had a while back, I found that if you don’t use `go`, the more general type works:

                                                                                                                                                      Greg Pfeil @sellout@2017-10-04T00:10:18.621Z
```scala
mutu
  :: (Recursive t f, Functor f)
  => GAlgebra ((,) a) f b
  -> GAlgebra ((,) b) f a
  -> t
  -> a
mutu φ' φ = φ . fmap (mutu φ φ' &&& mutu φ' φ) . project
```
(where `GAlgebra w f a = f w a -> a`)

                                                                                                                                                      Greg Pfeil @sellout@2017-10-04T00:11:32.296Z
@DanielPorter You’re saying that `.ana[Cofree[MoveITF, Int]]` works, but `.ana[Fix[EnvT[Int, MoveITF, ?]]]` doesn’t?

                                                                                                                                                      Greg Pfeil @sellout@2017-10-04T00:12:48.959Z
@DanielPorter What are your imports?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-04T07:50:33.551Z
@sellout wow! https://github.com/sellout/yaya I can add monadic versions =)

                                                                                                                                                      Greg Pfeil @sellout@2017-10-04T13:45:51.817Z
@xgrommx Cool. I have cataM and gcataM locally, but not the others yet.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-10-04T15:41:38.541Z
@sellout i'm using the imports in the gist just up the page

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-04T16:48:08.034Z
@sellout I cannot port zygoM from matryoshka =(

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-04T17:12:51.339Z
@sellout if u interested in some examples, several of them I had provide here https://github.com/vmchale/recursion_schemes/issues/5#issue-248280570 (also I have too much interesting experiments, but never publish it)

                                                                                                                                                      Greg Pfeil @sellout@2017-10-04T18:11:20.507Z
@xgrommx Don't bother porting zygoM, just use `zygoM = gcataM . distZygo`

                                                                                                                                                      Greg Pfeil @sellout@2017-10-04T18:12:35.286Z
Oh, I guess it's more complicated. Sorry, on my phone.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-04T18:40:43.239Z
oh) just `zygoM = gcataM . distZygo`? @sellout 

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-04T19:47:01.115Z
what is gcataM? do u have this implementation?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-04T20:08:56.218Z
why this code doesn't work? https://gist.github.com/danidiaz/e5debcaf531838eb6e2afd3ef3b34d60

                                                                                                                                                      Greg Pfeil @sellout@2017-10-05T01:20:57.409Z
@xgrommx Sorry, I hadn’t pushed it before: https://github.com/sellout/yaya/blob/master/src/Yaya/Control.hs#L36

                                                                                                                                                      Greg Pfeil @sellout@2017-10-05T01:33:25.801Z
@xgrommx But `zygoM` _is_ more complicated than that. I’ll try to get that pushed tonight.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-05T15:06:12.623Z
@xgrommx Ok, I confused myself. So, in Idris I wouldn’t _necessarily_ implement things like `paraM`. `paraM = gcataM $ distZygo embed`. If using `gcataM` infers properly, just use that directly. Also, `apoM = ganaM $ distGApo id`, `anaM = ganaM $ distAna`, `futuM = ganaM $ distGFutu id`, etc.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-05T15:06:39.137Z
Use `%default total` – I think a lot of your definitions (like `paraM`) won’t pass.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-05T15:07:56.739Z
Oh, and `zygoM` is a bit confusing. If you look at the pattern everywhere else `zygoM φ = gcataM $ distZygo φ` … but that doesn’t give you a monadic “helper” algebra.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-05T15:09:27.396Z
But, because of the pattern, I’d say that’s the correct definition for `zygoM`. You definitely _can_ implement a flavor of `zygoM` that does have a monadic helper, but I think it needs to be done without relying on `gcataM`.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-05T15:55:59.631Z
In matryoshka zygoM without gCataM or something

                                                                                                                                                      Greg Pfeil @sellout@2017-10-05T15:59:43.613Z
Right … Matryoshka gives you the richer definition – where the helper is also monadic.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-05T16:00:46.039Z
Well, it still uses gcataM, but it’s more complicated than just passing the right distributive law.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-05T16:05:01.207Z
I tried to port it to haskell, but... Maybe I don't understand scala)

                                                                                                                                                      Greg Pfeil @sellout@2017-10-05T16:14:42.846Z
@xgrommx https://github.com/sellout/yaya/blob/master/core/src/Yaya/Control.hs#L45

                                                                                                                                                      Greg Pfeil @sellout@2017-10-05T16:14:49.024Z
(just pushed it)

                                                                                                                                                      Greg Pfeil @sellout@2017-10-05T16:15:09.510Z
The Scala is definitely confusing to follow.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-05T16:28:05.969Z
@sellout nice! maybe some example with it?)

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-05T16:31:42.648Z
```hs
type ParaAlgebraM m t a = Base t (t, a) -> m a

paraM
  :: (Monad m, Traversable (Base t), Recursive t)
  => ParaAlgebraM m t a -> t -> m a
paraM alg = go where go t = alg =<< traverse (fmap (t,) . go) (project t)

anaM
  :: (Monad m, Traversable (Base t), Corecursive t)
  => (a -> m (Base t a)) -> a -> m t
anaM f = fmap embed . traverse (anaM f) <=< f
-- anaM coalg = a where
--   a = (return . embed) <=< traverse a <=< coalg

futuM :: (Corecursive t, Traversable (Base t), Monad m)
      => (a -> m (Base t (Free (Base t) a)))
      -> a
      -> m t
futuM coalg = anaM go . Pure
  where
    go (Pure a)  = coalg a
    go (Free fa) = return fa

apoM
  :: (Monad m, Traversable (Base t), Corecursive t)
  => (a -> m (Base t (Either t a))) -> a -> m t
apoM coalg = a where
  a = (return . embed) <=< traverse f <=< coalg
  f = either return a

hyloM
  :: (Monad m, Traversable t)
  => (t b -> m b) -> (a -> m (t a)) -> a -> m b
hyloM alg coalg = h
  where h = alg <=< traverse h <=< coalg
```

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-05T16:34:52.491Z
```hs
dyna' :: Functor f => (f (Cofree f b) -> b) -> (a -> f a) -> a -> b
dyna' a c = extract . hylo (\b -> a b :< b) c
```

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-05T16:35:26.877Z
or
```hs
dyna :: Functor f => (f (Cofree f a) -> a) -> (c -> f c) -> c -> a
dyna a c = extract . h
  where h = uncurry (:<) . (a &&& id) . fmap h . c
```

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-05T16:37:04.835Z
composition for algebras
```hs
infixr 9 <><

f <>< g = f . project . g
```

and we can `cata(alg1 <>< alg2 <>< alg3)`

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-05T16:40:01.089Z
maybe do u know how second function will be rewritten with recursion schemes?
```hs
polyPlus''' :: Num a => [a] -> [a] -> [a]
polyPlus''' =
  curry $ apo coalg where
    coalg :: Num a => ([a], [a]) -> ListF a (Either [a] ([a], [a]))
    coalg = \case
      ([], []) -> Nil
      ([], x:xs) -> Cons x $ Left xs
      (x:xs, []) -> Cons x $ Left xs
      (a:as, b:bs) -> Cons (a + b) $ Right (as, bs)

polyMult' (f:fs) gss@(g:gs) = f*g : polyPlus''' (polyMult' [f] gs) (polyMult' fs gss)
polyMult' _ _ = []
```

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-05T16:40:17.930Z
I talk about `polyMult'`

                                                                                                                                                      Olivier Mélois @Baccata@2017-10-14T22:22:18.369Z
Hey guys, I have no idea whether it'd be useful or not, and I suppose somebody already emitted the idea anyway, but I wanted to take a shot at implementing a stack safe `hylo`. Managed to do it using cats's`Eval` and increasing the requirement for `F[_]` from `Functor` to `Traverse`. [here's the code](https://gist.github.com/Baccata/5fb6e9784992b2a467aa1c846d4585c2). 

                                                                                                                                                      Olivier Mélois @Baccata@2017-10-14T22:25:20.168Z
Dumb benchmarks show the performance of that version isn't too bad 

                                                                                                                                                      Greg Pfeil @sellout@2017-10-14T23:15:09.622Z
@Baccata I think this is really useful. There’s been a _little_ discussion about how to handle stack-safety in general, and I don’t think we have a good solution. There is already `hyloM`, which (as with yours) requires `Traverse`. And `hyloM[Eval]` (or `Free.Trampoline`) should be stack-safe. However, it uses `A => M[F[A]]` (and `F[A] => M[A]`). I wonder if you could define a version like yours (without the `M` in the algebras) on top of `hyloM[Eval]`.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-14T23:19:51.396Z
@xgrommx Sorry, I’ve been away from Gitter for a while … looking at your stuff from a couple weeks ago now.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-14T23:20:15.027Z
hyloM with eval is not stack-safe

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-14T23:20:28.841Z
It can't be, because you need to guard the recursive call

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-14T23:20:35.557Z
`Monad` has no idea how to do that

                                                                                                                                                      Greg Pfeil @sellout@2017-10-14T23:22:09.444Z
@edmundnoble Hrmm, well stuff that overflows with `hylo` definitely doesn’t with `hyloM`. Doesn’t the fact that the result of the coalgebra is delayed handle that?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-14T23:25:37.768Z
It doesn't?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-14T23:25:44.368Z
It does with `cataM`

                                                                                                                                                      Greg Pfeil @sellout@2017-10-14T23:26:01.948Z
Wait, what? `cataM[Eval]` is definitely not stack-safe.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-14T23:26:12.778Z
It does *overflow* *

                                                                                                                                                      Greg Pfeil @sellout@2017-10-14T23:27:00.725Z
Ah – yeah, `cataM[Eval]` isn’t stack-safe, because it uses `M.pure`, which is not `delay`.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-14T23:27:49.527Z
But if the `A => Eval[F[A]]` coalgebra uses `delay`, then `hyloM` should be stack-safe.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-14T23:28:39.990Z
Right, true, that's the user's choice

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-14T23:28:56.897Z
This version uses `Eval.defer`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-14T23:29:20.421Z
I think actually letting the user decide may be better, that sounds like it means the user can control the stack bouncing

                                                                                                                                                      Olivier Mélois @Baccata@2017-10-14T23:32:18.193Z
I had misread the definition of `hyloM`. Hadn't notice it could provide type safety provided the coalgebra handles it  ! yay for learning things  :smile: 

                                                                                                                                                      Greg Pfeil @sellout@2017-10-14T23:32:44.856Z
Yeah, and that’s great for `hyloM`, but you can’t get a user-controlled stack-safe `cataM`. You need like an explicit `cataEval` that knows to `defer`. The problem is that because of inference issues, you can’t just have `gcataEval` and let users pass the `DistributiveLaw` they want, you need to provide `zygoEval`, `paraEval`, `histoEval`, etc. I mean, it’s just a bunch of annoying definitions over `gcataEval`, but still. Meh.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-14T23:33:29.807Z
I actually am not sure `hyloM` can do this.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-14T23:33:47.155Z
I guess `anaM[Eval]` is stack-safe? So it’s only the cata side of things that’s a problem.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-14T23:34:22.528Z
I really don't think either can be.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-14T23:34:41.963Z
These functions are `A => F[A]` not `(=> A) => F[A]`

                                                                                                                                                      Greg Pfeil @sellout@2017-10-14T23:34:46.277Z
@edmundnoble You mean, you’re not sure if @Baccata’s `hylo` can be defined in terms of `hyloM`? I think you may be right. But I was hoping someone thinking about it longer would solve it :D

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-14T23:35:35.977Z
I think up there I've found the reason. Even with a lazy monad, the ~~result~~ parameter has already been evaluated.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-14T23:38:10.101Z
But with `Eval.defer <<< ψ`, we’ve calculated `F[A]`, but then it should still defer the recursive call … no?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-14T23:38:24.698Z
We have an `F[A]` to pass to that, though

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-14T23:38:32.078Z
Not an `=> F[A]`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-14T23:38:54.415Z
Or rather an `A` and not an `=> A`, sorry, still not clear on the phi vs psi distinction ;)

                                                                                                                                                      Greg Pfeil @sellout@2017-10-14T23:39:33.552Z
ψ : A => F[A]

                                                                                                                                                      Greg Pfeil @sellout@2017-10-14T23:40:01.147Z
I see it as ψ opens it up, and φ folds it down … a visual mnemonic.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-14T23:40:07.164Z
Ah that helps!

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-14T23:40:19.068Z
Right yeah, the trouble is that the signature of that (`Eval.defer <<< up`) is still going to be adapted to `A => F[A]` which means the `A` is evaluated before calling

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-14T23:42:43.715Z
The caller has no knowledge that the function call could be lazy

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-15T02:26:31.253Z
@sellout oh)

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T03:38:35.307Z
@sellout Hello. I try to create monadic histomorphism but I don't know how...
```hs
histoM :: (Traversable f, Monad m) => (m (f (Cofree f a)) -> a) -> Fix f -> m a
histoM coalg = fmap extract . cataM (\x -> Cofree(Fix (CoBindF (coalg x) (fmap uncofree x))))
```

I create `histo` via `cata`
```hs
histo :: Functor f => (f (Cofree f a) -> a) -> Fix f -> a
histo f = extract . cata (\x -> Cofree(Fix (CoBindF (f x) (fmap uncofree x))))
```

could u please help my with `histoM`?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T04:01:32.958Z
@sellout Okay, looks like type is correct, but how about implementation?
```
histoM :: (Traversable f, Monad m) => (m (f (Cofree f a)) -> a) -> Fix f -> m a
histoM f = fmap extract . cataM (\x -> return(Cofree(Fix(CoBindF (f $ return x) (fmap uncofree x)))))
``` 

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T17:13:40.112Z
anybody can help me?
https://gist.github.com/xgrommx/8da8b1b1c5f55081656ede665e80ab40#file-fix-hs-L45-L46

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T18:21:31.013Z
@xgrommx Because Haskell is lazy, Fix ~ Nu (`Nu` makes the laziness explicit. In Scala, Fix ~ Mu), and both Free and Cofree should use Nu (in Haskell).

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T18:23:27.662Z
@xgrommx You might want to look at sellout/yaya – you can start with something like `anaM = ganaM distAna`, then manually expand the definition step by step.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T18:24:09.247Z
Oh, or start with `anaM = hyloM $ pure . embed`, and expand.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T18:24:38.189Z
That probably makes more sense, as `ganaM` is defined in terms of `anaM` 😆

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T18:26:08.702Z
but now is problem with `histoM`)

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T18:26:17.428Z
could you help me?)

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T18:27:06.389Z
also histo via cata
```hs
histo :: Functor f => (f (Cofree f c) -> c) -> Fix f -> c
histo f = extract . cata (\x -> Cofree(Fix (CoBindF (f x) (fmap uncofree x))))

histoM :: (Traversable f, Monad m) => (m (f (Cofree f a)) -> a) -> Fix f -> m a
histoM f = fmap extract . cataM (\x -> ...)
```

I think we can create `histoM` via `cataM`

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T18:27:54.118Z
@sellout what do u think?)

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T18:58:24.839Z
@xgrommx Yeah, start from `gcataM (disGHisto id)` and expand it out.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T19:16:40.147Z
hm

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T19:17:00.345Z
`gcataM (distGHisto id)` is `histoM`? @sellout

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T19:27:06.530Z
@sellout looks like no

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T19:30:12.474Z
@sellout maybe you could help me?)

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T19:32:24.700Z
@xgrommx it _should_ be. I think your type for HistoM is wrong … sorry, on my phone.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T19:33:16.129Z
I just revert functional arrow from `futuM`

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T19:34:14.592Z
`m (f (Cofree f a)) -> a` isn't generally implementable.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T19:34:55.715Z
histoM uses `f (Cofree f a) -> m a`.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T19:35:23.107Z
And you're right, that's not the dual of futuM.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T19:35:49.432Z
`futuM :: (Traversable f, Monad m) => (a -> m (f (Free f a))) -> a -> m (Fix f)` hm I think it should dual for `histoM`

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T19:36:17.210Z
To take the dual, you would have to flip _all_ the arrows, which means your Monad would become a Comonad as well.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T19:36:59.760Z
maybe you could help me later... thanks

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T19:37:53.689Z
As I understand `chronoM f g = histoM f <=< futuM g`

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T19:40:16.363Z
but why in `anaM` and `cataM` used `Monad m`?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T19:42:59.842Z
here also `Monad` but I don't understand how can I port it https://github.com/pa-ba/compdata-param/blob/079c5f34a2b433607a14b467c2e17af0d5df6ceb/src/Data/Comp/Param/Algebra.hs#L571-L578

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T19:59:10.547Z
Maybe I'm wrong but
```hs
chronoM :: (Traversable f, Monad m) => (m (f (Cofree f b)) -> b) -> (a -> m (f (Free f a))) -> a -> m b
chronoM f g = _x f <=< futuM g
```
`Found hole: _x :: (m (f (Cofree f b)) -> b) -> Fix f -> m b` and it should be type signature for `histoM`

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T20:34:20.974Z
@xgrommx It’s not possible to implement, that, though. Andi it’s only telling you that’s the signature because that’s what you gave it. Try

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T20:35:07.548Z
```haskell
chronoM :: (Traversable f, Monad m) => (f (Cofree f b) -> m b) -> (a -> m (f (Free f a))) -> a -> m b
chronoM f g = _x f <=< futuM g
```
and see what it tells you.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T20:36:42.963Z
With your type for `f`, you need a way to eliminate an arbitrary `Monad`, which isn’t a thing.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T20:43:55.961Z
@sellout what do u mean?

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T20:45:11.992Z
`m (f (Cofree f b)) -> b` has `m` in the parameter, but not in the result – how do you do that?

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T20:45:28.197Z
You can’t implement any `f`.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T20:46:00.985Z
ok, now I got this one `Found hole: _x :: (f (Cofree f b) -> m b) -> Fix f -> m b`

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T20:47:14.931Z
Yeah, that’s what you want. So, you can write the type for `histoM` and use that in place of _x.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T20:48:49.202Z
```hs
histoM :: (Traversable f, Monad m) => (f (Cofree f a) -> m a) -> Fix f -> m a
histoM = undefined

chronoM :: (Traversable f, Monad m) => (f (Cofree f b) -> m b) -> (a -> m (f (Free f a))) -> a -> m b
chronoM f g = histoM f <=< futuM g
```

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T20:48:52.656Z
okay

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T20:49:14.960Z
but I cannot realize how should be implemented `histoM`

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T20:51:11.982Z
Right … so the way _I_ implement it is via `gcataM`, because that works for any[†] Comonad, not just Cofree. ([†]: presuming you have a distributive law `f (w a) -> w (f a)` … which is what `distGHisto` is.)

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T20:51:18.431Z
```hs
histoM :: (Traversable f, Monad m) => (f (Cofree f a) -> m a) -> Fix f -> m a
histoM f = fmap extract . cataM (\x -> ?)
```

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T20:51:40.683Z
Yep!

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T20:52:01.405Z
but what is body in `cataM`?

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T20:52:08.024Z
So, `(traverse f . w . fmap duplicate)` is the argument to `cataM`.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T20:52:24.268Z
Now you just need to define `w`.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T20:52:35.172Z
Which, use `_w` to see what it needs to be.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T20:52:38.069Z
oh... help me =(

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T20:53:13.431Z
Sure. I’m definitely not doing any thinking at the moment, just pasting, so … lemme think.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T20:53:56.318Z
`cataM` is expecting some `g b -> m b` … but we don’t know what `g` and `b` are yet.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T20:54:55.928Z
`fmap extract` tells us that the result of `cataM` is `m (Cofree f a)`.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T20:56:04.686Z
Because `histoM` needs to return `m a`, and so we’re `fmap`ping over the `m` and using `extract` to get rid of _some_ Comonad … and the Comonad we have is `Cofree f`.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T20:59:10.276Z
okay, do u think it will be implemented via `cataM`?

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T21:06:30.184Z
Yes, definitely.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T21:07:05.283Z
So, `b` is `Cofree f a`.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T21:07:59.224Z
Ok, sorry on my phone again … back later :)

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T21:12:59.510Z
okay)

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T21:36:52.624Z
The short answer is that `w` should be replaced by `distGHisto id`. But figuring out what that means is the hard part.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T21:57:54.725Z
could u help me with Comonadic instance for Cofree? (my Cofree which I provided above)
```hs
instance Functor f => Comonad (Cofree f) where
    duplicate :: Cofree f a -> Cofree f (Cofree f a)
    duplicate w = Cofree(Fix(CoBindF w (fmap duplicate w)))
    extract (Cofree(Fix(CoBindF a _))) = a
```

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T21:58:19.616Z
Looks like some problem in `fmap duplicate w`

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T01:13:23.756Z
@xgrommx Are you saying that that doesn’t compile?

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T01:16:22.069Z
I’m guessing it’s because `duplicate` in `fmap duplicate w` is being applied to `Fix CofreeF`, not to `Cofree`. Maybe `fmap duplicate (Cofree w)`?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T05:52:35.086Z
@sellout no, now I got
```
/Users/dstoyano/work/app10/src/Free.hs:295:30: error:
    • Couldn't match kind ‘* -> *’ with ‘*’
      When matching the kind of ‘Fix’
      Expected type: CofreeF
                       (Cofree f0) (Cofree f a) (Fix (CofreeF (Cofree f0) (Cofree f a)))
        Actual type: CofreeF
                       (Cofree f0) (Cofree f a) (Fix (Fix (Cofree f a)))
    • In the first argument of ‘Fix’, namely
        ‘(CoBindF w (fmap duplicate (Cofree w)))’
      In the first argument of ‘Cofree’, namely
        ‘(Fix (CoBindF w (fmap duplicate (Cofree w))))’
      In the expression:
        Cofree (Fix (CoBindF w (fmap duplicate (Cofree w))))

/Users/dstoyano/work/app10/src/Free.hs:295:64: error:
    • Couldn't match expected type ‘Fix
                                      (CofreeF f0 (Fix (Cofree f a)))’
                  with actual type ‘Cofree f a’
    • In the first argument of ‘Cofree’, namely ‘w’
      In the second argument of ‘fmap’, namely ‘(Cofree w)’
      In the second argument of ‘CoBindF’, namely
        ‘(fmap duplicate (Cofree w))’
    • Relevant bindings include
        w :: Cofree f a
          (bound at /Users/dstoyano/work/app10/src/Free.hs:295:15)
        duplicate :: Cofree f a -> Cofree f (Cofree f a)
          (bound at /Users/dstoyano/work/app10/src/Free.hs:295:5)
Failed, modules loaded: none.
```

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T05:52:47.458Z
```hs
instance Functor f => Comonad (Cofree f) where
    duplicate :: Cofree f a -> Cofree f (Cofree f a)
    duplicate w = Cofree(Fix(CoBindF w (fmap duplicate (Cofree w))))
    extract (Cofree(Fix(CoBindF a _))) = a
```

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T06:00:59.390Z
@xgrommx Oh, whoops – you want to do `(fmap (duplicate . Cofree) (unwrap w))` (or something similar), where `unwrap (Cofree (Fix (CoBindF _ fr))) = fr`

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T06:16:29.703Z
@sellout do u mean `duplicate w = Cofree(Fix(CoBindF w (fmap (duplicate . Cofree) (_unwrap w))))`?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T06:16:52.037Z
```hs
_unwrap :: Cofree a b -> a (Fix (CofreeF a b))
_unwrap (Cofree(Fix(CoBindF _ as))) = as
```

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T06:23:25.408Z
Yep.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T06:26:02.097Z
I got new error. (I hate newtype :)) 
```
/Users/dstoyano/work/app10/src/Free.hs:300:30: error:
    • Couldn't match type ‘Cofree f (Cofree f a)’
                     with ‘Fix (CofreeF f (Cofree f a))’
      Expected type: CofreeF
                       f (Cofree f a) (Fix (CofreeF f (Cofree f a)))
        Actual type: CofreeF f (Cofree f a) (Cofree f (Cofree f a))
    • In the first argument of ‘Fix’, namely
        ‘(CoBindF w (fmap (duplicate . Cofree) (_unwrap w)))’
      In the first argument of ‘Cofree’, namely
        ‘(Fix (CoBindF w (fmap (duplicate . Cofree) (_unwrap w))))’
      In the expression:
        Cofree (Fix (CoBindF w (fmap (duplicate . Cofree) (_unwrap w))))
    • Relevant bindings include
        w :: Cofree f a
          (bound at /Users/dstoyano/work/app10/src/Free.hs:300:15)
        duplicate :: Cofree f a -> Cofree f (Cofree f a)
          (bound at /Users/dstoyano/work/app10/src/Free.hs:300:5)
Failed, modules loaded: none.
```

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T06:30:16.969Z
Ok, so I _think_ `(duplicate . Cofree)` has to be `(uncofree . duplicate . Cofree)`.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T06:31:51.395Z
wow!

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T06:33:20.332Z
another problem) I see u create `mutuM` via `cataM` I tried the same for `paraM` but got some errors
```hs
para :: Functor f => (f (Fix f, c) -> c) -> Fix f -> c
para psi = snd . cata ((Fix . fmap fst) &&& psi)

paraM :: (Traversable t, Monad m) => (t (Fix t, b) -> m b) -> Fix t -> m b
paraM f = fmap snd . cataM (bisequence . (Fix fmap fst &&& f))
```
in `Fix fmap fst `
```
/Users/dstoyano/work/app10/src/Free.hs:123:43: error:
    • Couldn't match expected type ‘((a0, b0) -> a0)
                                    -> t (Fix t, b) -> m (Fix t)’
                  with actual type ‘Fix ((->) (a1 -> b1))’
    • The function ‘Fix’ is applied to two arguments,
      but its type ‘((a1 -> b1) -> Fix ((->) (a1 -> b1)))
                    -> Fix ((->) (a1 -> b1))’
      has only one
      In the first argument of ‘(&&&)’, namely ‘Fix fmap fst’
      In the second argument of ‘(.)’, namely ‘(Fix fmap fst &&& f)’
    • Relevant bindings include
        f :: t (Fix t, b) -> m b
          (bound at /Users/dstoyano/work/app10/src/Free.hs:123:7)
        paraM :: (t (Fix t, b) -> m b) -> Fix t -> m b
          (bound at /Users/dstoyano/work/app10/src/Free.hs:123:1)

/Users/dstoyano/work/app10/src/Free.hs:123:47: error:
    • Couldn't match type ‘f0 a1 -> f0 b1’ with ‘Fix ((->) (a1 -> b1))’
      Expected type: (a1 -> b1) -> Fix ((->) (a1 -> b1))
        Actual type: (a1 -> b1) -> f0 a1 -> f0 b1
    • In the first argument of ‘Fix’, namely ‘fmap’
      In the first argument of ‘(&&&)’, namely ‘Fix fmap fst’
      In the second argument of ‘(.)’, namely ‘(Fix fmap fst &&& f)’
Failed, modules loaded: none.
```

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T06:34:13.529Z
Hah! I _just_ pushed that `mutuM` like an hour ago :D

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T06:35:43.618Z
yes) I like idea with `cataM`

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T06:35:49.647Z
Did you forget the `.` between `Fix` and `fmap`?

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T06:36:23.582Z
Also, you should only need `sequenceA`, not `bisequence` there.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T06:36:26.655Z
yep

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T06:36:46.276Z
wow!

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T06:37:17.720Z
and how about our discussion about `histoM`?)

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T06:37:53.698Z
Ahahaha – where did we leave it? I figured that’s why you were working on the Comonad Cofree instance.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T06:38:17.674Z
yes, Comonad is implemented

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T06:38:46.770Z
```hs
histoM :: (Traversable f, Monad m) => (f (Cofree f a) -> m a) -> Fix f -> m a
histoM f = fmap _extract . cataM (\x -> undefined)

chronoM :: (Traversable f, Monad m) => (f (Cofree f b) -> m b) -> (a -> m (f (Free f a))) -> a -> m b
chronoM f g = histoM f <=< futuM g
```

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T06:40:31.710Z
So
```haskell
histoM f = fmap extract . cataM (traverse f . distGHisto id . fmap duplicate)
```

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T06:41:04.723Z
Unexplained, because I really need to go to bed soon :D

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T06:41:46.363Z
But, `distGHisto id` is the thing to figure out – it’s `f (Cofree f a) -> Cofree f (f a)`

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T06:44:07.575Z
@sellout good night =)

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T06:44:19.452Z
and thanks again =)

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T06:44:39.843Z
I need go deeper to recursion schemes

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T06:44:50.963Z
No problem. It’s always fun to work through this stuff (for me, at least).

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T06:46:18.843Z
Kmett's version is ok for 
```hs
histoM :: (Traversable f, Comonad m, Monad m) => (f (Cofree f a) -> m a) -> Fix f -> m a
histoM f = fmap extract . cataM (traverse f . distGHisto id . fmap duplicate)

chronoM :: (Traversable f, Comonad m, Monad m) => (f (Cofree f b) -> m b) -> (a -> m (f (Free f a))) -> a -> m b
chronoM f g = histoM f <=< futuM g
```
Now I need create it for my Cofree via Fix

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T06:58:24.525Z
strange result for your new version of `mutu`
Old
```hs
mutu':: Recursive t => (Base t (a, b) -> b) -> (Base t (b, a) -> a) -> t -> a
mutu' φ' φ = φ . fmap (mutu' φ φ' &&& mutu' φ' φ) . project

evenOdd :: Nat -> Bool
evenOdd = mutu' f g where
  f ZeroF = False
  f (SuccF (b, _)) = b
  g ZeroF = True
  g (SuccF(b, _)) = b

evenOdd 10 -- True
```

New
```hs
mutu :: Recursive t => (Base t (b, a) -> b) -> (Base t (b, a) -> a) -> t -> a
mutu f g = snd . cata (f &&& g)

evenOdd' :: Nat -> Bool
evenOdd' = mutu f g where
  f ZeroF = False
  f (SuccF (b, _)) = b
  g ZeroF = True
  g (SuccF(b, _)) = b

evenOdd' 10 -- False
```

Looks like for new it isn't correct result

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T06:59:09.189Z
Because `even 10` should be `True`

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T06:59:43.595Z
@xgrommx Yeah … the new one has a different type for `f :: Base t (b, a) -> b`.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T07:00:54.106Z
That’s actually the way it’s defined in the literature, but I’m not sure if I like it. To get the old signature back, you could do
```haskell
mutu':: Recursive t => (Base t (a, b) -> b) -> (Base t (b, a) -> a) -> t -> a
mutu' f g = snd . cata (f . fmap swap &&& g)
```

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T07:01:05.412Z
(`fmap swap` being the difference)

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T07:02:48.053Z
I like that with my previous def, both parameters were `GAlgebra`s. The new way matches the papers and avoids the `fmap swap`.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T07:03:30.335Z
but why old version isn't correct?
```
*Nat> even 10
True
*Nat> evenOdd 10
True
*Nat> evenOdd' 10
False
*Nat>
```

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T07:03:49.375Z
To fix your `evenOdd'`, I think just change `f (SuccF (b, _)) = b` to `f (SuccF (_, b)) = b`

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T07:04:03.799Z
flipped arguments?)

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T07:04:08.840Z
Yep.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T07:04:48.718Z
I’m inclined to change it back … gotta sleep on it :D

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T07:04:53.786Z
hm, looks good
```
*Nat> even 10
True
*Nat> evenOdd 10
True
*Nat> evenOdd' 10
True
*Nat> evenOdd 3
False
*Nat> evenOdd' 3
True
```

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T07:05:10.138Z
That last one daesn’t look good …

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T07:05:29.076Z
oh sure

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T07:05:40.750Z
now, it always True

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T07:05:52.159Z
Did you change the argument order to `g` as well?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T07:06:24.630Z
I did it in both...

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T07:06:35.262Z
now I change only in first function

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T07:06:36.280Z
Only `f` needed it.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T07:06:41.625Z
```hs
evenOdd' :: Nat -> Bool
evenOdd' = mutu' f g where
  f ZeroF = False
  f (SuccF (_, b)) = b
  g ZeroF = True
  g (SuccF(b, _)) = b
```

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T07:06:44.254Z
👍🏼

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T07:07:05.725Z
But tomorrow I might switch it back and break your code again 😆

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T07:07:12.906Z
why we have 2 versions of `mutu`?)

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T07:07:48.696Z
There should only be the one. I thought I deleted the old one. Maybe I didn’t commit that …

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T07:08:10.121Z
Hrmm, I did. Should be good.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T07:13:46.302Z
So, a practical reason I liked the old one is that with your function, `mutu f g` returns `True` when even and `False` when odd, but `mutu g f` would return `False` when even and `True` when odd. With the new version, I don’t think you can do that.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T07:14:41.407Z
It might do something reasonable in this case, but when `a` and `b` are different types, it can’t do anything good to switch the parameter order.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T07:15:14.843Z
Pretty sure I’m going to switch it back tomorrow – sorry for breaking your code :D

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T07:16:47.768Z
@sellout don't worry) This is only my experiments, I don't know what is version of `mutu` will be correct

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T07:18:15.943Z
I use this classic version of mutual recursion
```hs
even :: Int -> Bool
even 0 = True
even n = odd (n - 1)

odd :: Int -> Bool
odd 0 = False
odd n = even (n - 1)
```

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T06:58:15.325Z
@sellout Hello) How can I solve this problem?)
```hs
chronoM :: (Corecursive a1, Recursive a1, Traversable (Base a1), Monad m) => (Base a1 (Cofree (Base a1) c) -> m c) -> (a -> m (Base a1 (Free (Base a1) a))) -> a -> m c
chronoM f g = histoM f <=< futuM g 
```

```
/Users/dstoyano/work/app10/src/Experiments2.hs:1670:22: error:
    • Couldn't match type ‘Base a10’ with ‘Base a1’
      Expected type: Base a10 (Cofree (Base a10) c) -> m c
        Actual type: Base a1 (Cofree (Base a1) c) -> m c
      NB: ‘Base’ is a type function, and may not be injective
      The type variable ‘a10’ is ambiguous
    • In the first argument of ‘histoM’, namely ‘f’
      In the first argument of ‘(<=<)’, namely ‘histoM f’
      In the expression: histoM f <=< futuM g
    • Relevant bindings include
        g :: a -> m (Base a1 (Free (Base a1) a))
          (bound at /Users/dstoyano/work/app10/src/Experiments2.hs:1670:11)
        f :: Base a1 (Cofree (Base a1) c) -> m c
          (bound at /Users/dstoyano/work/app10/src/Experiments2.hs:1670:9)
        chronoM :: (Base a1 (Cofree (Base a1) c) -> m c)
                   -> (a -> m (Base a1 (Free (Base a1) a))) -> a -> m c
          (bound at /Users/dstoyano/work/app10/src/Experiments2.hs:1670:1)
Failed, modules loaded: none.
```

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T14:47:48.735Z
@xgrommx Because there’s nothing that determines what `a1` is in that definition. Two of your options are to `AllowAmbiguousTypes` and have some caller use `TypeApplications` to specify which `a1` they want, or to just add an annotation here, like `:: a -> Fix f`, and replace all the mentions of `Base a1` with `f`.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T17:02:54.570Z
@sellout Sorry, could you please explain it?

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T17:14:10.537Z
@xgrommx I’ll give it a go … `futuM g` returns `a1`, `histoM f` consumes `a1`, but there is no `a1` either being passed to or returned from `chronoM`. So GHC has to infer the type. But there can be multiple types that satisfy `Corecursive a1, Recursive a1` with a `Base`. So GHC can’t infer one.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T17:15:13.897Z
E.g., `Fix f` and `Nu f` are two things that satisfy that regardless of what `Base a1` is.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T17:18:23.638Z
When I'll be home, I'll try it and notify you about result. Thanks

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T19:47:34.673Z
@sellout and what is should be my signature?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T19:48:24.340Z
```hs
futuM :: (Corecursive t, Traversable (Base t), Monad m) => (a -> m (Base t (Free (Base t) a))) -> a -> m t
futuM coalg = anaM go . Pure where
  go (Pure a)  = coalg a
  go (Free fa) = return fa

histoM :: (Traversable (Base a1), Recursive a1, Monad f) => (Base a1 (Cofree (Base a1) a) -> f a) -> a1 -> f a
histoM f = fmap extract . cataM (traverse f . distGHisto id . fmap duplicate)

chronoM :: (Corecursive a1, Recursive a1, Traversable (Base a1), Comonad m, Monad m) => (Base a1 (Cofree (Base a1) c) -> m c) -> (a -> m (Base a1 (Free (Base a1) a))) -> a -> m c
chronoM f g = histoM f <=< futuM g
```

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T19:48:47.152Z
 @xgrommx `chronoM :: (Traversable f, Monad m) => (f (Cofree f c) -> m c) -> (a -> m (f (Free f a))) -> a -> m c`

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:06:56.035Z
how about `zygoM` via `cataM`?
```hs
zygoM :: (Monad (Base a1), Traversable (Base a1), Recursive a1) => (Base a1 b -> Base a1 b) -> (Base a1 (b, a) -> Base a1 a) -> a1 -> Base a1 a
zygoM φ' φ =
  gcataM (distZygo (φ' <=< sequenceA))
                   (φ <=< traverse (fmap swap . sequenceA . swap)) 
                         
zygoM' :: (Recursive a, Traversable (Base a), Monad f) => (Base a b1 -> f b1) -> (Base a (b1, b) -> f b) -> a -> f b
zygoM' g f = fmap snd . cataM(bisequence . (g . fmap fst &&& f))  
```

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:09:14.639Z
@sellout I got it
```
/Users/dstoyano/work/app10/src/Experiments2.hs:1668:34: error:
    • Couldn't match type ‘f’ with ‘Base a10’
      ‘f’ is a rigid type variable bound by
        the type signature for:
          chronoM :: forall (f :: * -> *) (m :: * -> *) c a.
                     (Traversable f, Monad m) =>
                     (f (Cofree f c) -> m c) -> (a -> m (f (Free f a))) -> a -> m c
        at /Users/dstoyano/work/app10/src/Experiments2.hs:1667:12
      Expected type: a -> m (Base a10 (Free (Base a10) a))
        Actual type: a -> m (f (Free f a))
    • In the first argument of ‘futuM’, namely ‘g’
      In the second argument of ‘(<=<)’, namely ‘futuM g’
      In the expression: histoM f <=< futuM g
    • Relevant bindings include
        g :: a -> m (f (Free f a))
          (bound at /Users/dstoyano/work/app10/src/Experiments2.hs:1668:11)
        f :: f (Cofree f c) -> m c
          (bound at /Users/dstoyano/work/app10/src/Experiments2.hs:1668:9)
        chronoM :: (f (Cofree f c) -> m c)
                   -> (a -> m (f (Free f a))) -> a -> m c
          (bound at /Users/dstoyano/work/app10/src/Experiments2.hs:1668:1)
Failed, modules loaded: none.
```

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:24:09.855Z
Also another question. How will be implemented `anaM`  via `ana` for example `cataM` => `cataM alg = (>>= alg) . cata (traverse (>>= alg))`

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:31:51.308Z
and about `dynaM` this is correct?
```hs
dyna :: Functor f => (f (Cofree f b) -> b) -> (a -> f a) -> a -> b
dyna f g = chrono f (fmap return . g)

dynaM :: (Monad m, Comonad m, Traversable f) => (f (Cofree f b) -> m b) -> (a -> m (f (Free f a))) -> a -> m b
dynaM f g = chronoM f (traverse return <=< g)
```

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:32:17.607Z
I have some doubt about `(a -> m (f (Free f a)))`

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T21:36:17.363Z
There shouldn’t be a Free  … why use `chrono` for  `dyna`? `dyna f g = histo f . ana g` (plus the type annotation like you added for `chrono`)

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T21:38:58.639Z
`anaM`, unfortunately, isn’t implementable that way, I think (or, if it is, I haven’t figured it out): https://github.com/sellout/yaya/blob/master/unsafe/src/Yaya/Unsafe/Control.hs#L16

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T21:39:52.840Z
@xgrommx And what’s the context of that error you pasted?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:40:02.974Z
:point_up: [October 24, 2017 12:06 AM](https://gitter.im/slamdata/matryoshka?at=59ee59f0614889d475ef9411) how about this error?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:40:19.744Z
context?

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T21:41:20.007Z
Yeah, there’s an error from like 30 minutes ago, and I don’t know what it relates to.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:42:03.115Z
It regarding with your signature `chronoM :: (Traversable f, Monad m) => (f (Cofree f c) -> m c) -> (a -> m (f (Free f a))) -> a -> m c`

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:42:31.221Z
Also I understand about `anaM` via `futuM`
```hs
anaM' :: (Monad m, Traversable f) => (a -> m (f a)) -> a -> m (Fix f)
anaM' f = futuM(fmap (\x -> fmap (\y -> Free(Fix(ReturnF y))) x) . f)
```

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T21:43:23.626Z
@xgrommx So, what’s the code that got you that error?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:44:18.135Z
```hs
futuM :: (Corecursive t, Traversable (Base t), Monad m) => (a -> m (Base t (Free (Base t) a))) -> a -> m t
futuM coalg = anaM go . Pure where
  go (Pure a)  = coalg a
  go (Free fa) = return fa

histoM :: (Traversable (Base a1), Recursive a1, Monad f) => (Base a1 (Cofree (Base a1) a) -> f a) -> a1 -> f a
histoM f = fmap extract . cataM (traverse f . distGHisto id . fmap duplicate)

chronoM :: (Traversable f, Monad m) => (f (Cofree f c) -> m c) -> (a -> m (f (Free f a))) -> a -> m c
chronoM f g = histoM f <=< futuM g 
```

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T21:45:37.205Z
Right, so as I mentioned earlier, you need a type annotation in `chronoM` – like `histoM f <=< (futuM g :: a -> m (Fix f))`

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T21:46:07.446Z
You probably also need `forall f m a c.`, too.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:47:03.693Z
hm

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:47:17.570Z
In Kmett's version used `Base` not `Fix`

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T21:47:39.682Z
?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:48:18.569Z
histoM, futuM used `Base t`
```hs
futuM :: (Corecursive t, Traversable (Base t), Monad m) => (a -> m (Base t (Free (Base t) a))) -> a -> m t
futuM coalg = anaM go . Pure where
  go (Pure a)  = coalg a
  go (Free fa) = return fa

histoM :: (Traversable (Base a1), Recursive a1, Monad f) => (Base a1 (Cofree (Base a1) a) -> f a) -> a1 -> f a
histoM f = fmap extract . cataM (traverse f . distGHisto id . fmap duplicate)
```

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T21:48:42.774Z
Yeah, those should. We’re talking about `chronoM`.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:48:58.994Z
but why here `Fix`? `futuM g :: a -> m (Fix f))`

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T21:49:22.046Z
Because you have to choose _some_ specific type for the result of `futuM`.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:50:27.007Z
ohh... type families isn't helpful sometime, I talk about restriction `Base`

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T21:51:05.805Z
restriction?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:51:19.736Z
`(Base t) => ...`

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T21:51:36.529Z
I’m still not sure what you’re saying.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:51:47.561Z
ok, no problem)

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T21:51:49.590Z
`Base t` isn’t a constraint.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:52:21.101Z
yes) I know, maybe I use wrong word for it

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:52:23.951Z
and about `zygoM` looks like this is correct deriving via `cataM`?)

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T21:54:15.182Z
You have `Traversable (Base t)` when you need to extract the `Base` from a known fixed-point type, but the problem with `chronoM` (or any hylomorphism) is that there’s no way for the compiler to guess which fixed-point type you want to use for the intermediate step (and those functions are usually defined in a way that avoids the problem, e.g., `hylo f g = f . fmap (hylo f g) . g` rather than `hylo f g = cata f . ana g`)

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:56:02.760Z
yes, I know, because if we unpack `cata, ana` we can eliminate some part of it `fmap unfix . fmap Fix` => `fmap (unfix . Fix)` => `fmap id` => `id`

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T21:56:14.316Z
Your `zygoM` looks a lot like `mutuM` – so you could define it as `zygoM g f = mutuM(g . fmap snd, f)`

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:56:52.176Z
@sellout my version with `cataM` is wrong?

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T21:57:42.442Z
No, it looks right … but you have a lot of duplicated code between all of your schemes, so I was trying to simplify it.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:58:28.715Z
I just make my old version of `zygo` - monadic
```hs
zygo :: Functor f => (f a -> a) -> (f (a, b) -> b) -> Fix f -> b
zygo g f = snd . cata (\x -> (g $ fmap fst x, f x))

zygoM :: (Monad f, Traversable t) => (t a -> f a) -> (t (a, b) -> f b) -> Fix t -> f b
zygoM g f = fmap snd . cataM(bisequence . (g . fmap fst &&& f))
```

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T21:59:24.525Z
So, we’ve been going over this stuff for a while – I’m curious what your goal is. Just a deeper understanding of these tools?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T22:00:53.346Z
And I have maybe another version of `mutu` unlike your version
```hs
mutu :: Functor f => (f (a, b) -> b) -> (f (b, a) -> a) -> Fix f -> a
mutu f g = snd . cata (f . fmap swap &&& g)
-- mutu φ' φ t = φ (fmap (\x -> (mutu φ φ' x, mutu φ' φ x)) (unfix t))

mutuM :: (Monad f, Traversable t) => (t (a, b) -> f a) -> (t (a, b) -> f b) -> Fix t -> f b
mutuM f g = fmap snd . cataM (bisequence . (f &&& g))
```

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T22:01:18.223Z
That is exactly my version of mutu.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T22:01:59.432Z
@sellout yes! I love recursion schemes. And I want replace all my recursion on a specific recursion schemes

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T22:02:28.627Z
@sellout and `mutuM`?

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T22:03:12.569Z
Yeah … other than that I do `f . fmap swap` in both – mixing those seems like a bad idea.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T22:03:32.399Z
I mean in both `mutu` and `mutuM`

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T22:05:32.830Z
@sellout what is wrong here? `zygoM g f = mutuM(g . fmap snd, f)` should be tuple?

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T22:07:33.591Z
If you’re using your definition of `mutuM`, then you want `zygoM g f = mutuM(g . fmap fst, f)`, but if you change your `mutuM` to match your `mutu`, then you should keep `snd`.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T22:07:57.728Z
oh

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T22:08:20.295Z
```hs
mutuM f g = fmap snd . cataM (bisequence . ((f . fmap swap) &&& g))
```
how it will be correct regarding with my `mutu` version

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T22:08:31.637Z
Yep.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T22:08:53.879Z
this `mutuM` doesn't compile

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T22:09:03.815Z
Did you fix the type?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T22:10:00.741Z
should be?
```hs
mutuM :: (Monad f, Traversable t) => (t (a, b) -> f b) -> (t (b, a) -> f a) -> Fix t -> f a
mutuM f g = fmap snd . cataM (bisequence . ((f . fmap swap) &&& g))
```

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T22:10:37.418Z
but I got error
```
src/Free.hs:144:18: error:
    • Couldn't match expected type ‘t (a, b) -> f b’
                  with actual type ‘(f1 (a0, b1) -> c, t1)’
    • In the first argument of ‘mutuM’, namely ‘(g . fmap snd, f)’
      In the expression: mutuM (g . fmap snd, f)
      In an equation for ‘zygoM’: zygoM g f = mutuM (g . fmap snd, f)
    • Relevant bindings include
        f :: t1 (bound at src/Free.hs:144:9)
        g :: f1 b1 -> c (bound at src/Free.hs:144:7)
        zygoM :: (f1 b1 -> c) -> t1 -> (t (b, a) -> f a) -> Fix t -> f a
          (bound at src/Free.hs:144:1)
Failed, modules loaded: none.
```

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T22:11:47.058Z
You mean _zygoM_ doesn’t compile.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T22:12:10.562Z
oh

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T22:13:01.369Z
this isn't what should be)
```hs
zygoM :: (Traversable t, Monoid c) => (t a -> c) -> (t (a, b) -> b) -> (t (b, a) -> (c, a)) -> Fix t -> (c, a)
zygoM g f = mutuM(g . fmap fst &&& f)
```

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T22:13:19.266Z
Looks like `zygoM` should be `zygoM :: (Monad f, Traversable t) => (t a -> f a) -> (t (a, b) -> f b) -> Fix t -> f b`

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T22:13:20.515Z
That type signature is wrong …

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T22:13:29.504Z
Yeah, that’s right.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T22:14:09.017Z
some problem here `g . fmap fst &&& f`

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T22:14:24.471Z
```hs
src/Free.hs:145:13: error:
    • Couldn't match type ‘Fix t’ with ‘t (f b, a) -> (f a, a)’
      Expected type: Fix t -> f b
        Actual type: (t (f b, a) -> (f a, a)) -> Fix t -> (f a, a)
    • Possible cause: ‘mutuM’ is applied to too many arguments
      In the expression: mutuM (g . fmap fst &&& f)
      In an equation for ‘zygoM’: zygoM g f = mutuM (g . fmap fst &&& f)
    • Relevant bindings include
        f :: t (a, b) -> f b (bound at src/Free.hs:145:9)
        g :: t a -> f a (bound at src/Free.hs:145:7)
        zygoM :: (t a -> f a) -> (t (a, b) -> f b) -> Fix t -> f b
          (bound at src/Free.hs:145:1)
Failed, modules loaded: none.
```

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T22:15:13.195Z
Oh, now I understand your “should be tuple?” question.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T22:15:28.079Z
No – `zygoM g f = mutuM (g . fmap snd) f`

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T22:17:51.226Z
oh!!! thaaaanks!

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T22:18:32.719Z
Maybe I need sleep. I a little bit tired today, and cannot normal think.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T22:19:53.156Z
I love it!)
```hs
zygo :: Functor f => (f a -> a) -> (f (a, b) -> b) -> Fix f -> b
zygo g f = mutu(g . fmap snd) f
```

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T22:21:52.560Z
@sellout what is your main reason why you avoid type families in `yaya`?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T22:29:13.875Z
Also can we derive `paraM` via `para`?

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T22:37:04.507Z
So, if you start doing a bunch of polymorphic folds (and most in my experience are), you do a _lot_ of `Recursive t, Base t ~ Maybe` constraints. So I prefer writing `Recursive t Maybe`.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T22:39:27.584Z
Re: para/paraM – I would define them in terms of zygo/zygoM – `para f = zygo embed f`

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T22:42:58.582Z
This is why all these operations are in a `Zoo` module in `Yaya` – they’ve been given names by various papers over the years, but it turns out they’re all ultimately the same thing. So rather than define every single variation, only have `gcata` and `gcataM` (need both, because `gcataM` is more constrained). And those are defined in terms of `cata`, because `cata` is the easiest to define for `Recursive` instances.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T22:55:09.434Z
@sellout I ask you about `paraM` via `para` because I see in your `Yaya` exists `cataM` version via `cata`

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T22:57:07.318Z
And what is a version of `paraM` via `zygoM`?
```hs
para' :: Functor f => (f (Fix f, c) -> c) -> Fix f -> c
para' f = zygo Fix f

paraM' :: (Traversable t, Monad m) => (t (Fix t, b) -> m b) -> Fix t -> m b
paraM' f = zygoM Fix f
```

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T22:58:54.811Z
Well, your `zygoM` helper is `f a -> m a`, right? But `Fix :: f (Fix f) -> Fix f`, so you gotta add `pure`.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T23:01:16.942Z
And I guess you could do something like `paraM f = para (f <=< traverse sequenceA)`?

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T23:01:33.717Z
Not _certain_ that’s right. It seems to easy.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T23:01:51.001Z
@sellout where `pure`?

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T23:02:21.134Z
@xgrommx On `Applicative` – it’s the less-constrained name for `return`.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T23:02:41.588Z
Oh, you mean where to _use_ it?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T23:02:43.780Z
`zygo Fix f . pure`? looks like it is wrong

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T23:02:57.571Z
`zygo (pure . Fix) f`

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T23:03:11.186Z
oh

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T23:03:26.034Z
I try `zygo (Fix . pure) f`

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T23:04:02.230Z
By the way) this is version will be compiled
```hs
paraM' :: (Traversable t, Monad m) => (t (Fix t, b) -> m b) -> Fix t -> m b
paraM' f = para (f <=< traverse sequenceA)
```

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-25T23:06:01.212Z
@sellout I just implemented `transHyloM`, will get into matryoshka probably fairly soon

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:22:14.595Z
anyone have any resources on matryoshka and how it relates to monads like Task?

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:22:46.907Z
@wemrysi how you doing by the way

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:31:04.416Z
another thing i'm interested in is taking a recursive structure like `case class Foo(a: Bar, bars: List[Bar], irrelevant: Baz)` and being able to define a function that can return a List[Bar]

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:31:21.485Z
i.e. filtering all the `Bar` out of the structure

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:31:47.879Z
I'm guessing that's possible with matryoshka

                                                                                                                                                      Greg Pfeil @sellout@2017-10-28T04:33:44.947Z
@hderms I don’t see how that case class is recursive (other than it containing a List, which is recursive).

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:33:51.350Z
@sellout i got lazy

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:33:58.200Z
but in reality some of it would be recursive

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:34:26.621Z
with respect to how matryoshka relates to Task or Future, I'm interested in whether matryoshka would enable me to take a nested ADT that has some Task as members and be able to define traverse for it 

                                                                                                                                                      Greg Pfeil @sellout@2017-10-28T04:35:12.451Z
So, you’re saying that there’d be a parameter of type `Foo`, and you’d want to concat the nested `bars` with the outer `bars`?

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:35:24.943Z
yeah

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:35:38.330Z
basically recurse through the structure pulling out anything of type Bar

                                                                                                                                                      Greg Pfeil @sellout@2017-10-28T04:39:47.450Z
Well, it’d have to be specific to the structure. Maybe _have to_ is a strong word, but otherwise you need to get into Generics / HList … or, you could parameterize over `Bar`, like `Foo[A](a: A, bars: List[A], recursive: Foo[A])`, in which case having `Traverse[Foo]` would let you use Matryoshka on the pattern functor (which would be like `FooF[A, B]` to collect all the Bars, with only `Bitraverse[F]`, rather than specifically on `FooF`.

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:40:09.072Z
yeah i was thinking shapeless might be involved

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:40:44.787Z
whats FooF ? Fix[Foo] ?

                                                                                                                                                      Greg Pfeil @sellout@2017-10-28T04:41:00.190Z
I’d have to see an example of what you mean re: `Task`. Let’s not talk about `Future`, though. It doesn’t mix so well with this sort of thing.

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:41:14.375Z
yeah i was thinking task would be more appropriate

                                                                                                                                                      Greg Pfeil @sellout@2017-10-28T04:41:34.498Z
`FooF` is a functor such that `Foo ≅ Fix[FooF]`

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:42:05.940Z
@sellout basically its the same question as the previous one but it would be like a sealed trait where some of the nodes have a Task[Foo] as a member

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:43:03.757Z
basically want to be able to traverse it returning Task[Foo] replacing the things that had been Task[Foo] with Foo

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:43:14.411Z
might be a pipe dream

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:43:50.234Z
the questions are related as far as i can see but im trying to solve different problems

                                                                                                                                                      Greg Pfeil @sellout@2017-10-28T04:44:07.065Z
Yeah, I think doing specifically that might not be feasible, but that stepping back a bit and taking a different approach might avoid having `Task[Foo]` members at all.

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:44:28.220Z
@sellout its basically an ADT that describes steps in a web form wizard

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:44:39.493Z
some of the steps aren't known without making asynchronous requests

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:45:02.151Z
and im trying to build up a tree structure thats concrete and has no async parts

                                                                                                                                                      Greg Pfeil @sellout@2017-10-28T04:45:21.799Z
Yeah, so you might just want some sort of `anaM[Task]` to do that.

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:45:32.689Z
cool i'll look into that

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:45:40.080Z
the non-task related question is that i'm trying to take a data model that's defined through a JSON schema

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:45:51.315Z
use argus to produce a bunch of case classes automatically

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:46:20.607Z
and then be able to take this big nested JSON structure and pull out all the individual case classes that appear separately

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:46:34.006Z
so that i can use Slick or something to build a big SQL transaction

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:46:39.874Z
saving them all in one go into separate tables

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:47:08.097Z
another possible pipe dream but i'm trying to think outside the box to solve this problem elegantly so i can evangelize scala at my workplace

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:49:18.342Z
which i was thinking is superficially similar to JSON encoding or other stuff i could use shapeless to do

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-30T00:20:46.127Z
@sellout hello =) I have this code with `apo`
```hs
zapWith :: (a -> a -> a) -> [a] -> [a] -> [a]
zapWith f =
  curry $ apo coalg where
    coalg = \case
      ([], []) -> Nil
      ([], x:xs) -> Cons x $ Left xs
      (x:xs, []) -> Cons x $ Left xs
      (a:as, b:bs) -> Cons (f a b) $ Right (as, bs)
```

But how the same code will be with para?
```hs
zapWith' :: (a -> b -> c) -> [a] -> [b] -> [c]
zapWith' f =
  curry $ para alg where
    alg = \case
      ? -> ?
```

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-30T00:47:30.066Z
looks like need `Recursive` instance for `([a], [b])` but how can I implement type instance? `type instance Base ([a], [b]) = ?`

                                                                                                                                                      Greg Pfeil @sellout@2017-10-30T03:02:57.543Z
@xgrommx I’m pretty sure you can’t write that with para.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-30T03:08:41.372Z
@xgrommx What is your goal with the `para` version – since you separated the types, it seems you want to truncate the longer list, but you do want them aligned from the head? (if so, just use `ana`) or the tail? (you could do something hylo-y, I think)

                                                                                                                                                      Greg Pfeil @sellout@2017-10-30T03:20:13.577Z
Like, `anaM` with `State`, where you zip, then throw the tail of the longer list into the `State`, followed by `cataM`, where you `ConsF h t -> s -> (f (fst h) (last s) : t, snd h : init s)` (in the case where the 2nd list was longer).

                                                                                                                                                      Greg Pfeil @sellout@2017-10-30T05:48:52.089Z
@xgrommx I guess you could make something like `data TwoListF a b c = TwoConsF a b c | LeftConsF a c | RightConsF b c | NoneConsF` … but that’s not quite right, because there are constructions of that which aren’t isomorphic with `([a], [b])`, like `LeftConsF 0 (RightConsF 'a' NoneConsF)` -> `([0], ['a'])` -> `TwoConsF 0 'a' NoneConsF`.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-30T10:12:43.755Z
ok

                                                                                                                                                      Julien Truffaut @julien-truffaut@2017-11-06T15:04:34.458Z
Hi all,  I am having an issue at work where it seems I am missing the right recursion abstraction.  I hope you don't mind if I try to describe the problem quickly, maybe you would have have some pointers to give me!

                                                                                                                                                      Greg Pfeil @sellout@2017-11-06T15:05:01.285Z
@julien-truffaut Absolutely!

                                                                                                                                                      Julien Truffaut @julien-truffaut@2017-11-06T15:09:13.874Z
```
val as: Stream[A] = Stream(a1,a2,a3, ...)
lazy val bs: Stream[B] = (as |@| (hardCodedC ##:: cs)).map(f)
lazy val cs: Stream[C] = bs.map(g)
```

So we have two "Stream" (doesn't have to be std stream) that depend on each other but it is ok because we "shift" `cs` in `bs`

                                                                                                                                                      Julien Truffaut @julien-truffaut@2017-11-06T15:10:32.734Z
now we are trying to replicate the same behaviour but inside of a Monad `F`, e.g.:
```
val as: F[Stream[A]] = ???
lazy val bs: F[Stream[B]] = ???
lazy val cs: F[Stream[C]] = ???
```

                                                                                                                                                      Julien Truffaut @julien-truffaut@2017-11-06T15:11:30.353Z
what I don't know is what properties `F` needs in order to maintain the lazyness of the original stream encoding

                                                                                                                                                      Greg Pfeil @sellout@2017-11-06T15:36:43.329Z
@julien-truffaut I have to run … but does it need anything beyond `Applicative?`
```scala
val as: F[Stream[A]] = ???
lazy val bs: F[Stream[B]] = (as |@| cs).map((as, cs) => (as |@| (hardCodedC ##:: cs)).map(f))
lazy val cs: F[Stream[C]] = bs.map(_.map(g))
```

                                                                                                                                                      Julien Truffaut @julien-truffaut@2017-11-06T15:53:00.690Z
np

                                                                                                                                                      Julien Truffaut @julien-truffaut@2017-11-06T15:56:08.303Z
I am not sure how to accurately describe it but I think the issue is that `F[Stream[B]]` is not lazy. I have `B_n` depend on `C_n-1` and `C_n` depends on `B_n` and `C_0` is hardcoded

                                                                                                                                                      Greg Pfeil @sellout@2017-11-06T17:13:28.793Z
@julien-truffaut I think I’d have to experiment with it – it _seems_ to me that you don’t need `F` to be lazy, but I’m not surprised that I’m wrong about that.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-10T13:10:18.987Z
@sellout  I see u create https://github.com/sellout/Iaia and also I know about https://github.com/vmchale/recursion_schemes

                                                                                                                                                      Greg Pfeil @sellout@2017-11-10T16:50:35.894Z
@xgrommx Heh, you’re the second person to mention that today 😆 Yeah, I know Vanessa and we talk about recursion schemes. Iaia makes some different decisions than the existing libraries (somewhat summarized in https://github.com/sellout/yaya#differences-from-recursion-schemes), and I created Yaya & Iaia (I promise they’re pronounced differently) to illustrate those, to simplify discussions with Vanessa, Kmett, and others. I’m hoping we can come to some agreement on the approaches, and re-unify the libs.

                                                                                                                                                      Greg Pfeil @sellout@2017-11-10T17:01:41.993Z
(Actually, you were probably the first … I just saw it second)

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-10T17:51:46.795Z
interesting idea with Stepper

                                                                                                                                                      Greg Pfeil @sellout@2017-11-10T18:00:26.413Z
@xgrommx Well, my hand was kind of forced by totality :D

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-10T18:10:20.036Z
@sellout looks like Stepper + Recursive is Recursive from Kmett's recursion schemes

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-10T18:10:58.608Z
and why u don't use `Control.Arrow`? https://github.com/sellout/Iaia/blob/master/src/Iaia/Control.idr#L78-L92

                                                                                                                                                      Greg Pfeil @sellout@2017-11-10T18:29:45.590Z
@xgrommx Ah! That is because you can’t define instances on `->`!

                                                                                                                                                      Greg Pfeil @sellout@2017-11-10T18:31:24.626Z
But, I wondered if you could add those definitions to Control.Arrow under a namespace and hope that Idris would successfully disambiguate them. So a friend said he’s going to try that. At least then it’ll often _look_ like you have `Arrow (->)`, but it still wouldn’t work anywhere you had an `Arrow` constraint.

                                                                                                                                                      Greg Pfeil @sellout@2017-11-13T10:42:38.147Z
**\[Jean-Remi Desjardins, SlamData Inc.\]** What does “irrufutable” mean here?: [https://github.com/slamdata/matryoshka/blob/master/core/shared/src/main/scala/matryoshka/Embed.scala#L27](https://github.com/slamdata/matryoshka/blob/master/core/shared/src/main/scala/matryoshka/Embed.scala#L27)

                                                                                                                                                      Greg Pfeil @sellout@2017-11-13T10:42:58.216Z
**\[Jean-Remi Desjardins, SlamData Inc.\]** Google tells me it’s a typo, but I’m wondering if that’s actually the case

                                                                                                                                                      Greg Pfeil @sellout@2017-11-13T10:43:33.035Z
**\[Jean-Remi Desjardins, SlamData Inc.\]** But if someone knows, I might add a reference because it’s not easy to find what that word means

                                                                                                                                                      Greg Pfeil @sellout@2017-11-13T12:25:23.370Z
**\[Rintcius Blok, SlamData Inc.\]** @jr yeah, that's a typo - it should be irrefutable

                                                                                                                                                      Greg Pfeil @sellout@2017-11-13T17:38:49.573Z
**\[Jean-Remi Desjardins, SlamData Inc.\]** @rintcius What does an irrefutable extractor mean?

                                                                                                                                                      Jean-Rémi Desjardins @jedesah@2017-11-13T18:05:42.152Z
Haha, didn't realize @sellout was being the messenger here! :smile: We might want to fix that one of these days

                                                                                                                                                      Greg Pfeil @sellout@2017-11-14T23:06:42.163Z
@jedesah It means it always returns `Some`, so it doesn’t break exhaustivity when you use it.

                                                                                                                                                      andy scott @andyscott@2017-11-20T00:26:53.318Z
Is there a reasonable way to implement a stack safe hylo for regular Algebra/Coalgebras?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-11-20T01:56:19.841Z
Yes

                                                                                                                                                      Edmund Noble @edmundnoble@2017-11-20T01:56:26.729Z
Not regular

                                                                                                                                                      Edmund Noble @edmundnoble@2017-11-20T01:56:33.441Z
You need to have a `Traverse` constraint

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T14:42:57.061Z
@sellout Hello!)
I have some question about `distGMutu` also `gmutu` and `comutu` =)
```hs
-- distGMutu ?
-- gmutu ?
comutu :: Functor f => (b -> f(Either a b)) -> (a -> f(Either b a)) -> a -> Fix f
comutu f g = Fix . fmap (either (comutu g f) (comutu f g)) . g -- I'm not sure here

cozygo :: Functor f => (a -> f a) -> (b -> f (Either a b)) -> b -> Fix f
cozygo f psi = ana (either (fmap Left . f) psi) . Right
```

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T14:51:41.648Z
@sellout and also
```hs
cozygo :: Functor f => (a -> f a) -> (b -> f (Either a b)) -> b -> Fix f
cozygo f psi = comutu (f . ?) psi
```

                                                                                                                                                      andy scott @andyscott@2017-11-20T16:17:44.682Z
@edmundnoble Awesome. I had implemented one myself with a traverse constraint but wasn’t sure if there was a better way!

                                                                                                                                                      andy scott @andyscott@2017-11-20T16:18:08.000Z
Thanks :)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-11-20T16:50:54.859Z
Welcome :) you can probably do it in a nicer way than using `Trampoline` or `Eval` but I haven't cracked it yet.

                                                                                                                                                      Greg Pfeil @sellout@2017-11-20T18:59:13.774Z
@xgrommx cozygo is better known as gapo.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T19:09:18.091Z
@sellout I know)

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T19:09:36.493Z
@sellout how about `distGMutu`, `gmutu`?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T19:14:17.503Z
also I realize it
```hs
gapo :: Functor f => (a -> f a) -> (b -> f (Either a b)) -> b -> Fix f
gapo f psi = comutu (fmap Right . f) psi
```

                                                                                                                                                      Greg Pfeil @sellout@2017-11-20T21:10:18.291Z
@xgrommx So, what do you expect `gmutu` to look like? I.e., how does it generalize `mutu`?

                                                                                                                                                      Greg Pfeil @sellout@2017-11-20T21:12:18.929Z
@xgrommx And `distGMutu` seems unlikely to me – at least, I don’t think that even a `distMutu` is possible with comonadic folds. You need a distributive law over adjunctions (as in http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/urs.pdf), rather than one over comonads.

                                                                                                                                                      Greg Pfeil @sellout@2017-11-20T21:12:50.627Z
@xgrommx `comutu` looks interesting, though – would be cool to see a use case for it.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T22:00:22.170Z
```hs
comutuM :: (Traversable f, Monad m) => (b -> m (f (Either a b))) -> (a -> m (f (Either b a))) -> a -> m (Fix f)
comutuM f g = fmap Fix . traverse(either (comutuM g f) (comutuM f g)) <=< g
```

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T22:30:12.523Z
oh...
```hs
ana :: Functor f => (a -> f a) -> a -> Fix f
ana phi = comutu (fmap Right . unfix) (fmap Right . phi)
```

                                                                                                                                                      Greg Pfeil @sellout@2017-11-20T22:34:21.890Z
Yeah, there is a line of generalization `ana` → `apo` → `gapo` → `comutu`. All of those except `comutu` are part of the family of generalized monadic unfolds (`gana`).

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T22:43:46.437Z
sure) but I think should exists `gmutu/gcomutu`?

                                                                                                                                                      Greg Pfeil @sellout@2017-11-20T22:44:31.908Z
What do you think `gmutu` would look like?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T22:45:00.546Z
like `mutu` but with `DistributiveLaw`

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T22:47:53.257Z
smth like here https://github.com/ekmett/recursion-schemes/blob/master/Data/Functor/Foldable.hs#L610-L625

                                                                                                                                                      Greg Pfeil @sellout@2017-11-20T22:49:31.903Z
So, I think you’re working your way toward adjoint folds. The problem is that most useful adjunctions (including `∆ ⊣ (×)` for `mutu`) require non-endo `Functors`.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T22:51:28.898Z
@sellout sorry?)

                                                                                                                                                      Greg Pfeil @sellout@2017-11-20T22:54:09.348Z
Oh, wait … I might be misinterpreting … you’re saying you want something like `gmutu :: (Recursive t f, Functor f, Comonad w) => DistributiveLaw f w -> GAlgebra (Compose ((,) a) w) f b -> GAlgebra (Compose ((,) b) w) f a -> t -> a`?

                                                                                                                                                      Greg Pfeil @sellout@2017-11-20T22:54:41.736Z
And then you can treat `gmutu` as a generalization over `gcata`?

                                                                                                                                                      Greg Pfeil @sellout@2017-11-20T22:56:39.602Z
Oh, and I guess using `EnvT` instead of `Compose` is a good way to go, like `gzygo` does.

                                                                                                                                                      Greg Pfeil @sellout@2017-11-20T22:57:29.993Z
`gmutu :: (Recursive t f, Functor f, Comonad w) => DistributiveLaw f w -> GAlgebra (EnvT a w) f b -> GAlgebra (EnvT b w) f a -> t -> a`

                                                                                                                                                      Greg Pfeil @sellout@2017-11-20T22:59:38.845Z
(Yeah, I think you could do that)

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T23:09:30.954Z
looks like

                                                                                                                                                      Greg Pfeil @sellout@2017-11-20T23:10:18.295Z
👍🏼 I like it

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T23:11:35.271Z
and `gcomutu` will be generalized version of `gana` (as I understand `gana` correctly)

                                                                                                                                                      Greg Pfeil @sellout@2017-11-20T23:12:00.273Z
`gcomutu`, yeah, totally.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T23:12:17.714Z
yes)

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T23:12:21.474Z
some mistake

                                                                                                                                                      Greg Pfeil @sellout@2017-11-20T23:12:28.698Z
I think it needs a better name than `comutu`, though :D

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T23:13:00.408Z
what is signature for `gcomutu`?)

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T23:13:34.682Z
`gmutu :: (Recursive t f, Functor f, Comonad w) => DistributiveLaw f w -> GAlgebra (EnvT a w) f b -> GAlgebra (EnvT b w) f a -> t -> a` oh... Can we use `mutu` for it?)

                                                                                                                                                      Greg Pfeil @sellout@2017-11-20T23:16:26.469Z
So … `GCoalgebra (ExceptT a m) f b` … but I think that stack might be in the wrong order, so you might need to try `GCoalgebra (Compose (Either a) m) f b`?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T23:20:39.699Z
I try it
```hs
gmutu :: (Functor f, Comonad w) => DistributiveLaw f w -> GAlgebra (EnvT a w) f b -> GAlgebra (EnvT b w) f a -> Fix f -> a
gmutu = undefined
```

And got
```
    • Cannot instantiate unification variable ‘a0’
      with a type involving foralls:
        DistributiveLaw f w
        -> GAlgebra (EnvT a w) f b -> GAlgebra (EnvT b w) f a -> Fix f -> a
        GHC doesn't yet support impredicative polymorphism
    • In the expression: undefined
      In an equation for ‘gmutu’: gmutu = undefined
    • Relevant bindings include
        gmutu :: DistributiveLaw f w
                 -> GAlgebra (EnvT a w) f b -> GAlgebra (EnvT b w) f a -> Fix f -> a
          (bound at src/Free.hs:503:1)
Failed, modules loaded: none.
```

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T23:21:30.931Z
pragma `ImpredicativeTypes`...

                                                                                                                                                      Greg Pfeil @sellout@2017-11-20T23:22:39.196Z
That error seems to be about the expression, not the type, right?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T23:25:15.816Z
`ImpredicativeTypes` fix it

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T23:26:09.454Z
```hs
gmutu :: (Functor f, Comonad w) => DistributiveLaw f w -> GAlgebra (EnvT a w) f b -> GAlgebra (EnvT b w) f a -> Fix f -> a
gmutu n f g = undefined
```

body for `gmutu` is complicated for me(

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T23:26:35.940Z
looks like we need use `gana`?

                                                                                                                                                      Greg Pfeil @sellout@2017-11-20T23:27:21.161Z
But once you implement it, you should be able to remove ImpredicativeTypes, I believe.

                                                                                                                                                      Greg Pfeil @sellout@2017-11-20T23:27:39.391Z
Also, I’m trying to avoid implementing it, so I can get some work done 😆

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T23:28:02.426Z
nice)

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-21T23:59:41.823Z
@sellout some results?) hello

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-24T15:58:17.714Z
@sellout hello!) are u here?

                                                                                                                                                      Greg Pfeil @sellout@2017-11-24T16:28:35.563Z
@xgrommx Not really – but I might be around some either tomorrow or Sunday.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-24T16:37:47.059Z
@sellout I have some question
```hs
import Data.Functor.Foldable

type List a = Mu(ListF a)

unMu (Mu m) = m

nil :: Mu(ListF a)
nil = Mu $ \f -> f Nil
    
cons :: forall a. a -> Mu (ListF a) -> Mu (ListF a)
cons a b = Mu $ \f -> f ?
```

what is should be `cons`?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-24T16:38:42.327Z
`Mu` from here https://github.com/ekmett/recursion-schemes/blob/master/Data/Functor/Foldable.hs#L539

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-24T16:45:42.552Z
```hs
cons :: forall a. a -> Mu (ListF a) -> Mu (ListF a)
cons a b = Mu $ \f -> f $ Cons a _y
```
ok... but `_y` is?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-24T17:46:39.453Z
@sellout solve it! thx)
```hs
nil :: Mu(ListF a)
nil = Mu $ \f -> f Nil
    
cons :: forall a. a -> Mu (ListF a) -> Mu (ListF a)
cons a (Mu b) = Mu $ \f -> f $ Cons a (b f)
```

                                                                                                                                                      Greg Pfeil @sellout@2017-11-24T18:58:40.411Z
@xgrommx Indeed, it’s `embed $ Cons a b`, given `embed m = Mu (\f -> f (fmap (fold f) m))` (also from `Data.Functor.Foldable`).

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-24T19:13:02.995Z
`fold` - `cata`?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-24T19:13:09.918Z
or Data.Foldable?

                                                                                                                                                      Greg Pfeil @sellout@2017-11-24T19:13:20.592Z
Yeah, `cata`.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-24T19:13:38.555Z
how about gmutu/gcomutu?)

                                                                                                                                                      Greg Pfeil @sellout@2017-11-24T19:13:59.433Z
I haven’t had a chance to think about them :D

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-24T19:14:37.922Z
also https://github.com/xgrommx/awesome-functional-programming/blob/master/rsfa.md

                                                                                                                                                      Greg Pfeil @sellout@2017-11-24T19:14:45.896Z
But I want to call `comutu` something like a `divmorphism` or something (for “diverging”), but that’s still not a nice name.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-24T19:16:22.462Z
will be nice)

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-24T19:16:25.385Z
https://hackage.haskell.org/package/recursion-schemes-ext-1.0.0.0/docs/Data-Functor-Foldable-Exotic.html

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-24T19:16:35.478Z
several strange operators)

                                                                                                                                                      LukaJCB @LukaJCB@2017-12-09T16:34:54.861Z
Might be a stupid question, but are `ana` and `catamorphisms` guaranteed to be total? 🤔 

                                                                                                                                                      Greg Pfeil @sellout@2017-12-09T17:48:12.280Z
@LukaJCB Great question! They are not.

                                                                                                                                                      Greg Pfeil @sellout@2017-12-09T17:48:45.621Z
But I’m working on libraries where you can expect them to be – e.g. sellout/yaya

                                                                                                                                                      LukaJCB @LukaJCB@2017-12-09T17:49:38.812Z
Nice!

                                                                                                                                                      Greg Pfeil @sellout@2017-12-09T17:50:06.392Z
If you were to define cata on a Stream, it may never terminate, for example. But ana on a Stream is total.

                                                                                                                                                      LukaJCB @LukaJCB@2017-12-09T17:50:17.574Z
Makes sense

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-12-09T18:01:18.367Z
Also u can take a look on recursion schemes which written on idris

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-12-09T18:03:06.524Z
cc @sellout and https://github.com/vmchale/recursion_schemes

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-12-09T18:04:38.729Z
https://github.com/sellout/Iaia

                                                                                                                                                      Torsten Scholak @tscholak@2017-12-09T18:40:24.427Z
@sellout I’m looking closely into Idris these days and I noticed that you started implementing a recursion schemes library, iaia. Would you say that this channel is a good place to discuss it?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-12-09T18:41:13.477Z
How about gcomutu and other friends?)

                                                                                                                                                      Greg Pfeil @sellout@2017-12-09T20:06:41.907Z
@tscholak Fine by me – already been discussing the Haskell one here.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-12-09T20:08:41.848Z
@sellout ?

                                                                                                                                                      Greg Pfeil @sellout@2017-12-09T21:53:44.864Z
@xgrommx I just tried for a bit, and got this:

                                                                                                                                                      Greg Pfeil @sellout@2017-12-09T21:54:25.230Z
```haskell
gmutu
  :: ( Comonad w
     , Recursive t f
     , Functor f)
  => DistributiveLaw f w
  -> GAlgebra (EnvT a w) f b
  -> GAlgebra (EnvT b w) f a
  -> t
  -> a
gmutu w φ' φ = extract . mutu (lowerEnv φ') (lowerEnv φ)
  where
    -- lowerEnv :: GAlgebra (EnvT c w) f d -> GAlgebra ((,) (w c)) f (w d)
    lowerEnv φ'' =
      lower . fmap φ'' . distZygoT _f w . fmap (duplicate . uncurry EnvT . first extract)
```

                                                                                                                                                      Greg Pfeil @sellout@2017-12-09T21:54:53.955Z
It’s not quite right … that `_f` I haven’t figured out.

                                                                                                                                                      Greg Pfeil @sellout@2017-12-10T16:08:23.917Z
@xgrommx Got it!
```haskell
gmutu
  :: (Comonad w, Comonad v, Recursive t f, Functor f)
  => DistributiveLaw f w
  -> DistributiveLaw f v
  -> GAlgebra (EnvT a w) f b
  -> GAlgebra (EnvT b v) f a
  -> t
  -> a
gmutu w v φ' φ = extract . mutu (lowerEnv w φ') (lowerEnv v φ)
  where
    lowerEnv x φ'' =
      fmap φ''
      . x
      . fmap (fmap (uncurry EnvT) . distProd . fmap duplicate . first extract)
    distProd p =
      let a = fst p
      in fmap (\b -> (a , b)) (snd p)
```
It even allows you to use a different comonad for each algebra.

                                                                                                                                                      Greg Pfeil @sellout@2017-12-10T16:23:14.748Z
Minor simplification: `fmap duplicate . first extract` → `(extract *** duplicate)`

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-12-10T21:38:56.219Z
@sellout wow! nice

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-12-10T21:39:47.461Z
@sellout this is should be `gmutu` or `gcomutu`?

                                                                                                                                                      Greg Pfeil @sellout@2017-12-10T21:41:20.092Z
gmutu … but it can be mechanically converted to gcomutu.

                                                                                                                                                      Greg Pfeil @sellout@2017-12-10T21:41:53.294Z
I started to do it, but then I decided it’d be better to teach GHC to do it.

                                                                                                                                                      Greg Pfeil @sellout@2017-12-10T21:42:16.099Z
I.e., `makeDualValue 'gmutu 'gcomutu`.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-12-10T21:46:38.652Z
@sellout nice idea, about `makeDualValue`

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-12-10T23:07:23.518Z
@sellout my small experiments for recursion schemes with gadts! https://gist.github.com/xgrommx/4c72ae9d407214deab55fe9aebc08b45 (PHOAS, HOAS,...)

                                                                                                                                                      Greg Pfeil @sellout@2017-12-11T16:33:13.757Z
@xgrommx 👍🏼

                                                                                                                                                      Valentin Kasas @vil1@2017-12-15T08:57:45.420Z
Hi there, long time no see

                                                                                                                                                      Valentin Kasas @vil1@2017-12-15T08:58:14.576Z
Seems like this as turned to an Haskell channel :)

                                                                                                                                                      Valentin Kasas @vil1@2017-12-15T09:03:58.266Z
I'm back with yet another not so smart question: I have two pattern functors `D` and `V` and I use an hylo to build an `EnvT[E, V, A]` out of a pair `(E, D)` (pretty standard so far) 

                                                                                                                                                      Valentin Kasas @vil1@2017-12-15T09:06:37.562Z
My problem is that `D` and `V` are (or should not be) isomorphic: some cases of `D` do not exist in `V`so in my coalgebra, I find myself wanting to consume multiple layers of `D` at once

                                                                                                                                                      Valentin Kasas @vil1@2017-12-15T09:07:44.467Z
but I don't know how to do that, so for now, I've just created "useless" cases in `V` so that it matches `D`'s structure and I simply ignore these cases in my algebra

                                                                                                                                                      Valentin Kasas @vil1@2017-12-15T09:08:42.563Z
I suspect there is a cleaner way to do that

                                                                                                                                                      Matija Folnovic @mfolnovic@2017-12-29T13:11:59.806Z
what would you recommend me to read / watch if I understand Fix and `cata` (and barely `ana`), but don't understand anything else?

                                                                                                                                                      Matija Folnovic @mfolnovic@2017-12-29T13:12:06.453Z
any Scala examples would be :ok_hand: 

                                                                                                                                                      Holothuroid @Holothuroid@2017-12-29T13:39:56.846Z
Hi everyone. I heard from several sources that recursion schemes combine in such a way that they can safe traversals. I'm interested how that works.

                                                                                                                                                      Matija Folnovic @mfolnovic@2017-12-29T13:53:25.679Z
@Holothuroid you might want to look at (6:44 - 8:54): https://youtu.be/IlvJnkWH6CA?t=404

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-12-29T14:01:26.435Z
@mfolnovic my big list about RS https://github.com/xgrommx/awesome-functional-programming/blob/master/rsfa.md

                                                                                                                                                      Matija Folnovic @mfolnovic@2017-12-29T14:03:54.442Z
@xgrommx my google-fu was weak, tnx! :blush:

                                                                                                                                                      Greg Pfeil @sellout@2017-12-29T14:13:11.631Z
@Holothuroid RS definitely provide safer tree traversals than doing direct recursion – it handles the recursion automatically, so you can’t accidentally miss cases, and you only have to reason about one node at a time. However, it’s still hard to ensure that RS are total (e.g., not letting you fold an infinite stream). I now have a total implementation in Idris to help guide my hand a bit, but it’s not a perfect mapping (especially with Haskell, because laziness).

                                                                                                                                                      Holothuroid @Holothuroid@2017-12-29T14:31:20.079Z
@mfolnovic That very talk brought me here. At the end (42:00) Pawel says that recursion scheme are composable, so they are faster than traversing the AST every time. - How? What's the limitations? 

Say I have: `as.zip(bs).reduce(...).reduce(...)`

Will Matryoshka automatically combine the last two Catamorphisms, when I call `.cata{...}.cata{...}`? Do I have to call that optimisation explicitely? Is such optimisation possible with other *morphisms? Between different types`?

                                                                                                                                                      Greg Pfeil @sellout@2017-12-29T14:34:04.044Z
@Holothuroid Currently you don’t get that kind of fusion automatically from Matryoshka, but can do it manually like `.cata(f).cata(g)` -> `.cata(f >>> project >>> g)` (although you’ll probably have to annotate types or do `.cata(x => g(f(x).project))` or something).

                                                                                                                                                      Greg Pfeil @sellout@2017-12-29T14:35:43.464Z
And yes, you can apply that in many cases. The most well known cases first unfold then fold – `.ana(f).cata(g)` -> `.hylo(g, f)`, and yes, that works with other morphisms like `histo`, `zygo`, whatever.

                                                                                                                                                      Greg Pfeil @sellout@2017-12-29T14:37:15.190Z
`cata` (and `ana`) is fully general – if you look at the code, you’ll see that things like `histo` are implemented in terms of `gcata`, and `gcata` is implemented in terms of `cata`. So, not that you’d want to do it manually, but any fold can be written using only `cata` for recursion.

                                                                                                                                                      Greg Pfeil @sellout@2017-12-29T14:40:49.506Z
@Holothuroid I would love to see some macros that handle those rewrites, even just a tiny subset of them, automatically.

                                                                                                                                                      Holothuroid @Holothuroid@2017-12-29T14:44:11.021Z
Thank you. That helps. What type does `.project`belong to?

                                                                                                                                                      Greg Pfeil @sellout@2017-12-29T14:44:27.650Z
It’s a method on the `Recursive` type class.

                                                                                                                                                      Greg Pfeil @sellout@2017-12-29T14:44:45.730Z
Roughly `Fix[F] => F[Fix[F]]`.

                                                                                                                                                      Holothuroid @Holothuroid@2017-12-29T14:45:43.136Z
Cool. Thanks.

                                                                                                                                                      Greg Pfeil @sellout@2017-12-29T14:47:48.598Z
I find that I often write natural transformations, `F ~> G`, and then it’s really easy to compose them, as they can be used in both folds and unfolds. So whenever you have a 1:1 mapping, `~>` is the way to go. `.cata(natTrans >>> embed).cata(alg)`, and since `embed` is the dual of `project` that becomes `.cata(natTrans >>> alg)`

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-12-29T14:59:02.675Z
https://twitter.com/xgrommx/status/861913282541740036

                                                                                                                                                      Matija Folnovic @mfolnovic@2017-12-30T16:16:56.302Z
> The .embed calls in someExpr wrap the nodes in the fixed point type. embed is generic, and we abstract someExpr over the fixed point type (only requiring that it has an instance of Corecursive), so **we can postpone the choice of the fixed point as long as possible**.

bolded part, why?

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-01T12:01:08.573Z
Hi everyone, I've just started playing around with matryoshka and I think I might need a hand from someone with a bit more knowledge than me :)

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-01T12:01:54.262Z
I'm trying to parse a hierarchy of case classes from json, but I'd like to have the resulting tree annotated 

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-01T12:01:59.724Z
Basically like a merkle tree

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-01T12:02:49.805Z
I was thinking I could just use argonauts optionDecoder which seems to work fine with something like an anaM

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-01T12:03:19.996Z
I then want to use a histo to annotate the nodes with the hash of the children

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-01T12:04:01.766Z
The problem seems to be when I want to combine these two, I think I need something like dynaM, but there's only a dyna

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-01T12:04:12.065Z
Maybe there's an easier way to do this?

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T12:10:00.709Z
@freskog whenever someone talks about annotating a structure, I tend to think about https://github.com/slamdata/matryoshka/blob/master/core/shared/src/main/scala/matryoshka/patterns/EnvT.scala

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T12:17:31.234Z
let say you have a pattern functor `JsonF`, and a `Hash` type, you can build an `T[EnvT[Hash, JsonF, ?]]` from a `T[JsonF]` quite easily (`T` being your fix point of choice)

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T12:21:44.995Z
which leads to @mfolnovic's question: postponing choices is always a good practice in FP. When you abstract over the fix-point type, and defer the choice, it allows you to, for example, use `Fix` for tests and debugging (`Fix` is easy to print but not stack-safe) and to use `Mu` or `Nu`for production code 

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T12:44:35.689Z
(back to @freskog's problem), the cool thing is that given a `T` with the proper `Corecursive` instance, you can write an `AlgebraM[Option, JsonF, T[EnvT[Hash, JsonF, ?]]]` so you can use `hyloM` with `optionDecoder` and this algebraM and obtain your simili-merkle tree

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-01T13:18:26.273Z
Ah, interesting!

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-01T15:09:11.484Z
Out of curiosity, it seems like using EnvT is solving the same problem as histo

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-01T15:09:14.081Z
is that correct?

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T15:56:27.011Z
I might not be the best person to ask that (I'm still a n00b here), but I think histo solves a more general problem

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T15:59:26.657Z
In other words, you could rewrite any fold+EnvT into an histo, but not the other way around

                                                                                                                                                      Greg Pfeil @sellout@2018-01-01T16:05:19.778Z
@freskog histo doesn’t give you an annotated tree, but rather uses annotations _while folding_ to give you access to intermediate results of the fold. @vil1’s suggestion is the right path to pursue.

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T16:06:53.414Z
G

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T16:07:29.058Z
(damned phone)

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T16:09:30.375Z
FWIW I've been fiddling with Matryoshka for roughly a year now and I am yet to find a problem that needs more than a cata/ana/hylo

                                                                                                                                                      Greg Pfeil @sellout@2018-01-01T16:17:14.916Z
Yeah, on my phone here, too.

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T16:21:58.778Z
BTW @sellout, how do I consume multiple layers of a structure at once during a fold ?

                                                                                                                                                      Greg Pfeil @sellout@2018-01-01T16:22:49.328Z
@vil1 Technically nothing requires more than those three 😎 but I get your point

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T16:23:13.405Z
I refold a functor `D`into another functor `E` (both ADTs) but some cases of `D` do not exist in `E`

                                                                                                                                                      Daniel Porter @DanielPorter@2018-01-01T16:24:18.083Z
@freskog i have a gist that shows doing some nonsense annotations using cata and ana.  https://gist.github.com/DanielPorter/460ff5e4c5246ef680e053d95bd5a010

                                                                                                                                                      Daniel Porter @DanielPorter@2018-01-01T16:24:26.744Z
lines 170-184

                                                                                                                                                      Daniel Porter @DanielPorter@2018-01-01T16:24:29.127Z
the naming is awful, but it does compile :)

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T16:24:49.773Z
`map[_, B]`?

                                                                                                                                                      Greg Pfeil @sellout@2018-01-01T16:24:54.194Z
@vil1 I think I need my laptop, but probably histo with Maybe in the carrier (not histoM)

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T16:25:04.651Z
currently I just add "useless" cases in `E` so that it matches `D`'s structure and ignores these cases when I fold `E` but that looks bad 

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T16:25:26.610Z
@sellout I'd probably add `Fix[D] Either ?` to the carrier instead

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T16:27:59.486Z
(@freskog, @DanielPorter I have some too : https://github.com/ScalaIO/pear/blob/master/core/src/main/scala/pear/form/package.scala, and it is also the problem I have with my `D`s and `E`s)

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T16:28:25.194Z
@sellout, @edmundnoble : I'll dig that, thx

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T16:29:43.590Z
I would also probably not use `State` to accumulate errors

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T16:29:54.905Z
Because by definition you *must* lose type-safety

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T16:30:34.343Z
I don't follow you there

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T16:31:14.333Z
If you use `State` to accumulate errors that means you can keep processing even after you've reached an error

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T16:31:34.587Z
And if you've reached an error and you needed the result that instead gave you an error to proceed

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T16:31:52.905Z
You have to return some *fake* result for upstream to deal with

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T16:32:23.904Z
that's right, I usually return `ValueNull` upon error

                                                                                                                                                      Greg Pfeil @sellout@2018-01-01T16:32:28.217Z
@edmundnoble Yeah, I just meant “some failure”.

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T16:32:41.030Z
Right, I consider that to be a hack

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T16:32:59.682Z
You're including the effects of your traversal *inside the output AST itself*

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T16:33:06.193Z
which is fine IMO, at the end I return a well formed result or all the errors I envountered

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T16:33:26.959Z
If you want sane error accumulation that isn't actually inside the output AST you should just use `Either`

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T16:33:41.050Z
OK I see your point now

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T16:35:03.660Z
but I use `Either` (or `\/`) as my carrier monad, I'll fail on the first error

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T16:35:26.239Z
and I want to simulate a `Validation`, hence collect all possible errors

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T16:36:34.223Z
Right, this is a good point, you can overcome it though

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T16:36:42.857Z
One possibility is not to use `hyloM` or `cataM`

                                                                                                                                                      Greg Pfeil @sellout@2018-01-01T16:36:57.739Z
Yeah, don’t use hyloM – include `Either` in the carrier itself.

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T16:36:58.377Z
You can do the `toValidation` followed by the `Applicative` calls yourself then, and you're in the clear

                                                                                                                                                      Greg Pfeil @sellout@2018-01-01T16:37:53.827Z
`Algebra D Either[Fix[D], Fix[E]]`

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T16:38:06.203Z
hmm

                                                                                                                                                      Greg Pfeil @sellout@2018-01-01T16:38:24.085Z
Well … GAlgebra, with the Cofree in there.

                                                                                                                                                      Greg Pfeil @sellout@2018-01-01T16:39:02.683Z
Or use Validation directly instead, that’s fine. The thing is, if you’re passing over some intermediate results, those Lefts might never actually be in the result.

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T16:39:29.099Z
Oh, are the only errors values of type `Fix[D]` that couldn't be translated to `E`?

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T16:40:01.284Z
nope, that's something else

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T16:42:40.953Z
Right yeah, `Either[NonEmptyList[Error], ?]` wrapped around your algebra's `A` should suffice

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T16:43:06.761Z
anyway, you both provided me with good leads (as usual ^^), I need to tinker a little bit on that

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T16:45:10.272Z
having to pattern match on a Either at each case of my algebra might fell a little bit clumsy, but it'll help simplify my ADTs so the end result might indeed be clearer

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T16:45:20.789Z
Oh you don't need to do that

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T16:45:38.231Z
You make a `flatMap` or `Applicative.mapN` followed by `.toValidation` call

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T16:47:44.032Z
hmm right, `Applicative.mapN` it is then (to be able to accumulate errors)

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T16:48:05.415Z
Exactly

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T16:49:01.416Z
so, lets get to work!

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-01T16:49:30.251Z
Thanks for you help, I have my "merkle" tree now

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-01T16:49:44.049Z
I just need to figure out how to write an efficient merge :)

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-01T16:50:17.890Z
I'm looking at paraMerga but I can't say I understand it

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T16:51:06.419Z
^^ welcome to the club buddy

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-01T16:51:34.785Z
I suspect that's there's probably another way of doing it that makes more sense

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T16:52:56.399Z
@freskog I might suggest doing it in the simplest way you can think of first, potentially without even using recursion schemes, then factoring it down

                                                                                                                                                      Greg Pfeil @sellout@2018-01-01T17:05:06.322Z
@freskog paraMerga is definitely one of the weakest points of the library 😝

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-01T20:04:05.031Z
I have (simplified):
```scala
trait Root[E, M]
case class Expr[E, M](metadata: M, next: Option[E])
case class Loop[E, M](metadata: M, next: Option[E])
```

and I have defined a `scalaz.Functor[Root[?, M]]` for this, but I get `value cata is not a member of Root`

from my debugging, I realized `toRecursiveOps[Fix[Root[?, M]], Root[?, M]](x)` doesn't work because:
`could not find implicit value for parameter tc: matryoshka.Recursive.Aux[matryoshka.data.Fix[[α$30$]Root[α$30$,M]],[α$31$]Root[α$31$,M]]`

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-01T20:04:13.729Z
how can I make this to compile? :(

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T20:04:32.694Z
You'll have to reverse the type parameters.

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T20:04:40.196Z
Are you familiar with SI-2712, or partial unification?

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-01T20:04:54.278Z
only heard of it, but didn't understand what's going on there...

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T20:05:04.455Z
Right, SI-2712 is what lets you have a functor for `Either[E, ?]`.

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T20:05:14.317Z
It can't possibly let you have a functor for `Either[?, E]`.

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-01T20:05:31.164Z
oh, never realized order is important

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-01T20:05:36.056Z
thanks, I'll try that!

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T20:05:38.767Z
Welcome :)

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-01T20:13:27.155Z
yep, it works, thanks again :)

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T20:13:34.984Z
Good to hear :)

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-01T20:13:53.818Z
well, at least it compiles, can't run it yet :joy: 

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T12:37:01.410Z
hello! could someone explain to me pros & cons for having both `TreeF[_]` and `Tree` and what `Birecursive` is? :angel:

                                                                                                                                                      Valentin Kasas @vil1@2018-01-02T12:47:26.361Z
Tree is easy to build manually. And if you have a Birecursive it means that you can use/return a Tree wherever a TreeF is needed

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T12:48:56.627Z
hmm, would it also work if I returned `Tree` in my algebra (instead of `Fix[TreeF]`) ?

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T12:49:26.666Z
or better, do you know of any example showing this?

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T12:49:45.416Z
my google-fu isn't working on matryoshka :sweat_smile: 

                                                                                                                                                      Valentin Kasas @vil1@2018-01-02T13:00:38.897Z
I think so

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T13:04:57.558Z
thanks! :blush: 

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T13:05:08.435Z
aaand about example, do you know of any? :blush:

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T13:05:26.203Z
not sure if impatient or missed my other question

                                                                                                                                                      Valentin Kasas @vil1@2018-01-02T13:07:58.478Z
I think I missed it 😓

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T13:08:23.852Z
:angel:

                                                                                                                                                      Valentin Kasas @vil1@2018-01-02T13:08:52.884Z
I'm afk right now but I 'lol be back soon

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T13:09:04.888Z
okay, thanks :)

                                                                                                                                                      Valentin Kasas @vil1@2018-01-02T13:13:16.171Z
Meanwhile you can look the signatures in `IdOps`

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T13:16:02.707Z
:thumbsup: 

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T14:39:17.531Z
for some reason, I need to explicitly forward a `Functor` instance, e.g.

```scala
val tree: Fix[NodeF[Int, Int, ?]] = ...

implicit def functor[A, B] = new Functor[NodeF[A, B, ?]] {
  ...
}

tree.cata(algebra) // doesn't work

tree.cata(algebra)(functor) // works
```

                                                                                                                                                      Greg Pfeil @sellout@2018-01-02T14:40:07.282Z
@mfolnovic What’s your algebra?

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T14:41:14.177Z
`val algebra: Algebra[NodeF[Expr, Nothing, ?], Fix[NodeF[Expr, Nothing]]] = ...`

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T14:41:42.104Z
but I don't think it's connected to algebra, this also happens with `embed` / `project`, e.g.: `tree.project(functor).embed(functor)`

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T14:42:09.665Z
(I'm trying to experiment with my instance of `Birecursive` for `NodeF` / `Node`)

                                                                                                                                                      Greg Pfeil @sellout@2018-01-02T14:42:15.990Z
What error do you get?

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T14:43:02.506Z
`could not find implicit value for parameter BF: scalaz.Functor[[Node]NodeF[Int,Int,Node]]`

                                                                                                                                                      Greg Pfeil @sellout@2018-01-02T14:43:20.138Z
So … you might have _multiple_ `Functor` instances for `NodeF`?

                                                                                                                                                      Greg Pfeil @sellout@2018-01-02T14:43:34.415Z
(sometimes scalac gets confused and thinks ambiguous instances are no instances)

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T14:43:51.055Z
hmmm, is there a way I could debug that in IDEA ?

                                                                                                                                                      Greg Pfeil @sellout@2018-01-02T14:44:15.762Z
I haven’t used it, so I dunno.

                                                                                                                                                      Greg Pfeil @sellout@2018-01-02T14:44:27.280Z
But try commenting out the one instance you can see.

                                                                                                                                                      Greg Pfeil @sellout@2018-01-02T14:45:13.501Z
I’ve also had cases where an instance has been hidden by another value with the same name, perhaps from another import, and that is _hella_ confusing.

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T14:46:16.370Z
commenting out doesn't help, I name all functors the same, so let me try to rename it

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T14:48:40.472Z
hmm that also doesn't help... :(

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T14:49:23.878Z
is it possible it can't handle `implicit def functor[A, B]`, where it would need to infer `A =:= Int` and `B =:= Int` (in my first example)?

                                                                                                                                                      Greg Pfeil @sellout@2018-01-02T14:51:13.897Z
I dunno – I’ve had functors at least that complicated before. You are compiling with `-Ypartial-unification`, right?

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T14:51:34.862Z
I tried:
`implicit val fc = functor[Int, Int]`
before calling `cata` and it works without passing a `Functor`

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T14:51:48.285Z
yep, I am

                                                                                                                                                      Greg Pfeil @sellout@2018-01-02T14:53:51.130Z
@mfolnovic You might fare better in a Scalaz channel or #typelevel/general, or something.

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T14:53:52.286Z
at least I know it should work, I'll figure it out, tnx! :)

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T14:54:02.359Z
true, tnx!

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T15:51:33.803Z
another question, I've defined `Birecursive` for my `NodeF[_]` / `Node`. how would I go from converting `Fix[NodeF]` to `Node` ?

                                                                                                                                                      Valentin Kasas @vil1@2018-01-02T17:01:57.506Z
Things have a little diverged and I am still afk. tek/slain 

                                                                                                                                                      Valentin Kasas @vil1@2018-01-02T17:02:06.131Z
Arrrr

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T17:02:46.081Z
hah, it's fine :)

                                                                                                                                                      Valentin Kasas @vil1@2018-01-02T17:02:58.203Z
github.com/tek/splain might help debugging implicit resolution

                                                                                                                                                      Greg Pfeil @sellout@2018-01-02T17:04:33.334Z
@mfolnovic `tree.convertTo[Node]` – which is just a nice name for `tree.cata[Node](_.embed)`

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T17:08:06.193Z
oh, nice, tnx!

                                                                                                                                                      Greg Pfeil @sellout@2018-01-02T17:08:38.498Z
But … you should be able to just generate Node directly anywhere you generate Fix[NodeF].

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T17:09:06.062Z
what do you mean?

                                                                                                                                                      Greg Pfeil @sellout@2018-01-02T17:10:04.264Z
if you’re doing something like `x.ana[Fix[NodeF]](coalg)`, you should be able to just do `x.ana[Node](coalg)` and have it work.

                                                                                                                                                      Greg Pfeil @sellout@2018-01-02T17:10:10.430Z
Or any other operation.

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T17:11:23.364Z
wait, and `x` can be of type `Node` ?

                                                                                                                                                      Greg Pfeil @sellout@2018-01-02T17:11:37.827Z
No.

                                                                                                                                                      Greg Pfeil @sellout@2018-01-02T17:11:49.441Z
Show me where you use `Fix[NodeF]`.

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T17:16:28.361Z
I'm not exactly sure what you mean... but since I get type mismatch when I inject my `Birecursive` directly, I've probably defined it wrong so I'm debugging that

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-02T17:16:54.712Z
What actually is `Node`? 

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T17:17:01.154Z
but just out of curiosity, when I generate my instance from input, should I generate `Fix[NodeF]` or `Node` ?

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T17:18:22.704Z
simplified, something like:
```
sealed trait Node[Expr, +Info]
case class ExprNode[Expr, +Info](expr: Expr, info: Info) extends Node
case class WhileLoopNode[Expr, +Info](condition: Expr, body: Node, info: Info) extends Node
etc.
```

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-02T17:19:57.877Z
Why does `Node` exist when you have `Fix[NodeF]`?

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T17:21:07.400Z
and my `Birecursive` is:

```scala
  implicit def birecursive[Expr, Info]: Birecursive[Node[Expr, Info]] =
    new Birecursive[Node[Expr, Info]] {
      private type N = Node[Expr, Info]

      override type Base[A] = NodeF[Expr, Info, A]

      override def project(t: N)(implicit BF: Functor[Base[?]]): Base[N] = t match {
        case ExprNode(expr, info) => ExprNodeF(expr, info)
      }

      override def embed(t: Base[N])(implicit BF: Functor[Base[?]]): N = t match {
        case ExprNodeF(expr, info) => ExprNode(expr, info)
      }
    }
```

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T17:22:31.880Z
well, atm I'm just experimenting with this, seeing if it'll help my issue with pattern matching and building DSL

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-02T17:25:01.120Z
What version of Scala are you running?

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T17:25:15.674Z
oook, it works with:
```scala
  implicit def birecursive[Expr, Info] =
    Birecursive.algebraIso[Node[Expr, Info], NodeF[Expr, Info, ?]](
      {
        case ExprNodeF(expr, next, info) => ExprNode(expr, next, info)
      }, {
        case ExprNode(expr, next, info) => ExprNodeF(expr, next, info)
      }
    )
```

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T17:25:20.827Z
2.12.4

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-02T17:25:49.341Z
Do you have  `-Ypartial-unification` in your compiler options?

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T17:26:13.634Z
I've defined it both in SBT and IDEA, so I hope so :(

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-02T17:26:29.088Z
Right, here's your issue

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-02T17:26:45.669Z
Look at the difference between the two of those

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-02T17:27:07.719Z
`def birecursive[Expr, Info] = ...` and `def birecursive[Expr, Info]: Birecursive[Node[Expr, Info]] = ...`

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-02T17:27:23.465Z
Your type annotation here is *forgetting the value of `Base`*

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T17:27:50.993Z
ooooh :facepalm:

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T17:27:55.357Z
tnx!

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-02T17:28:04.726Z
You're welcome, so the solution here is to use `Birecursive.Aux`

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T13:11:21.937Z
continuing from yesterday, I'm trying to define `def transform[T, F[_]](x: T)(f: T => T)(implicit BC: Birecursive[T, F], F: Functor[F]): T): T`  that would be basically `cata` but for `Node => Node` instead of `Fix[NodeF] => Fix[NodeF]`

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T13:11:49.074Z
this is my first attempt, but isn't even close to compiling... I'm quite confused about `Birecursive` here...:

```scala
    implicit class AnyOps[T, F[_]](x: T) {
      def transform(f: PartialFunction[T, T])(
          implicit
          BC: Birecursive.Aux[T, F],
          F: scalaz.Functor[F],
      ): T = {
        val transformed =
          BC.cata[Fix[F]](x) {
            case x: F[Fix[F]] =>
              val embedded = BC.embed(x)
              val value = f.lift(embedded).getOrElse(embedded)
              val projected = BC.project(value)
              Fix(projected)
          }

        BC.embed(transformed.unFix)
      }
    }
```

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T13:15:23.287Z
hmm this compiles, though haven't tested if it works yet:
```scala
BC.cata[T](x) { x =>
  val embedded = BC.embed(x)
  f.lift(embedded).getOrElse(embedded)
}
```

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T14:07:13.850Z
@mfolnovic Look for `transCataT` … I think that still exists.

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T14:08:14.841Z
wow, tnx!

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T15:07:31.598Z
another question :angel: 

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T15:08:06.340Z
cata, but with state from previous element?

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T15:08:12.256Z
and of course, initial state...

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T15:09:02.807Z
e.g. `Cons(5, Cons(9, Nil))`, and let's say I want to increment first by 1, second by 2 etc.

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T15:09:57.153Z
and another, I assume trickier requirement... I would need to do that from both sides, so the other side would be: increment last by 1, second from last by 2 etc.

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T15:14:30.034Z
Well, the second one is easier … that’s just `cataM`. You might be able to avoid a hylo with something like `incrAlg :: AlgebraM[State[Int, ?], ListF[Int, ?], Int -> Int]`, then do `list.cataM(incrAlg).eval(1)(1)`.

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T15:16:32.988Z
hmm, it says:
`type AlgebraM[M[_], F[_], A] = F[A] => M[A]`

which looks like I wouldn't receive the state in my algebra? or I'm misunderstanding something? :(

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T15:17:39.827Z
To unpack that a bit … `State` is for the tail->head state, and `Int ->` is for the head->tail state (that is a bit of an attribute grammar trick for passing state up toward the leaves, even though you’re folding down toward the root). Then `cataM(incrAlg)` returns `State[Int, Int -> Int]`, so `.eval(1)` passes the tail->head initial state, and the second `(1)` applies the final `Int -> Int` function .

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T15:18:10.461Z
@mfolnovic Are you familiar with the State monad?

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T15:20:01.486Z
just in case, either I'm totally misreading what you are saying or you misunderstood me :) what I'd like to do is, receive a List, and based on some logic, choose if I'm going to increment it from last element or from first one, so something like:

`def increment(list: Fix[ListF], direction: Direction): Fix[ListF] = ???`

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T15:20:27.691Z
@mfolnovic What it effectively does is delay the processing, returning a function where you pass the initial state, and it applies that through all the nested state values. So `State[A, B]` is really `A -> (A, B)`, “given some initial state value, return a new state value and the result that required that state”.

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T15:20:30.299Z
hmm, I'm familiar and I guess I understand it, though haven't used it yet

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T15:21:30.475Z
ooh, I think I understand

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T15:22:06.124Z
I should have made this example with different types, it's kinda hard to differentiate `Int` between a value from list and state

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T15:23:18.600Z
Yeah, you should be able to do that `increment` approach with that type – What you’ll effectively return from the algebra is `Int -> Int -> Int`, where the first arg is the tail->head state, and the second is the head-to-tail state … actually, slight change …

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T15:23:49.170Z
Try `AlgebraM[State[Int, ?], ListF[Int, ?], State[Int, Int]]`.

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T15:24:48.251Z
ok, let me try to write all this on List example :)

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T15:25:45.929Z
Then you effectively return `Int -> (Int, Int -> (Int, Int)` … that’s a lot of `Int`s, but the first `Int -> (Int,` is the incoming and outgoing tail->head state and the second `Int -> (Int,` is the incoming and outgoing head->tail state, and the final `Int)` is the result.

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T15:26:14.419Z
But you don’t want the result to be Int … you want `List[Int]` … so `AlgebraM[State[Int, ?], ListF[Int, ?], State[Int, List[Int]]]`

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T15:26:18.834Z
*phew*

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T15:26:41.527Z
I haven’t done anything like that before, but I think it should work.

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T15:27:55.727Z
And to be clear, `Int -> (Int, List[Int])` isn’t literally what you have, but `State[Int, List[Int]]` is equivalent to that structure.

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T15:28:08.607Z
hah, I'm still kinda understanding this :)

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T15:30:54.373Z
@mfolnovic Then you’re doing better than me 😆

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T15:31:16.563Z
it doesn't look like that :P

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T15:41:10.029Z
`But you don’t want the result to be Int … you want List[Int] … ` didn't understand this? :(

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T15:57:07.371Z
@sellout I tried this, trying not do dig into State monad in Scalaz just yet, so:

```scala
  type Result = State[Int, Fix[ListF]]
  val incrementByState: AlgebraM[State[Int, ?], ListF[?], Result] = {
    case NilF() =>
      State[Int, Result] { incoming =>
        val result = State[Int, Fix[ListF]] { outgoing =>
          (outgoing + 1, Fix(NilF()))
        }

        (incoming + 1, result)
      }
    case ConsF(x, xs) =>
      State[Int, Result] { incoming =>
        val result = State[Int, Fix[ListF]] { outgoing =>
          (outgoing + 1, Fix(ConsF(x + incoming, ???)))
        }

        (incoming + 1, result)
      }
  }

  val result: State[Int, State[Int, Fix[ListF]]] = list.cataM(incrementByState)
  val (_, phase1)                                = result.apply(0)
  val (_, phase2)                                = phase1.apply(0)

  println(phase2)
```

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T15:57:24.088Z
but don't really know what I should put in `???`, since xs is of type `State[Int, Fix[ListF]]`

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T16:01:40.728Z
putting `xs.eval(outgoing)` there makes it work, `List(5, 9, 14) -> List(8, 11, 15)`

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T16:02:41.685Z
now just to figure out how to have `List(5, 9, 14) -> List(6, 11, 17)` ;)

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T16:03:07.818Z
You might want to start with different initial states (like `0` and `100` to make it clear you’re using the right one)

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T16:03:32.729Z
good point, tnx!

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T16:04:46.309Z
also changed:
```scala
  val (phase1State, phase1)                      = result.apply(0)
  val (phase2State, phase2)                      = phase1.apply(phase1State)
```

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T16:08:40.014Z
for some reason, `State[Int, Fix[ListF]] { outgoing =>` here, `outgoing` is always equal to what I give in `phase1.apply(...)`

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T16:08:49.196Z
Here’s something
```scala
val incrementByState: AlgebraM[State[Int, ?], ListF[?], State[Int, List[Int]]] = {
  case NilF() =>
    State(bottomUp => (bottomUp + 1, State(topDown => (topDown + 1, Nil))))
  case ConsF(x, xs) =>
    State(bottomUp =>
      (bottomUp + 1,
       State(topDown =>
         (topDown + 1,
          chooseDirection match {
            case BottomUp => (x + bottomUp) :: xs
            case TopDown => (x + topDown) :: xs
          }))))
}
```

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T16:09:12.709Z
So, `chooseDirection` returns which state you want to apply to that index.

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T16:11:19.591Z
`xs` is a `State[Int, List[Int]]`, so I guess you want to `eval` on that?

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T16:13:55.333Z
yeah, blindly changing yours to:
```scala
               case BottomUp => (x + bottomUp) :: xs.eval(bottomUp)
               case TopDown  => (x + topDown) :: xs.eval(topDown)
```

makes it behave same as mine, so I'm misunderstanding something here :(

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T16:26:21.926Z
Oh, whoops … 

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T16:26:27.523Z
You don’t want to eval.

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T16:30:12.236Z
@mfolnovic
```scala
val incrementByState: AlgebraM[State[Int, ?], ListF[?], State[Int, List[Int]]] = {
  case NilF() =>
    State(bottomUp => (bottomUp + 1, State(topDown => (topDown + 1, Nil))))
  case ConsF(x, tdState) =>
    State(bottomUp =>
      (bottomUp + 1,
       tdState >>= (\xs =>
         State(topDown =>
           (topDown + 1,
            chooseDirection match {
              case BottomUp => (x + bottomUp) :: xs
              case TopDown => (x + topDown) :: xs
            })))))
}
```
So, the change there is that you have to use `>>=` (`flatMap`) to “combine” the state.

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T16:35:03.703Z
hm, with eval, I actually got it working with:
```scala
               case TopDown =>
                 (x + topDown) :: xs.eval(topDown + 1)
```

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T16:35:21.083Z
for some reason, I get same result with either `BottomUp` or `TopDown` with your code :|

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T16:35:43.256Z
what should initial states be?

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T16:36:19.138Z
Same as with your version … I’m sure I just did something silly. Sorry, trying to focus on both this and work, and failing :D

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T16:36:57.214Z
oh, sorry :(

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T16:37:18.813Z
and I actually changed both initial states to zero

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T16:39:24.194Z
```
input == List(5, 9, 6)

both initial states == 0:
TopDown: List(8, 11, 7)
BottomUp: List(8, 11, 7)

second initial state == first final state
TopDown: List(8, 11, 7)
BottomUp: List(12, 15, 11)
```

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T16:40:46.745Z
`12 == 5 + 3 + 4`, `15 == 9 + 2 + 4`, `11 = 6 + 1 + 4`

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T16:53:56.833Z
I understand why `eval` variant works, though it's also (hopefully unnecessarily) slow, but can't figure out how to make your variant work :/

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T17:03:20.625Z
I think it might be time to switch back to a Scalaz or Typelevel channel again :D Glad you have something that works now, though.

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T17:06:06.631Z
not sure if someone who doesn't understand `cataM` would figure out how this works :(

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T17:06:15.775Z
but thanks for all the help :)

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T17:09:37.679Z
True … I might get time to look at it more later. But I haven’t been trying to compile any of this or anything, so it’s very hand-wavy. Now that I’m not working in Scala, sbt and everything seem very out of reach :D

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T17:10:04.782Z
still amazing you came up with this without compiling :D

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T17:10:32.331Z
in the meantime, i'll try to write this same thing with normal recursion and without Fix and ask in Scalaz :)

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-03T19:12:18.594Z
Hi again, I've been trying to use the operation generalizeM from the AlgebraOps trait, but it doesn't seem to work the way I thought it does

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-03T19:13:09.438Z
I was expecting to be able to call it like (myAlgebra:Algebra[MyF,MyA]).generalizeM[Option]

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-03T19:13:43.829Z
but the above doesn't compile, I have the standard imports in scope, matryoshka._, matryoshka.implicits._ etc...

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-03T19:14:02.489Z
Is that expected?

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-03T19:14:11.740Z
or should it work as I thought?

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T19:14:33.926Z
@freskog Hrmm … that’s how I would expect it to work, too. What’s the error?

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-03T19:15:58.651Z
value generalizeM is not a member of matryoshka.Algebra[experiments.EntityF,scalaz.Cofree[experiments.EntityF,experiments.EntityF.Hash]]
[error]     optionDecoder[Cofree[EntityF,Hash]]( _.hyloM(merkleAlgebra.generalizeM[Option], entityDecoderCoalgebraM), "EntityF")


                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-03T19:18:27.446Z
when trying to compile 
optionDecoder[Cofree[EntityF,Hash]]( _.hyloM(merkleAlgebra.generalizeM[Option], entityDecoderCoalgebraM), "EntityF")

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-03T19:18:44.977Z
```optionDecoder[Cofree[EntityF,Hash]]( _.hyloM(merkleAlgebra.generalizeM[Option], entityDecoderCoalgebraM), "EntityF")```

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-03T19:19:31.126Z
if I change it to 
```optionDecoder[Cofree[EntityF,Hash]]( _.hyloM(merkleAlgebra andThen (Option(_)), entityDecoderCoalgebraM), "EntityF")```

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-03T19:19:34.641Z
it compiles 

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T19:21:11.947Z
Yeah … the whole point of `generalizeM` was to fix inference issues … I would prefer to write `merkleAlgebra >>> pure` anyway (or `andThen` if you like). So, if it’s not converting/inferring properly, then I would do what you’re doing.

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T19:21:16.772Z
Sorry about that :/

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-03T19:21:45.796Z
No worries, it's not a problem 

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-04T10:03:36.375Z
me again :joy: I defined my structure as (simplified):

```scala
case class Container(node: Node, info: Info)

sealed trait Node
case class ExprNode(expr: Expr) extends Node
case class WhileLoopNode(condition: Expr, body: Container) extends Node
```

which looks natural to me (?)

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-04T10:04:18.111Z
so I also tried to define:

```scala
case class ContainerF[T](node: T, info: Info)

sealed trait NodeF[T]
case class ExprNodeF[T](expr: Expr) extends NodeF[T]
case class WhileLoopNodeF[T](condition: Expr, body: T) extends NodeF[T]
```

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-04T10:04:51.040Z
which isn't really right I guess, because I can't enforce that `body` is always a `Container`, which makes sense to me?

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-04T10:05:28.005Z
so then I tried to define it as:

```scala
case class ContainerF[T](node: T, info: Info)

sealed trait NodeF[T]
case class ExprNodeF[T](expr: Expr) extends NodeF[T]
case class WhileLoopNodeF[T](condition: Expr, body: ContainerF[T]) extends NodeF[T]
```

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-04T10:08:07.818Z
but I'm having issues defining `Birecursive` ...

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-04T10:08:37.212Z
this is my attempt:

```scala
  implicit def containerBirecursive =
    Birecursive.algebraIso[Container, ContainerF[?]](
      {
        case ContainerF(node, info) => Container(node, info)
      }, {
        case Container(node, info)  => ContainerF(node, info)
      }
    )

  implicit def nodeBirecursive =
    Birecursive.algebraIso[Node, NodeF[?]](
      {
        case ExprNodeF(expr)                 => ExprNode(expr)
        case WhileLoopNodeF(condition, body) => WhileLoopNode(condition, body)
      }, {
        case ExprNode(expr)                 => ExprNodeF(expr)
        case WhileLoopNode(condition, body) => WhileLoopNodeF(condition, body)
      }
    )
```

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-04T10:10:56.281Z
errors:

```
[error] /home/mfolnovic/dev/projects/playground/src/Playground.scala:72: type mismatch;
[error]  found   : Playground.Container
[error]  required: Playground.Node
[error]                                                  ^
[error] /home/mfolnovic/dev/projects/playground/src/Playground.scala:74: type mismatch;
[error]  found   : Playground.Node
[error]  required: Playground.Container
[error]                                                  ^
[error] /home/mfolnovic/dev/projects/playground/src/Playground.scala:82: type mismatch;
[error]  found   : Playground.Node
[error]  required: Playground.Container
[error]                                                                          ^
[error] /home/mfolnovic/dev/projects/playground/src/Playground.scala:85: type mismatch;
[error]  found   : Playground.Container
[error]  required: Playground.Node
[error]                                                                          ^
```

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-04T10:28:36.922Z
I also tried doing something like: https://gist.github.com/mfolnovic/a66dba4fb7bdf1ab75b48f689109d81a

                                                                                                                                                      Greg Pfeil @sellout@2018-01-04T15:12:48.433Z
@mfolnovic Ok, yeah, you are entering dangerous waters … but I think there’s a way out for you.

                                                                                                                                                      Greg Pfeil @sellout@2018-01-04T15:14:09.456Z
“Mutual recursion” is when you have two structures that refer to each other, and you have to use something more akin to an HList to manage it – where at each recursive point, you have to indicate _which_ structure belongs there. It’s totally feasible, but hasn’t been integrated into Matryoshka (there is a PR, though).

                                                                                                                                                      Greg Pfeil @sellout@2018-01-04T15:14:56.911Z
However … in your case, it seems like you strictly alternate between the two types, which is good - it means the mutual part can be eliminated.

                                                                                                                                                      Greg Pfeil @sellout@2018-01-04T15:15:08.677Z
In two different ways, in your particular case.

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-04T15:15:44.752Z
in what two ways? :)

                                                                                                                                                      Greg Pfeil @sellout@2018-01-04T15:16:39.501Z
1. flatten the structure, something like `WhileLoopNodeF[T](condition: Expr, body: T, info: Info)`, eliminating Container

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-04T15:17:03.009Z
1. I actually had that, and I refactored it to this :joy: 

                                                                                                                                                      Greg Pfeil @sellout@2018-01-04T15:17:17.709Z
2. just eliminate the Birecursive instance for Container, and handle modifying the Container within the Node instance.

                                                                                                                                                      Greg Pfeil @sellout@2018-01-04T15:17:29.684Z
Ugh, Gitter doesn’t like me numbering things.

                                                                                                                                                      Greg Pfeil @sellout@2018-01-04T15:17:42.380Z
There’s also a third way, which is my favorite.

                                                                                                                                                      Greg Pfeil @sellout@2018-01-04T15:18:21.977Z
Eliminate `ContainerF`, and make your recursive structure `Fix[EnvT[Info, NodeF, ?]]`

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-04T15:18:43.873Z
in your second case, I'm actually having difficulty defining `Eq`

                                                                                                                                                      Greg Pfeil @sellout@2018-01-04T15:19:01.150Z
EnvT is basically a recursive tuple (which is what Cofree is – `type Cofree[F[_], A] = Fix[EnvT[A, F, ?]]`)

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-04T15:19:43.971Z
oh, let me look that into, tnx!

                                                                                                                                                      Greg Pfeil @sellout@2018-01-04T15:19:54.710Z
So you can annotate your structure with Info when you want it, and in other cases simply have `Fix[NodeF]` (or even treat the EnvT structure _as if_ it were `Fix[NodeF]` (ignoring the annotation without discarding it).

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-04T15:21:54.081Z
I had issues with diverging implicits (while defining `Eq` for `ContainerF`), but I just stumbled upon:

```scala
/** To avoid diverging implicits with fixed-point types, we need to defer the
  * lookup.
  */
trait Delay[F[_], G[_]] {
  def apply[A](fa: F[A]): F[G[A]]
}
```

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-04T15:22:25.919Z
I'll play around both of those ideas and see which looks better in my case, thank you for your help, I really appreciate it! :blush: 

                                                                                                                                                      Greg Pfeil @sellout@2018-01-04T15:23:39.688Z
Yeah, `Delay` is definitely what you want for defining instances on functors. 👍🏼

                                                                                                                                                      Greg Pfeil @sellout@2018-01-04T15:23:46.488Z
No worries – glad to help.

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-04T19:32:24.567Z
I'm wondering if it's possible to compose multiple F-Algebras

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-04T19:33:08.026Z
Basically, imagine I have a bunch of rewrite rules like Algebra[F,Fix[F]] or something, and I want to chain them to one call of cata

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-04T19:34:01.244Z
like  someData.cata(alg1 compose alg2)

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-04T19:34:36.235Z
I haven't figured out how to do that yet (in such a way that it generalizes to an arbitrary amount of algebras)

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-04T19:34:39.945Z
Any tips?

                                                                                                                                                      Greg Pfeil @sellout@2018-01-04T19:39:43.118Z
@freskog Yep, definitely. The easiest way is if you can actually define one of the algebras as a natural transformation `F ~> F`. But even without that, you can do `alg2 . project . alg1` … but I also find sometimes it’s simpler to define a function `F[Fix[F]] -> F[Fix[F]]` (which Matryoshka calls a `Transform`) than an `Algebra` (by simpler, I mean that you are basically just doing `.embed` at the end of every case, so that you can just delete those and end up with a transform).  If you can do that, then you could do `alg2 . trans1` (where `trans1` is just `alg1` with all the trailing `.embed`s removed). Then you can also still use `.cata(embed . trans1)`, but you don’t end up with an invisible `project . embed` isomorphism in your algebra.

                                                                                                                                                      Greg Pfeil @sellout@2018-01-04T19:39:46.108Z
Does that make sense?

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-04T19:48:35.791Z
Yeah, I just tried the EndoTransform

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T16:07:50.901Z
Hi guys. I have an AST with a node of the form `AndThen[A](lhs: A, rhs: A)`. I want to write a fold that evaluates this AST but semantically I need the result of the evaluation of `lhs` to evaluate `rhs`, so `cata` doesn't seem to be a viable option. Is there a scheme that allows that ?

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T17:10:47.387Z
Reading the cheat-sheet, `histo` is said to carry "the previous answers it has given".  So I suppose it might be worth trying, but I'm not sure how to use it yet

                                                                                                                                                      Greg Pfeil @sellout@2018-01-06T20:24:34.274Z
@vil1 para might do you better than histo – you get a pair of the original subtree and the result for that node, so you can ignore the lhs subtree and re-evaluate the rhs subtree the way you want.

                                                                                                                                                      Greg Pfeil @sellout@2018-01-06T20:27:06.245Z
Alternatively, an attribute grammar, where you fold to A => A, then you return exactly `rhs <<< lhs` for that node.

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T20:43:13.557Z
what is an attribute grammar ?

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T20:43:54.957Z
(I do not understand your second line at all :worried: )

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T20:47:31.902Z
With para, when it comes to a `AndThen` node, I'll receive a `(result, original)` pair for both `lhs` and `rhs`,  but in order to use the result from `lhs` in the evaluation of `rhs`, won't I need to fold again on `rhs`'s ``original` ?

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T20:54:45.145Z
`rhs <<< lhs` (as you might have guessed) is really what I want to achieve here (but https://en.wikipedia.org/wiki/Attribute_grammar doesn't help much)

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T20:55:10.280Z
I'd say just use `cata` and put a function in your carrier

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T20:56:20.321Z
I don't think I can do that. I want to be able to (de)serialize my carrier

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T20:56:32.141Z
Why???

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T20:57:11.968Z
Why do I want to serialize or why can't I put a function in it ?

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T20:57:16.544Z
Is your tree distributed between machines?

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T20:57:56.710Z
it will be stored in a database

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T20:58:03.465Z
Right but your carrier is transient

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T20:58:09.846Z
When your cata is done you get a function

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T20:58:13.445Z
You feed it your "starting" state

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T20:58:16.809Z
Now it's not a function anymore

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T20:58:25.987Z
You can store it any way you wish

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T20:58:51.670Z
but I want to store "the function" 

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T20:59:40.379Z
You want to store the output of interpreting your tree

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T20:59:46.542Z
concretely, my carrier represents a form definition (and embedded in it, the way I need to validate input), but this definition is data in my domain

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T21:00:27.155Z
Your carrier represents a form definition? Doesn't your tree represent the form definition?

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T21:00:36.277Z
Can you show code?

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:01:07.752Z
I think I don't understand what you call carrier (> <)'

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T21:01:17.556Z
`F[A] => A`

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T21:01:19.875Z
`A` is your carrier

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:01:23.565Z
ahhh

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:01:27.428Z
my bad

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T21:01:37.522Z
Ah okay now I think we understand each other :)

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:01:58.794Z
and I think my mind has blown, again

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T21:02:14.558Z
:fire: 

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:02:24.764Z
lemme scroll up a few line and read that again with that new perspective

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:04:10.507Z
(and ponder for a while)

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T21:04:16.946Z
:thinking:

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:07:14.923Z
so what you're saying is that I should `cata`to produce, say, a `Map[String, String] => ValidationResult`

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T21:07:25.249Z
Sure, something like that

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:10:55.993Z
it's worth a try

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:12:05.773Z
awesome if it works, since it means I'd need to fold the definition only once, and apply the resulting function for each input

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:13:28.421Z
but in the case of validation errors, I'll want to generate a tree (form) decorated with the errors (so that I can send back some HTML to the client)

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:13:52.955Z
I'll sure won't go to bed early tonite ^^

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T21:14:19.655Z
Maybe you need some kind of "path" type which represents how you can drill down from the top of the tree to the "current" leaf that you can return with errors

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:14:41.654Z
yep, I already have something like that

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T21:15:12.146Z
Yeah, just represent the "current" path as state in your algebra (as both an input and an output to the function) and away you go

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:15:14.427Z
I basically `ana` to a `EnvT[Path, Form, ...]`

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T21:15:34.509Z
Could do that too

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:16:32.930Z
more precisely, I have a Coalgebra that does that, so my Algebra will get a proper EnvT as input

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:16:56.852Z
sounds like a plan then

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T21:17:01.963Z
Could also put it into your algebra and avoid the ana call, if you prefer, but yeah

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:18:50.540Z
I don't call ana but hylo

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T21:18:57.921Z
Ah right

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:19:28.819Z
the coalgebra decorates the tree with the path, and the algebra ... is now to rewrite XD

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T21:19:38.320Z
Right I see

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:26:43.665Z
> did you have fun last Saturday night ?


                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:27:03.179Z
> you bet ! I wrote an `Algebra[EnvT[Path, FormF, ?], DecodedForm => Either[T[EnvT[Option[Error], FormF, ?]], FormValue]]`

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:37:48.863Z
BTW and **for the record**, @edmundnoble, @sellout, I owe you both an <insert your favorite beverage> for the patience you've shown with my questions and the wise answer you gave me in 1+ year of me trying to make sense of all that recursion stuff and I'm a man of my words, so I hope we'll meet someday

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T21:38:24.113Z
Hope so too, that'd be cool :)

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:43:05.767Z
Funnily enough, I've been convinced to submit a "Practical applications of recursion schemes" workshop to LC2018, if it's accepted we might meet in Boulder

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T21:43:22.564Z
Very likely

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:49:39.015Z
^^

                                                                                                                                                      Greg Pfeil @sellout@2018-01-07T04:09:13.633Z
👍🏾

                                                                                                                                                      Greg Pfeil @sellout@2018-01-07T04:11:17.982Z
@vil1 Sorry – I was skiing earlier. But “put a function in your carrier” == “fold to `A => A`” == attribute grammar.

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-07T04:11:30.002Z
Oh that's what an attribute grammar is!

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-07T04:11:40.015Z
I didn't get anything from the wiki page either :P

                                                                                                                                                      Greg Pfeil @sellout@2018-01-07T04:16:07.647Z
@edmundnoble I’m not sure I really understand them. Someone was explaining them to me one day, and I was like “oh, I think you can do that with recursion schemes by folding to a function” and the next day they sent me a link to something that agreed with me, so I’m satisfied.

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-07T04:16:48.561Z
"The synthesized attributes are the result of the attribute evaluation rules, and may also use the values of the inherited attributes. The inherited attributes are passed down from parent nodes."

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-07T04:16:57.596Z
This certainly sounds like something I can do with `A => A`

                                                                                                                                                      Greg Pfeil @sellout@2018-01-07T04:20:40.516Z
Still trying to figure out Löb, though 😄

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T14:04:40.217Z
Здравствуйте

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T14:10:24.007Z
👋🏾

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T14:10:55.359Z
I wanted to call the library “

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T14:11:15.357Z
Ugh.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T14:11:26.666Z
`plugins.sbt` pulls in `"org.kohsuke" % "github-api" % "1.59"`  which has an alarming number of dependencies. Is it being used or is this an artifact from the original slamdata build?

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T14:11:36.754Z
матрёшка”, but even I can't type that easily.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T14:12:02.822Z
I think that's not necessary.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T14:12:38.169Z
I only noticed because I'm on the plane home and it was taking a while.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T14:15:43.792Z
I still have more of the stuff to support your use cases to commit, meant to get it in last night, but forgot my power cord at the conference. Stole one from my brother this morning, though.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T14:17:12.192Z
Are you talking about matryosha at LambdaConf?

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T14:17:38.027Z
```scala
scala> val матрёшка = 42
матрёшка: Int = 42
```

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T14:17:51.812Z
Heh, it would have worked too. 

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T14:18:00.706Z
Well, I’m going to submit a talk about it to the Typelevel summit. And I’m doing a recursion-schemes-in-haskell workshop.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T14:20:02.993Z
Ok cool. I'm going to get my stuff working with matryoshka and give it a shout-out next time I do that talk.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T14:21:58.093Z
I translated some of the stuff from your talk: https://gist.github.com/sellout/b29f1aec33bb841df109 (but again, it requires not-yet-committed changes).

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T14:22:35.129Z
oh sweet

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T14:25:09.528Z
I really appreciate your help and encouragement on this, by the way.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T14:25:20.333Z
As someone (forget who 😕) pointed out in my unsession, you can `.embed` with `Cofree[F, A]` if the `A` has a monoid. Which is what lets the `convertTo` line work, but haven’t committed that, so currently only the `cata` line above it works.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T14:25:43.759Z
oh right, ok

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T14:25:45.367Z
@tpolecat I really appreciate that I’m not the only one actually playing in this space!

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T14:26:01.247Z
Right!

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T14:55:23.940Z
@tpolecat If you clone sellout/matryoshka (rather than slamdata), the “doobied” branch should have everything you need.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T14:56:40.780Z
I’ll get a PR in soon.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T14:56:52.699Z
soon = in a few days :D

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T14:56:53.714Z
rock on, thanks! 

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T14:57:27.039Z
I was trying to figure out how to express this in terms of the slamdata head and wasn't seeing it.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T15:04:55.392Z
I'm not seeing the `.cata` syntax, and the type of `Recursive[Fix].cata` doesn't seem to be what I want. Trying to go `Fix[F] => Cofree[F, Unit]`.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T15:05:32.103Z
It wants `F[A] => A` which I can't provide for `ProfF`.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T15:05:51.456Z
I might be reading it wrong.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T15:06:31.856Z
Well, `Cofree((), _)` is `F[Cofree[F, Unit]] => Cofree[F, Unit]`, but wait …

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T15:06:52.279Z
You can actually go directly `Fix[F] => Cofree[F, Int]`

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T15:07:33.096Z
Yeah, I was just trying baby steps.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T15:07:49.428Z
Oh, sorry. Yeah.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T15:08:06.763Z
I think I'm reading it wrong. `A` is going to be the cofree.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T15:08:12.775Z
Right, exactly.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T15:09:59.404Z
The `.cata` syntax … oh, right … so, I still have to fix imports and stuff. Right now you need to explicitly `import matryoshka.Recursive.ops._`, because I haven’t done anything to organize the ops generated by Simulacrum.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T15:10:46.482Z
oh ok, i haven't used simulacrum before

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T15:11:11.673Z
That should be the only one you need, though … most of the other ops are manually created and the implicit conversions are directly in the matryoshka package.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T15:11:40.106Z
Eventually something like `import matryoshka.syntax._` will get you all the ops, like in Cats.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T15:11:53.168Z
right right

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T15:12:00.765Z
works. this is so badass

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T15:12:08.909Z
💃🏽

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T15:15:58.072Z
It does require a type arg, which may be unavoidable.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T15:16:17.364Z
```scala
p.cata[Cofree[ProfF, Unit]](Cofree((), _))
```

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T15:17:22.984Z
Actually we may be able to fix that with an unapply. I'll give it a try.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T15:20:47.488Z
`p.cata(Cofree[ProfF, Unit]((), _))` should work, too, right?

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T15:20:58.575Z
eliminates one `Cofree`.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T15:21:13.690Z
ah maybe

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T15:22:27.018Z
`p.convertTo[Cofree[?[_], Unit]]` _should_ work, but that might actually have trouble finding the right implicit?

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T15:25:25.674Z
Yeah that works. Type args on `Cofree` don't work.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T15:25:31.791Z
```scala
    val p0 = Recursive[Fix].cata[ProfF, Cofree[ProfF, Unit]](p)(Cofree((), _))
    val p1 = p.cata[Cofree[ProfF, Unit]](Cofree((), _))
    val p2 = p.convertTo[Cofree[?[_], Unit]]
```

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T15:26:22.930Z
So all of those are ok.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T15:28:04.053Z
Cool, so yeah, we need like cataU, etc. to handle things with a `[?[_], A]` shape automatically, right?

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T15:37:42.786Z
I tried it for a minute and it didn't look like it would work the way it's written because you need the `F` immediately, so maybe with the partially applied trick.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T15:43:51.912Z
If you want to open an issue and assign it to me I can put on my weeine hat and see what I can do.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T15:45:07.327Z
I think I'm too wrecked to cope with `Unapply` today though ;-)

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T15:45:21.221Z
Hahaha – yeah, understood.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T15:45:48.716Z
I’ll open an issue, but out of curiosity, _can_ you open an issue / assign it? Or do you have to be a member of the org to do so?

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T15:46:08.355Z
Seems like anyone should be able to open one. Just want to make sure I don’t have any settings that need changing.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-06T15:46:27.786Z
Oh, dunno. An `@` mention works.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-06T15:48:00.114Z
*sigh* … too many chat clients. I got all of my services into one, but now we have a new generation of proprietary protocols.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-09T01:01:08.751Z
If Scala Exercises ends up not being ready for prime time I'm happy to help you get set up with tut. Not much to it really.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-09T01:01:31.969Z
I think Scala Exercises or something like it might subsume tut at some point though. It's really promising.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-09T03:23:42.424Z
Yep, I'm planning to use tut for the docs. I have a backlog of changes to get merged first (including the stuff for Doobie).

                                                                                                                                                      Greg Pfeil @sellout@2016-03-09T21:10:46.555Z
@tpolecat The changes for Doobie are released in v0.4.0.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-09T21:42:12.949Z
Rock on, thanks! Did you publish it anywhere or should I just build locally?

                                                                                                                                                      Greg Pfeil @sellout@2016-03-09T21:42:32.654Z
It’s on sonatype … oh, I should add that to the README :D

                                                                                                                                                      Greg Pfeil @sellout@2016-03-09T21:43:03.154Z
"com.slamdata" %% "matryoshka-core" % "0.4.0"

                                                                                                                                                      Rob Norris @tpolecat@2016-03-09T21:43:08.836Z
\o/

                                                                                                                                                      Greg Pfeil @sellout@2016-03-13T15:48:02.308Z
If anyone *cough* @tpolecat *cough* wants to comment on the crazy Scala tricks in #13, that’d be great.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-13T18:17:32.663Z
this is some crazy computer shit right here

                                                                                                                                                      Rob Norris @tpolecat@2016-03-13T18:18:45.653Z
you're generalizing generalizations of things i don't understand to begin with, but i'll take a look

                                                                                                                                                      Greg Pfeil @sellout@2016-03-13T18:55:46.684Z
@tpolecat Yeah, but I'm guessing you're more familiar with how to convince Scala of things in general.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-13T19:08:29.449Z
Also, I need to add _tons_ of docs, so questions help, too :D

                                                                                                                                                      Rob Norris @tpolecat@2016-03-13T19:21:49.014Z
@sellout your `version.sbt` is sitting on the next version rather that `-SNAPSHOT` which makes it a little harder to `publish-local` … not a big deal but slightly unusual

                                                                                                                                                      Greg Pfeil @sellout@2016-03-13T19:23:01.669Z
@tpolecat Oh, we’re trying to do continuous delivery. Every merge into master is a new release. So we don’t bother to go back to SNAPSHOT in between. Did you just manually edit version.sbt for publish-local?

                                                                                                                                                      Rob Norris @tpolecat@2016-03-13T19:23:38.139Z
Ok, gotcha.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-13T19:23:46.852Z
Yeah I just manually change it.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-13T19:25:50.094Z
So, I’m open to better ways to manage what we’re doing. I didn’t really find anything on doing continuous delivery in Scala. Everything is very open to input 😄

                                                                                                                                                      Rob Norris @tpolecat@2016-03-13T19:29:04.387Z
I have never done continuous delivery so I have no idea. The verizon boys do continuous delivery but they do have snapshots so their CI system must roll the version.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-13T19:30:07.534Z
Stylistic question … we make pretty much everything available both with and without `ops`, which is easy with @typeclass. But how bad is it to make certain things kind of _only_ available in `ops` style?

                                                                                                                                                      Greg Pfeil @sellout@2016-03-13T19:31:46.685Z
E.g., there are methods `hylo` and `chrono`which are just specializations of `ghylo` (and specializing it makes inference better, eliminates some parameters, etc.). But it would be nice to only define `hylo` and `chrono` in `IdOps`, and not making them available via the package object. But will users hate me?

                                                                                                                                                      Greg Pfeil @sellout@2016-03-13T19:32:19.251Z
If you don’t use `ops` style, you could still call `ghylo` directly, it’s just noisier.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-13T19:33:47.192Z
I think there's some wiggle room for trivial variations that exist only in syntax.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-13T19:34:03.411Z
You might be able to find people who would object loudly but seems ok to me.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-13T19:34:21.006Z
Cool. I always like maintaining less code.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-13T19:37:42.161Z
Also I have to tell you I'm irritated at your  `cofreeShow[F[_], A: Show](implicit F: (Show ~> λ[α => Show[F[α]]]))` because it took me a really long time to figure out how to encode that in Scala and yours is better than mine.


                                                                                                                                                      Rob Norris @tpolecat@2016-03-13T19:37:48.613Z
;-)

                                                                                                                                                      Greg Pfeil @sellout@2016-03-13T19:39:41.777Z
Heh, I came up with that after the first time I spoke about recursion schemes (internally at SlamData), and I was trying to explain the structure to people unfamiliar with Cofree. Of course, it’s a bad Show instance, because you couldn’t write a Read instance to match it ;)

                                                                                                                                                      Greg Pfeil @sellout@2016-03-13T19:41:04.389Z
Oh, you mean the NaturalTransformation bit? I stole that from something in Scalaz. But I don’t recall what. I think it may have been some other instance on Cofree. But I use it all over Quasar now.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-13T19:42:19.579Z
Oh you know what, I think I was doing something more general.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-13T19:42:20.123Z
https://gist.github.com/tpolecat/0ef576a0150d95b4d9e6

                                                                                                                                                      Rob Norris @tpolecat@2016-03-13T19:43:42.873Z
Kinda squinting at it now. It made sense at the time.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-13T19:44:38.431Z
Ahaha, I have thought about something like `~~>`, but never made it. Makes total sense!

                                                                                                                                                      Rob Norris @tpolecat@2016-03-13T19:44:40.084Z
Nope, same thing you're doing. Oh well.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-13T19:48:48.121Z
Stylistically you might get some complaints about things like `(a(node ∘ (_ ∘ (_ ∘ (_._1)))) ⊛ b(node ∘ (_ ∘ (_ ∘ (_._2)))))((_, _))` because the bullet-like things are hard to distinguish and aren't in common use.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-13T19:49:11.816Z
Fine w/me though.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-13T19:49:28.498Z
I will fight to the death for my Unicode operators ;)

                                                                                                                                                      Rob Norris @tpolecat@2016-03-13T19:50:51.461Z
Rock on.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-13T19:56:43.238Z
The poor man's unapply seems good to me. It handles the [co]free shape which is the main use case. The normal unapply machinery has the hole in the wrong place so I think you would end up having to rewrite it anyway.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-13T20:44:36.024Z
Actually I'm going to give it another try. I think I see what I need to do.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-13T20:45:42.167Z
👍🏾 (want Slack reactions here so bad)

                                                                                                                                                      Rob Norris @tpolecat@2016-03-13T23:30:55.167Z
so ... close

                                                                                                                                                      Rob Norris @tpolecat@2016-03-14T04:18:16.086Z
@sellout ok i made a wip pr against your branch so you can see what i figured out. looks like it's possible

                                                                                                                                                      Greg Pfeil @sellout@2016-03-20T02:09:22.318Z
@tpolecat BTW, `Nu` is fixed now, so we have codata.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-20T02:31:36.235Z
:+1: 

                                                                                                                                                      Greg Pfeil @sellout@2016-03-20T02:38:37.180Z
#19 

                                                                                                                                                      Greg Pfeil @sellout@2016-03-22T02:09:08.695Z
@tpolecat unfolding to `Nu[ProfF]` would be an alternative to the case where you call the coalgebra directly – it’s lazy, so you can treat it like the corecursive structure, rather than having to explicitly apply the coalgebra at each step.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-22T02:33:55.107Z
@sellout not quite sure which step you're talking about. you mean the `unfoldCM`?

                                                                                                                                                      Rob Norris @tpolecat@2016-03-22T02:34:41.593Z
i really need to work on this presentation so i have time for you to correct it for me!

                                                                                                                                                      Greg Pfeil @sellout@2016-03-22T02:36:37.814Z
@tpolecat In your unsession at NEScala, you showed a case (and maybe it was just for example) where you called a function with the type `Int ⇒ ConnectionIO[ProfF[Int]]` directly, returning a single Prof where the students were just represented by their dbid.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-22T02:36:50.812Z
right, yes

                                                                                                                                                      Greg Pfeil @sellout@2016-03-22T02:37:07.954Z
Was that just for illustration?

                                                                                                                                                      Rob Norris @tpolecat@2016-03-22T02:37:46.113Z
No, it seemed like a good idea since I can then `.unfoldCM` with that to get the `ConnectionIO[Cofree[ProfF, Int]]`.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-22T02:37:58.384Z
So what does `Nu` do for me?

                                                                                                                                                      Greg Pfeil @sellout@2016-03-22T02:41:38.009Z
But I mean, was calling it directly for illustration? Passing it to `unfoldCM` ends up giving the recursive structure all at once (once you run that monad). When you might only care about a small slice of the results, right?

                                                                                                                                                      Rob Norris @tpolecat@2016-03-22T02:42:16.814Z
Yes, right. It materializes the whole structure from the root.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-22T02:43:28.651Z
So, yeah, I’m not positive about `Nu` in monads. I have to think about that.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-22T02:44:41.547Z
For your stuff, this requires a few other things … like you can define `type Cofree[F[_], A] = Mu[Ann[F, A, ?]]`.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-22T02:44:58.097Z
Mmmm. Ok.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-22T02:45:17.394Z
But, you can have an attributed stream (CoCofree?) like `Nu[Ann[F, A, ?]]`.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-22T02:46:59.928Z
Anyway, I’m just meandering now.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-22T02:47:19.157Z
But the idea of `Nu` is having a stream/codata of any data structure.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-22T02:48:25.557Z
So `type List[A] = Mu[ListF[A, ?]]` and `type Stream[A] = Nu[ListF[A, ?]]`

                                                                                                                                                      Rob Norris @tpolecat@2016-03-22T02:49:06.064Z
So when you do `unfoldCM` you have to traverse `F` which kind of forces things I think. I don't know what the effectful streamy type would look like.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-22T02:49:34.807Z
I need to sit down and play with `Mu` and `Nu` because I don't know anything about them. I get `Fix` and `Cofree` but just don't have any exposure to the others.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-22T02:49:50.245Z
Yeah, exactly. I wasn’t thinking of ConnectionIO when I first mentioned Nu, then you threw a wrench in the works, as always ;)

                                                                                                                                                      Rob Norris @tpolecat@2016-03-22T02:50:01.513Z
\o/

                                                                                                                                                      Rob Norris @tpolecat@2016-03-22T02:50:23.529Z
Although something I was interested in illustrating would be:

                                                                                                                                                      Rob Norris @tpolecat@2016-03-22T02:51:06.222Z
`case class Foo[A](data: Whatevs, parent: Option[A], children: List[A])` where you can walk the structure up and down forever.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-22T02:51:22.198Z
And I don't know if you can do that with `Fix`.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-22T02:52:53.380Z
I haven't tried it. Would be a cool trick if I could unfold the database structure into a doubly-linked tree.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-22T02:53:12.505Z
So maybe `Nu` could do that?

                                                                                                                                                      Greg Pfeil @sellout@2016-03-22T02:53:39.317Z
Yeah, that’s where you want things like Mu/Nu.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-22T02:53:59.672Z
Ok, cool.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-22T02:55:30.522Z
A “true” stream is the minimal argument for Nu, I think: `final case class StreamF[A, R](head: A, tail: R)`

                                                                                                                                                      Greg Pfeil @sellout@2016-03-22T02:56:21.485Z
`Fix[StreamF]` is going to get you in trouble instantly.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-22T02:57:14.627Z
So, `scalaz.Cofree` is trampolined which might be cheating. Is it supposed to be finite?

                                                                                                                                                      Rob Norris @tpolecat@2016-03-22T02:59:50.707Z
Like, `Cofree.unfoldC(1)(a => Option(a + 1))` terminates but you can peel off layers forever.

                                                                                                                                                      Rob Norris @tpolecat@2016-03-22T03:00:19.831Z
Ok bedtime for 2yo, gotta run. Thanks for your help, this is a lot of fun.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-22T03:00:30.144Z
Right, I think trampolining gets you that, too. I’m not sure what the tradeoffs are. Cool. Thank _you_.

                                                                                                                                                      Greg Pfeil @sellout@2016-03-28T17:28:36.192Z
Really need to convince myself that `type Free[F[_], A] = Nu[CoAnn[F, A, ?]]` is equivalent to the trampolined version.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-01T15:05:40.200Z
So, did some thinking about Cofree last night. Realized that the `Mu[Ann[F, A, ?]]` encoding simplifies a bunch of things for Matryoshka.  One of those things is that `unfoldC` (which I called `attributeAna` in Matryoshka) no longer needs its own operation. Instead of `1.attributeAna(a => Option(a + 1))`, you can do `1.ana(attribute(a => Option(a + 1)))`. I.e., the `attribute` function transforms the coalgebra from `Int => Option[Int]` into `Int => Ann[Option, Int, Int]`. And if you unfold into `Mu`, you end up with `Mu[Ann[Option, Int, ?]]`, which is Cofree.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-01T15:07:03.298Z
And other classes of things change in a similar way – meaning most (all?) of the operations outside of the generalized core can be brought into it.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-01T15:08:28.980Z
Also, it turns out that `Ann[F[_], A, B]` ≣ `EnvT[A, F[_], B]`, which is already in Matryoshka. (`EnvT[A, F[_], B]` is the comonad transformer for `(A, F[B])`.)

                                                                                                                                                      Greg Pfeil @sellout@2016-04-01T16:41:41.766Z
Oh man, this just made me realize why Kmett’s using open type families to encode `T[F] => F[T[F]]`. Now, how do I do that in Scala …

                                                                                                                                                      Greg Pfeil @sellout@2016-04-02T19:54:38.087Z
Apparently I’m now using Matryoshka to rebuild everything.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-02T19:55:10.985Z
@tpolecat I don’t think I need that unapply trick for `Cofree[?[_], A]`, etc. anymore.

                                                                                                                                                      Rob Norris @tpolecat@2016-04-02T20:15:25.089Z
@sellout oh that's good news. :+1: 

                                                                                                                                                      Greg Pfeil @sellout@2016-04-02T20:25:26.599Z
@tpolecat I’m just guessing at this point, but I changed the type classes from `trait Recursive[T[_[_]]]` to `trait Recursive[T]`, and instances from `implicit def recursive[A]: Recursive[Cofree[?[_], A]` to `implicit def recursive[F[_], A]: Recursive[Cofree[F, A]]`. But that looks like an improvement in terms of implicit search?

                                                                                                                                                      Greg Pfeil @sellout@2016-04-02T20:27:58.755Z
It’s a consequence of a change that lets you pretend that, say, `List[A]` is actually `Mu[ListF[A, ?]]`, getting all the folds/unfolds on traditionally-defined data structures.

                                                                                                                                                      Rob Norris @tpolecat@2016-04-02T21:10:57.084Z
Oh, cool. Yeah once you don't need higher-kinded unification you're in much better shape, inference-wise.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-04T03:04:41.427Z
@tpolecat Ok, cool. Still have 38 errors (hey, down from 511), but it looks like the new approach _does_ fix the implicit search.

                                                                                                                                                      Rob Norris @tpolecat@2016-04-04T03:06:09.434Z
Cool, I look forward to seeing it.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-04T14:22:46.236Z
So confused … I have two type classes that extend the same trait. One works just fine, the other can’t find a type that’s declared in the super trait.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-04T14:32:57.163Z
Oh, I think I figured it out.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-10T23:44:15.787Z
“Recursion: where functional programming hits bottom”

                                                                                                                                                      Rob Norris @tpolecat@2016-04-11T00:04:54.543Z
:+1: 

                                                                                                                                                      Greg Pfeil @sellout@2016-04-11T03:58:41.682Z
Submitted to SBTB.

                                                                                                                                                      jeremyrsmith @jeremyrsmith@2016-04-15T02:44:49.960Z
I subscribe to so many gitter channels now, and I kind of feel bad for all of them

                                                                                                                                                      Greg Pfeil @sellout@2016-04-15T02:45:41.325Z
Oh man – way too many. And sometimes I wish multiple projects would aggregate under one channel. Like, does scalacheck-shapeless need its own?

                                                                                                                                                      Rob Norris @tpolecat@2016-04-15T02:46:26.738Z
just submitted my fix+cofree+doobie talk to scala up north

                                                                                                                                                      jeremyrsmith @jeremyrsmith@2016-04-15T02:46:39.883Z
anyway, whatever books or blogs or videos or degree programs would be helpful, I want to have the background I need to understand this tool.  Because I know that it applies to several things I have solved in less elegant ways, but I don't know what the link is

                                                                                                                                                      Rob Norris @tpolecat@2016-04-15T02:46:52.585Z
so i may be spreading the gospel of fixpoint types to our adorable canadian friends

                                                                                                                                                      Greg Pfeil @sellout@2016-04-15T02:46:53.135Z
@tpolecat Is “Scala Up North” an actual thing?

                                                                                                                                                      Rob Norris @tpolecat@2016-04-15T02:46:57.460Z
yeah

                                                                                                                                                      Rob Norris @tpolecat@2016-04-15T02:47:10.729Z
http://scalaupnorth.com/

                                                                                                                                                      Greg Pfeil @sellout@2016-04-15T02:48:56.392Z
@jeremyrsmith It’s mostly papers, which aren’t the most direct way to get there. There are a couple blog posts. https://medium.com/@jaredtobin/practical-recursion-schemes-c10648ec1c29#.611hff5gp is a decent one, but in Haskell.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-15T02:49:13.112Z
However, Matryoshka takes a lot from Ed Kmett’s Haskell recursion schemes.

                                                                                                                                                      jeremyrsmith @jeremyrsmith@2016-04-15T02:50:18.411Z
Thanks, I'll check those out.  I am not a Haskell programmer, but even so it's often easier to understand than corresponding Scala

                                                                                                                                                      Greg Pfeil @sellout@2016-04-15T02:50:29.023Z
(Although, toward the end of that post, Jared advocates a few things I don’t agree with, which I’ll cover in my next talk, which will hopefully be a bit more practical).

                                                                                                                                                      Greg Pfeil @sellout@2016-04-15T02:51:32.857Z
I think I bit off a bit too much in that Typelevel talk – I also had other stuff involving Shapeless and Monocle that I ended up cutting, and I probably should have cut the Inject/Coproduct stuff and just focused on Matryoshka, too.

                                                                                                                                                      jeremyrsmith @jeremyrsmith@2016-04-15T02:51:55.235Z
trust me, it was a good talk.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-15T02:52:21.014Z
Thanks. I appreciate it 😄

                                                                                                                                                      Rob Norris @tpolecat@2016-04-15T02:52:26.449Z
Are we talking about Typelevel Summit? Did I meet you @jeremyrsmith?

                                                                                                                                                      jeremyrsmith @jeremyrsmith@2016-04-15T02:52:30.671Z
the talk informs people who understand, and piques the interest of people who don't

                                                                                                                                                      jeremyrsmith @jeremyrsmith@2016-04-15T02:52:39.047Z
that's the goal of a talk

                                                                                                                                                      jeremyrsmith @jeremyrsmith@2016-04-15T02:52:52.765Z
I didn't make typelevel @tpolecat but I watched it on YouTube

                                                                                                                                                      Rob Norris @tpolecat@2016-04-15T02:52:59.451Z
Aha ok.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-15T02:53:37.321Z
@jeremyrsmith True – I think what I need is better docs/tutorial to get people from the talk to writing code. Well, that’s a goal for the next month as I get ready to talk again.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-15T02:57:08.914Z
@tpolecat Hrmm, early August … I’ll already be in PA. Montreal is close enough and my parents can watch the kids …

                                                                                                                                                      Rob Norris @tpolecat@2016-04-15T02:57:54.330Z
Do it!

                                                                                                                                                      Greg Pfeil @sellout@2016-04-15T03:02:09.418Z
PRs welcome 😉 https://github.com/sellout/fix

                                                                                                                                                      Greg Pfeil @sellout@2016-04-15T03:09:24.696Z
@jeremyrsmith I’m also happy to answer more specific questions. The README has links to a couple papers, but that’s probably not the kind of answers you’re looking for.

                                                                                                                                                      Cody Allen @ceedubs@2016-04-19T20:03:45.280Z
my cat stepped on my keyboard and Gitter recommended that I join this room. Probably about the best case scenario for how that could have ended

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T04:45:36.111Z
Hey @sellout which repo/branch is the most likely to become reality at this point?

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T04:46:07.327Z
I'd like to try to adapt my examples and see how much it cleans up my talk. It needs some cleaning up.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T04:46:44.550Z
@tpolecat All except for the oldest one, parts of which have already been absorbed elsewhere.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T04:47:37.809Z
But if you just use attributeAnaM and I forget the other one, it should be a simple change once the `Base` stuff is in.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T04:48:25.965Z
@tpolecat I could use some help with that `Base` PR if you want ;)

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T04:50:45.116Z
Hm looks like it's compiling except for a scaladoc error. What do you need help with?

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T04:51:21.802Z
@tpolecat But the tests don’t compile, right?

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T04:52:37.341Z
Ok I was just looking at the travis output. I'll give it a try.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T04:53:50.759Z
The problem I _think_ I’m running into now is that I define the type class instances with the type `Recursive.Aux[T, F] with Corecursive.Aux[T, F]`, and so when something is looking for a `Recursive.Aux` implicit, it doesn’t find it … does that make sense?

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T04:55:55.628Z
Huh. That works fine with single-param typeclasses.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T04:57:06.217Z
So, part of it may be that the `.Aux` is a type alias to the `Recursive[T[F]]` type class (with a specific `Base` type member)?

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T04:57:25.594Z
And I might just be misinterpreting what @InTheNow had told me was happening.

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T04:58:44.669Z
Ah, yes. The tests don't quite compile.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T04:59:20.805Z
I would like to instantiate the type classes separately anyway, but I can’t because they need to provably have the same `Base`. And I don’t _think_ there’s a way to define a type family in Scala other than using an associated type.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:00:36.489Z
Like, instead of `@typeclass Recursive[T[F]] extends Base[T[F]]`, I’d rather do `@typeclass trait Recursive[T[F]](implicit B: Base[T[F]])` (which doesn’t work, of course).

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:05:18.502Z
Ok, yeah I have a similar problem in doobie. I'm using a superclass like you are.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:08:22.023Z
@tpolecat And you end up instantiating with `with`?

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:08:45.130Z
I haven't gotten that far. I was thinking I would. This is a new thing I'm messing with.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:09:07.802Z
Ah, ok. Well, it’s good to know there’s someone in the same boat :D

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:11:29.899Z
And there are still other things that haven’t been sorted out on that branch. Even after it works, it may live on its own branch for a while.

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:15:13.765Z
hm how do i get a repl? it wants to compile the tests

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:16:12.251Z
Oh, I haven’t tried. But I have another branch that moves the tests to their own subproject. Not that that helps you now.

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:17:11.622Z
i'll delete the tests. need to crank down the warnings and stuff too

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:17:27.289Z
do you not use the repl when you're coding?

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:18:06.595Z
Ok that worked.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:18:31.018Z
No, I know it’s something I _should_ be doing, but the couple times I tried I got pretty frustrated. I think there are like two compiler flags that need to be disabled for it, though.

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:20:40.644Z
well it's working with the tests deleted ;-)

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:21:02.224Z
I should try that will _all_ my tests.

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:22:09.283Z
so yeah i'm seeing what you're seeing

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:22:44.165Z
`Recursive.Aux[Fix[F], F]` works on its own but not `with ...`

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:24:16.813Z
So you need to define them together but do you ever want to have a handle on the combined instance?

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:25:03.549Z
Well, I tend to just use two constraints in that case.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:25:14.472Z
rather than one with a `with`

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:25:14.928Z
ok

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:25:26.965Z
I definitely need just one or the other, though.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:26:11.159Z
Oh, could that one be a lower-prio instance, and then have a `Recursive.Aux` instance that just refers to that instance?

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:26:23.054Z
I guess it doesn’t even need to be lower-prio.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:26:42.297Z
I should just spell out priority, because autocorrect ruins it otherwisee.

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:26:50.530Z
If you make `matryoshoka` non-implicit and add
```
  implicit def matryoshkaRA[F[_]]:   Recursive.Aux[Fix[F], F] = matryoshka[F]
  implicit def matryoshkaCA[F[_]]: Corecursive.Aux[Fix[F], F] = matryoshka[F]
```
then the instances are available implicitly.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:27:07.710Z
Yeah, exactly. Awesome.

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:36:23.723Z
So with this encoding I have to name the functor if I'm abstracting over recursion schemes?

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:36:45.594Z
i.e., I can't say `[T[_[_]]: Recursive]` .. I have to say `[T[_[_]], F[_]](implicit ev: Recursive.Aux[T[F], F])`

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:38:28.368Z
Yeah, but you probably want to say `[T, F[_]](implicit ev: Recursive.Aux[T, F])`

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:38:42.589Z
I.e., T shouldn’t be parameterized.

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:38:55.356Z
Ah ok.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:40:29.499Z
Because F is really naming the _base_ of the fixpoint. Which is `[T[F], F]` when T is Fix/Mu/Nu, but it’s `[Cofree[F, A], EnvT[A, F, ?]]`, `[List[A], ListF[A, ?]]`, etc.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:40:59.635Z
The benefit of this change is that you can treat arbitrary types as if they had been implemented in fixpoint style.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:42:07.666Z
And, I haven’t really seen the impact this has on user code yet – converting all the tests should give me some idea. I hope it’s not _too_ terrible.

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:45:26.015Z
Ok, that almost makes sense. I look forward to seeing some examples.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:46:06.456Z
I hope it works out, because one of the points in my upcoming talks is how you can take advantage of that to smooth the transition of existing code – 1. define a pattern functor that parallels your ADT, 2. define a {co}rec instance on it directly (`Recursive.Aux[Foo, FooF]`), then you can write algebras over `FooF`, and use them in folds over `Foo`.

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:47:48.673Z
Ohhhh. Wow, ok.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:47:58.365Z
Does that actually make sense?

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:48:32.688Z
Yes, I don't know how it could possibly work but I'm looking at `ListF` and I see what you're talking about.

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:49:11.431Z
So if you start out with a pattern functor by itself does it collapse into something simpler?

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:50:07.288Z
You mean if you don’t already have a directly-recursive structure? Yeah, in that case you don’t need your own Recursive instance, you just take advantage of the ones defined for Mu/Nu.

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:50:12.536Z
RIght.

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:50:15.477Z
ok ok

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:51:10.928Z
But the instances you define yourself are pretty simple – like the List/ListF one – it just maps each node to its corresponding node in the functor (and embed does the opposite).

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:52:29.214Z
Yeah it looks pretty mechanical.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T05:52:45.933Z
Probably Shapeless could do it for you ;)

                                                                                                                                                      Rob Norris @tpolecat@2016-04-21T05:59:20.621Z
If you could define the pattern functor as a typeclass then I'll bet it could.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-21T06:15:14.474Z
I like that, every 30 minutes, my computer alerts me to how little sleep I’m going to be getting.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-25T20:52:05.379Z
This type family stuff is still a PITA. Maybe I’ll have time to wrap it up in the near future.

                                                                                                                                                      Rob Norris @tpolecat@2016-04-26T05:06:44.504Z
This fixpoint stuff is solid gold for database programming. I have never heard of it being used this way before. It totally solves the id problem and the "only materialize part of the graph" problem.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-26T05:20:33.633Z
@tpolecat Yeah, your stuff is the only time I've seen it, and it seems so widely applicable.

                                                                                                                                                      JerrySwan @JerrySwan@2016-04-28T22:12:38.606Z
Hi. What imports do I need in order to compile the code in the README at https://github.com/slamdata/matryoshka?

                                                                                                                                                      Greg Pfeil @sellout@2016-04-28T22:14:48.757Z
`import matryoshka._, Recursive.ops._, TraverseT.ops._` should get you everything. It’s on my todo list to clean up imports, and also to start using tut, so I can’t just omit important details like how to import stuff.

                                                                                                                                                      Rob Norris @tpolecat@2016-04-28T22:17:37.173Z
:-)

                                                                                                                                                      JerrySwan @JerrySwan@2016-04-29T05:08:34.254Z
@sellout - that's not working for me. The following fails to compile:
```  
import matryoshka._
  import matryoshka.Recursive.ops._, matryoshka.FunctorT.ops._
  import scalaz._, Scalaz._
  
  sealed trait Expr[A]
  final case class Num[A](value: Long) extends Expr[A]
  final case class Mul[A](l: A, r: A)  extends Expr[A]
  
  val eval: Expr[Long] => Long = {
    case Num(x)    => x
    case Mul(x, y) => x * y
  }
  
  implicit object expFunctor extends Functor[Expr] {
    def map[A, B](fa: Expr[A])(f: A => B): Expr[B] = fa match {
      case Num(v)   => Num[B](v)
      case Mul(a,b) => Mul[B](f(a),f(b))
    }
   }
  
  def someExpr[T[_[_]]: Corecursive]: T[Expr] =
    Mul(Num(2).embed, Mul(Num(3).embed, Num(4).embed).embed).embed

  someExpr[Mu].cata(eval) // ⇒ 24
```
reporting: 
value embed is not a member of Num[A]

                                                                                                                                                      Greg Pfeil @sellout@2016-04-29T12:38:49.710Z
@JerrySwan You're right – in someExpr, the Num nodes need to have a type annotation – Num[T[Expr]](2)

                                                                                                                                                      Greg Pfeil @sellout@2016-04-29T12:38:55.556Z
Ugh

                                                                                                                                                      Greg Pfeil @sellout@2016-04-29T12:40:01.928Z
`Num[T[Expr]]`

                                                                                                                                                      Greg Pfeil @sellout@2016-04-29T12:41:26.667Z
Ok, I'll tut today, because that's embarrassing.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-29T12:42:41.995Z
Also, I'm trying to figure out if I can use covariance at all to eliminate the need for all the leaves to be annotated like that.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-29T15:33:28.841Z
@JerrySwan Also, the examples in the test folder (granted, all currently conflated under Spec) are things that actually get compiled. #16 pulls those test algebras, etc. into their own files, hopefully making them more digestible. I need to get that merged.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-29T15:34:07.364Z
I imagine there’ll be increasing work on Matryoshka as my next talk on the topic approaches ;)

                                                                                                                                                      Greg Pfeil @sellout@2016-04-30T19:46:35.415Z
So, matryoshka has stuff like `F[T[F]]` everywhere. However, we often want to operate on `G[Nothing]` (where `G <: F`), so technically that’s a subtype of `F[T[F]]`, but I can’t figure out where I can put variance annotations to make that work.

                                                                                                                                                      Greg Pfeil @sellout@2016-04-30T19:47:33.130Z
In SlamData, we do smart constructors (well, prisms) to promote the `G` to `F`, but we still need explicit type annotations to get `T[F]` rather than `Nothing`.

                                                                                                                                                      Greg Pfeil @sellout@2016-05-13T02:50:12.068Z
**\[Greg Pfeil, SlamData Inc.\]** Random neat thing: `1.ana[Nu](constantly).ana[Nu](find(_ > 10)): Partial[Int]`

                                                                                                                                                      Greg Pfeil @sellout@2016-05-13T02:51:14.541Z
**\[Greg Pfeil, SlamData Inc.\]** `1.ana[Nu](constantly)` generates an infinite stream of `1`s. and `.ana[Nu](find(_ > 10))` returns the first item from that stream that’s greater than 10.

                                                                                                                                                      Greg Pfeil @sellout@2016-05-13T02:56:16.815Z
**\[Greg Pfeil, SlamData Inc.\]** It’ll run forever, but the type tells you that’s a possibility. But rather than having to either do `.take(100)` before `find`ing or just get back some forever-running future, you can peek ahead in chunks however large you want … `runFor(100)`, see if it got a result in that time, and if not, just run for more, or give up.

                                                                                                                                                      Greg Pfeil @sellout@2016-05-13T18:09:03.293Z
I changed it a bit, so `find` is now a transformation, which means you can equivalently write `1.ana[Nu](constantly ⋙ find(_ > 10))`.

                                                                                                                                                      Cody Allen @ceedubs@2016-05-13T18:15:16.881Z
yer a wizard @sellout 

                                                                                                                                                      Greg Pfeil @sellout@2016-05-20T16:22:56.493Z
**\[Greg Pfeil, SlamData Inc.\]** A problem I run into constantly in algebras – I have an algebra like `EJson[Bson] => PlannerError \/ Bson` \(`F[A] => M[A]`, a Kleisli algebra\), but when it fails, I want to return the structure that failed, a `T[EJson]`, but that forces me to turn the simple cata into a para – carrying the recursive structure along with me: `EJson[(T[EJson], Bson)] => PlannerError \/ Bson`. But that makes the whole thing a bit less general \(ran into a problem today where I’m actually folding from a `Free[EJson, _]`, and there’s really no way for me to reconstruct a `T[EJson]` that perhaps never even existed\).

                                                                                                                                                      Greg Pfeil @sellout@2016-05-20T16:25:49.512Z
**\[Greg Pfeil, SlamData Inc.\]** Also, I wonder if there’s a way to do something even more useful – like use an applicative to build a structure of `Free[EJson, PlannerError]`, with the errors in the holes that failed for whatever reason. Which maybe gives the caller something they can more usefully translate back to the end user \(e.g., positions in the query where the error happened\).

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T22:35:51.537Z
So I'm just getting into recursion schemes.  I know Erik Meijer often talks about using the *morphisms as a replacement for general recursion.  So as I'm using recursion schemes, I'm taking note for when I feel forced to use recursion.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T22:36:31.690Z
With Mu, I can turn Mu[ListF] into a scala.collection.List without a recursive call. . . that's pretty straight forward.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T22:37:08.713Z
but my attempt to turning Nu[ListF] into a scala.collection.Stream uses recursion.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T22:37:32.012Z
should I keep hunting?  Or can someone stop me from hunting for the impossible?

                                                                                                                                                      Greg Pfeil @sellout@2016-06-22T22:39:03.347Z
Yes. It’s not as straightforward as it could be (there’s a PR to fix that), but you can use `ListF.listIso` – `muListF.cata(ListF.listIso.get)` … or `reverseGet` … I always forget which is which :D

                                                                                                                                                      Greg Pfeil @sellout@2016-06-22T22:40:03.936Z
With the `Base` PR, if I ever figure it out, you’ll be able to just apply recursion schemes to scala Lists and Streams directly.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T22:40:24.474Z
actually, it's kind of a two-part question.  1) is it possible?  2) is it possible with Matryoshka?

                                                                                                                                                      Greg Pfeil @sellout@2016-06-22T22:42:22.571Z
So, you can see that `ListF.listIso.get` is “just” an Algebra. So if you’re building up a Mu[ListF] with a Coalgebra, you can do `x.hylo(ListF.listIso.get, myCoalgebra)` to build up the Mu[ListF] and convert it to a scala List in a single pass.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T22:43:15.451Z
okay, I think that pointer makes sense.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-22T22:43:23.095Z
Oh, so all my rambling is for naught, because you figured that part out. I missed that `Nu` was your problematic case.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T22:43:38.300Z
oh, good.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T22:43:42.370Z
yeah, I got it for Mu!

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T22:44:16.168Z
honestly, I'm completely okay with it not being possible for Nu.  It just puts an asterisk by Erik's claims.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T22:44:25.869Z
but perhaps all of Erik's claims need asterisks.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-22T22:44:43.605Z
Well, there are other things that aren’t in Matryoshka yet. Like good metamorphisms …

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T22:44:53.658Z
so many *morphisms.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T22:45:01.639Z
I saw the picture you put up.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-22T22:46:39.999Z
This paper, if you care to dig in: https://www.researchgate.net/publication/220131211_Metamorphisms_Streaming_representation-changers

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T22:46:53.736Z
Comonad.Reader posts from 2008-2009. . . somehow being 8 years behind doesn't feel that bad.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-22T22:48:00.048Z
But I don’t think there needs to be a * next to Erik’s claims (maybe there should be, I certainly haven’t proved otherwise). But you should be able to do the things you want to do with Streams without converting to Stream. Just might mean reimplementing stuff ;)

                                                                                                                                                      Greg Pfeil @sellout@2016-06-22T22:48:25.718Z
But I’ll think about trying to convert to Stream as well.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T22:49:53.946Z
for me, it's more the exercise of seeing the benefits of recursion schemes.  I agree that a raw Nu[StreamF] is effectively stream.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T22:50:49.523Z
cool, that paper makes very clear what a metamorphism is.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T22:59:31.786Z
@sellout maybe you can short-circuit some learning for me.  I'm still trying to figure out the relationship Mu has with Free.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T23:00:00.955Z
in particular, whether one can be defined in terms of the other.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T23:00:30.575Z
(even if it's not in the libraries we use day-to-day)

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T23:02:38.171Z
I think this is on the last pages of the bananas paper that I haven't gotten to yet.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T23:03:55.885Z
my hunch is that Free can be defined in terms of Mu, where the functor is the non-recursive algebra for Return | Bind

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T23:05:36.121Z
but I won't believe it til I see it all compiling.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-22T23:07:42.016Z
Yeah, look in matryoshka.instances.fixedpoint – Free is Mu[CoEnv] (and Cofree is Mu[EnvT])

                                                                                                                                                      Greg Pfeil @sellout@2016-06-22T23:09:05.117Z
Co/monad instances yet.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T23:09:24.413Z
cool.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-22T23:09:50.540Z
But I don't have … co/monad …

                                                                                                                                                      Greg Pfeil @sellout@2016-06-22T23:10:41.303Z
I'm hoping to discover some type class that when defined on a Functor provides Monad on the fixed point of that Functor.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-22T23:11:45.910Z
Like the current stuff for Bifunctor[F] => Functor[Mu[F]]

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T23:12:02.819Z
interesting.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T23:12:32.645Z
I think I should look at the tests; maybe it will give me some better idea for the usefulness.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T23:12:54.249Z
there's a point in learning this stuff where it really feels like the brunt of an "Evolution of a Haskeller" joke.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T23:13:05.032Z
like a needless complication.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T23:15:26.717Z
@sellout so Runar put in some work to make sure his Free didn't blow stack.  does Mu[CoEnv] have the same gaurantees of stack-safety?

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T23:16:15.071Z
(I'm speaking specifically to the matryoshka implementation of Mu and CoEnv with that question).

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T23:27:38.859Z
also, I think I see now that Mu just deals with the recursive-type part of Free.  Free as a concept is just a different concept.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T23:27:58.149Z
and probably similarly for Nu and Cofree.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-22T23:32:21.535Z
How do you mean it's a different concept? You should be able to get the Free Monad-ness from MuCoEnv.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T23:43:16.449Z
I can't figure out how to say it in text.  I'm just saying that the fact that Free can be written in terms of Mu is not really related to the fact it's a "left adjoint of a forgetful functor". . . more that it's a recursive type, and Mu factors out the recursiveness of any recursive type.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-22T23:43:33.145Z
hopefully that makes sense.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-23T00:03:37.451Z
okay, this is where my play got me:  https://gist.github.com/shajra/6d88a35b76a2c62a171bd41ac090aada

                                                                                                                                                      Sukant Hajra @shajra@2016-06-23T00:03:50.432Z
whoa. . . not sure if I wanted that all expanded out, Gitter.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-23T02:03:59.491Z
@shajra You’re right about the Mu representation not saying anything meaningful about the left adjointness. However … http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.307.5950

                                                                                                                                                      Greg Pfeil @sellout@2016-06-23T02:05:22.724Z
That paper has a generalization of recursion schemes (using adjunctions rather than monads/comonads) that does rely on that relationship (look at λ-coiteration, which is a generalization of the comonad-based futumorphism).

                                                                                                                                                      Greg Pfeil @sellout@2016-06-23T02:05:36.884Z
That’s one of the three big changes currently happening in Matryoshka. Heh.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-23T02:06:22.195Z
The others are the “Base” approach I mentioned earlier, and then higher-order recursion schemes that allow for mutually-recursive types.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-23T02:11:04.374Z
Higher-order is going to get in first, because I already have parts of it working and it’s useful for work.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-23T02:12:07.212Z
“Base” I would like to get in next because it cleans up a lot of stuff conceptually and makes it easier to use recursion schemes with “traditional” data types. And it’s also useful for work. But it has hit a snag that I suppose I will eventually have to deal with.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-23T02:12:34.377Z
Adjunctions seems fun, but I don’t have a particular need for it yet.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-23T02:34:23.586Z
@sellout glad I asked.  Good information.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-23T02:36:53.070Z
no joke:  "The  many  divergent  generalisations  of  catamorphisms  can  be bewildering  to  the  uninitiated..."

                                                                                                                                                      Greg Pfeil @sellout@2016-06-23T02:38:00.657Z
Oh, and you had also asked about trampolining – I haven’t done anything for it _yet_. I want to get a good test case that shows the improvement. But I _think_ I can trampoline Mu, and get it for free on all functors.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-23T02:38:49.367Z
@sellout I think Stephen Compall is making some good arguments against trampolining at _every_ step.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-23T02:39:17.161Z
@shajra Heh, yeah, I joke that if you understand the generalized Elgot hylomorphism, all the others just fall out of that ;)

                                                                                                                                                      Sukant Hajra @shajra@2016-06-23T02:39:41.112Z
is that true?

                                                                                                                                                      Greg Pfeil @sellout@2016-06-23T02:40:18.175Z
Yeah, pretty much.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-23T02:40:40.715Z
I mean, there’s also the Kleisli variants, but those work as you’d expect.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-23T02:41:17.164Z
okay, there's just so many:  http://comonad.com/reader/2009/recursion-schemes/

                                                                                                                                                      Sukant Hajra @shajra@2016-06-23T02:42:44.529Z
is this Elgot holymorphism generalization covered in the paper you linked?  If not, then is it in some other paper?

                                                                                                                                                      Greg Pfeil @sellout@2016-06-23T02:42:55.005Z
Yeah, actually the synchro and exo maybe don’t fall under that … at least not without adjunctions.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-23T02:43:12.048Z
I don’t think there’s anything that covers that explicitly.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-23T02:43:33.043Z
okay, I have a feeling this is all going to keep me busy if I let it.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-23T02:44:17.101Z
But, all folds are hylos with `project` for the unfold and all unfolds are hylos with `embed` for the fold.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-23T02:45:14.142Z
cool, I saw this usage of project and embed in various libraries, but didn't get to understanding it yet.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-23T02:45:30.030Z
And then cata/ana just use `Id` for the {co}monads, histo/futu use {co}free, para/apo use {co}product, etc.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-23T02:46:45.803Z
I made https://github.com/sellout/recursion-scheme-talk/blob/master/cheat%20sheet.pdf, which builds on that post of Kmett’s – you’ve probably seen it. That version is a bit out of date. I should commit an updated one.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-23T02:47:07.314Z
The left and right sides represent duals.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-23T02:47:28.208Z
cool, I can see cata/ana right off the bat.  I'll try to remember the other four relations for histo/futu/para/apo.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-23T02:47:47.432Z
yeah, I saw that.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-23T02:48:13.307Z
all this started when I decided to present the bananas paper because a meetup organizer twisted my arm.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-23T02:48:23.357Z
Hah!

                                                                                                                                                      Sukant Hajra @shajra@2016-06-23T02:48:45.695Z
then I saw how deep the hole went, jumped in, and realized I didn't have an escape plan.

                                                                                                                                                      Suhail Shergill @suhailshergill@2016-06-23T18:31:22.071Z
@sellout i recently became aware of this project. does it include the work from gibbons' conjugate hylomorphism paper? an attempt to have a toolbox to unify recursion schemes?

                                                                                                                                                      Suhail Shergill @suhailshergill@2016-06-23T18:31:24.720Z
http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/conjugate-hylos.pdf

                                                                                                                                                      Greg Pfeil @sellout@2016-06-23T19:28:46.338Z
@suhailshergill 😆 We were just discussing that yesterday, actually – you can probably find it in scrollback. But that requires the adjunction approach, which is a generalization of what’s currently in Matryoshka (comonadic folds). 

                                                                                                                                                      Greg Pfeil @sellout@2016-06-23T19:29:51.649Z
The current comonadic version does have some generalized hylomorphisms – {co}Elogot algebras, chronomorphisms, dynamorphisms, etc. – but not as rich as adjoint folds.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-23T20:17:35.053Z
I'm new to this stuff.  Does Haskell's recursion-scheme library have this generalization?  Or another library?

                                                                                                                                                      Greg Pfeil @sellout@2016-06-23T20:38:37.004Z
@shajra I don’t know of a library that uses adjoint folds. Both recursion-schemes (I’m certain) and comp-data (I think) use comonadic folds. Other libraries (fixplate, etc.) have a few hand-written folds, but not generalized ones (I think).

                                                                                                                                                      Suhail Shergill @suhailshergill@2016-06-24T00:28:07.752Z
@shajra not to my knowledge. i've been aware of that paper for a while now, and hoping someone will get to implementing it before i get the time to ;)

                                                                                                                                                      Suhail Shergill @suhailshergill@2016-06-24T00:29:11.339Z
@sellout is there work being done to switch to switch to adjoint folds?

                                                                                                                                                      Suhail Shergill @suhailshergill@2016-06-24T00:30:25.502Z
seems like it is
> That’s one of the three big changes currently happening in Matryoshka. Heh.

is there a specific branch i should look at?

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T00:31:13.894Z
@suhailshergill I don't know if that one has been pushed. I'll figure it out and let you know.

                                                                                                                                                      Suhail Shergill @suhailshergill@2016-06-24T00:31:39.831Z
rock on dude :) appreciate it

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T03:10:48.689Z
bananas paper question: in that paper, they define both the "banana" and "lens" operator in terms of mu, which they explicitly call the "least fixed point".  I was expecting them to introduce both mu and nu.  The paper makes no reference to "greatest fixed point" so something feels missing.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T03:14:49.278Z
actually, I think it makes sense.  it's just a normal "fix" function.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T03:15:32.336Z
to turn ((L -> A) -> (L -> A)) into just (L -> A)

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T03:56:01.870Z
okay, tried to implement the banana and lens function directly, and got a stack overflow

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T04:04:24.232Z
oh, probably because I defined fix wrong.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T04:09:02.052Z
yeah, needed the fancier z-combinator for a strict language.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T05:17:57.713Z
okay, I got rid of the stack overflow for making a finite stream with Mu, but making a "lens" function causes my infinite stream to unwravel all the way and blow stack.

                                                                                                                                                      Suhail Shergill @suhailshergill@2016-06-24T10:54:38.260Z
@shajra an alternate to z combinator is to simply use trampolining. see https://github.com/suhailshergill/predef/blob/master/src/main/scala/sss/predef/Fix.scala#L68

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T13:00:28.895Z
@suhailshergill thanks for the suggestion.  My real problem is too much strictness for my core curation.  But once I solve that, stack safety is good to have too.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T13:01:21.363Z
I had this working already.  I just wanted to make functions that reflected exactly the notation in the Bananas paper.

                                                                                                                                                      Suhail Shergill @suhailshergill@2016-06-24T13:01:47.143Z
right hence the stream evaluation. understood

                                                                                                                                                      Suhail Shergill @suhailshergill@2016-06-24T13:02:11.831Z
btw, what're you doing these days sukant? still awesome stuff at rackspace?

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T13:05:11.079Z
No, Rackspace was never the ideal place to do machine learning, so we left when they did a reorg that put us under a crazy Hadoop project that seemed flawed on construct.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T13:06:26.195Z
Two of us went to Helium to do some engineering in Haskell there, and I went to a local startup that's in a similar space as IBM Watson (which has pros and cons).

                                                                                                                                                      Suhail Shergill @suhailshergill@2016-06-24T13:46:39.086Z
:)

                                                                                                                                                      Suhail Shergill @suhailshergill@2016-06-24T13:47:26.134Z
if you're ever in toronto, we should grab a bite

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T15:34:04.791Z
@suhailshergill same for if you're in Austin

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T15:34:40.171Z
(or anyone!)  Also, if anyone wants to present at an Austin Scala or Haskell meetup, I can help set that up.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T15:55:53.940Z
I can see how working with recursion schemes and remove some boilerplate of recursion, but some claims of the benefits seem stronger than I can see.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T15:56:00.014Z
@suhailshergill Going to Scala Up North, by any chance?

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T15:56:16.413Z
@shajra Like which ones?

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T15:56:30.856Z
For instance, do recursion schemes enhance composability of abstraction?

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T15:57:23.843Z
@shajra I’m not sure exactly what you mean by that, but there are a lot of compositionality / fusion benefits.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T15:58:13.340Z
Although, it can be hard to clearly separate the benefits that come from pattern functors and those that come from recursion schemes.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T15:58:16.194Z
okay, that's what I'm hoping, but in the middle of seeing all the mechanics, I feel I might be losing perspective.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T15:58:23.868Z
right!  

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T15:58:52.118Z
what I'd like to see is something like a side-by-side comparison with respect to composition and fusion.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T15:59:21.016Z
@shajra I find that it lets me break things down into very small simple pieces. The complexity doesn’t _completely_ go away, but it’s moved away from the logic into the composition of the algebras.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T15:59:24.023Z
maybe with just ana/cata/hylo

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T15:59:43.020Z
right, I can see how it factors down into smaller parts.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T16:00:18.099Z
but that gets to another claim, which is reuse of algorithms with different functors.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T16:00:36.300Z
E.g., I can write a bunch of simple algebras, and one that requires some wild combination of annotation, state, whatever. Then, I can “lift” the simple algebras into that same shape when I compose them.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T16:01:04.178Z
Yeah, matryoshka has a small number of common algebras currently – that should grow, and should become a separate `package`.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T16:01:40.437Z
what's the function for "lifting"?

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T16:01:54.927Z
I think a type signature will help me see this more concretely.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T16:03:26.556Z
So, there are a couple. There is `generalizeAlgebra[W[_]]: Algebra[F, A] => GAlgebra[W, F, A]`, and `generalizeCoalgebra[M[_]]: Coalgebra[F, A] => GCoalgebra[M, F, A]` – then others for lifting to Elgot algebras and Kleisli variants.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T16:04:22.770Z
Hmm, it looks like we don’t yet have a release that takes advantage of `@group` in Scaladoc. That helps for seeing the generic algebras.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T16:05:11.601Z
It really needs some reorg.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T16:05:50.736Z
Ah, wait, we do – I was just on an old Scaladoc: https://oss.sonatype.org/service/local/repositories/releases/archive/com/slamdata/matryoshka-core_2.11/0.11.0/matryoshka-core_2.11-0.11.0-javadoc.jar/!/index.html#matryoshka.package

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T16:06:16.450Z
The bottom of that “Algebras & Coalgebras” section has a few generic algebras.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T16:07:02.653Z
oh right, all the "general algebra" stuff is new to me.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T16:08:26.809Z
Mostly I add stuff as I need to use it. At some point I’d like to go through and fill in all the gaps.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T16:11:03.649Z
got it, I think this makes it more clear.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T16:11:13.979Z
fortunately, functors compose.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T16:11:51.188Z
so I see what you mean by some of these benefits really coming from the fact we're working with functors (and less from the recursion scheme part)

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T16:13:50.669Z
Yeah, so functors let you use the same structure for a “bare” AST and an annotated one (see Brian McKenna’s post on bottom-up type annotation). But recursion schemes let you avoid building the annotated AST at all.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T16:14:46.794Z
I just realized, there's no Functor instances on Mu or Nu using the underlying functor.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T16:15:16.924Z
is that just an oversight?  Or is it not possible to make them (which at this point I wouldn't suspect is true)?

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T16:17:07.009Z
wait, I just realized that question doesn't typecheck (kinds mixed up)

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T16:17:29.022Z
I thought it was, but must be on a branch that has other in-progress stuff ;)

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T16:18:19.659Z
okay, it seems like we can get a functor instance, but Mu[F] is not the right kind `(* -> *)`

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T16:19:20.504Z
Ok … so my connection is bad and at least one message dropped …

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T16:19:24.675Z
this one: @shajra Ah, just not published yet – You get a `Functor[Mu[F[?, ?]]]` from a `Bifunctor[F]`, etc.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T16:20:20.378Z
`Functor[λ[α => Mu[F[α, ?]]]]`, that is.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T16:20:39.695Z
thanks, makes more sense now.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T16:21:53.846Z
That works for Traverse and its supers … trying to figure out if there’s an incantation where `Bimonadish[F] => Monad[λ[α => Mu[F[α, ?]]]]`.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T16:22:07.726Z
cool.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T16:24:03.972Z
I'm looking for a small example that makes the abstraction benefits of recursion schemes shine (in a presentation)

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T16:25:09.607Z
I need to read Brian's post.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T16:25:56.926Z
@shajra My “Efficient Nanopass Compilers” talk (https://github.com/sellout/recursion-scheme-talk) has an example of the same code with three different approaches.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T16:26:31.635Z
I should really fix the outline to use the proper syntax for Coproduct/Inject.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T16:28:16.909Z
cool, let me look at that too.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T16:30:45.056Z
I like that Org-mode with notes renders on Github the way it does.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T16:31:56.764Z
Yeah, me too. I’m still working on getting to the point where org-mode gives me both a polished presentation and a polished blog post. Getting there, though. Having epresent actually show speaker notes during the presentation would be great. Trying to add that.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-24T20:05:03.679Z
@sellout that talk was really helpful in seeing the benefit of this approach -- especially when using Coproduct.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T20:32:19.089Z
There are a lot of pieces that fit together really well – recursion schemes, coproducts, ABTs, invertible-syntax, etc.

                                                                                                                                                      Suhail Shergill @suhailshergill@2016-06-24T20:32:46.007Z
@sellout whoa. github's org mode renderer now shows inline images?

                                                                                                                                                      Suhail Shergill @suhailshergill@2016-06-24T20:35:49.537Z
@sellout unfortunately not. i'd planned to pitch my tagless final talk again, but then life intervened (have recently moved to a different role, and so that's been taking a lot of time)

                                                                                                                                                      Greg Pfeil @sellout@2016-06-24T20:56:02.800Z
Ah yeah, understandable. I’ll be talking about Matryoshka there.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T02:40:28.039Z
@sellout reading more of your presentation, and I'm a bit confused about how `(Let :+: F)[Fix[F]]` matches directly with a `Let(...)` pattern match.  are there custom extractors for Coproduct?

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T02:40:51.802Z
I know loosely about Coproduct, but haven't used it in a Scala project.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T02:55:59.638Z
so many implementations with the name ':+:'

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T02:56:05.778Z
one in Scalaz and one in Shapeless.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-25T02:56:23.560Z
@shajra I edited things for slide space, but also that section was just sloppy. The way we _really_ do it is just `Let[Fix[F]] => F[Fix[F]]`, then we have a function: `(G :<: H) => (G[A] => H[A]) => (H[A] => H[A])`

                                                                                                                                                      Greg Pfeil @sellout@2016-06-25T02:56:40.250Z
(where `Let :<: F`, of course)

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T02:56:50.828Z
awesome.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T02:57:07.852Z
part of me always distrusts the compiler in my head before distrusting the compiler in other people's head.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T02:57:13.476Z
not always a sound way to go.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-25T02:57:46.251Z
One of the selling points of Haskell is that it fits on slides better, but that doesn’t go over at a Scala conference ;)

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T02:57:52.402Z
right.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T02:58:09.001Z
at some point, I think the important part is really the type signatures.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-25T02:58:26.114Z
But I also need to start using Babel with my org-mode stuff to keep me honest.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T02:58:27.418Z
with a lot of ... for the implementation and a link to a source repo.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T02:58:43.116Z
right, I use tut for all my presentations for this reason.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T02:58:47.777Z
(when in Scala)

                                                                                                                                                      Greg Pfeil @sellout@2016-06-25T02:59:05.849Z
Even if I hide stuff in the slides, it’ll compile in the repo :)

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T02:59:25.823Z
but it has one side-effect, which is that you have to introduce stuff in dependency order, which is sometimes good for comprehension, sometimes a distraction.

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-06-25T07:14:47.345Z
Out of interest: What level of education do the users of this library have?

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T07:18:16.287Z
@mgttlinger I've definitely seen people of all kinds of backgrounds pick this stuff up.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T07:19:34.864Z
So I almost don't want to admit to my education, because while it's helpful, it also seems besides the point.

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-06-25T07:24:13.634Z
I think a background in theoretical computer science mostly helps in seeing a need for it.

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-06-25T07:34:31.629Z
For example I currently am in my master studies in computer science and started focusing on the theoretical part of the field. From talking to other students about topics in that direction, I get the sense I have acquired above average knowledge there, but I am still struggling at understanding the recursion schemes talk which was mentioned further up.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T14:11:03.131Z
I think what might help your perspective is to meet people in the same boat as you coming at this material without an academic background.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T14:16:08.396Z
My belief is that graduate school is sometimes a consequence of a personal motivation and ability to learn.  So it makes sense that people into recursion schemes may also have been interested in other things you can get from graduate school.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T14:16:38.011Z
But that thinking makes it more of a correlation than a cause.

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-06-25T14:22:56.994Z
That may be helpful.

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-06-25T14:24:27.811Z
So far I haven't even met people at the university which are really interested in that topic.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T14:27:36.381Z
The emphasis in various topics varies a lot from school to school.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T14:29:00.840Z
In that regard, there's more homogeneity with FP conferences, including the industry ones.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T14:30:54.514Z
I bet a lot of people found Free monads more from blogs and talks, for instance.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T14:32:45.533Z
Which leads a community that's academic-friendly, but not really academic (not publishing, for instance).

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-06-25T14:33:15.287Z
As traveling to conferences out of my own pocket as a student is difficult I mostly try to read literature on those topics ond follow conversations in chats like this.

                                                                                                                                                      Torsten Scholak @tscholak@2016-06-25T14:45:42.562Z
May I chime in?

                                                                                                                                                      Torsten Scholak @tscholak@2016-06-25T14:46:42.933Z
Are there any review articles or book (chapters) that could be recommended to a beginner?

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T14:59:10.688Z
@tscholak in recursion schemes, you mean?

                                                                                                                                                      Torsten Scholak @tscholak@2016-06-25T14:59:36.256Z
Yes

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T15:02:31.313Z
@sellout's talks seemed pretty good as an intro to me.

                                                                                                                                                      Torsten Scholak @tscholak@2016-06-25T15:05:26.116Z
Alright, I'll start there :) thanks.

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-06-25T15:21:34.086Z
In the example from the talk when the recursion is removed from `Expr`. By pulling the type of the nested expressions into a type parameter (I hope that are somewhat understandable terms for what happened) don't we loose type safety of the built language as we now can write expressions that wont compile (in the sense of the `eval` method being the compiler) like `Mul "nope" "notexp"` when we really want to only have other nested expressions?

                                                                                                                                                      Suhail Shergill @suhailshergill@2016-06-25T15:30:29.127Z
agreed
:point_up: [June 25, 2016 10:16 AM](https://gitter.im/slamdata/matryoshka?at=576e92288c9263ba30e5aac0)

                                                                                                                                                      Greg Pfeil @sellout@2016-06-25T16:01:23.850Z
@mgttlinger Part of the point is that we _don’t_ only want nested expressions. And isn’t “not compiling” the definition of type safety? You could have written `Mul “nope” “notexp”` with the traditional definition, but you’d just get a type error in a different place.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-25T16:05:52.333Z
The idea of “pattern functors” – the removal of recursion from a data type – is useful beyond just recursion schemes, and in fact is somewhat unnecessary for recursion schemes (impl. in Scala pending 😆). But it allows for composition of recursive structures. E.g., one of the things we do at SlamData is separate the data model from the rest of the AST, so we can say something like `eval: Data :+: Operations ~> Data`. And don’t have to define the Data bits in two places.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-25T16:06:53.157Z
Brian McKenna’s post: https://brianmckenna.org/blog/type_annotation_cofree is another example, using pattern functors to allow arbitrary annotation on the nodes of a tree (and his example gets even more compelling, IMO, if you add recursion schemes to the mix).

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-06-25T17:15:34.673Z
@sellout Well if it doesn't compile or crash at runtime depends on the implementation of the `eval`function I think. I am sure there are cool benefits from doing it that way but I still need to get used to this "level of abstraction" to see the pros and cons.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T17:43:50.921Z
@mgttlinger you're not alone.  I think the tests and examples of Matroyshka illustrate that the complexity can be most factored into library code.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T17:44:46.649Z
You /could/ complain about complexity in the types, but there's a counter-argument that parametricity kicks in, so you get more out of "following the types"

                                                                                                                                                      Greg Pfeil @sellout@2016-06-25T18:32:15.095Z
 I've been unhappy with the way a lot of tests look, because building up an example structure is _ugly_. But you tend not to do that in real code, just one or two layers at a time and the transformations handle the noisy bits.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-25T19:56:57.070Z
I don’t think you can write `eval` in a way that would crash at runtime (I mean, other than `sys.error` or something). It is type safe. In the cases where you do want a recursive type, you use `Mu[Expr]`, which is equivalent to the old `Expr`. But now you have other ways to use it, too. In the same way that `List[A]` isn’t less type safe than explicitly defining `IntList`, etc..

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-06-25T20:57:35.996Z
@sellout When you write eval to match on the `Expr` you could reach a point where you have no match defined for e.g. a `Add` between different types than `Expr`, but yeah that would be a rather naive implementation.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-25T20:58:30.281Z
@mgttlinger I don’t understand. Could you give an example?

                                                                                                                                                      Greg Pfeil @sellout@2016-06-25T21:00:31.716Z
`eval: Expr[Int] => Int` expects arguments of the form `Add(1, 3)` exhaustiveness checking should ensure that you’ve covered all the alternatives in `Expr`.

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-06-25T21:03:48.265Z
```scala
def eval(program: Expr[_]): Int = program match {
  case Mul[Expr[_]](a, b) => eval(a) * eval(b)
  case Add[Expr[_]](a, b) => eval(a) + eval(b)
  case Num(i) => i
}
```
This should fail at runtime when applied to something that is not entirely built from our `Expr` syntax, right?

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-06-25T21:04:37.176Z
I mean that implementation is obviously flawed but it looks correct at first glance.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-25T21:05:03.953Z
@mgttlinger Won’t that fail at compile time, complaining about erasure? Or at least not being exhaustive.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-25T21:06:11.405Z
I would say that the `_` makes it look flawed at first glance.

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-06-25T21:06:32.647Z
But those are just warnings, aren't they? But I get your point.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-25T21:07:31.440Z
Are those warnings? Exhaustiveness seems like it should be an error. But we treat all warnings as errors, so I don’t really know where the line is.

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-06-25T21:07:50.039Z
You don't prevent writing (syntactically) incorrect programms directly, but prevent them from being compiled/executed.

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-06-25T21:08:02.014Z
I'm not sure also.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-25T21:10:55.988Z
But you’d have the same problem with something like `sum(l: List[_]): Int = { case Cons[Int](h, t) =>  h + sum(t); case Nil => 0 }`, no? I.e., that seems more like a Scala bug, which I guess could be abused, but I’m going to deny that it’s an issue with the approach ;)

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-06-25T21:11:59.847Z
Unrelated question: Terms like `Mu` and `Nu` are used like they are common sense.  From what context do these greek letters come because I'm not familiar with those?

                                                                                                                                                      Greg Pfeil @sellout@2016-06-25T21:14:00.105Z
I’m not sure, either, other than they’re used in the papers and Haskell libs. `Fix` is clearer, IMO, but its semantics are bad.

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-06-25T21:18:14.476Z
Fixpoints are also something which I feel like I only have a basic understanding of which needs to be improved. My understanding of a fixpoint is that it is the set of inputs where every element is mapped onto itself by the morphism in question. Is that correct?

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T21:24:53.012Z
Reading the banana paper, it gets crazier than just mu/nu.  It's like like Erik and company got inspired by funny symbols he found LaTeX would typeset.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-25T21:24:53.145Z
@mgttlinger Yeah, so, the Y combinator is a value-level fixed-point operator, right? `Y f = f (Y f)`, and Mu/Nu/Fix are the same thing at the type level.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-25T21:25:24.935Z
@shajra Seriously. Glad we don’t have barbedWireMorphism as a result ;)

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T21:25:29.163Z
Be careful with a straight Y in a strict language.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-25T21:26:38.043Z
@shajra Indeed, but that’s just to illustrate the `x = f x`-ness, and the parallel to `Fix f = f (Fix f)`.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-25T21:27:01.274Z
Right, makes sense.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-26T04:16:45.332Z
I just reached a reminder that a `tail` function for Mu[ListF] is O(n).  Is this just the way it is, or is there a common remediation?

                                                                                                                                                      Sukant Hajra @shajra@2016-06-26T04:17:16.198Z
I mean, there's always just using a normal List if you need those asymptotics.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-26T04:59:03.693Z
I _think_ that’s just the way it is. But I also think it’s not as bad as it seems. E.g., traversing the list is still O(n). It’s just that the structure is effectively a suspended foldRight, so getting the tail requires traversing the structure. Also, in the middle of composed transformations, you usually don’t build up recursive structure.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-26T04:59:59.432Z
It’s a good reminder, though. I definitely see `.project` and think of it as a cheap operation, but it’s not necessarily. Same for `.embed` on Nu.

                                                                                                                                                      Greg Pfeil @sellout@2016-06-26T05:05:31.553Z
Actually, nvm on the .embed bit.

                                                                                                                                                      Sukant Hajra @shajra@2016-06-26T05:35:37.212Z
Yeah, it kind of flips for Nu.

                                                                                                                                                      Cody Allen @ceedubs@2016-06-29T01:53:18.895Z
As I start to play around with recursion schemes I feel like they are either going to allow me to move stack safety concerns to a central location or they are going to be completely incompatible with stack safety and all of my apps are going to be a ticking time bomb. I'm hoping it's the former but fearing the latter. Any good news here?

                                                                                                                                                      Greg Pfeil @sellout@2016-06-29T02:39:16.924Z
@ceedubs I’m hoping for the former, too 😉 I do think it’s likely, though that you can handle it exclusively in the fixed-point types. E.g., tramplining `Fix` seems trivial – just haven’t had a need to yet.

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-06-30T09:15:20.840Z
Any recommendations for introductory material on fixpoint theory?

                                                                                                                                                      Lars Hupel @larsrh@2016-09-07T11:05:05.903Z
Would something like an ANF transformation for syntax trees (see [here](http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/blog/2016/09/05/normal-forms.lhs/)) expressible with Matryoshka?

                                                                                                                                                      Greg Pfeil @sellout@2016-09-09T17:50:31.120Z
**\[Jean-Remi Desjardins, SlamData Inc.\]** Wow!
looking at `ShowT` and somewhat surprised, there must be something I am missing:
```
@typeclass trait ShowT[T[_[_]]] {
  def show[F[_]: Functor](tf: T[F])(implicit del: Delay[Show, F]): Cord =
    Cord(shows(tf))

  def shows[F[_]: Functor](tf: T[F])(implicit del: Delay[Show, F]): String =
    show(tf).toString

  def showT[F[_]: Functor](delay: Delay[Show, F]): Show[T[F]] =
    Show.show[T[F]](show[F](_)(Functor[F], delay))
}
```
Aren’t `show` and `shows` jus calling themselves recursively, how can that ever terminate?

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-09-10T06:39:07.843Z
Afaik you are supposed to overwrite one of the two "to break the loop" but it's up to you which one you want to overwrite

                                                                                                                                                      Greg Pfeil @sellout@2016-09-10T16:09:27.184Z
**\[Jean-Remi Desjardins, SlamData Inc.\]** @mgttlinger Thx! That is indeed the intent as confirmed by @sellout offline. Unfortunately, unlike Haskell, the Scala is not smart enough to know that needs to happen though :\( We should probably add a comment to add that intent since I don’t think it’s a common pattern in Scala.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T15:19:17.818Z
**\[Moss Prescott, SlamData Inc.\]** I'm finding that it's annoying to have to require a `Functor[F]` when I need to do `.project` on some `Fix[F]`, because the `Recursive[Fix].project` doesn't _actually_ need `F` to be a functor. NB, it actually is a Functor, so there's no real problem, it's just littering my code with `: Functor` where it wouldn't otherwise be needed.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T15:22:17.800Z
**\[Moss Prescott, SlamData Inc.\]** I guess what I want is to be able to require Functor only on the `Recursive.project` for the types where it's actually needed, which I guess is `Mu` and `Nu`. But that's not how typeclasses work, because you can't require the Functor on the `Recursive` instance, because `F` isn't known there, and you can't require it on only _some_ of the `project` definitions, because Scala. Not sure if Haskell would impose the same constraint.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T15:27:12.450Z
**\[Moss Prescott, SlamData Inc.\]** Thinking out loud, what you'd need to be able to express is "I'll give you a Recursive instance for T, but when I do its `project[F[_]]` will require `Functor[F]`". Which sounds like two different `Recursive` types, so I guess that's the rub. And unless the other operations on Recursive could be similarly generalized for the "general recursion" forms, then it's probably not worth the trouble.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T15:27:16.502Z
**\[Moss Prescott, SlamData Inc.\]** Thanks for listening ;\)

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T15:51:59.528Z
**\[Greg Pfeil, SlamData Inc.\]** @mprescot But the point with `Recursive` is that you don’t know if you have `Fix` or not. If you want to `project` from `Fix`, use `unFix`. But in Quasar we’ve been moving away from using `unFix`, because we want to move away from knowing about `Fix`. It should be `T[_[_]]: Recursive`.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T15:55:17.149Z
**\[Moss Prescott, SlamData Inc.\]** @sellout: Yes, I see that. I was writing to T\[\_\[\_\]\] but happened to know it would only be applied to Fix. But obviously I can't have it both ways.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T15:57:06.426Z
**\[Greg Pfeil, SlamData Inc.\]** @mprescot Yeah, you only know that because we haven’t fixed enough of the code yet. I had Quasar using `Mu` for `compile` for about two commits, until we realized that instantiating a new parser for each request was not a good idea. So more has to happen to make it actually flexible.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T15:59:35.140Z
**\[Moss Prescott, SlamData Inc.\]** Right. Well, I'll keep moving to `T[_[_]]` when I can and try to leave `Fix` only at the "top" where things are relatively static so far. I'm trying to make more incremental changes this time but still touching a lot of code as it is.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T16:06:45.525Z
**\[Moss Prescott, SlamData Inc.\]** @sellout: next question: I have an algebra that gets applied to a coproduct. Therefore the signature looks like this: `def foo[G[_]: Functor](arg: ...)(implicit inj: Inj[F, G]): Algebra[F, Fix[G]]`. That means you always have to apply it like this: `cp.cata(Typeclass[CP].foo[CP])`. That seems dumb, so I'm tempted to define a wrapper that applies `cata`, and  provides the type, as in `fooNotF(arg: ...)(t: T[F]): T[F] = t.cata(foo(arg))`

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T16:07:24.486Z
**\[Moss Prescott, SlamData Inc.\]** But it seems like matryoshka purity would call for _just_ defining the algebra and letting the caller think about cata.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T16:09:09.053Z
**\[Moss Prescott, SlamData Inc.\]** I can't capture that type without also defining the not-an-algebra function, I think.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T16:09:17.596Z
**\[Greg Pfeil, SlamData Inc.\]** @mprescot I think you should look at some of the type classes on QScript – it can be simpler than that. You need an instance on `Coproduct` itself. Then you don’t need the `inj` constraint … at least, I _think_ that’s what you’re trying to do.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T16:10:17.785Z
**\[Moss Prescott, SlamData Inc.\]** I have an instance for Coproduct. I need to be abel to inject because the algebra is a simplification, which builds new trees consisting of nodes from one of the types in the coproduct.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T16:10:53.838Z
**\[Moss Prescott, SlamData Inc.\]** @sellout: Probably we should just go over this code together when it'

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T16:11:48.523Z
**\[Moss Prescott, SlamData Inc.\]** Or maybe you

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T16:12:02.369Z
**\[Greg Pfeil, SlamData Inc.\]** Yeah, I’d like to. My guess is you really want `G` as an associated type, but I guess that doesn’t clean things up at all. That’s what we do in the QScript instances. You could add a second `apply` on the companion object for when F and G are the same.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T16:13:38.299Z
**\[Moss Prescott, SlamData Inc.\]** The typeclass

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T16:13:41.288Z
**\[Greg Pfeil, SlamData Inc.\]** Which is now something I want to do for QScript …

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T16:13:51.587Z
**\[Greg Pfeil, SlamData Inc.\]** Yea.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T16:14:30.726Z
**\[Greg Pfeil, SlamData Inc.\]** So, using an associated type, it’d look like `Typeclass[CP, CP].foo` – so it just moves the second type parameter.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T16:14:37.605Z
**\[Moss Prescott, SlamData Inc.\]** Oh, you mean, two types on the typeclass. I get it. Yes, I think that would help

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T16:14:47.446Z
**\[Greg Pfeil, SlamData Inc.\]** But with an additional apply, you could maybe do `Typeclass[CP].foo`

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T16:15:50.621Z
**\[Moss Prescott, SlamData Inc.\]** I have two algebras with this pattern, so that might make sense. On the other hand, there are two other simpler algebras, so maybe I have more than one type class here. Sigh.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T16:20:42.143Z
**\[Greg Pfeil, SlamData Inc.\]** Ah, in QScript we’ve been doing a lot of type classes – like one for each algebra. I’ve been meaning to condense some of them, but haven’t looked yet. This is definitely the kind of thing we should add to our style guide, though.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-11T19:03:39.207Z
**\[Greg Pfeil, SlamData Inc.\]** @mprescot BTW, just tried the two-apply thing, and it didn’t work, because they erase to the same type. But we could give one an explicit name. Should definitely discuss.

                                                                                                                                                      Alex Gryzlov @clayrat@2016-09-12T19:17:01.655Z
somehow the name "matryoshka" feels fitting for this split-personality-style dialogue ;)

                                                                                                                                                      Greg Pfeil @sellout@2016-09-15T21:25:31.818Z
**\[Moss Prescott, SlamData Inc.\]** @Here: if I want to define "macros" of 1, 2, and 3 arguments for my language whose nodes are F\[?\] using Free\[F, ...\], do I have to define my own types for the arguments as in `data UnaryArg = Arg; data BinaryArg = Arg1 | Arg2; data TernaryArg = Arg1 | Arg2 | Arg3`? There isn't any type lying around that I can use that way?

                                                                                                                                                      Greg Pfeil @sellout@2016-09-15T21:27:00.784Z
**\[Greg Pfeil, SlamData Inc.\]** Hrmm, I don’t think I understand the question.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-15T21:27:39.565Z
**\[Moss Prescott, SlamData Inc.\]** Haha that's not a good sign.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-15T21:28:53.455Z
**\[Greg Pfeil, SlamData Inc.\]** Are you talking about stuff like the structures we use in QScript? I.e., you’d have `Free[F, UnaryArg]`?

                                                                                                                                                      Greg Pfeil @sellout@2016-09-15T21:28:59.132Z
**\[Moss Prescott, SlamData Inc.\]** I want to write a translator from, e.g. `GenericFunc[_2] => Free[ExprOp, TwoArgs]`

                                                                                                                                                      Greg Pfeil @sellout@2016-09-15T21:29:12.126Z
**\[Moss Prescott, SlamData Inc.\]** Right.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-15T21:29:18.708Z
**\[Greg Pfeil, SlamData Inc.\]** `Free[ExprOp, Boolean]` ;\)

                                                                                                                                                      Greg Pfeil @sellout@2016-09-15T21:29:53.539Z
**\[Moss Prescott, SlamData Inc.\]** Sure, `Unit`, `Boolean`, and uh, `SignedBit`? What could go wrong?

                                                                                                                                                      Greg Pfeil @sellout@2016-09-15T21:30:09.460Z
**\[Moss Prescott, SlamData Inc.\]** Wait, `Ord`.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-15T21:30:28.298Z
**\[Greg Pfeil, SlamData Inc.\]** In QScript we have `Hole` for one arg, `JoinSide` for two … so yeah, I guess define your own. But you could also do something like `T[Coproduct[Const[UnaryArg, ?], ExprOp, ?]]`

                                                                                                                                                      Greg Pfeil @sellout@2016-09-15T21:30:51.791Z
**\[Greg Pfeil, SlamData Inc.\]** Which is what QScript will have to move to when we have mutu-rec available.

                                                                                                                                                      Greg Pfeil @sellout@2016-09-15T21:31:21.722Z
**\[Moss Prescott, SlamData Inc.\]** _looks for brain-exploding emoji_

                                                                                                                                                      Greg Pfeil @sellout@2016-09-15T21:34:37.741Z
**\[Moss Prescott, SlamData Inc.\]** I guess I'll give it a try with my own types. Thanks ;\)

                                                                                                                                                      Torsten Scholak @tscholak@2016-10-03T14:11:42.776Z
Hi, is it true that I cannot separate my dsl into expressions and statements unless https://github.com/sellout/matryoshka/tree/mutually-recursive gets merged?

                                                                                                                                                      Greg Pfeil @sellout@2016-10-03T14:26:06.942Z
You can (and SlamData does), but it’s awkward. I’m planning to finish up and merge that branch soon, but it might still be like two weeks out.

                                                                                                                                                      Greg Pfeil @sellout@2016-10-03T14:30:48.941Z
@tscholak ^

                                                                                                                                                      Torsten Scholak @tscholak@2016-10-03T14:48:25.592Z
hmmm, thank you. I'm just starting with my design, and I guess I can work around this limitation in some way or the other.

                                                                                                                                                      Greg Pfeil @sellout@2016-10-03T14:55:19.086Z
@tscholak So, it’s “easy” to work around if your ADTs and type indices line up (which it sounds like they might for you). You can still make `Expr[A]` and `Stmt[A]`. Then you have a couple options.

                                                                                                                                                      Torsten Scholak @tscholak@2016-10-03T14:58:41.285Z
ah, I see. ok, good to know. Can I ask you for a link to a quasar source file with mutually recursive awkwardness?

                                                                                                                                                      Greg Pfeil @sellout@2016-10-03T14:58:48.800Z
1. you could still `Coproduct` them together, as you would for mutual-rec, but it means they can be arbitrarily intermingled, and you might need to protect against that with some other mechanism. Or, 2. you could pass around the fixed point operator. E.g., `Expr[T[_[_]], A]` and `Stmt[T[_[_]], A]` then, you might have something like `case class Block[T[_[_]], A](stmts: T[Stmt], result: A) extends Expr[T, A]` and `case class Assign[T[_[_]], A](name: String, value: T[Expr]) extends Stmt[T, A]`.

                                                                                                                                                      Greg Pfeil @sellout@2016-10-03T15:02:38.036Z
@tscholak Here’s a place with some of that: https://github.com/quasar-analytics/quasar/blob/master/connector/src/main/scala/quasar/qscript/QScriptCore.scala#L32. The types FreeMap and FreeQS are places that _should_ use mutual recursion. The FreeMap case is similar to what I was describing, whereas FreeQS is a _more_ awkward case where the ADT and indices don’t actually line up – which is the primary motivation for wanting mutual-rec.

                                                                                                                                                      Greg Pfeil @sellout@2016-10-03T15:04:20.449Z
The FreeMap type is a fixed-point of the type in https://github.com/quasar-analytics/quasar/blob/master/connector/src/main/scala/quasar/qscript/MapFunc.scala#L550, which has yet another ADT, `EJson` (representing literals), so you can see how that `T` is passed all the way down to be used as the fixed-point operator there.

                                                                                                                                                      Greg Pfeil @sellout@2016-10-03T15:05:40.923Z
FreeMap and FreeQS are a bit different from just using `T`, as they fake mutual-rec even a bit more, effectively giving a type like `Coproduct[Const[Hole, ?], F]`.

                                                                                                                                                      Greg Pfeil @sellout@2016-10-03T15:06:01.277Z
But let’s just say mutual-rec would help SlamData a lot, so I’m motivated to get it done 😄

                                                                                                                                                      Torsten Scholak @tscholak@2016-10-03T15:07:12.236Z
thank you very much. I now have to go and digest this stuff :) thanks a lot!

                                                                                                                                                      Greg Pfeil @sellout@2016-10-03T15:08:49.365Z
Sure, no problem. Feel free to ask anything.

                                                                                                                                                      Torsten Scholak @tscholak@2016-10-04T14:22:32.683Z
hm, so if I do something like this,
 ```
sealed trait Expr[T[_[_]], A]

sealed trait Stmt[T[_[_]], A]

final case class AssignDeterministically[T[_[_]], A](name: scala.Symbol, value: T[Expr]) extends Stmt[T, A]
```
to get mutual recursiveness, then scala complains that, in the last line, `Expr` takes one type argument. I can't replace `Expr` by `Expr[T, A]`, because these would be two type arguments. `Expr[T, ?]` compiles so far, but I think that may cause problems later. 
So I guess I have to say `Expr[T[_[_, _]], A]`, `Stmt[T[_[_, _]], A]`.

                                                                                                                                                      Greg Pfeil @sellout@2016-10-04T14:38:38.655Z
@tscholak You should use the kind-projector compiler plugin, then you can write `T[Expr[T, ?]]` … sorry I left out that bit of noise yesterday.

                                                                                                                                                      Greg Pfeil @sellout@2016-10-04T14:39:04.202Z
But that’s the annoying thing – you have to explicitly pass the `T` around.

                                                                                                                                                      Torsten Scholak @tscholak@2016-10-04T14:39:56.499Z
ah, ok, so `Expr[T, ?]` is the answer. cool

                                                                                                                                                      Torsten Scholak @tscholak@2016-10-04T14:41:04.700Z
I didn't see something like that in quasar. `EJson` is a coprodut of something and a `sealed trait Extension[A]`. So it's not really "mutually" recursive.

                                                                                                                                                      Torsten Scholak @tscholak@2016-10-04T14:41:51.728Z
btw, do you happen to know if ensime works with kind-projector?

                                                                                                                                                      Greg Pfeil @sellout@2016-10-04T15:32:44.706Z
**\[Greg Pfeil, SlamData Inc.\]** It works reasonably well with kind-projector ;\)

                                                                                                                                                      Sumedh Mungee @smungee@2016-10-19T00:44:06.994Z
Anyone see any issues using matryoskha with scalaz 7.2.2 (currently matryoshka is being built with 7.2.1)

                                                                                                                                                      Sumedh Mungee @smungee@2016-10-19T00:45:14.734Z
(Awesome library, I'm here after watching @sellout's talk at Scala North.)

                                                                                                                                                      Greg Pfeil @sellout@2016-10-19T00:47:29.532Z
@paulp submitted #36 with some updates, but it doesn’t update scalaz. Could have been an oversight, or might have been related to julien-truffaut/Monocle#399.

                                                                                                                                                      Sumedh Mungee @smungee@2016-10-19T00:50:36.186Z
Looks like @paulp tried to update it to 7.2.6 (which is the latest stable scalaz-core version), but then reverted it: https://github.com/slamdata/matryoshka/pull/36/commits/7da3483ffe600350fe0aef945624e51f3e226ad0

                                                                                                                                                      Greg Pfeil @sellout@2016-10-19T00:52:58.265Z
**\[Greg Pfeil, SlamData Inc.\]** Ah, good eye.

                                                                                                                                                      Sumedh Mungee @smungee@2016-10-19T00:52:58.923Z
"sbt test" passes for me, both with scalaz 7.2.2 and with scalaz 7.2.6

                                                                                                                                                      Sumedh Mungee @smungee@2016-10-19T00:55:06.999Z
That monocle issue has been fixed: https://github.com/julien-truffaut/Monocle/issues/399

                                                                                                                                                      Greg Pfeil @sellout@2016-10-19T00:56:03.955Z
Cool, so I should get @paulp to update his PR with the new Monocle and get scalaz, etc. updated again.

                                                                                                                                                      Sumedh Mungee @smungee@2016-10-19T00:56:53.724Z
awesome.. 

                                                                                                                                                      Paul Phillips @paulp@2016-10-19T05:52:09.043Z
Ugh, I tried and it blew up on a binary incompatibility which I could not figure out. 

                                                                                                                                                      Sumedh Mungee @smungee@2016-10-19T08:37:06.493Z
btw monocle 1.3.0 has now moved to scalajs 0.6.13, which needs matryoshka to do the same.. 

                                                                                                                                                      Paul Phillips @paulp@2016-10-19T15:56:17.305Z
I pushed another commit to https://github.com/slamdata/matryoshka/pull/36 and maybe someone else can see what I'm missing because I don't know what the problem is.

                                                                                                                                                      Paul Phillips @paulp@2016-10-20T06:08:49.822Z
Here is the problem: scalacheck 1.12.5. https://repo1.maven.org/maven2/org/scalaz/scalaz-scalacheck-binding_2.11/7.2.6/scalaz-scalacheck-binding_2.11-7.2.6.pom

                                                                                                                                                      Greg Pfeil @sellout@2016-10-20T16:17:17.550Z
**\[Jean-Remi Desjardins, SlamData Inc.\]** See [https://github.com/quasar-analytics/quasar/issues/1609](https://github.com/quasar-analytics/quasar/issues/1609)

                                                                                                                                                      Paul Phillips @paulp@2016-10-22T17:31:51.216Z
I updated the build PR with some Cogen efforts. Definitely not done, but I let it sidetrack me too long already.

                                                                                                                                                      Rob Norris @tpolecat@2016-10-31T18:08:53.998Z
@sellout ok so you can define `ana/anaM` for `Cofree` but you can't define `embed` so it's not corecursive. Is there a name for such things or is it just a special case? Or am I horribly confused?

                                                                                                                                                      Rob Norris @tpolecat@2016-10-31T18:15:14.253Z
Well, I mean. I'm certainly horribly confused. But with some luck that's an orthogonal concern.

                                                                                                                                                      Greg Pfeil @sellout@2016-10-31T18:22:54.053Z
**\[Greg Pfeil, SlamData Inc.\]** Cofree can be Corecursive, but it requires the changes from one of the PRs … something about directly-recursive types.

                                                                                                                                                      Greg Pfeil @sellout@2016-10-31T18:23:51.781Z
**\[Greg Pfeil, SlamData Inc.\]** Basically, the Functor of the fixed point in that case isn't just F, but rather CoEnv\[F\].

                                                                                                                                                      Greg Pfeil @sellout@2016-10-31T18:24:13.830Z
**\[Greg Pfeil, SlamData Inc.\]** Sorry, EnvT\[F\].

                                                                                                                                                      Rob Norris @tpolecat@2016-10-31T18:24:37.554Z
I see, ok. That's interesting.

                                                                                                                                                      Rob Norris @tpolecat@2016-10-31T18:25:29.680Z
Hey are you staying at the Holiday Inn Civic Center for SBTB?

                                                                                                                                                      Rob Norris @tpolecat@2016-10-31T18:25:54.755Z
I'd like to talk through some of this stuff with you so I can sound more like I know what I'm talking about in my talk.

                                                                                                                                                      Rob Norris @tpolecat@2016-10-31T18:26:14.946Z
Which is sadly scheduled after yours. So you can offer mine as a lifeboat for people in your talk I guess.

                                                                                                                                                      Greg Pfeil @sellout@2016-10-31T18:49:26.912Z
Heh – yeah, trying to make my talk a bit less … confusing this time. Focusing on usage more. We'll see.

                                                                                                                                                      Greg Pfeil @sellout@2016-10-31T18:50:32.153Z
I'm not sure where I'm staying – might commute back to Cupertino or crash with SF friends. But I'll keep the Holiday Inn in mind.

                                                                                                                                                      Greg Pfeil @sellout@2016-10-31T18:51:06.159Z
Happy to talk about it whenever, and hoping to get some of those PRs merged this week.

                                                                                                                                                      Sumedh Mungee @smungee@2016-10-31T23:45:23.547Z
Any ideas on how to serialize a `Fix`-based tree into JSON? We use upickle as our serializer, but it can't serialize a `Fix[Expr]`

                                                                                                                                                      Sumedh Mungee @smungee@2016-10-31T23:46:48.508Z
I have an `Expr` class that is very similar to the `Exp` and `Exp2` classes in matryoshka. Before making the change from `Expr` to `Expr[A]`, upickle had no trouble serializing it..

                                                                                                                                                      Greg Pfeil @sellout@2016-11-01T02:08:30.975Z
@smungee I don’t know anything about upickle, but we generally pretty-print with an algebra like `Expr[String] => String`. If you’re actually converting to some JSON AST, then similarly `Expr[Json] => Json` (aka. `Algebra[Expr, Json]`)

                                                                                                                                                      Greg Pfeil @sellout@2016-11-01T02:18:02.792Z
For actual `Serializable`, I think we could provide that, although haven’t looked into it.

                                                                                                                                                      Sumedh Mungee @smungee@2016-11-01T04:42:54.210Z
@sellout I don't need Serializable. We're converting to a JSON AST. I guess we could write `Expr[Json] => Json` but our Expr is huge (hundreds of classes), and upickle can generate JSON automatically for us. 

                                                                                                                                                      Sumedh Mungee @smungee@2016-11-01T04:43:46.615Z
Basically our `Expr` is exchanged across service boundaries, and so it needs to be written and read from JSON 

                                                                                                                                                      Sumedh Mungee @smungee@2016-11-01T04:47:48.676Z
Is there any way to take a `Fix`-ed tree and convert it into a tree that is only `Expr`? Then it can be easily JSON-ified by any library..

                                                                                                                                                      Greg Pfeil @sellout@2016-11-01T04:49:35.124Z
Oh, there is a `matryoshka.toTree` algebra – from `fixed.cata(toTree)` is `Fix[F] => Tree[F[Unit]]`. Would that work?

                                                                                                                                                      Sumedh Mungee @smungee@2016-11-01T07:06:20.516Z
That looks promising! Will try it out. :)

                                                                                                                                                      Pawel Szulc @rabbitonweb@2016-11-06T22:11:31.804Z
@sellout btw can u post ur slides online from Scala Up North? I hve the video but it's really hard to follow the slides on the recording

                                                                                                                                                      Greg Pfeil @sellout@2016-11-06T22:13:47.454Z
**\[Greg Pfeil, SlamData Inc.\]** I thought they were posted … hold on.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-06T22:14:08.428Z
**\[Greg Pfeil, SlamData Inc.\]** [https://github.com/sellout/recursion-scheme-talk/blob/master/fix-ing-your-types.org](https://github.com/sellout/recursion-scheme-talk/blob/master/fix-ing-your-types.org)

                                                                                                                                                      Greg Pfeil @sellout@2016-11-06T22:15:34.368Z
**\[Greg Pfeil, SlamData Inc.\]** \(the text doesn’t necessarily line up with the talk – that’s mostly notes as I put the talk together\)

                                                                                                                                                      Greg Pfeil @sellout@2016-11-06T22:32:30.900Z
*phew* _finally_ got #21 compiling and passing all tests. This is a big deal for Quasar, and Matryoshka in general.

                                                                                                                                                      Paul Phillips @paulp@2016-11-06T22:40:14.999Z
@sellout Nice job! Sorry but not that sorry that you managed it before I had a chance to look at it.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-06T22:41:19.707Z
Heh, I’m sure – I’m hoping you can still make it better, though ;)

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T00:17:13.150Z
@tpolecat So, during my talk, you asked about Functor/Foldable/etc. and I mentioned that if you have Bifoldable on the pattern functor, you have Foldable on the fixed-point.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T00:17:34.299Z
Which is true … but, I don’t know how to generalize it as much as I’d like.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T00:19:44.886Z
I.e, you get `Foldable[λ[A => Fix[F[A, ?]]]` for free, but I can’t figure out how to give you `Foldable[Cofree[F, ?]]` for free, because I can’t tie it to the `EnvT[?, F, ?]` pattern functor – it’s not exposed in directly-recursive types the way it is in fixed-point types.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T00:20:11.085Z
So, if anyone has any ideas on how to define that … I’m all ears.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T00:28:24.156Z
Also, while I’m here: implementing `Birecursive[T] extends Recursive[T] with Corecursive[T]` is on the list, too.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T00:28:43.557Z
Those implicits just won’t resolve.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T00:29:36.401Z
And … apparently that’s enough traffic to shut down my Sameroom connection for the day 😆

                                                                                                                                                      Pawel Szulc @rabbitonweb@2016-11-17T15:51:25.693Z
@sellout is it ok if I add my http://www.slideshare.net/paulszulc/going-bananas-with-recursion-schemes-for-fixed-point-data-types to README?

                                                                                                                                                      Torsten Scholak @tscholak@2016-11-17T15:53:38.094Z
oh, awesome!

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T15:53:41.721Z
Yeah, definitely!

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-11-17T16:14:49.302Z
What is the reasoning for defining the type alias `Algebra` and `Coalgebra`? I guess it captures the notion of the morphism defining the algebra. Maybe I have a wrong intuition about all this but if I read `Algebra[X, Y]` I think of some data structure rather than a morphism that can be used to tear down our data structure.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T16:34:30.262Z
@mgttlinger One of the reasons is that when people first see recursion schemes, the function types look pretty odd – they see `Expr[Int] => Int` in isolation, and have no notion of what to do with it. The aliases let them jump to the definition or Scaladoc and get more context.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-17T16:40:05.563Z
Funny, I have to undo the alias in my head. 

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-11-17T16:41:04.339Z
I guess I'm not familiar enough with the concepts to see why such a morphism can be called an `Algebra`. However I get the use of it as far as the documentation aspect you mentioned.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-17T16:41:12.253Z
I get alias fatigue and prefer to see simple types like that in expanded form because I see them as "words". 

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T16:41:30.448Z
https://en.wikipedia.org/wiki/F-algebra

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T16:41:36.463Z
@mgttlinger ^

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T16:42:11.617Z
@tpolecat In reality, Algebra isn’t too complicated, but GAlgebraM is much easier to see with the alias, IMO.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T16:42:23.080Z
Especially when you get transformers in there, etc.

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-11-17T16:42:36.888Z
> F-algebras can also be used to represent data structures used in programming, such as lists and trees.

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-11-17T16:42:47.122Z
But here we do not represent data structures.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-17T16:43:10.243Z
The thing that blew my mind is that `A` seems to come out of nowhere. 

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T16:44:56.572Z
@mgttlinger I could rename the alias to InitialFAlgebra if that’d clear things up ;)

                                                                                                                                                      Rob Norris @tpolecat@2016-11-17T16:45:04.880Z
Heh. 

                                                                                                                                                      Rob Norris @tpolecat@2016-11-17T16:45:47.710Z
I added "tut doc for matryoshka" to my infinite queue btw. Would be a good way to learn this stuff. 

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T16:46:16.029Z
But I just stole the aliases from Kmett’s recursion-schemes. Initially I used the functions directly, but I had to keep explaining that they were algebras.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T16:46:54.718Z
Once you know what an algebra is, you see `Algebra[F, A]` and say “ah, ok, this lets me fold a recursive F to an A”.

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-11-17T16:47:26.824Z
That would not fit my intuition of initial F-Algebras as well but again my intuition may be wrong :wink: . My intuition of an initial F-Algebra (which is again limited to data types) is that it is somewhat like the set of all possible instances that can be constructed.

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-11-17T16:48:58.231Z
Maybe it is wrong altogether to try to get an intuition about these things.

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-11-17T16:50:37.894Z
When I asked people about the intuition for those things they basically started to draw the commutative squares which did not really give me an intuition.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T16:52:17.538Z
I hope it’s not wrong – although I agree that it’s difficult, and I’m still trying to figure out how to provide one. Remember, though, that all data structures can be modeled exclusively with morphisms. Note that in the Wikipedia entry it says “F-algebras can **also** be used to represent data structures”.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T16:57:41.914Z
In @jdegoes’s Next Functional Programming Language talk, he discussed implementing all data structures as their folds. I don’t have a good reference for that idea, though.

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-11-17T17:01:52.385Z
That's similar to the way Morte implements things, right?

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T17:03:38.635Z
I _think_ so … since it’s basically lambda calc + proofs.

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-11-17T17:04:25.207Z
I will watch that talk when I find the time. Maybe that will clear things up.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T17:05:41.699Z
Well, I wouldn’t say John’s talk is big on explanation – more like “here’s a bunch of interesting ideas to look into” ;)

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-11-17T17:07:08.294Z
But maybe that is enough to make it click :wink: 

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2016-11-17T17:08:49.221Z
And if not that was probably still time well spent.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-17T17:09:35.057Z
Don't mention Morte. It's too exciting. I can't handle it.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T17:09:47.147Z
😆 Agreed.

                                                                                                                                                      Gabriel Claramunt @gclaramunt@2016-11-17T21:25:37.107Z
I'm trying to do a very similar thing as Matrioshka, but since I'm translating a library from Haskell, I ran into problems 

                                                                                                                                                      Gabriel Claramunt @gclaramunt@2016-11-17T21:27:03.547Z
it works but it has pattern matching on types :/

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T22:24:17.075Z
@gclaramunt Which library are you translating? Matryoshka started as a translation of Kmett’s recursion-schemes … sort of, I guess it actually started as a translation of fixplate, then moved toward recursion-schemes.

                                                                                                                                                      Gabriel Claramunt @gclaramunt@2016-11-17T22:27:37.398Z
Is something that my functional programming professor made, I don't think is public anymore

                                                                                                                                                      Gabriel Claramunt @gclaramunt@2016-11-17T22:27:41.780Z
here is my transaltion

                                                                                                                                                      Gabriel Claramunt @gclaramunt@2016-11-17T22:27:42.543Z
https://github.com/gclaramunt/scala-reggen

                                                                                                                                                      Gabriel Claramunt @gclaramunt@2016-11-17T22:27:59.689Z
but I have troubles with type inferece :)

                                                                                                                                                      Gabriel Claramunt @gclaramunt@2016-11-17T22:29:49.018Z
the haskell version uses type families to get the pattern functor, and then type classes to get the type <-> pattern functor conversions

                                                                                                                                                      Gabriel Claramunt @gclaramunt@2016-11-17T22:29:59.559Z
it only does fold tho

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T22:30:45.359Z
@gclaramunt Ah, recursion-schemes uses an open type family for that, too. In Matryoshka, it’s done with a type member in the type class.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T22:31:29.889Z
@gclaramunt https://github.com/slamdata/matryoshka/blob/master/core/shared/src/main/scala/matryoshka/Recursive.scala#L307

                                                                                                                                                      Gabriel Claramunt @gclaramunt@2016-11-17T22:31:37.998Z
yeah, I did the same since at the end, we need the type class anyway

                                                                                                                                                      Gabriel Claramunt @gclaramunt@2016-11-17T22:32:41.389Z
interesting, because one of my problems is the parametrization on the generic type 

                                                                                                                                                      Gabriel Claramunt @gclaramunt@2016-11-17T22:33:07.746Z
I came to the conclusion I don't know enough Scala for what I'm trying to do :P

                                                                                                                                                      Gabriel Claramunt @gclaramunt@2016-11-17T22:33:48.860Z
but I wanted to look into Matrioshka for inspiration :)

                                                                                                                                                      Gabriel Claramunt @gclaramunt@2016-11-17T22:34:44.724Z
https://github.com/gclaramunt/scala-reggen/blob/master/src/main/scala/reggen/Regular.scala

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T22:37:51.700Z
@gclaramunt Maybe not at all what you want to do – but I’d be willing to help you take advantage of Matryoshka directly (i.e., depend on it). I like unifying these things, but I understand if you just want your own sandbox.

                                                                                                                                                      Gabriel Claramunt @gclaramunt@2016-11-17T22:38:58.388Z
yep, the whole point was an experiment and depending on a already completed library is not what I want :D

                                                                                                                                                      Gabriel Claramunt @gclaramunt@2016-11-17T22:39:03.443Z
but thanks a lot

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T22:40:14.990Z
@gclaramunt So, Rather than using `Regular` as a type (as in `count[Z]: Regular[Z]#PF[Int] => Int`), I would recommend something like `count[Z, F[_]](implicit R: Regular.Aux[Z, F]): F[Int] => Int`.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T22:40:36.600Z
This is something @mandubian helped me with a while ago – I too had impossible implicit resolution.

                                                                                                                                                      Gabriel Claramunt @gclaramunt@2016-11-17T22:41:33.339Z
yeah, makes sense

                                                                                                                                                      Gabriel Claramunt @gclaramunt@2016-11-17T22:41:56.770Z
will try that, thanks !

                                                                                                                                                      Greg Pfeil @sellout@2016-11-17T22:42:20.601Z
Sure – let me know if you need any help with the details :)

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-21T19:55:58.713Z
this library isn't available for cats yet, right?

                                                                                                                                                      Greg Pfeil @sellout@2016-11-21T19:56:30.794Z
Correct – although recent changes _should_ make it easier to support both Cats & Scalaz.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-21T19:58:53.826Z
I want to make matryoshka-cats and -scalaz projects, and start pushing down the easy stuff – e.g., instances for the types in those libraries. Then there are some concrete data dependencies (e.g. `Free` in `futu`) that I _hope_ I can turn into type class constraints but, failing that, I can probably push them down as well, with implicit conversions that make them work as expected. After that, should just be left with type class dependencies, and then something like shims should help.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-21T19:59:04.848Z
So … there is a plan. Just not there yet.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-21T19:59:32.671Z
I’m open to other approaches, too – especially if suggested in a PR 😆

                                                                                                                                                      Greg Pfeil @sellout@2016-11-21T19:59:56.758Z
But we can’t _abandon_ scalaz, since Quasar (Matryoshka’s primary use case) depends on it.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-21T20:11:25.087Z
yeah its probably going to be a lot of work just looking through all the code

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-21T20:46:52.915Z
Is 0.11.1 the latest published version?

                                                                                                                                                      Greg Pfeil @sellout@2016-11-21T21:47:29.773Z
@dispalt Ah, sorry – I should publish a newer one.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-21T22:17:53.029Z
Hm is `type AnnFree[F[_], T, A] = Free[λ[α => (T, F[α])], A]` a thing?

                                                                                                                                                      Rob Norris @tpolecat@2016-11-21T22:20:22.828Z
I'm working on that thing I asked you about and I need to annotate the interior nodes of`Free[F,A]` by inspecting the `F`s, and then `cata` to get the final result ... I need prior information about the structure of each F before it's folded up.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-21T22:20:35.660Z
(where you = @sellout)

                                                                                                                                                      Greg Pfeil @sellout@2016-11-21T22:21:27.274Z
@tpolecat `Free[EnvT[T, F, ?], A]`

                                                                                                                                                      Greg Pfeil @sellout@2016-11-21T22:21:41.664Z
But it doesn’t have an alias as such.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-21T22:22:03.109Z
Cool. Just wanted to be sure I'm not stepping off the edge.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-21T22:22:12.436Z
Nope, we use that, too ;)

                                                                                                                                                      Rob Norris @tpolecat@2016-11-21T22:22:22.491Z
amazing

                                                                                                                                                      Greg Pfeil @sellout@2016-11-21T22:24:23.874Z
@tpolecat Admittedly, there are a bunch of things we do that I don’t think are good … but Matryoshka changes to improve that whenever possible/necessary (like the new directly-recursive stuff).

                                                                                                                                                      Rob Norris @tpolecat@2016-11-21T22:27:14.417Z
I'm convinced the thing I'm doing is awesome but I'm worried how far out on the plank I have to walk to convince my coworkers.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-21T22:27:44.720Z
@tpolecat Are you considering actually using Matryoshka yet? ;)

                                                                                                                                                      Rob Norris @tpolecat@2016-11-21T22:28:45.985Z
It's helpful to me to build it up on my own, at least until I'm convinced I understand the basics.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-21T22:29:10.271Z
But yes I'd like to pull it in once all the huge changes have been merged.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-21T22:29:24.035Z
@sellout feigns innocence.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-21T22:31:28.707Z
@tpolecat that approach is what I am trying to do, basically build some of the parts myself

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-21T22:31:46.620Z
so then my conviction is through the roof, and since I am bad at lying

                                                                                                                                                      Rob Norris @tpolecat@2016-11-21T22:37:07.410Z
okie dokie … `scalaOrganization := "org.typelevel"`

                                                                                                                                                      Greg Pfeil @sellout@2016-11-21T22:37:26.410Z
@tpolecat What took you so long? ;)

                                                                                                                                                      Greg Pfeil @sellout@2016-11-21T22:44:21.301Z
@dispalt BTW, I am in the process of publishing current Matryoshka – but apparently the wifi here is terrible (I generally never notice, because I just use Gitter/Slack/whatever), so it’s all taking a surprisingly long time.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-21T22:44:58.988Z
And, it also seems to want to lock ~/.ivy2, which is nice for me trying to do anything else while this publishes …

                                                                                                                                                      Rob Norris @tpolecat@2016-11-21T22:51:10.931Z
works \o/

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-21T23:13:44.611Z
All good, was just curious, I can of course publish locally 

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-21T23:13:58.931Z
btw `sbt-release` changed my life

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-22T00:27:11.959Z
spec.scala file melts my intellij

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T00:27:25.415Z
Oh yeah … it’ll do that …

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T00:27:49.110Z
I don’t think anyone at SlamData still uses IntelliJ.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-22T00:28:05.074Z
what do you use?

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T00:29:10.833Z
I use Emacs+Ensime, but even Ensime isn’t always great at this stuff. I mean, it takes the “right” approach (which is “ask the compiler”), but the presentation compiler isn’t always as forthcoming with answers as it should be.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-22T00:29:44.851Z
I don't think I could survive without being able cmd + click stuff

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T00:30:08.915Z
Well, Ensime should give you that, too – in some editor that supports it.

                                                                                                                                                      Torsten Scholak @tscholak@2016-11-22T00:31:00.270Z
it works in atom

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T00:31:02.829Z
But IntelliJ’s implementation of Scala is always going to fall short, and Typelevel in general doesn’t really limit itself to that ;)

                                                                                                                                                      Torsten Scholak @tscholak@2016-11-22T00:32:19.064Z
[![matryoshka.svg](https://files.gitter.im/slamdata/matryoshka/w5CB/thumb/matryoshka.jpg)](https://files.gitter.im/slamdata/matryoshka/w5CB/matryoshka.svg)

                                                                                                                                                      Torsten Scholak @tscholak@2016-11-22T00:32:39.877Z
ok, I thought that would work better

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T00:33:01.825Z
Hah! That opened in Atom for some reason.

                                                                                                                                                      Torsten Scholak @tscholak@2016-11-22T00:33:03.389Z
that’s an svg with the sticker I made yesterday

                                                                                                                                                      Torsten Scholak @tscholak@2016-11-22T00:33:31.016Z
lol

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T00:34:08.903Z
Yeah – we should definitely set that as the channel logo at the very least :D

                                                                                                                                                      Torsten Scholak @tscholak@2016-11-22T00:34:33.588Z
I’m glad people seem to like it. was a quick idea

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T00:34:43.858Z
If I could figure out how to do that …

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T00:35:46.569Z
@tscholak Yeah, I appreciate it – definitely streets ahead of my ideas. First one was nested boxes, but like a literal matryoshka, and the second was a sort of Sierpinski hexagon … which ended up looking more like a flower than a fractal.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T00:37:03.398Z
And I really wanted something that took advantage of the isometric aspect of the hexagon, so 👍🏾

                                                                                                                                                      Torsten Scholak @tscholak@2016-11-22T00:39:24.476Z
yay

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-22T05:07:58.321Z
btw, I think this is the most underrated type of documentation https://raw.githubusercontent.com/slamdata/matryoshka/master/resources/recursion-schemes.png

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-22T05:38:34.291Z
If I wanted to accumulate some audit log type thing as I am executing/recursing an expr tree, what kind of op would I use? I've built up a cofree tree with the `A` spot being information about the AST (like position, and the logical operation it maps to, etc).  The ast itself is fairly pure.  The example of `attributeTopDown` doesn't really give me a clue since that's about building up the AST.  Should I just add more information to the AST instead and reserve that purely for this operation?

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T06:33:33.646Z
@dispalt Glad you like that – at SlamData we tend to have copies printed out on our desks :)

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-22T06:34:24.300Z
Good idea, printed (landscape mode)

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T06:37:11.011Z
So, you want to accumulate a single log while folding, right? I think something like `cataM[Writer[Log, ?], Result]` is what you want.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-22T06:40:34.754Z
here's a smaller ask, say you wanted to execute your `Exp` example to a result.  Say you also wanted to implement something like explain in the sql world

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-22T06:40:59.816Z
say then you wanted to run the query with explain at the same time

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-22T06:41:58.446Z
and the second explain might be different because based on weights you changed what reductions you did

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-22T06:42:38.615Z
like since you had a limit on a subquery, so you did an inmemory join or something

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-22T06:43:22.107Z
so that's obviously just an analogy but my whole goal with this stuff is really good introspection of everything

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T06:45:47.550Z
Right, so if explain is an algebra like `Exp[String] => String`, then you can `(explain zip execute): Exp[(String, Result)] => (String, Result)` … but that would explain the same `Fix[Exp]` that you evaluated – assuming that you did whatever cost optimization before that step. But you could “chain” them in certain ways – maybe with a `zygo`, where you can “inform” a second algebra with the intermediate results from a first.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-22T06:50:34.991Z
Yeah interesting, gotcha, the full example section on your one of your talks was great when I cross referenced it with quasar btw

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T06:51:00.190Z
Oh cool – was that the Scala Up North one?

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-22T06:51:28.901Z
Yes

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-22T06:53:34.303Z
Okay last question before I try to do this, with your AST's if you had something like position and other metadata on a field, would you add it to the AST or generally put them in something like `a` position in Cofree

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T07:08:36.801Z
Yeah, I’d be inclined to use Cofree for that (or some other approach outside of the core AST).

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-22T17:45:55.793Z
if I wanted to match on something like this, what would my `case` statements look like? `val eval: AlgebraM[Writer[List[String], ?], Cofree[Expr, ?], Int] = ...`

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T17:55:54.957Z
So, Cofree _is_ a functor, but that’s probably not what you want to be doing. If you have `Cofree[Expr, A]` and want to fold it, you’d actually have `AlgebraM[Writer[List[String], ?], EnvT[A, Expr, ?], Int] `, then the body would probably look like `_.run match { case (SomeA, SomeExprCase(…)) => … }`

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T18:01:23.360Z
(`EnvT[A, F[_], B]` is just the transformer for `(A, F[B])`)

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-22T18:03:35.794Z
perfect, sorry for the dumb questions

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T18:03:56.816Z
Definitely not dumb questions. This stuff is very non-obvious.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T18:08:22.256Z
We say "annotate", the universe says `EnvT`.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T18:08:30.237Z
Apparently. It has happened to me at least twice.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T18:09:32.650Z
So, the thing I was working on is dramatically simpler just using direct recursion. Sadly.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T18:09:37.366Z
It's like 1/3 the code.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T18:15:39.619Z
Yeah … `(A, ?)` is the “environment comonad” (at least in Haskell parlance) where A is the environment. Not to be confused with the “writer monad”, which requires a monoid on A. Interestingly, the environment comonad is the same thing as the reader monad ∵ currying isomorphism.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T18:16:10.901Z
And there is also a comonad (traced, in Haskell) that is equivalent to the writer monad for the same reason.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T18:17:20.860Z
@tpolecat 😢

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T18:17:31.081Z
@tpolecat I would be interested in seeing the code ;)

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T18:18:52.957Z
Ok, yeah I'll make a gist. I'm going to be working on it more later today.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T18:23:19.993Z
It turns out that there are a bunch of different ways to write Algebras that are equivalent, but might be simpler in different situations. E.g., with `Algebra[EnvT[A, F, ?], Int]`, you might instead do `ElgotAlgebra[(A, ?), F, Int]` – the body looks the same as the one above, but you can drop the `_.run match`, since you’ll already have a value of `(A, F[Int])`. Then, if you need to use it on a Cofree, there’s an algebra transformation that’ll turn the Elgot into an algebra on EnvT.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-22T18:42:30.133Z
Yeah I was just noticing the weighted example

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T18:51:17.439Z
A `{Co}MonadTrans` type class should probably have a type member `M` and an isomorphism that wraps/runs the transformer. Then something like that Algebra/ElgotAlgebra conversion could be generic.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T18:59:55.718Z
Here's my [code](https://gist.github.com/tpolecat/150ca1089cd6a5b3d15ed75e5bd73865) ... having to do it in two steps is a hassle. It doesn't bother me but my coworkers won't like it.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T19:00:41.089Z
I'll add the direct recursion code in a sec.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T19:05:50.155Z
I guess the computation in question is about half the size, but also a lot simpler.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T19:06:31.386Z
@tpolecat This has a terrible name, but there’s an algebra transformation in Matryoshka called `interpret`, which takes an `A => B` and an `F[B] => B`, so your `str` could be written as an algebra on PlanF (ignoring that you _happen_ to use it in Free), then you can `plan.cata(interpret(_.shows, str))`

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T19:07:04.538Z
Ok, yeah I figured matryoshka would be able to eliminate some of the machinery.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T19:07:59.781Z
I guess the real question is how to implement `next`. Having to lift it into `EnvT` before folding is a lot of work.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T19:14:15.654Z
Right – so I would do the same thing with next initially – separate the A => List[A] from the EnvT => List[A], then I would actually write it as `(Int, PlanF[List[A]]) => List[A]`, again, postponing that you _happen_ to want it in EnvT until you actually apply the fold … because you might not actually want it in EnvT …

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T19:15:14.893Z
@tpolecat squints

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T19:17:26.297Z
So, finally, you use `coelgot` ;)

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T19:17:31.927Z
hooray!

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T19:18:25.794Z
So yeah it's going to come down to what we really want to do with this structure and I don't know yet.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T19:18:27.293Z
Mmm, maybe not that simple ;)

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T19:19:01.496Z
Yeah, but that’s kind of the goal of the algebras – is you implement them in the simplest way possible, then you massage things into the right shape when you use them.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T19:19:59.695Z
Right. I think I don't have enough mana to convince people yet since it's a lot to bite off for not much gain *yet*.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T19:20:12.063Z
Yeah, I get that.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T19:20:34.185Z
It's a matter of building it out a bit and learning how to think this way. I'm still on the outer edge.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T19:21:11.440Z
So I think I'll keep a parallel implementation going and attack when I'm sure I'm right.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T19:21:27.911Z
And you can implement `len` as just `PlanF[_] => Int`, then `plan.cata(attributeAlgebra(len))` will give you the Cofree you want.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T19:22:44.314Z
aaaaaaaaah

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T19:23:21.163Z
Is that terror or realization?

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T19:25:46.514Z
little of both?

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T19:25:52.777Z
No, that makes total sense.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T19:27:22.189Z
Ok I need to perform some actual work, if I can remember how. This is all helpful. I'll keep at it.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T19:36:53.514Z
@tpolecat Last thing – I’m thinking maybe Free (vs another node in PlanF) maybe does make this more complicated. With a 3-node, this is actually a zygo: `plan.zygo(len, next)` (using my changes to len and next) – so each `len` generates an Int, and then `next` takes `(Int, ProfF[List[A]])` and generates the list in a single pass. Anyway … I’ll comment on the gist ;)

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T19:37:30.621Z
Actually, maybe the Free doesn’t get in the way.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T22:09:40.193Z
Actually this turns horrible again if I don't use a pattern functor. If you're keeping score at home.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T22:10:05.045Z
Always.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T22:32:54.487Z
`Recursive[Cofree[?[_], Int]].convertTo[PlanF[Observation.Id, ?], Fix](a)` ... is this improved in 0.12? Or is there a less type-argumenty way to do it?

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T22:34:02.766Z
Oh wait I'm not on the typelevel compiler.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T22:34:21.713Z
*phew*

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T22:35:27.256Z
Yeah, it should work like `a.convertTo[Fix]` … I think … since it sounds like you’re on pre-directly-recursive-support.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T22:35:52.986Z
With the newer stuff, you wouldn’t be able to convert directly, because the functor would be `EnvT[PlanF]`.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T22:36:45.868Z
So you would do something like `a.cata(env => Fix(env.lower))` to actually discard the annotation.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T22:37:07.883Z
I think there may already be an algebra defined for that – like `a.cata(forget)` or something.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T22:37:38.357Z
Ok. Is there any reason why 0.12 isn't on sonatype? 

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T22:38:23.586Z
Oh, right :/ Yeah, I started doing it yesterday, but then it tried to publish stuff that it shouldn’t (we split into multiple subprojects) and it failed. I have to fix that.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T22:38:30.535Z
k

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T22:40:54.721Z
Any idea why I get “(root/*:publishSignedConfiguration) Repository for publishing is not specified.” with https://github.com/slamdata/matryoshka/blob/master/build.sbt#L150

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T22:41:55.016Z
I just added `publishTo := None` – see if that does anything.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T22:43:56.303Z
No, my `noPublishSettings` looks exactly the same as yours.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T22:44:07.777Z
This stuff is unforgivably complicated.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T22:44:33.012Z
Ok, well, it looks like it actually staged the stuff that succeeded, so I’m about to release it.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T22:46:06.875Z
Ok, looks like 0.14.0 is now released.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T22:46:17.013Z
@dispalt ^

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-22T22:46:36.756Z
@sellout thx!

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T22:46:53.013Z
Our next PR, IIRC, also crossbuilds on 2.12 and switches to TLS.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T22:54:49.691Z
oh sweet

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T23:03:14.068Z
Hm where are ana and anaM for cofree?

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T23:03:39.710Z
They are just in the Corecursive type class.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T23:04:04.309Z
You need `import matryoshka.implicits._`

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T23:04:27.536Z
Then you should be able to just call them on the Cofree.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T23:05:23.327Z
Ah ok I'm still on 0.11.1 ... 0.14 hasn't shown up yet.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T23:05:29.789Z
Oh …

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T23:05:46.272Z
getting the instance by hand works

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T23:07:39.227Z
Well, the problem there is the old Corecursive version just uses Monoid.zero to populate the annotation. This is basically the whole reason for the change to support directly-recursive types. Because doing anything properly with {co}free before required hand-written {un}folds.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T23:08:06.224Z
Your original use case is what led me to understand this :D

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T23:08:09.025Z
I see, ok. Well I can use `Cofree.unfoldC` if I need to.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-22T23:08:12.917Z
\o/

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T23:08:13.853Z
Yeah.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T23:53:27.712Z
```
[error] This looks like a specs2 exception...
[error] Please report it with the preceding stacktrace at http://github.com/etorreborre/specs2/issues
```
but there is no preceding stacktrace :/

                                                                                                                                                      Greg Pfeil @sellout@2016-11-22T23:54:31.730Z
Oh, phew, simple syntax error in the spec.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-23T00:07:24.845Z
Is there way to abstract over Fix vs Cofree, like for instance if I don't need any of the "annotations" ?

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-23T00:09:34.511Z
this method signature doesn't seem to work anymore with the change to direct recursion `def someExpr[T[_[_]]: Corecursive]: T[Exp] `

                                                                                                                                                      Greg Pfeil @sellout@2016-11-23T00:11:45.617Z
Yeah, so that’s the big change – now that would look like `def someExpr[T](implicit T: Corecursive.Aux[T, Exp]): T`.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-23T00:12:05.746Z
The `[T, Exp]` part basically says “Exp is the pattern functor for T”.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-23T00:12:14.957Z
The old syntax only worked for Fix/Mu/Nu.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-23T00:13:11.646Z
And, yes, if you have `val foo: Cofree[F, A]`, you can do `foo.cata(deattribute(f: F[A] => A))`

                                                                                                                                                      Greg Pfeil @sellout@2016-11-23T00:13:35.453Z
Which would work like `val foo: Fix[F]; foo.cata(f)`

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-23T00:19:50.500Z
ah the old aux pattern, great Ill give it a try

                                                                                                                                                      Greg Pfeil @sellout@2016-11-23T00:20:02.062Z
Indeed :/

                                                                                                                                                      Greg Pfeil @sellout@2016-11-23T00:21:30.812Z
The problem I’m having with it now is that I want to define `Birecursive` as a type class that extends Recursive and Corecursive, but when I do, there seems to be no hope of implicit resolution.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-23T00:21:42.397Z
_Someone_ probably knows a trick to sort that out, too.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-23T17:02:41.113Z
I feel like I am programming in braille sometimes with this stuff, but it's starting to come together

                                                                                                                                                      Rob Norris @tpolecat@2016-11-23T17:08:13.040Z
I feel like a 12th-century monk trying to set up a VCR.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-23T17:10:48.640Z
Yeah it probably isn't like laser disc, Vcr seems more appropriate

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-23T19:03:38.933Z
how would a substitute work with a cofree?  I basically have to make multiple passes in my datastructure because of the way scoping works.  I still feel like I am missing something with this Cofree -> EnvT concept.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-23T19:17:22.560Z
@dispalt `Base = EnvT` basically means that you can view `Cofree[F, A]` as `Fix[EnvT[A, F, ?]]`, and then all the {un}folds work as you’d expect on the latter.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-23T20:47:18.934Z
@tscholak If you want to submit a PR to Matryoshka that adds the logo to the README (and some mention that you made it), that would be awesome. Otherwise, I’ll get around to it eventually.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-23T22:00:32.002Z
@sellout where are the best examples to see this?  I don't see much (granted im really early on this stuff).

                                                                                                                                                      Torsten Scholak @tscholak@2016-11-23T22:01:30.365Z
@sellout I'll do it tonight. Does Lars Hupel want a copy of the svg? Wasn't sure what's going on in the typelevel channel

                                                                                                                                                      Greg Pfeil @sellout@2016-11-23T22:02:03.258Z
@tscholak Yeah, he probably does :D

                                                                                                                                                      Greg Pfeil @sellout@2016-11-23T22:02:22.405Z
@dispalt the best examples to see what? I have to run for a bit, but I’ll catch up when I’m back.

                                                                                                                                                      Torsten Scholak @tscholak@2016-11-23T22:02:27.707Z
kk

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-23T22:05:01.732Z
Ill formulate a better question for when you're back!

                                                                                                                                                      Rob Norris @tpolecat@2016-11-23T23:03:34.438Z
:+1:  for 0.14.0 … much nicer

                                                                                                                                                      Rob Norris @tpolecat@2016-11-23T23:03:50.743Z
However ... `root.ana[Fix[PlanF[Observation.Id, ?]]](planIdCoalgebra)` ... any way to make that less argumenty?

                                                                                                                                                      Rob Norris @tpolecat@2016-11-23T23:06:09.317Z
Also I can't find `T[F] => (F ~> G) => T[G]` but it has to be here somewhere.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-23T23:20:52.426Z
Hm looks like `.hmap` but it doesn't seem to exist for `Fix`.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-23T23:26:26.270Z
@tpolecat For the case of Fix/Mu/Nu, you could try `root.anaT[Fix]` (although, it might have different type params, since I doubt I hand-wrote that one) – it’s like the old `ana` –  doesn’t generalize to directly-recursive types.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-23T23:27:36.740Z
And (again, only for Fix/Mu/Nu), you want `transAna` or `transCata` to apply the natural transformation (depending on which direction).

                                                                                                                                                      Greg Pfeil @sellout@2016-11-23T23:27:46.912Z
Although, of course, it should be irrelevant.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-23T23:27:52.881Z
`value anaT is not a member of ...`

                                                                                                                                                      Greg Pfeil @sellout@2016-11-23T23:28:24.527Z
@tpolecat Yeah, I kind of was hoping no one would want to use `anaT` directly ;)

                                                                                                                                                      Greg Pfeil @sellout@2016-11-23T23:29:17.416Z
I mean, if you abstract over some `T` such that `Corecursive.Aux[T, PlanF[Observation.Id, ?]]`, then `root.ana[T]` is what you want.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-23T23:29:31.237Z
And then you’ve freed up the fixed-point operator, too ;)

                                                                                                                                                      Greg Pfeil @sellout@2016-11-23T23:31:16.467Z
But there’s no way to not specify the `T` because it only shows up in the result.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-23T23:35:37.102Z
I am very confused by `T` being a proper type.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-23T23:37:52.360Z
dammit

                                                                                                                                                      Rob Norris @tpolecat@2016-11-23T23:38:44.150Z
```
def unfold[T](root: PlanRow.Id)(
  implicit ev: Corecursive.Aux[T, PlanF[Observation.Id, ?]]
): WAT[PlanF[Observation.Id, ?]] = ...
```

                                                                                                                                                      Rob Norris @tpolecat@2016-11-23T23:39:18.801Z
If I want for instance to call this and say ok I want `Fix` what do I pass for `T` and what is the return type?

                                                                                                                                                      Rob Norris @tpolecat@2016-11-23T23:39:40.594Z
Or probably I misunderstood.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-23T23:41:53.011Z
oh it's just `T`. hm

                                                                                                                                                      Rob Norris @tpolecat@2016-11-23T23:42:52.115Z
Nevermind, got it. Ow my head.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-24T00:17:02.513Z
`transCata` :+1: 

                                                                                                                                                      Rob Norris @tpolecat@2016-11-24T00:18:19.221Z
I feel certain that once this clicks I will never be able to explain it to anyone.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-24T00:18:58.208Z
I keep going from wait, what to oh, duh.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T00:44:54.562Z
Im stuck on wait

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T00:45:07.932Z
or more precisely "I"

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T00:47:31.741Z
Okay here's what I want to do simplify an AST, similar to [this](https://github.com/slamdata/matryoshka/blob/master/tests/src/test/scala/matryoshka/spec.scala#L92-L101), but doing it over `Cofree[Expr, _]` and maintaining the annotations, I can't seem to negotiate the right types/transformations. 

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T00:48:04.879Z
basically there is a lack of order on my AST so you can declare something later and use it earlier in the tree.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T00:48:20.452Z
so I do a pass to collect everything and now I want to reduce it back to the number

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T00:49:10.197Z
I technically don't need the `A` in the cofree to do the reduction, I just need to manipulate the resulting tree with the `A`

                                                                                                                                                      Greg Pfeil @sellout@2016-11-24T03:46:02.973Z
So, if you’re doing the reduction, you’re going `Cofree[Expr, _] => Int` right?

                                                                                                                                                      Greg Pfeil @sellout@2016-11-24T03:46:24.971Z
And you’re saying you can ignore the annotation, right?

                                                                                                                                                      Greg Pfeil @sellout@2016-11-24T03:46:25.483Z
@dispalt ^

                                                                                                                                                      Greg Pfeil @sellout@2016-11-24T03:48:27.717Z
So, you can write an algebra `Expr[Int] => Int`, and use it like `_.cata(deattribute(reduceAlgebra))` – `deattribute` lets you apply an algebra over some `F` into an algebra over `EnvT[_, F, ?]`, just ignoring the annotation.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-24T03:50:08.288Z
I feel like I have to populate the space of these algebra transformations and come up with names that describe the motion around that space.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-24T03:50:29.615Z
there is sort of an attribute/deattribute dual, so ¯\\\_(ツ)_/¯

                                                                                                                                                      Greg Pfeil @sellout@2016-11-24T03:56:54.852Z
@dispalt Oh, and as for the doing something like `simplify` over Cofree, ignoring-but-maintaining the annotations … I’ve wanted that. Haven’t managed to get it to work yet. https://github.com/slamdata/matryoshka/blob/3e3de4f0f210de5e1aa3cf270c1023e038d118cd/core/shared/src/main/scala/matryoshka/package.scala#L556 – but I think I can make it work.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T04:14:11.229Z
I want to do a `Cofree[Expr,_]` => `Cofree[Expr,_]` similar to simplify in `spec.scala` file, but for cofrees.  I guess I am trying to reverse engineer my understanding through examples

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T04:14:21.437Z
https://github.com/slamdata/matryoshka/blob/master/tests/src/test/scala/matryoshka/spec.scala#L92-L101

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T04:14:31.031Z
@sellout ^

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T04:17:00.314Z
I'd like to simplify my ast with a step while maintaining the metadata attached to branches (which means probably some Monoid instance on `A` I am guessing)

                                                                                                                                                      Greg Pfeil @sellout@2016-11-24T04:21:14.991Z
Right – so if you write `simplify` algebra replacing `Exp[…]` in my examples with `EnvT[A, Exp, …]`, then you can explicitly manage the annotations. If you want to write it _without_ mentioning `EnvT`, then … that’s currently problematic, but I think solvable … I hope.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T04:23:15.833Z
Gotcha

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T04:23:20.163Z
Sorry for being dense

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T04:23:26.218Z
yeah ill give that a shot

                                                                                                                                                      Greg Pfeil @sellout@2016-11-24T04:24:43.553Z
No, you’re definitely not! I promise. Just not a lot of explanatory material yet. But, now that I have the API in what I think is a _pretty_ stable state (i.e., the shapes of type params, etc. shouldn’t change), I hope I can start getting some real docs put together, and think about some of this stuff more holistically.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T04:25:07.224Z
You know what I should do

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T04:25:18.718Z
keep notes, even if they look like a 3rd grader wrote them

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T04:25:39.862Z
then you can see how a beginner sees this stuff

                                                                                                                                                      Greg Pfeil @sellout@2016-11-24T04:26:01.458Z
Oh, that would be fantastic.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T04:29:17.919Z
Actually the biggest thing that clicked for me and made me want to go much further, was this realization, https://gist.github.com/dispalt/4ed461e14c66db6b6e13ceab7fe82538 that the substitution was able to work on the adt level not the tree level

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T04:29:23.644Z
that kinda blew my mind

                                                                                                                                                      Rob Norris @tpolecat@2016-11-24T04:30:38.844Z
I should do that too. Lots of things look impossible at first. 

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T04:31:12.139Z
basically if the types line up it will work as expected, which I guess is true of most fp

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T04:41:13.229Z
@sellout also `transCata` doesn't seem to be a part of cofree

                                                                                                                                                      Rob Norris @tpolecat@2016-11-24T05:42:51.606Z
Even with the 2712 fix the syntax doesn't work. If you alias it down to a simpler type it works. 

                                                                                                                                                      Rob Norris @tpolecat@2016-11-24T05:43:42.053Z
type Foo[F[_]] = Cofree[F, Woozle]

                                                                                                                                                      Rob Norris @tpolecat@2016-11-24T05:44:19.428Z
Then Foo[Qux] will have .transCata

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T05:49:45.266Z
ahh thanks

                                                                                                                                                      Greg Pfeil @sellout@2016-11-24T05:51:18.368Z
@dispalt Ah right, sorry. I’d like to make it work. One thing that’ll work now is to convert the Cofree to Fix[EnvT[…]] … because FunctorT requires that the pattern functor is directly exposed … like all of Matryoshka used to require.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-24T06:17:19.178Z
Is there a snippet somewhere for something that shows, `Cofree` to `Fix[EnvT[…]]`?

                                                                                                                                                      Greg Pfeil @sellout@2016-11-24T06:19:08.284Z
`someCofree.ana[Fix[EnvT[A, F, ?]]](_.project)`

                                                                                                                                                      Greg Pfeil @sellout@2016-11-24T06:20:36.378Z
Actually … this might work … `someCofree.convertTo[Fix[EnvT[A, F, ?]]]`

                                                                                                                                                      Greg Pfeil @sellout@2016-11-24T06:21:25.929Z
convertTo is just a wrapper around the opposite of that first one … `someCofree.cata[Fix[EnvT[A, F, ?]]](_.embed)`

                                                                                                                                                      Greg Pfeil @sellout@2016-11-24T06:21:47.690Z
The idea is you can convert between things that have the same pattern functor.

                                                                                                                                                      Torsten Scholak @tscholak@2016-11-24T14:56:14.755Z
@sellout sorry for the spam. there is no way to test this without pushing changes. I got it working now.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-24T16:43:47.297Z
**\[Greg Pfeil, SlamData Inc.\]** @tsccholak No worries. Thanks!

                                                                                                                                                      Torsten Scholak @tscholak@2016-11-24T16:49:43.952Z
you're welcome

                                                                                                                                                      andy scott @andyscott@2016-11-24T22:04:41.016Z
@andyscott waves at @sellout 

                                                                                                                                                      Greg Pfeil @sellout@2016-11-24T22:06:38.853Z
Hey :D

                                                                                                                                                      Greg Pfeil @sellout@2016-11-24T22:22:04.231Z
So, if I have a `matryoshka.scalaz` package, should I _also_ have a `matryoshka.scalaz.implicits` package, or is there some magic that will only allow the implicits to work in the case that I have imported `matryoshka.implicits._`, or is that just bad mojo?

                                                                                                                                                      Greg Pfeil @sellout@2016-11-24T22:32:10.213Z
@tpolecat Is your preprocessor library public somewhere? I couldn’t find it on your GH. Debating this whole matryoshka-scalaz thing once again ;)

                                                                                                                                                      Rob Norris @tpolecat@2016-11-25T02:29:30.218Z
@sellout it's just kind of hacked into the doobie build. Not a whole lot to it. I didn't make it a plugin because I don't want to be blamed.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-25T02:30:20.916Z
Ross got it working pretty easily for http4s but in the end he decided to do a fork instead. 

                                                                                                                                                      Rob Norris @tpolecat@2016-11-25T02:31:32.345Z
I'm on my phone until Comcast fixes my internets so I'm a bit limited in my powers atm. 

                                                                                                                                                      Greg Pfeil @sellout@2016-11-25T02:42:52.135Z
As I’m trying to abstract over dependencies, I realize I don’t even know how to construct an `Either`.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-25T04:07:51.526Z
I did the shimmy/stubby/stabby thing with atto so you might check that out. Seems to work but irritating in places. 

                                                                                                                                                      Greg Pfeil @sellout@2016-11-25T06:01:19.969Z
Yes … I am certainly doing the stabby thing at the moment.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-25T06:02:09.602Z
I _think_ I’ve pushed all Scalaz datatypes down to the subproject. So next is shims. Then adding a comparable Cats subproject.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-25T06:33:49.002Z
Tried the bananas paper again and I'm irritated by the notation. It's hard to follow even when I know what they're talking about. 

                                                                                                                                                      Greg Pfeil @sellout@2016-11-25T06:34:00.953Z
@tpolecat Yeah, agreed.

                                                                                                                                                      Torsten Scholak @tscholak@2016-11-25T13:28:45.925Z
@sellout do you want me to squash my commits?

                                                                                                                                                      Greg Pfeil @sellout@2016-11-25T16:18:12.951Z
@tscholak Only if you want to – we don’t usually squash.

                                                                                                                                                      Torsten Scholak @tscholak@2016-11-25T16:22:49.713Z
@sellout k, then I'm done.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-25T16:24:01.268Z
Merged! Thanks :D

                                                                                                                                                      Torsten Scholak @tscholak@2016-11-25T16:24:15.724Z
:+1:

                                                                                                                                                      Rob Norris @tpolecat@2016-11-26T06:30:10.897Z
I'm puzzled about Nu

                                                                                                                                                      Rob Norris @tpolecat@2016-11-26T06:32:30.308Z
If I unfold (A, ?) with n => (n, n + 1) and then unNu I get (1, 2) but I expected (1, the next Nu)

                                                                                                                                                      Rob Norris @tpolecat@2016-11-26T06:34:10.957Z
How do I turn the crank to walk the structure? I think maybe I'm doing `Ana` wrong. 

                                                                                                                                                      Rob Norris @tpolecat@2016-11-26T06:34:38.562Z
On my phone so this is hard to type. Standby. 

                                                                                                                                                      Rob Norris @tpolecat@2016-11-26T06:36:00.172Z
`1.ana[Nu[(Int, ?)]((n: Int) => (n, n + 1))`

                                                                                                                                                      Greg Pfeil @sellout@2016-11-26T06:36:16.166Z
**\[Greg Pfeil, SlamData Inc.\]** Yeah, you don't want unNu – you want .project

                                                                                                                                                      Rob Norris @tpolecat@2016-11-26T06:36:26.182Z
Hmm. 

                                                                                                                                                      Rob Norris @tpolecat@2016-11-26T06:36:44.020Z
Oh rock on. 

                                                                                                                                                      Greg Pfeil @sellout@2016-11-26T06:36:51.476Z
**\[Greg Pfeil, SlamData Inc.\]** Notice that for Fix project = unFix, but not for the other types.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-26T06:37:22.420Z
Ok gotcha. That clicks. 

                                                                                                                                                      Greg Pfeil @sellout@2016-11-26T06:37:44.645Z
**\[Greg Pfeil, SlamData Inc.\]** unNu is just a bad name that I should change. I hate when Haskell gets to avoid naming something ;\)

                                                                                                                                                      Rob Norris @tpolecat@2016-11-26T06:40:11.501Z
I'm trying to load up the dikumud map and represent the user's location with a cursor in an infinite unfold. 

                                                                                                                                                      Rob Norris @tpolecat@2016-11-26T06:40:24.726Z
Seems like this will work. 

                                                                                                                                                      Rob Norris @tpolecat@2016-11-26T06:41:00.543Z
Maybe unFix should just be called project. 

                                                                                                                                                      Greg Pfeil @sellout@2016-11-26T21:39:58.724Z
So … `Seq` and Matryoshka … I feel like it’s important to do _something_, because of variadic functions, but it’d be nice if there were some way to dissuade its use in general.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-26T22:42:37.232Z
Also, I’m _really_ not feeling this thing where we keep implicit conversions in a separate package.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-26T23:44:27.808Z
do what with Seq?

                                                                                                                                                      Rob Norris @tpolecat@2016-11-26T23:47:36.198Z
I usually pretend it doesn't exist since it has no instances. 

                                                                                                                                                      Greg Pfeil @sellout@2016-11-26T23:47:54.676Z
@tpolecat I mean I want to be able to apply algebras, etc. to Seq, so you don’t need to do some conversions to deal with `A*`.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-26T23:48:32.656Z
Ah

                                                                                                                                                      Greg Pfeil @sellout@2016-11-27T00:15:53.199Z
Or should I just not encourage use of variation functions either?

                                                                                                                                                      Greg Pfeil @sellout@2016-11-27T00:16:01.958Z
Grr autocorrect.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-27T00:17:19.544Z
I only added instances for Seq in the first place because I was implementing List.apply.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-27T00:19:23.257Z
Which is `seq.convertTo[List[A]]`

                                                                                                                                                      Paul Phillips @paulp@2016-11-27T01:03:30.602Z
@sellout trying to abstract over `A*` like it isn't just a little bundle of snowflakiness is a doomed errand.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-27T01:12:51.859Z
@sellout What do you need for shims?

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-27T01:13:17.543Z
I have a copy with newer cats and scalaz versions and JS and JVM both building, which I was about to contribute back

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-27T01:16:54.482Z
PR is now up

                                                                                                                                                      Greg Pfeil @sellout@2016-11-27T02:04:44.586Z
@paulp 👍🏾 then I'll just make the minimal thing for getting a List from a Seq.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-27T02:06:54.261Z
@edmundnoble That sounds useful for me – I'll upvote. I haven't started with shims yet – still getting everything working with pushing the non-type class stuff to subprojects. Might get to try shims tonight.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-27T04:05:31.051Z
@sellout Glad to hear my PR for shims is what you need. It's not a coincidence ;)

                                                                                                                                                      Greg Pfeil @sellout@2016-11-27T04:07:22.038Z
I still have to add a bunch of others … Foldable, Bi*, etc. but getting closer. And … it’s not possible to define an instance in the shims-only project, right? You have to make instances in the specific subprojects?

                                                                                                                                                      Greg Pfeil @sellout@2016-11-27T04:08:06.759Z
How does anyone manage to use Shims without Comonad? ;)

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-27T04:09:46.917Z
Ugh I know ;) it's a lazily evaluated library, as Daniel puts it. You can totally define instances in the shims-only project

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-27T04:10:21.310Z
My mistake earlier

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-27T04:10:22.504Z
You totally can

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-27T04:10:33.590Z
Shims provides implicit conversions from the shims typeclasses

                                                                                                                                                      Greg Pfeil @sellout@2016-11-28T05:16:39.816Z
Down to 582 shims-related errors ;) This has not been a good weekend for coding …

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-28T05:18:07.478Z
I bet there's more hidden under those though :P hope it's going alright :) can't wait to re-introduce matryoshka to slate, I've been working with just Fix for too long now

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-28T05:18:55.483Z
Are you working at all on stack-safety or is that still an open issue?

                                                                                                                                                      Greg Pfeil @sellout@2016-11-28T05:23:37.211Z
Oh, that’s still an open issue. But your shims PR should help :D

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-28T05:24:00.473Z
I hoped as much

                                                                                                                                                      Greg Pfeil @sellout@2016-11-28T05:24:18.474Z
The code is going fine … just haven’t had much time. Woke up yesterday to a flooded basement … but hey, it’s the fourth time, so it goes pretty smoothly now :laughing:

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-28T05:27:49.284Z
That's not a great thing to make a routine of ;) at least the code is DRY.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-28T05:35:39.120Z
:clap:

                                                                                                                                                      Greg Pfeil @sellout@2016-11-28T05:49:05.144Z
I think Shims may just be a ploy to show everyone how much they depend on Scalaz.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-28T05:50:12.661Z
To get them to contribute to it, probably :P

                                                                                                                                                      Greg Pfeil @sellout@2016-11-28T05:54:15.335Z
So, I think there’s no way for me to avoid defining `~>` and `Id` locally, right? Not that they’re very complicated. I might also add `Const`.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-28T06:07:10.208Z
Probably. Which const? Type-level or the class?

                                                                                                                                                      Greg Pfeil @sellout@2016-11-28T06:19:32.707Z
I’m confused … isn’t the class the type-level const? Value-level one is Function1.const, or scala.Predef.const … or at least _somewhere_ in the stdlib.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-11-28T06:24:34.874Z
@sellout dang flooded basement sounds crappy

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-28T06:36:55.156Z
So there's `Lambda[A => C]`, then there's `class Const[A, B] { def getConst: A }`, then there's `def const(a, b) = a`

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-28T06:37:16.617Z
Two of em are type level, just from different perspectives

                                                                                                                                                      Greg Pfeil @sellout@2016-11-28T16:11:55.371Z
@edmundnoble Ah yeah – just the class then :)

                                                                                                                                                      Rob Norris @tpolecat@2016-11-29T00:36:23.929Z
Feeling pretty macho with fixpoints of `EnvT` of  `CoEnv` [here](https://gist.github.com/tpolecat/f2c1005b66f18f925232e55f646369a6). My coworkers will never go for it but it's fun that it works. Do you see any obvious simplifications?

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-29T00:39:50.073Z
Is this the kind of thing that gets fused into a single iteration? The transCata followed by cata?

                                                                                                                                                      Rob Norris @tpolecat@2016-11-29T00:44:28.465Z
Would be cool but I don't know how to do that.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-29T00:44:46.536Z
I thought they did when you used Mu instead of Fix. Dunno. @sellout?

                                                                                                                                                      Rob Norris @tpolecat@2016-11-29T00:45:21.174Z
Oh that's possible, sure.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-29T00:51:44.601Z
transCata, unfortunately, loses any real benefit of Mu. But … these sorts of things can be manually fused in a couple ways. I’ll take a look later, but I’m about to run.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-29T15:17:30.634Z
Every time I add anything to Matryoshka, I’m like “oh, I really need this one more thing …”

                                                                                                                                                      Greg Pfeil @sellout@2016-11-29T15:18:15.471Z
Today, in coming up with a mutually-recursive representation for QScript, I’m like “mmmm, ABTs would make this nicer …”

                                                                                                                                                      Greg Pfeil @sellout@2016-11-29T15:24:05.572Z
I’m like so close to having a correct-by-construction AST for Quasar. Think I’m gonna need HList to finish it.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-29T15:26:21.959Z
It does require a bit in the way of type parameters, though :laughing:

                                                                                                                                                      Greg Pfeil @sellout@2016-11-29T23:40:06.548Z
So, if anyone can figure out how to make `Birecursive[T] extends Recursive[T] with Corecursive[T]` work, I would be pretty grateful.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-29T23:42:16.597Z
That's the only requirement?

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-29T23:42:27.828Z
I'll take a look, no other code for it already?

                                                                                                                                                      Greg Pfeil @sellout@2016-11-29T23:43:51.952Z
No other code for it – I basically want to be able to replace `implicit TR: Recursive.Aux[T, F],  TC: Corecursive.Aux[T, F]` with `implicit T: Birecursive.Aux[T, F]` (and have method calls within that that only depend on the `Recursive` or `Corecursive` aspect).

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-30T00:04:46.783Z
How opposed are you to `type Birecursive[T] = Recursive[T] with Corecursive[T]` ;)

                                                                                                                                                      Greg Pfeil @sellout@2016-11-30T00:19:42.888Z
Not at all if it works. That won't actually get me the constraints I need though … will it?

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-30T00:33:55.857Z
Why not?

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-30T00:34:05.423Z
Either way it will break a lot

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-30T00:34:23.415Z
I went with actually making a Birecursive, I'm almost done and I had to duplicate the ops crap in Recursive that's not possible with simulacrum

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-30T00:35:02.342Z
It will break everybody who uses both constraints, so it forces a lot of change

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-30T00:51:33.759Z
@sellout I cannot get it to find an implicit Recursive.Aux[T[F], F] given an implicit Birecursive.Aux[T[F], F]. Guess this is the limit of the type system.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-30T00:54:08.227Z
`Recursive.Aux[T[F]] with Corecursive.Aux[T[F]]` is not the same as `Recursive[T] with Corecursive[T] { type Base = F }`, at least enough for implicit search

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-30T01:29:35.655Z
Yeah this looks impossible without duplicating the ops classes. Can't use either of their syntax. I've only spent an hour on it, but that's how it looks at the mo.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-30T02:48:52.516Z
@edmundnoble What about
```scala
object Birecursive {
  type Aux[T, F[_]] = (Recursive[T] with Corecursive[T]) { type Base[A] = F[A] }
}
```
?

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-30T04:17:38.556Z
Tried that as well after unfortunately implicit search still won't let you use rec or corec syntax on birec 

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-30T04:18:22.776Z
You can make birecs then from both instances, fixing some compatibility issues, but still

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-30T04:19:03.298Z
Some intersection of implicits and subtyping and refinement types which just ain't enough

                                                                                                                                                      Greg Pfeil @sellout@2016-11-30T04:19:47.910Z
Maybe @milessabin can fix the compiler ;)

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-30T04:21:08.118Z
Mayyyybe I can provide an implicit conversion which performs subtyping's job

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-30T04:21:28.716Z
And remove one of the things in play. Worth a shot, trying later

                                                                                                                                                      Greg Pfeil @sellout@2016-11-30T04:21:36.631Z
Ohhh, _that’s_ a good idea.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-30T04:21:51.027Z
Well, thanks for all the help, regardless of the outcome :laughing:

                                                                                                                                                      Edmund Noble @edmundnoble@2016-11-30T04:22:05.389Z
Welcomes :)

                                                                                                                                                      Miles Sabin @milessabin@2016-11-30T09:33:15.322Z
What's all this?

                                                                                                                                                      Pawel Szulc @rabbitonweb@2016-11-30T09:35:17.836Z
@milessabin black magic

                                                                                                                                                      Miles Sabin @milessabin@2016-11-30T09:37:38.873Z
Apparently I'm being volunteered to fix more compiler bugs :-)

                                                                                                                                                      Miles Sabin @milessabin@2016-11-30T09:39:10.141Z
@edmundnoble can you post a minimal standalone gist ... I think this one is most likely doable.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-30T18:13:38.730Z
@milessabin Here’s a standalone gist: https://gist.github.com/sellout/3bec3b9d3b6de2fd224daee5cf859ed6 – line 28 being the thing that I would like to make work. Anything outside of the `Test` class can be terrible, because it’ll be within Matryoshka.

                                                                                                                                                      Rob Norris @tpolecat@2016-11-30T18:16:23.224Z
Unicode Primes!

                                                                                                                                                      Greg Pfeil @sellout@2016-11-30T18:16:40.139Z
@tpolecat I waste no time 😆

                                                                                                                                                      Greg Pfeil @sellout@2016-11-30T18:20:19.465Z
@paulp and @edmundnoble Wanted to point you at that ↑ gist, since you’ve both tried to attack the problem.

                                                                                                                                                      Paul Phillips @paulp@2016-11-30T18:26:11.950Z
"Mayyyybe I can provide an implicit conversion which performs subtyping's job" I've tried that before. Nope.

                                                                                                                                                      Greg Pfeil @sellout@2016-11-30T18:54:02.478Z
If anyone has any ideas, @rabbitonweb is looking for some low-hanging Matryoshka fruit. I think `Birecursive` is probably not that …

                                                                                                                                                      Greg Pfeil @sellout@2016-11-30T18:54:31.164Z
I know I still have a bunch of things in my head, so I’m trying to reify them into issues as I think of them.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-12-01T21:35:29.401Z
if I just wanted cataM for cats, how hard would you think it'd be to pull that out?

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-01T21:35:52.895Z
@dispalt It would take around 4 lines

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-01T21:36:08.749Z


                                                                                                                                                      Dan Di Spaltro @dispalt@2016-12-01T21:36:10.294Z
so @edmundnoble your saying, it would be really hard

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-01T21:36:20.470Z
Real easy :)

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-01T21:36:22.620Z
One sec

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-01T21:36:36.817Z
What do you have? `Recursive`? `Fix`?

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-01T21:36:39.604Z
What you gonna tear down?

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-01T21:37:10.158Z
I ended up having to pull it out to work with cats myself, I just have a stack-safe version

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-12-01T21:37:12.160Z
A Cofree which I've stolen from your GH

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-01T21:37:26.718Z
(do you want the stack-safe version ;))

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-12-01T21:37:32.494Z
yes pls =)

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-01T21:40:54.255Z
(if you've just got Fix, [here's a gist](https://gist.github.com/edmundnoble/44e17ce1665076a7e82f6115efc8b2b1))

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-01T21:44:39.290Z
The source appears to be the same for scalaz and cats, funnily enough

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-01T22:18:05.400Z
@dispalt Glad to know you're getting use out of it :) do you want to cataM your cofree? I can help with that

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-01T22:18:15.721Z
Sorry for the delay, didn't get those messages for some reason

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-01T22:23:04.038Z
[Here you go, for Cofree instead](https://gist.github.com/edmundnoble/b9e4f9693a8f8601d2d3af7aaba9d5fb)

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-01T22:23:34.329Z
Call me... the *eliminator* ;)

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-12-01T22:54:56.327Z
haha, Ill give it a shot, thanks a bunch @edmundnoble !

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-01T23:12:32.151Z
Welcomes :)

                                                                                                                                                      Hamish Dickson @hamishdickson@2016-12-02T08:38:00.546Z
Ah awesome @edmundnoble ! I'm in need of this for cats as well - couldn't have timed that much better :smile: 

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-02T10:07:17.225Z
Excellent. It'll be in matryoshka-cats soon ;)

                                                                                                                                                      Valentin Kasas @vil1@2016-12-02T14:55:34.168Z
Hello recursive people. 
I have a little project in mind : I want to define a simple format to represent data and schemas that I would easily translate to other formats (eg sparkSQL `DataType`, avro `Schema` and so on). I feel that matryoshka would probably will be of good help for that purpose. Would someone here be so nice to point me out where I should start, considering that I have absolutely no prior knowledge of those matters and a fairly limited amount of time to  assign to this task ?

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-02T22:56:09.927Z
@tpolecat Nu is a partially-applied anamorphism. Mu is a partially-applied catamorphism. An anamorphism can be used to represent a potentially infinite dataset, because you can keep applying it, whereas a catamorphism can only be further destructed. That's my understanding.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-02T22:56:44.736Z
@vil1 You may be just fine with normal Scala data types and Shapeless for datatype-generic programming.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-02T22:57:28.514Z
Though with that said Matryoshka is mostly for recursive data, if your data is naturally recursive it may help with constructing and eliminating that data but probably not converting it.

                                                                                                                                                      Rob Norris @tpolecat@2016-12-02T22:59:00.036Z
In my experiments it's the opposite. Unfolding into `Nu` can be infinite but not into `Mu`.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-02T23:01:08.829Z
Wow I swapped them round :P one sec

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-02T23:01:21.991Z
There ya go

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-02T23:01:45.903Z
Admittedly though I don't know anything about their operational characteristics: all I know is they are each half the speed of Fix on a normal day (in JS, in my compiler)

                                                                                                                                                      Valentin Kasas @vil1@2016-12-03T00:24:19.618Z
@edmundnoble thanks for the insight. I'm quite comfortable with shapeless so I might give it a shot at my problem at some point. But I envision my conversions as catamorphisms from my (to be defined) data structure into the (kind *) spark/avro types, so I guessed it was a good occasion to use/learn matryoshka. Am I completely wrong  ?  (that's a genuine question, please beat in mind 

                                                                                                                                                      Valentin Kasas @vil1@2016-12-03T00:27:05.140Z
   that I know nothing)

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T00:29:00.375Z
@vil1 it depends. Is your data naturally recursive?

                                                                                                                                                      Valentin Kasas @vil1@2016-12-03T01:10:59.307Z
Well I guess so, I have simple types (integers, strings, booleans, etc ...) and structs and arrays containing simple types or stucts or arrays, and so on

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T01:12:15.680Z
Well catamorphisms may be useful for the recursion, absolutely. Come up with a pattern functor and you can see what you can do.

                                                                                                                                                      Valentin Kasas @vil1@2016-12-03T01:14:25.112Z
From a beginner point of view, the tricky part is structs , since the "content" of such struct would be something like a shapeless record

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T01:14:30.183Z
```
  final case class True[A]() extends JSONF[A]
  final case class False[A]() extends JSONF[A]
  final case class Null[A]() extends JSONF[A]
  final case class Str[A](value: String) extends JSONF[A]
  final case class Num[A](value: Double) extends JSONF[A]
  final case class ObjList[A](value: Vector[(String, A)]) extends JSONF[A]
  final case class Arr[A](value: Vector[A]) extends JSONF[A]
```

                                                                                                                                                      Valentin Kasas @vil1@2016-12-03T01:15:00.329Z
makes sense

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T01:15:11.649Z
Like if you recurse over that, do you get something close to what you want?

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T01:15:16.143Z
Given Fix[JSONF]?

                                                                                                                                                      Valentin Kasas @vil1@2016-12-03T01:15:39.057Z
absolutely

                                                                                                                                                      Valentin Kasas @vil1@2016-12-03T01:17:00.584Z
but how would I write an `Algebra[JSONF, DataType]` ? (`DataType` being the stuff I want to fold into) 

                                                                                                                                                      Valentin Kasas @vil1@2016-12-03T01:17:34.478Z
(or maybe `Algebra` is not what I need)

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T01:17:35.089Z
Ah, that'll be a function that given a JSONF[DataType] makes a DataType

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T01:18:00.335Z
Algebra probably will be what you need if you are destructing your data type to make some other one

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T01:18:18.020Z
Then `cata` will make that algebra into a function Fix[JSONF] => DataType

                                                                                                                                                      Valentin Kasas @vil1@2016-12-03T01:19:34.604Z
ok

                                                                                                                                                      Valentin Kasas @vil1@2016-12-03T01:20:47.041Z
mist comes a little bit clearer, thanks a lot

                                                                                                                                                      Valentin Kasas @vil1@2016-12-03T01:22:39.805Z
(it's 2AM here so I need to go to sleep, but I'll try to make some progress first time tomorrow, expect some more dummy questions)

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T01:25:02.131Z
RIghto, sounds good :D

                                                                                                                                                      Greg Pfeil @sellout@2016-12-03T16:51:06.868Z
@tpolecat I understand much less of this stuff than is generally assumed, I think. Re: Mu vs. Nu, my hand-wavy explanation is that we need laziness/trampolining/something to avoid stack-overflow on large finite values, but want to be able to reason about the structure inductively rather than coinductively. In most languages that’s a distinction without difference, I suppose. But now I wonder how Idris deals with `data` (vs lazy `codata`) internally. It’s a strict language, so is it just not stack-safe, or what?

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T19:33:47.864Z
@vil1 LOL, things really do get invented in parallel in our world. Have a look at http://github.com/nuttycom/sjsch and http://github.com/nuttycom/thx.schema

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T19:34:07.730Z
I'm just in the process of building almost exactly what you're describing.

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T19:35:59.997Z
https://github.com/nuttycom/sjsch/blob/master/src/main/scala/sjsch/Schema.scala is the main schema definition; I'm still figuring out how to build all the cofree structure that's needed for the interpreter. The thx.schema project is in Haxe, which doesn't have higher-kinded types and thus has to use direct recursion (and so you can't annotate the tree or do more interesting manipulations.)

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T19:36:28.384Z
But it's more complete, having interpreters from the Schema type into parsers, generators, etc.

                                                                                                                                                      Valentin Kasas @vil1@2016-12-03T19:38:34.324Z
interesting !

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T19:38:34.404Z
Anyway, the underlying concept is to use free applicative functors to allow you to describe the structure of JSON objects.

                                                                                                                                                      Valentin Kasas @vil1@2016-12-03T19:41:22.197Z
That sounds more advanced than what I had in mind though

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T19:43:16.622Z
Once you have a typed description of the JSON structure you're interested in, you can do whatever you want with it - generate a parser, generate the JSON-schema description of the structure, generate a ScalaCheck Gen instance, etc. So it might work for your use case, is all I'm saying.

                                                                                                                                                      Valentin Kasas @vil1@2016-12-03T19:45:12.053Z
yeah definitely

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T19:47:57.917Z
Mmmm it's beautiful. I think this might suffice as a basis for a JSON type system. I am also curious what you get out of this versus a more conventional free invariant monoidal, which is ordinarily what I look at for codecs.

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T19:49:18.046Z
Free invariant monoidal? I know all of those words individually, but my brain is having a hard time putting them together, can you describe in more detail?

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T19:52:56.804Z
Absolutely. These are the operations provided.
```
  def imap[B](f: A => B)(g: B => A): FA[F, B] = Imap(this, f, g)

  def product[B](b: FreeInvariant[F, B]): FA[F, (A, B)] = Zip(this, b)

  def foldMap[G[_]](n: F ~> G)(implicit I: Invariant[G], M: Monoidal[G]): G[A]
```
As you can see, the ordinary FreeInvariantMonoidal (in cats, I think) admits operations that a. zip two codecs together and b. map functions both ways. Adding a little bit of spice, you can come up with something similar:
```
sealed trait Iso[A, B] {
  def to: A => Option[B]
  def from: B => A
}
case class Id[A]() extends Iso[A, A]
case class Zip[A, B](fst: Iso[A, B], snd: Iso[C, D]) extends Iso[(A, C), (B, D)]
case class PartialImap[A, B, C](fst: Iso[A, B], to: B => Option[C], from: C => A) extends Iso[A, C]
```

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T19:55:21.552Z
Essentially, a category for correct-by-construction isomorphisms.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T19:56:05.405Z
(there is a similar, more practical example in my github repo [here](https://github.com/edmundnoble/slate/blob/23563a1cc42ac4579f4e4e634e2ca03181cd9aa6/ui/src/main/scala/slate/util/Delimiters.scala))

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T19:56:20.946Z
Huh... that PartialImap looks really familiar. That's almost exactly the signature that's necessary to support sum types. 

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T19:57:40.982Z
Composing partial isomorphisms. I can definitely see there being a relationship with say prisms.

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T19:57:58.103Z
Yup.

                                                                                                                                                      Valentin Kasas @vil1@2016-12-03T20:07:34.857Z
I definitely understand everything that is said here (*laughs nervously*)

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T20:21:57.182Z
@nuttycom i.... have also written a bidirectional parser/printer for JSON https://github.com/adelbertc/circular

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T20:22:15.784Z
and it uses essentially what @edmundnoble described

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T20:22:18.683Z
partial isomorphisms

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T20:22:26.872Z
i haven't found a way to unify it with optics yet

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T20:22:31.097Z
but i also haven't tried very hard

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T20:22:43.995Z
@adelbertc it's all the rage lately, apparently! :)

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T20:22:56.659Z
i'm sure many of us wrote a JSON encoder/decoder for the Nth time

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T20:23:06.864Z
and thought "there should be a better way" ;)

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T20:24:12.618Z
Eyyyy hell yes. Interesting you define it as partial both ways.

                                                                                                                                                      Miles Sabin @milessabin@2016-12-03T20:24:28.025Z
@adelbertc is circular in the TL incubator yet?

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T20:24:47.669Z
@milessabin not yet.. sooon... if i feel comfortable saying i will actively maintain it :)

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T20:24:51.606Z
Hey, @milessabin, it's been a while, how have you been?

                                                                                                                                                      Miles Sabin @milessabin@2016-12-03T20:25:05.331Z
Very busy :-)

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T20:27:06.717Z
Circular looks to be about two levels up from my current level of understanding... being out of the scala world for a bit has clearly caused me to fall behind. :/'

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T20:27:53.351Z
most of it is me transliterating Haskell code :P

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T20:34:14.438Z
@adelbertc so looking at https://github.com/adelbertc/circular/blob/master/argonaut/src/main/scala/circular/argonaut/JsonPIso.scala and PIso, is there a way to deconstruct the structure that you've built up to do anything other than run the isomorphism in one direction or the other? One of the things I want to be able to do is, for example, to write `Schema[E, ?] ~> Gen`

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T20:36:06.040Z
All the operations end up being like that: `Schema[E, ?] ~> CodecJson` etc. 

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T20:37:58.484Z
As a consequence, in sjsch the primitive types that everything eventually decomposes to have to be reified. At least right now, that is... eventually I want to change it up so that you can provide your own sum type to define what is "primitive."

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T20:38:41.041Z
Actually, maybe I should do that now.

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T20:59:55.528Z
@nuttycom my understanding is no, but i havent looked at it hard enough

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T21:00:24.948Z
@adelbertc okay, good, I'm still doing something useful then. :D

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T21:00:27.110Z
it doesn't look like it though since everything runs off `PIso`

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T21:00:39.311Z
and the end type you get assumes `Json` on one side and `A` on the other

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T21:00:52.209Z
so i guess unless `A` was parametric or something

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T21:01:09.415Z
I don't see why you couldn't do that

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T21:01:23.816Z
Make one of your circular codecs into a Gen

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T21:01:44.315Z
If you reified your structure a bit more maybe

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T21:02:05.057Z
@edmundnoble yeah, the reification of the structure is exactly why I need FreeAp

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T21:02:57.131Z
And the preservation of the A type parameter throughout is why I need generalized cofree

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T21:03:08.116Z
Generalized cofree?

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T21:03:33.949Z
Like the dual of generalized free?

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T21:03:46.489Z
https://github.com/nuttycom/sjsch/blob/master/src/main/scala/sjsch/GFunctor.scala#L18

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T21:03:47.363Z
Free c a = c f => f a?

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T21:04:12.186Z
That thing, whatever it is. Like cofree, but one kind level higher?

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T21:04:26.266Z
Oh my god, all of this talk of cofree is reminding me I haven't had a coffee

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T21:04:42.966Z
I wonder if you'll be able to unify that with ordinary cofree with polykinds.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T21:05:11.572Z
Your GFunctor is very familiar as HFunctor as well, have you looked at khats?

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T21:05:42.413Z
Maybe indexed cofree?

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T21:05:58.445Z
Maybe? polykinds still sketch me out a bit... I feel like if I lose the ascribed kinds, that I'll completely fail to be able to understand the code.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T21:06:35.954Z
I feel like I agree completely. The discussion as to the ways we might be able to manipulate it doesn't seem to be heading in a very human-friendly direction so far

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T21:06:56.960Z
Bunch of subtyping rules being invented, AnyKind and SameKind

                                                                                                                                                      Kris Nuttycombe @nuttycom@2016-12-03T21:07:30.222Z
And yeah, @sellout was mentioning that there were about 3 or 4 of these generalized functor types floating around. I just wrote this one myself for toying around purposes, I'll add a dependency on something (whether matryoshka or khats) once this all firms up a bit.

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T21:07:47.890Z
@edmundnoble probably if i substituted `PIso` with `FreeInvariantMonoidal` or something similar

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-03T21:20:20.728Z
If you need any [inspiration](https://github.com/edmundnoble/slate/blob/23563a1cc42ac4579f4e4e634e2ca03181cd9aa6/ui/src/main/scala/slate/util/Delimiters.scala)

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T21:42:48.608Z
maybe ill do the finally tagless version of FreeInvariantMonoidal #comeatmebro

                                                                                                                                                      Greg Pfeil @sellout@2016-12-03T22:03:51.625Z
@edmundnoble Yeah, @mossprescott eventually convinced me that generalized invertible syntax needs to be partial in both directions. Eventually he got tired of me always saying it should be a Prism ;)

                                                                                                                                                      Greg Pfeil @sellout@2016-12-03T22:09:41.702Z
Does anyone understand what the list of people on the right-hand side of a Gitter channel is for?

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T22:10:21.902Z
yeah at one point i had converted it to a Prism

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T22:10:23.643Z
and ran into a wall

                                                                                                                                                      Greg Pfeil @sellout@2016-12-03T22:10:38.857Z
Seems to be a random list of 10 people who were in the channel at some point during its existence.

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T22:11:21.123Z
the issue is the **expectation** is parsing may fail which accounts for partiality in one direction, but serialization is almost always total (there are some exceptions, like Scodec's utf8encode)

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T22:11:28.382Z
but due to the way its setup, at least in the paper

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T22:11:50.741Z
if you have a sum type, the codec is setup to be specific to **one of** the data constructors

                                                                                                                                                      Greg Pfeil @sellout@2016-12-03T22:12:00.144Z
@adelbertc Yeah – Moss’ example was when you have something like `Ident(name: String)`, but only some chars are valid in identifiers and the syntax has no escaping mechanism. You just can’t guarantee that you can print that AST.

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T22:12:40.141Z
so if you pass in a different data constructor to the codec, it fails. what we'd like is to be able to compose these codecs such that they can track partiality/totality.. maybe something like that patmat thing the haskell folks do with prisms http://www.haskellforall.com/2015/01/total-100-exhaustive-pattern-matching.html

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T22:12:56.388Z
yeah that too

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T22:13:21.288Z
and idnt hte right hand side of the channel the list of everyone in the channel?

                                                                                                                                                      Greg Pfeil @sellout@2016-12-03T22:13:27.711Z
Heh, yeah, I brought up exhaustive prisms at some point, but didn’t convince anyone to help me with it ;)

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T22:13:28.987Z
oh wait no  i take that back

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T22:13:32.967Z
guess not. no clue what it is thne

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T22:13:44.429Z
i think brian/puffnfresh tried it at some point and hit aw all

                                                                                                                                                      Adelbert Chang @adelbertc@2016-12-03T22:13:58.864Z
i spent a day on it a while back with Monocle and couldnt get the type checker to not give me the finger

                                                                                                                                                      Paul Phillips @paulp@2016-12-06T06:34:34.140Z
@sellout I'm really having trouble coming to terms with the fact that you can write `deriving Traversable` in haskell.

                                                                                                                                                      Paul Phillips @paulp@2016-12-06T06:35:06.185Z
Hmmm, maybe an annotation macro...

                                                                                                                                                      Greg Pfeil @sellout@2016-12-06T06:37:14.259Z
@paulp Shapeless should let us write that, I think … I tried like a year ago or so(?) but was fairly confused by it at the time.

                                                                                                                                                      Paul Phillips @paulp@2016-12-06T06:37:47.505Z
I do have to better acquaint myself with shapeless.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-06T06:39:42.926Z
There’s this: https://github.com/typelevel/shapeless-contrib/blob/master/scalaz/src/main/scala/typeclass.scala – but it doesn’t (yet) cover things like Functor & Traverse. But I think perhaps those are covered in wherever the Cats equivalent of this lives.

                                                                                                                                                      Rob Norris @tpolecat@2016-12-06T06:39:44.531Z
See https://github.com/milessabin/kittens … I think he got functor and foldable but not traverse yet.

                                                                                                                                                      Rob Norris @tpolecat@2016-12-06T06:41:00.339Z
I haven't played with it, just seen some examples.

                                                                                                                                                      Paul Phillips @paulp@2016-12-06T06:41:09.076Z
Mmm. We're a ways from using cats anyway.

                                                                                                                                                      Rob Norris @tpolecat@2016-12-06T06:41:39.227Z
I don't know that it's *that* specific to cats. Functor is functor more or less.

                                                                                                                                                      Paul Phillips @paulp@2016-12-06T06:44:58.380Z
Without looking I just kind of assume a library called "kittens" is likely to make certain assumptions

                                                                                                                                                      Greg Pfeil @sellout@2016-12-06T06:46:34.881Z
Yeah, the same stuff could be added to shapeless-contrib … that just stopped getting updated at _some_ point.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-06T15:46:48.064Z
Wondering how “helpful” Matryoshka should be. For example, it’s often nice to write things with a shape like `F[T[G] => G[T[G]]` (which I call transformations) rather than `F[T[G]] => T[G]` (which is a fold). Converting a transformation to a fold is easy: `_ >>> (_.embed)`.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-06T15:48:57.311Z
Now, should I let users write `_.cata(transform >>> (_.embed))`, which adds no weight to Matryoshka, provide (a small number of) functions that do the conversion like `_.cata(transformToAlgebra(transform))`, provide (a larger number of) transformations in addition to folds like `_.transCata(transform)`, or what?

                                                                                                                                                      Greg Pfeil @sellout@2016-12-06T15:50:35.983Z
Before 0.14, I took the last route because there were types that could do `transCata` that couldn’t do `cata`, but that’s no longer the case. But that also means the definition of `transCata` is simpler now (can be defined in terms of `cata`, as above).

                                                                                                                                                      Greg Pfeil @sellout@2016-12-06T15:51:11.510Z
I was leaning toward the first, because it’s shorter to write `>>> (_.embed)` than `transformToAlgebra` anyway ;)

                                                                                                                                                      Greg Pfeil @sellout@2016-12-06T15:51:43.029Z
And, IIRC, when I tried `transformToAlgebra` (and its ilk), I needed more type annotations.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-06T15:55:42.504Z
Actually, the last one (keeping pre-0.14 `transCata`) may not be generally possible until #44 is fixed, but it could still work for Fix/Mu/Nu in the mean time, I think.

                                                                                                                                                      Valentin Kasas @vil1@2016-12-08T09:28:30.624Z
Hello there. So I've made some (slight) progress since last time, elaborating on the example in the README. I have a Algebra and CoAlgebra allowing me to translate my (recursive) schema representation to `org.apache.spark.sql.types.DataType` back and forth. 
The next step is to find an easy way to embed a `F[F[F[X]]]` in, say a `Fix[F]`. Is there a method for that somewhere ? (the solution used in `someExpr` in the README is not acceptable for my use case)

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-08T09:38:54.389Z
What's your X? Essentially the Fix[F] is F[F[F[F[F[F[...]]]]]]. That's not something you can get directly from a F[F[F[X]]].

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-08T09:39:31.032Z
Perhaps what you'd like is to unfold the X into a Fix[F] so you have an F[F[F[Fix[F]]]], then embed the F's so you have a Fix[F]?

                                                                                                                                                      Valentin Kasas @vil1@2016-12-08T09:57:07.858Z
Well to make my question more clear, using the example in the README, I have a `Mul(Num(21), Num(2))` and I want a `Fix[Expr]` (so that I can `.cata(eval)` on it

                                                                                                                                                      Valentin Kasas @vil1@2016-12-08T09:57:36.138Z
I've tried to go the unfold way, but failed so far

                                                                                                                                                      Valentin Kasas @vil1@2016-12-08T10:42:10.661Z
First, I cannot write a `Coalgebra[Fix, Expr]` (since `Expr` takes a type parameter)

                                                                                                                                                      Greg Pfeil @sellout@2016-12-08T15:31:40.977Z
@vil1 I don’t see an example like that in the README (although I wouldn’t be surprised if there were). I’ve been meaning to write up a page about how/when to avoid writing `.embed` everywhere.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-08T15:32:43.041Z
(Mostly it shows up in tests, when you’re writing significant expectations, so there are a few tricks that I’m happy using in test code that I wouldn’t want in “main”.)

                                                                                                                                                      Valentin Kasas @vil1@2016-12-08T15:36:34.133Z
Sorry, I'm not really clear. I meant : using the `Expr` ADT defined in the readme, I'd like to be able to do what I described (embedding a whole, arbitrary, graph of `Expr` into a `Fix[Expr]` without having to write `.embed` on each node)

                                                                                                                                                      Greg Pfeil @sellout@2016-12-08T15:38:24.517Z
Yeah, so the problem with doing that “directly” is that the type changes at every iteration, right? Because if the type is actually infinite, then you have the problem that Fix … fixes. And if it’s _not_ infinite, then you have `Expr[Expr[Expr[Unit]]]` then `Expr[Expr[Unit]]`, etc.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-08T15:38:34.519Z
So, in Scala, maybe you could do something like …

                                                                                                                                                      Greg Pfeil @sellout@2016-12-08T15:41:37.909Z
```scala
def recurse: CoalgebraM[SomeErr \/ ?, Expr, Any] = {
  case e: Expr[Any] => e.right
  case _            => SomeErr("not an expr”).left
}
```

                                                                                                                                                      Greg Pfeil @sellout@2016-12-08T15:42:13.178Z
I wonder if that would work.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-08T15:57:18.296Z
The way we tend to do it (when we want to use it in production code is like on https://github.com/slamdata/matryoshka/wiki/Best%5B%E2%80%A0%5D-Practices – in the “FooR.scala” section. That example is broken the same way as the one you fixed in the README ;)

                                                                                                                                                      Greg Pfeil @sellout@2016-12-08T15:57:30.280Z
Definitely need to get around to tutting everything.

                                                                                                                                                      Rob Norris @tpolecat@2016-12-08T16:01:52.488Z
Let me know if you need help with that. I can set you up with an empty sbt-microsite if that would help.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-08T16:02:37.025Z
I don’t even know what that means, so … _maybe_?

                                                                                                                                                      Valentin Kasas @vil1@2016-12-08T16:03:22.225Z
I was intending to do that this week-end or the next one, but @tpolecat sur have more experience than I do in these kind of things

                                                                                                                                                      Rob Norris @tpolecat@2016-12-08T16:04:56.550Z
On my phone now but I'll set it up later and you can take a look. 

                                                                                                                                                      Valentin Kasas @vil1@2016-12-08T16:35:50.501Z
@sellout I'll take a look, thx

                                                                                                                                                      Greg Pfeil @sellout@2016-12-08T16:38:36.202Z
@vil1 I just fixed the Wiki page too, so it’s no longer broken.

                                                                                                                                                      Valentin Kasas @vil1@2016-12-08T16:45:37.032Z
Oh god, got it

                                                                                                                                                      Valentin Kasas @vil1@2016-12-08T16:46:05.826Z
I can use the said `FooR` like a "builder" 

                                                                                                                                                      Valentin Kasas @vil1@2016-12-08T16:58:13.315Z
This feels like magic

                                                                                                                                                      Greg Pfeil @sellout@2016-12-08T22:52:41.852Z
@tpolecat Thanks for getting the ball rolling!

                                                                                                                                                      Rob Norris @tpolecat@2016-12-08T22:55:06.542Z
happy to help

                                                                                                                                                      Greg Pfeil @sellout@2016-12-09T05:28:15.301Z
I’m going to issue some bounties – $1k for each type annotation you can remove from the unit tests.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-09T05:28:24.291Z
Might need to get spousal approval first …

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-09T05:29:20.142Z
I'll work full-time on removing type annotations :D

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-09T05:29:32.550Z
(no promises that I won't add any ;))

                                                                                                                                                      Greg Pfeil @sellout@2016-12-09T05:30:28.441Z
You get paid by `prevAnnotations - currentAnnotations`. You add any, you owe me ;)

                                                                                                                                                      Greg Pfeil @sellout@2016-12-09T17:17:55.828Z
@tpolecat BTW, I’m hoping to get in one other PR before merging yours – because then I can merge yours and immediately merge some actual docs afterward.

                                                                                                                                                      Rob Norris @tpolecat@2016-12-09T17:18:20.860Z
Cool, no worries at all.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-09T17:18:58.992Z
@sellout does the machine-checked docs dance 💃🏽

                                                                                                                                                      Greg Pfeil @sellout@2016-12-09T22:23:12.373Z
Loving `publishLocal`, but thinking I wouldn’t have to use it so much if I didn’t rely on Quasar as the Matryoshka test suite.

                                                                                                                                                      Valentin Kasas @vil1@2016-12-09T22:28:22.960Z
Hi. I reached a satisfying point (what I'm about to describe is probably completely trivial, but I like to share my joy when I understand new things). So I've defined a kind `*` `Schema` ADT for my users to instantiate. Using `cata` and an ad hoc `Coalgebra` I'm able to transform a `Schema`to a `SchemaF[A]` (which is a kind `* -> *` ADT that has the same modalities as `Schema` but with a type parameter replacing recursive references). Then I use a `SchemaR[A]` similar to the `FooR[A]` trick described in the wiki to embed `SchemaF` instances in a fixed-point type. So now, I'm an `Algebra` away from being able to translate my `Schema` into any other isomorphic representations like `org.apache.spark.sql.types.DataType` and so on. 

                                                                                                                                                      Greg Pfeil @sellout@2016-12-09T22:29:25.596Z
@vil1 🎉 sharing joy is very much encouraged :D

                                                                                                                                                      Valentin Kasas @vil1@2016-12-09T22:30:53.202Z
All this feels extremely cool. There is still some boilerplate going on, but it's mostly on the library part, so this is completely acceptable (and perhaps shapeless can help me getting rid of it)

                                                                                                                                                      Valentin Kasas @vil1@2016-12-09T22:32:20.985Z
@sellout about your `publishLocal` concerns, maybe you can steal some ideas from `scala/scala`'s build (especially the part with the pos/neg tests)

                                                                                                                                                      Valentin Kasas @vil1@2016-12-09T22:36:43.395Z
(sorry I was too verbose, in fact I do not really use the mentioned `SchemaR` thing anymore, at least for the moment)

                                                                                                                                                      Greg Pfeil @sellout@2016-12-09T22:39:38.983Z
@vil1 I don’t know that I’ve documented this anywhere, but if you have a directly-recursive Schema (as it sounds like you do), you can define your own `Recursive.Aux[Schema, SchemaF]` and `Corecursive` instances, then you never need to explicitly convert between the two – you can apply `cata`, etc. to your `Schema` values using `SchemaF` algebras.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-09T22:39:55.051Z
So it sounds like _maybe_ you can eliminate some more code?

                                                                                                                                                      Greg Pfeil @sellout@2016-12-09T22:41:07.982Z
It was on one of my last slides from Scala By The Bay (and perhaps also Moonconf), but I never got to show it.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-09T22:43:41.763Z
Some day `Birecursive` will work, and you’ll be able to just do
```scala
implicit val birecursive: Birecursive.Aux[Schema, SchemaF] =
  Birecursive.fromIso(iso: Iso[Schema, SchemaF[Schema]])
```

                                                                                                                                                      Greg Pfeil @sellout@2016-12-09T22:44:58.303Z
Actually, Birecursive will provide the Iso, you’ll just provide the two functions.

                                                                                                                                                      Valentin Kasas @vil1@2016-12-09T22:52:29.874Z
I'm not sure we're on the same page there

                                                                                                                                                      Valentin Kasas @vil1@2016-12-09T22:52:47.899Z
here's what I have https://gist.github.com/vil1/d48d612eba0900935b102d0e4fe0159a

                                                                                                                                                      Valentin Kasas @vil1@2016-12-09T22:55:38.110Z
what feels boilerplate-y is the apparent duplication  between `Schema` and `SchemaF`. But these are mirror of each other, one in the user world and the other one in the recursive world

                                                                                                                                                      Valentin Kasas @vil1@2016-12-09T22:56:06.317Z
ow well, I think I get what you said

                                                                                                                                                      Valentin Kasas @vil1@2016-12-09T22:56:27.283Z
I may be able to remove the `schemaToSchemaF` part, right ?

                                                                                                                                                      Greg Pfeil @sellout@2016-12-09T22:58:31.834Z
Yeah, I just commented – let me know if it makes any sense.

                                                                                                                                                      Valentin Kasas @vil1@2016-12-09T22:59:47.140Z
ok, my mind has just blown, did you hear it ?

                                                                                                                                                      Valentin Kasas @vil1@2016-12-09T23:00:27.736Z
yeah that makes perfect sense

                                                                                                                                                      Greg Pfeil @sellout@2016-12-09T23:00:45.618Z
And you define the reverse function – basically `Algebra[SchemaF, Schema]` to get a Corecursive instance.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-09T23:01:01.588Z
And those two functions form an isomorphism, yada yada.

                                                                                                                                                      Valentin Kasas @vil1@2016-12-09T23:02:39.182Z
I really need to learn some theory, but that opens so much opportunities 

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-11T06:09:05.315Z
@sellout I added `cata` and `cataM` for `Free` to cats in a PR. I was not able to use `tailRecM`. I came up with a less sexy solution, which forces trampolining in all uses. The question is whether we'd like to do something similar in matryoshka or make trampolining optional, and then the question is how to propagate that option.

                                                                                                                                                      Rob Norris @tpolecat@2016-12-11T06:22:24.636Z
Hm how would I go about conjuring the comonad instance for fix of envT? Also equal

                                                                                                                                                      Rob Norris @tpolecat@2016-12-11T06:23:33.979Z
Eh actually I don't need the comonad. But equal would be nice.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-11T06:26:41.410Z
@tpolecat So … I think I broke the Equal at some point. I’m about to submit a PR that fixes it, but what’s missing is basically
```scala
  implicit def equalTEqual[T[_[_]], F[_]: Functor]
    (implicit T: EqualT[T], F: Delay[Equal, F])
      : Equal[T[F]] =
    T.equalT[F](F)
```

                                                                                                                                                      Rob Norris @tpolecat@2016-12-11T06:34:47.070Z
Ok I can work around it for now.

                                                                                                                                                      Mark de Jong @Fristi@2016-12-12T21:31:10.782Z
Could matryoshka work with the GADT's encoding of Scala? Any tried or has examples?

                                                                                                                                                      Mark de Jong @Fristi@2016-12-12T21:41:40.411Z
Use-case: I have a GADT describing scala data types (product and coproducts) which can be used to construct JSON encoder/decoders, validators and documentation. Basically you reify the GADT structure into something you want. Generating the documentation is a bit hairy, at some points in building up my tree I combine certain data together to get new data. Which involves introducing some types in my documentation ADT I don't want.  As I am brand new to matryoshka, I wonder.. could this lib help ;)? And maybe it opens some more possibilities

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-12T21:46:52.570Z
@Fristi I dunno what you mean. GADTs are just case classes that fix type params of traits they inherit from. Make your GADT *recursive* and you should be able to matryoshka all over it

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-12T21:47:37.341Z
Everyone's made one of those at this point. If we could standardize on an awesome matryoshka-ified JSON impl that'd be just greeeeeeat

                                                                                                                                                      Rob Norris @tpolecat@2016-12-12T21:48:51.993Z
I know, I have been tempted to offer `JsonF` as an alternative to the Platform proposal but thankfully I'm too lazy.

                                                                                                                                                      Mark de Jong @Fristi@2016-12-12T21:56:56.128Z
@edmundnoble I am using a different encoding of GADT's I think. Guess you use a encoding like this: https://github.com/typelevel/cats/blob/master/free/src/main/scala/cats/free/FreeInvariantMonoidal.scala.

I am doing the finally tagless stuff like here: https://gist.github.com/pchiusano/10678834

Does it clear up things, or am I still vague ;) ?

                                                                                                                                                      Mark de Jong @Fristi@2016-12-12T21:58:29.316Z
JSON is great, but you could also use it to create binary codecs and schema data as data evolves over time and this could be useful. Even with JSON

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-12T21:58:31.184Z
Ah yeah, I am not sure

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-12T21:58:33.247Z
I'm using finally tagless as well but I think you need higher kinded recursion to make it work out.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-12T21:59:25.282Z
Actually you might be fine, just recurse over the A.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-12T21:59:28.926Z
There’s a PR for higher-kinded recursion in Matryoshka … hopefully I’ll get to it soon.

                                                                                                                                                      Mark de Jong @Fristi@2016-12-12T22:00:36.523Z
With only one type param it's oke ;P Thing is `Cartesian`, `CoCartesian` and `Invariant` use 2

                                                                                                                                                      Greg Pfeil @sellout@2016-12-12T22:01:39.373Z
Also, Quasar has its own Matryoshka-fied Json: https://github.com/quasar-analytics/quasar/blob/master/ejson/src/main/scala/quasar/ejson/EJson.scala ;)

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-12T22:02:41.872Z
Tuples?

                                                                                                                                                      Mark de Jong @Fristi@2016-12-12T22:02:42.583Z
@sellout Looking forward to it, till then I'll start with some simple basics of matroyshka then ;p

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-12-12T22:09:11.796Z
What is the `Delay[Equal, A]` pattern analogous to in Cats?

                                                                                                                                                      Paul Phillips @paulp@2016-12-12T22:19:04.339Z
I think ejson would be a very hard sell outside of quasar because the coproduct complicates it a lot and doesn't buy you anything if you're not trying to abstract over json extensions. 

                                                                                                                                                      Greg Pfeil @sellout@2016-12-12T22:28:10.471Z
@dispalt I don’t think there is one. It’s just `Equal[A] => Equal[F[A]]`, so it lets you defer type class resolution, with is necessary with the recursive types (otherwise you’d end up trying to infinitely resolve type class instances). Shapeless(?) has `Lazy[Equal[F[A]]]`, which does sort of the same thing, but requires a lot more machinery. In Haskell you sometimes see `EqualF`, which is yet another way. I’m not sure what is the best way to defer type class resolution, but I am all ears :D 

                                                                                                                                                      Greg Pfeil @sellout@2016-12-13T05:38:20.464Z
Ok, 0.16.1 is out (@tpolecat – this fixes `Equal`)

                                                                                                                                                      Rob Norris @tpolecat@2016-12-13T05:39:31.398Z
![](https://media0.giphy.com/media/JwjBy94VzDd6/200w.gif#0)

                                                                                                                                                      Rob Norris @tpolecat@2016-12-13T07:13:58.339Z
@sellout it appears that 0.15.1 is the latest on central … 

                                                                                                                                                      Greg Pfeil @sellout@2016-12-13T16:06:31.871Z
What is that? Is that different than Sonatype?

                                                                                                                                                      Greg Pfeil @sellout@2016-12-13T16:06:40.686Z
@tpolecat 

                                                                                                                                                      Rob Norris @tpolecat@2016-12-13T16:11:01.675Z
Sonatype, yes 

                                                                                                                                                      Rob Norris @tpolecat@2016-12-13T16:11:19.855Z
Maven central. Same thing as far as I can tell. 

                                                                                                                                                      Greg Pfeil @sellout@2016-12-13T16:28:37.448Z
This shows 16.1: https://oss.sonatype.org/#nexus-search;quick~matryoshka, and I made sure I could depend on 16.1 from Quasar before I posted that message.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-13T16:28:43.869Z
But … how does publishLocal work?

                                                                                                                                                      Greg Pfeil @sellout@2016-12-13T16:29:34.290Z
Because I was using that with Matryoshka/Quasar before, so is it possible that last night I actually picked up a locally-published 16.1? I thought I had to explicitly run `publishLocal` again to update it.

                                                                                                                                                      Rob Norris @tpolecat@2016-12-13T16:35:37.655Z
I'll try again. It wasn't resolving last night. On my phone but I'll check back in a bit. 

                                                                                                                                                      Rob Norris @tpolecat@2016-12-13T16:36:59.558Z
Yeah it comes up on search now. 

                                                                                                                                                      Greg Pfeil @sellout@2016-12-13T16:50:17.745Z
[your giphy back at you]

                                                                                                                                                      Greg Pfeil @sellout@2016-12-13T16:50:51.035Z
Also, I should have your PR merged today as well. Then … Doc City 💃🏽

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-12-13T16:58:11.112Z
Maven central is just a cache so sometimes it won’t show up til you try to download it

                                                                                                                                                      Miles Sabin @milessabin@2016-12-13T19:28:15.249Z
@sellout in a future version of scalac it'll be possible to replace `Lazy[T]` with `=> T` :-)

                                                                                                                                                      Greg Pfeil @sellout@2016-12-13T19:32:45.240Z
@milessabin How future?

                                                                                                                                                      Miles Sabin @milessabin@2016-12-13T19:33:08.759Z
Single digit months.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-13T19:33:18.732Z
That’s my favorite number of digits!

                                                                                                                                                      Rob Norris @tpolecat@2016-12-13T19:44:21.103Z
!

                                                                                                                                                      Valentin Kasas @vil1@2016-12-13T20:48:25.199Z
Hi again. 
Pursuing my schema-translation-thingy with matryoshka, I face an interesting challenge : using my "generic" `SchemaF[A]`, I want to produce (cata) a `avro.Schema`, which AFAIK is only possible using a java-based, side-effecting API. 
Should I go for an `AlgebraM` with `State` as the monad, or is there a simpler solution ?

                                                                                                                                                      Greg Pfeil @sellout@2016-12-13T20:54:46.345Z
Would `State` help? I think you want “the Java monad” – `OptionT[Task, ?]` ;)

                                                                                                                                                      Valentin Kasas @vil1@2016-12-13T20:59:04.377Z
well, I don't see why I need asynchrony there TBH

                                                                                                                                                      Valentin Kasas @vil1@2016-12-13T21:00:22.391Z
but maybe State is not the solution either

                                                                                                                                                      Greg Pfeil @sellout@2016-12-13T21:00:50.240Z
@vil1 Task keeps unmanaged side-effects out of your program.

                                                                                                                                                      Valentin Kasas @vil1@2016-12-13T21:05:36.556Z
ok but, the choice of the monad set aside, is an `AlgebraM` the way to go ?

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-13T21:54:50.985Z
@vil1 It's how I would do it.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-13T21:55:09.288Z
The Java monad, interesting :D

                                                                                                                                                      Paul Phillips @paulp@2016-12-13T22:09:10.878Z
@sellout speaking of the complication that is ejson, I want to cry for how hard it is to print it. What do I need to do to see it rendered in a way I can read it? And what is missing such that this piece doesn't work?
```scala
scala> implicitly[Show[ejson.Common[Data]]]
res5: scalaz.Show[quasar.ejson.Common[quasar.physical.fallback.fs.Data]] = scalaz.Show$$anon$4@1249bdbe

scala> implicitly[Show[ejson.Extension[Data]]]
res6: scalaz.Show[quasar.ejson.Extension[quasar.physical.fallback.fs.Data]] = scalaz.Show$$anon$4@345d1008

scala> implicitly[Show[ejson.EJson[Data]]]
<console>:51: error: could not find implicit value for parameter e: scalaz.Show[quasar.ejson.EJson[quasar.physical.fallback.fs.Data]]
        implicitly[Show[ejson.EJson[Data]]]
                  ^
```

                                                                                                                                                      Paul Phillips @paulp@2016-12-13T22:22:33.734Z
(That's a great example of what I might call "the coproduct tax")

                                                                                                                                                      Valentin Kasas @vil1@2016-12-13T22:31:48.316Z
@sellout, @edmundnoble  or maybe should I use some `Free` stuff to abstract that crappy java thing. God I still have so much things to learn. Be right back in a year or two

                                                                                                                                                      Greg Pfeil @sellout@2016-12-13T22:36:43.269Z
@paulp You _probably_ just need to `import quasar.fp._`

                                                                                                                                                      Valentin Kasas @vil1@2016-12-13T22:43:45.493Z
@sellout : having pondered about your "java monad" for 90+ minutes, I think I'll be remembering it as "computation that might fail but would eventually yield a value, which may be `null` though" 

                                                                                                                                                      Valentin Kasas @vil1@2016-12-13T22:44:16.137Z
(I agree, "java monad" sums it up quite well)

                                                                                                                                                      Paul Phillips @paulp@2016-12-13T22:45:27.029Z
@sellout yep, just discovered that myself

                                                                                                                                                      Paul Phillips @paulp@2016-12-13T22:45:57.528Z
what do you think is a plausible "best practice" way to discover that? I found it by "strategic grepping"

                                                                                                                                                      Rob Norris @tpolecat@2016-12-13T22:52:22.734Z
"How was I supposed to know that?" is an under-appreciated followup question.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-12-13T22:55:57.753Z
Omg totally agree.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-13T23:39:52.709Z
@paulp Yeah, I dunno – basically, we have to redefine a bunch of Scalaz instances so that they work with recursive types – Equal, Show, etc. We should probably do that in matryoshka-scalaz and make them available with all the other instances.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-13T23:40:44.282Z
Even if they stayed in Quasar, they probably belong in `quasar.contrib.scalaz`, not `quasar.fp` (but those two things were synonymous in early days).

                                                                                                                                                      Greg Pfeil @sellout@2016-12-13T23:48:56.476Z
@paulp In the current version, maybe we can add all these Scalaz instances to the `Delay` companion.

                                                                                                                                                      Paul Phillips @paulp@2016-12-14T01:34:36.641Z
@sellout I don't suppose we can mechanically derive all the Delay instances with an implicit macro or something...

                                                                                                                                                      Greg Pfeil @sellout@2016-12-14T03:13:18.186Z
@paulp I imagine with the Shapeless deriving stuff, we could probably get a bunch of the instances … it’s been on my list to dig into forever. I was hoping someone else would have added most of the (non-Delay) cases to shapeless-contrib by now ;)

                                                                                                                                                      Greg Pfeil @sellout@2016-12-14T05:01:50.107Z
So, there is a `Birecursive.Aux[Free[F, A], EnvT[A, F, ?]]` instance, but I’m thinking there can be a lower-priority `Corecursive.Aux[Free[F, A], F]` instance (which is like the pre-0.14 behavior of `Free`). Anyone have any thoughts on this?

                                                                                                                                                      Greg Pfeil @sellout@2016-12-14T05:03:26.762Z
With Cofree, there could be two lower-priority ones `Birecursive.Aux[Cofree[F, A], F]` when `A: Semigroup` and `Recursive[Cofree[F, A], F]` even lower priority.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-14T09:27:06.729Z
@sellout I think it's nice to have the less constrained instances. But all of the operations from them can be implemented using the other instances by ignoring values in a product or always ignoring a value from a `Reader`, except (I believe) the `Cofree` instance with `Semigroup`.

Depends how easy we'd like to make things.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-14T15:12:51.023Z
Yeah, that’s right. The case we run into in Quasar is we have stuff like
```scala
object Expr {
  final class fixpoint[T](implicit T: Corecursive.Aux[T, Expr]) {
    def var(x: String) = Var[T](x).embed
  }
}
```
which provides smart constructors. And we sometimes use those with `Free[Expr, A]`, so what I’ve done for now is to replace the implicit with an explicit `(embed: Expr[T] => T)` parameter and pass `Free.roll` when we want to use `Free`. It’s not a big hassle, but it seems reasonable to be able to use the old approach.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-15T23:00:09.878Z
Using mutual recursion in anger … and it turns out there’s a lot more machinery that has to be “lifted” to higher-order functors.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-15T23:02:22.284Z
PolyKinds and multiple implicit lists are looking better every minute. And there’s no way I would have gotten this far were it not for polymorphic lambdas in kind-projector.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-15T23:02:30.920Z
@sellout What do you think of a macro which generates smart constructors for each Corecursive?

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-15T23:02:44.223Z
Multiple implicit lists are great, where did you get something out of PolyKinds?

                                                                                                                                                      Greg Pfeil @sellout@2016-12-15T23:03:14.399Z
@edmundnoble Well, I haven’t yet – but I want Recursive + HRecursive to be the same type class, etc.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-15T23:03:58.760Z
Ah I see. Great.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-15T23:08:04.464Z
@edmundnoble You mean something that auto-creates the `FooR` class? Yes, that’d be great. There’s definitely a ton of stuff that could be auto-genned.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-15T23:09:21.247Z
Hmmm I smell matryoshka-generic ;)

                                                                                                                                                      Greg Pfeil @sellout@2016-12-16T19:41:31.185Z
Quick, someone get me PolyKinds before I implement `BitraverseKK`.

                                                                                                                                                      Miles Sabin @milessabin@2016-12-16T20:25:06.637Z
Still aiming for "before Xmas".

                                                                                                                                                      Rob Norris @tpolecat@2016-12-17T07:53:23.767Z
Hm, I want to go from `Nu[FooF]` to `Nu[BarF]` bottom-up … what should I be looking at?

                                                                                                                                                      Rob Norris @tpolecat@2016-12-17T07:54:06.130Z
Er `Fix` actually but it shouldn't matter.

                                                                                                                                                      Rob Norris @tpolecat@2016-12-17T07:55:47.418Z
Oh is it just  `cata` with `Algebra[FooF, Nu[BarF]]`? I guess that works.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-17T11:29:23.242Z
@tpolecat You could also use `transCata[Nu[BarF]]` and write your algebra like `FooF[Nu[BarF]] => BarF[Nu[BarF]]`, which is often slightly more convenient.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-20T19:26:16.855Z
https://github.com/slamdata/purescript-matryoshka

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-20T19:46:10.863Z
Mmmmm

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-20T19:46:18.526Z
:+1:

                                                                                                                                                      Rob Norris @tpolecat@2016-12-21T00:35:48.439Z
Say I have two ASTs that are mutually recursive. Is `Birecursive` what will allow me to do the pattern functor thing?

                                                                                                                                                      Rob Norris @tpolecat@2016-12-21T00:58:55.563Z
Oh, clearly not. Something else then?

                                                                                                                                                      Greg Pfeil @sellout@2016-12-21T01:38:34.632Z
@tpolecat You want my PR – #28. I have a bunch of changes that I should push to it, and then try to get it reviewed – it works, but it’s pretty spartan compared to the non-mutually-recursive stuff so far.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-21T01:39:04.505Z
Locally I have at least a few more folds and stuff added – things I needed for Quasar.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-21T01:41:51.202Z
Is there a paper on it? I'd love to learn more. The symbols are making my eyes glaze over ;)

                                                                                                                                                      Greg Pfeil @sellout@2016-12-21T01:45:25.007Z
Hrmm … I dunno. There’s probably something. I cobbled it together from compdata in Haskell, and from reading stuff about multi-sorted ABTs, etc. After staring for a while, you start seeing that everything that was `* -> *` is now `(* -> *) -> (* -> *)`, and the rest falls out of that (which, I know, vastly underestimates the amount of understanding required). But that plus two years ought to do it ;)

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-21T01:50:55.554Z
Damn, I need to look into ABTs now :). Hopefully polykinds helps clean it up and perhaps even gives it more power. compdata also looks interesting.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-21T01:52:46.470Z
@edmundnoble I think PFPL has a good intro to ABTs. I was introduced to them via working with Jon Sterling, who’s now studying under Bob Harper. ABT’s are on my Matryoshka todo list.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-21T01:55:56.374Z
Ahhh thank you. I found Jon's paper through some googling as well. More generic constructs for programming language development is always great :D

                                                                                                                                                      Rob Norris @tpolecat@2016-12-21T02:43:42.221Z
I'm going to conclude that I shouldn't attempt this quite yet.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-21T02:45:40.661Z
@tpolecat Well, I’d be happy to sit down with you and talk through it if you want to – but I understand if you don’t want to invest the time yet. I’m definitely still fleshing it all out.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-21T02:47:36.747Z
Conceptually, it adds an additional type parameter, so you use GADTs to restrict which parts of your coproduct are allowed at each node. But that means duplicating tons of abstractions over `F[_[_], _]` rather than `F[_]`, which isn’t yet there enough to make using it a simple task.

                                                                                                                                                      Tristan Lohman @gatorcse@2016-12-21T03:35:51.327Z
I’m looking through the source trying to familiarize myself with what matryoshka has to offer. I’m still pretty new to a bunch of the ‘hard’ FP stuff, so I’m trying to figure how this library relates to cats, fs2, and the like. In fixedpoint/package.scala, I see instances for Free (also in cats) and Stream (also in fs2). Where do you see this library fitting in with, or competing with, some of these libraries?

                                                                                                                                                      Greg Pfeil @sellout@2016-12-21T03:52:02.766Z
@gatorcse I see it fitting in with … the `matryoshka.instances.fixedpoint` package is mostly just for illustration as to how you could represent the same ideas in a fixed-point way (although Matryoshka’s Stream is different from fs2’s). I don’t want to necessarily advocate for that implementation (at least not until I can do some benchmarking, which I don’t expect will come out in my favor). Recent changes have made it fit in much better – you can see the {Co}Recursive instances for things like `List` in `matryoshka.data`, which weren’t really possible before v0.12 or so.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-21T04:08:30.362Z
That might read better if you imagine “fitting in with” in quotes.

                                                                                                                                                      Tristan Lohman @gatorcse@2016-12-21T04:43:57.399Z
So I shouldn’t read to much into `Mu`/`Nu` possibly representing streams of data?

                                                                                                                                                      Tristan Lohman @gatorcse@2016-12-21T04:44:37.315Z
Just asking because I’m enjoying working with fs2, but their streams can be a little slow sometimes, and I’m exploring to see if there’s anything faster

                                                                                                                                                      Tristan Lohman @gatorcse@2016-12-21T04:45:15.775Z
although I guess it doesn’t matter until @tpolecat writes `doobie-matryoshka`...

                                                                                                                                                      Rob Norris @tpolecat@2016-12-21T04:47:36.708Z
The devils (and there are many) are in the details with effectful streaming and fa2 is the best approach I know. 

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-21T04:47:45.902Z
@gatorcse `Mu` and `Nu` are not effectful streams

                                                                                                                                                      Rob Norris @tpolecat@2016-12-21T04:48:08.777Z
This is starting to get kind of spooky. 

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-21T04:48:16.413Z
You may be able to shove a pattern functor which is a monad transformer in, but I don't think it'd quite work.

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-12-21T04:48:25.837Z
Michael Pilquist is also really smart

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-21T04:49:08.965Z
What do you mean, everybody who writes Scala is smart ;)

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-21T04:49:31.679Z
Oh yes as in fs2, yeah it's not quite trying to solve the same problems.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-21T04:49:49.544Z
Nu and Mu are for fusion, essentially you can separate producers and consumers of recursive data at the type-level

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-21T04:50:23.562Z
That is my extremely limited understanding of them anyway

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-12-21T04:50:36.040Z
It’s my generic answer for any reason I like a library

                                                                                                                                                      Dan Di Spaltro @dispalt@2016-12-21T04:51:00.703Z
<library author name> is also really <smart or something similar>

                                                                                                                                                      Tristan Lohman @gatorcse@2016-12-21T05:01:28.593Z
ah, that makes sense, thanks!

                                                                                                                                                      Tristan Lohman @gatorcse@2016-12-21T05:02:02.235Z
and yes, fs2 Streams are pretty sweet!

                                                                                                                                                      Mark de Jong @Fristi@2016-12-21T11:49:00.206Z
I think `doc.transAna[Fix[Schema]](ana).transCata[Fix[Schema]](cata)` is a hylomorphism right? Can you write that as such, couldn't figure out the type signature ;P

                                                                                                                                                      Mark de Jong @Fristi@2016-12-21T11:49:17.253Z
should be something like `transHylo` right?

                                                                                                                                                      Greg Pfeil @sellout@2016-12-21T14:59:50.945Z
@Fristi I think `transHylo` exists in the `Recursive` type class, no?

                                                                                                                                                      Greg Pfeil @sellout@2016-12-21T15:00:02.751Z
(and yes, you should be able to)

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-21T15:00:22.773Z
@sellout @Fristi it's in FunctorT

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-21T15:00:35.796Z
Same place as the rest of the `trans*` family

                                                                                                                                                      Greg Pfeil @sellout@2016-12-21T15:00:44.757Z
@edmundnoble There is no more FunctorT ;)

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-21T15:01:26.675Z
:'( I am clearly in the past.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-21T15:02:18.756Z
That's what happens when I stop contributing to matryoshka for too long ;)

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-21T15:02:26.121Z
(speaking of which @sellout the shims PR is in)

                                                                                                                                                      Greg Pfeil @sellout@2016-12-21T15:02:52.922Z
@edmundnoble I saw 💯

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-21T15:18:56.780Z
:D and 2.12.1 support, woop

                                                                                                                                                      Mark de Jong @Fristi@2016-12-21T15:20:53.450Z
On fire :fire: 

                                                                                                                                                      Pawel Szulc @rabbitonweb@2016-12-22T09:00:29.967Z
hi, so regarding `RecursiveT` - I need it to be `Serializable`, any objections?

                                                                                                                                                      Pawel Szulc @rabbitonweb@2016-12-22T09:00:44.427Z
I will make PR for you guys to comment

                                                                                                                                                      Pawel Szulc @rabbitonweb@2016-12-22T09:14:22.972Z
https://github.com/slamdata/matryoshka/pull/55

                                                                                                                                                      Greg Pfeil @sellout@2016-12-22T18:32:35.994Z
@tpolecat So, returning to a conversation that started in tpolecat/tut … I don’t understand why certain instances aren’t found. Like I have  an instance `Recursive.Aux[Foo, FooF]`, which is actually `Recursive[Foo] { type Base[A] = FooF[A] }` So, then how come later an implicit for `Recursive[Foo]` can’t be resolved?

                                                                                                                                                      Greg Pfeil @sellout@2016-12-22T18:38:12.921Z
Oh, I think I understand. And I think multiple implicit lists may fix it?

                                                                                                                                                      Greg Pfeil @sellout@2016-12-22T18:44:06.179Z
Nope, I’m lost again.

                                                                                                                                                      Valentin Kasas @vil1@2016-12-23T13:57:20.784Z
HI there. Given I have a `F[_]: Functor`, a `Recursive.Aux[A, F]` and a `Corecursive.Aux[B, F]`, is there a way to convert a `A` to a `B` ?

                                                                                                                                                      Greg Pfeil @sellout@2016-12-23T13:58:15.865Z
@vil1 `a.convertTo[B]` should do it.

                                                                                                                                                      Valentin Kasas @vil1@2016-12-23T14:20:14.163Z
indeed, thx !

                                                                                                                                                      Greg Pfeil @sellout@2016-12-23T14:20:39.625Z
👍🏾 Had my fingers crossed 😄

                                                                                                                                                      Valentin Kasas @vil1@2016-12-23T14:27:33.242Z
I realize it is equivalent to having an `Algebra[F, B]` and using a `cata`  

                                                                                                                                                      Greg Pfeil @sellout@2016-12-23T14:27:55.781Z
Yep – and that algebra is simply `_.embed`

                                                                                                                                                      Valentin Kasas @vil1@2016-12-23T14:29:00.928Z
what a time to be alive

                                                                                                                                                      Rob Norris @tpolecat@2016-12-29T18:04:47.494Z
@sellout I'm playing around with typechecking and need a fold I can't quite figure out. I need to pass an Env down and yield an annotated tree or a type error. Something like `F[T] => A => (A, F[T]) => (A, M[G[T]]) => M[G[T]]` where `M` is `Error \/ ?`. I think.

                                                                                                                                                      Rob Norris @tpolecat@2016-12-29T18:07:22.346Z
`transSomething`, looks like.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T18:08:25.980Z
Ok, so what’s the type of the overall fold? `T => A => Error \/ U` (where `T.Base = F` and `U.Base = G`)?

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T18:10:13.130Z
It looks _kind of_ like `transElgotZygoM`, which would have an algebra like `(A, F[U]) => Error \/ G[U]`

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T18:10:47.558Z
Where the `A` is generated from a helper algebra like `F[A] => A`

                                                                                                                                                      Rob Norris @tpolecat@2016-12-29T18:13:27.933Z
The overall thing I want to do is `Cofree[Ast, Stuff] => TyEnv => Error \/ Cofree[Ast, (Stuff, Type)]` and the env I pass down to the next level might need a new binding, which I determine by looking at the current node, kind of like what you can do with attributeTopDown.

                                                                                                                                                      Rob Norris @tpolecat@2016-12-29T18:16:13.721Z
Not urgent, I'm experimenting with a talk idea.

                                                                                                                                                      Rob Norris @tpolecat@2016-12-29T18:19:07.025Z
(Instead of a generating a new `TyEnv` I may error out.)

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T18:21:09.043Z
Ok, so maybe `ana` with
```scala
(TyEnv, Cofree[Ast, Stuff]) => Error \/ EnvT[(Stuff, Type), Ast, (TyEnv, Cofree[Ast, Stuff])]
```
 … which is
```scala
CoalgebraM[
  Error \/ ?,
  EnvT[(Stuff, Type), Ast, ?],
  (TyEnv, Cofree[Ast, Stuff])]
```

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T18:21:19.856Z
Good thing I made that so readable.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T18:21:59.344Z
I give up.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-29T18:22:34.358Z
:clap: `transCataM` with Reader composed with Either?

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T18:24:08.681Z
@tpolecat You might pass a different TyEnv down to each branch, right?

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T18:24:23.160Z
@edmundnoble That’ll go bottom-up, though.

                                                                                                                                                      Rob Norris @tpolecat@2016-12-29T18:31:40.757Z
Well, duh. Stuff needs to bubble back up so I think maybe annotateTopDown and then transCata will do what I want. Ignore me, I'll mess around and then maybe you can tell me how to make it better.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T18:32:16.705Z
👍🏾 We’ll figure out _something_ that fuses ;)

                                                                                                                                                      Rob Norris @tpolecat@2016-12-29T18:32:22.442Z
right on

                                                                                                                                                      Rob Norris @tpolecat@2016-12-29T20:20:12.661Z
Hm Fix of EnvT of List doesn't have a Recursive instance. Is this right?

                                                                                                                                                      Rob Norris @tpolecat@2016-12-29T20:20:45.083Z
I could have sworn I did cata on Fix of EnvT before.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T20:21:12.888Z
Well, there’s a Recursive instance for any Fix.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T20:21:37.600Z
Probably missing an import? `import matryoshka._, data.Fix, implicits._`

                                                                                                                                                      Rob Norris @tpolecat@2016-12-29T20:24:41.472Z
Doh, sorry. 2712. I wasn't using scalatl

                                                                                                                                                      Rob Norris @tpolecat@2016-12-29T20:24:48.214Z
Works.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T20:25:26.721Z
👍🏾 I have happily forgotten about 2712. I _think_ it’s mentioned in the README? Should definitely be in the upcoming docs.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T20:25:55.518Z
Could also add that as a scala-clippy hint.

                                                                                                                                                      Rob Norris @tpolecat@2016-12-29T20:27:48.707Z
[redacted]

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T20:28:27.091Z
😂

                                                                                                                                                      Rob Norris @tpolecat@2016-12-29T20:28:35.705Z
That was mean, sorry.

                                                                                                                                                      Valentin Kasas @vil1@2016-12-29T20:31:16.690Z
Hi again !
Thanks  to you (especially @sellout) I made some valuable progress, I have a generic representation of a schema that I am able to translate to spark and avro flavours.
 Now I have to do something like : `F[A] => M[G[B]]`. 
To be more precise, I have my `SchemaF[A]` that I want to translate to a `Rule[I, Data]` where `Rule` is from `jto.validation` and `Data` a custom type (for which I have a pattern functor `DataF` FWIW). 
Since `Rule[I, ?]` has a monad instance, I think what I seek is around metamorphism/generalized in the cheatsheet provided in the README, but I'm not that confident.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T20:36:01.746Z
That sounds like some transform – either `transCataM` or `transAnaM` (bottom-up or top-down, respectively). I _hope_ you don’t need a metamorphism, because Matryoshka doesn’t have one yet (although I’d like to get around to it – it’s a neat one).

                                                                                                                                                      Valentin Kasas @vil1@2016-12-29T20:39:52.733Z
So, for what I understand from the cheatsheet, I need something that can destruct my SchemaF to its basic components and then build up Rule[I, DataF] from that, which I read like a cata-then-ana (and therefore metamorphism), but since I feel like Jon Snow north the Wall (I know nothing), I may be wrong

                                                                                                                                                      Valentin Kasas @vil1@2016-12-29T20:42:56.360Z
The thing is, I  need to create Rule[I, ?] bottom up

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T20:43:10.499Z
So, you’re overall doing `Fix[SchemaF] => Rule[I, Fix[DataF]]`, right? (although I think you actually have directly recursive `Schema` and `Data` data types). On of the nice things about the new representations, is that it doesn’t matter which of those types you have – they behave the same. So, you don’t need to destruct your Schema as a separate step – it is automatically destructed as you go (and `Data` is automatically built up). So you only need to worry about the “what do I do with one node of SchemaF?” problem.

                                                                                                                                                      Valentin Kasas @vil1@2016-12-29T20:44:31.230Z
I'm not sure I understand everything you wrote (yet) but that feel about it, yes

                                                                                                                                                      Valentin Kasas @vil1@2016-12-29T20:45:34.829Z
to illustrate, I know how to do `IntType => Rule[I, IntValue]` 

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T20:45:59.837Z
So, yeah, I’m _guessing_ you want something like `SchemaF[Data] => Rule[I, DataF[Data]]` and pass that to `transCataM`

                                                                                                                                                      Valentin Kasas @vil1@2016-12-29T20:47:29.381Z
well, that should work 

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T20:47:37.749Z
Also, you can do it without the `trans` bit … `SchemaF[Data] => Rule[I, Data]` – the `trans` variation is semantically the same, just sometimes easier to write. But if you have a directly-recursive `Data`, it probably doesn’t buy you anything.

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T20:48:00.017Z
By “without the `trans` bit”, I mean use `cataM` rather than `transCataM`.

                                                                                                                                                      Valentin Kasas @vil1@2016-12-29T20:48:37.507Z
(I still have to work the X part of `AnyPattern[X]`, my brain focuses too much on the `AnyPattern` part)

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T20:50:23.216Z
Yeah – when you’re looking at `SchemaF[Data]`, the subtrees of that node have already been converted to `Data`. There are other morphisms that give you different additional data – e.g., you can have `SchemaF[(Schema, Data)]` that gives you both the converted and unconverted subtrees.

                                                                                                                                                      Valentin Kasas @vil1@2016-12-29T20:51:25.383Z
like histomorphisms ?

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T20:52:15.488Z
Well, that’s a paramorphism – a histo gets you even _more_ info, as you have the original tree plus the intermediate results at every step – `SchemaF[Cofree[SchemaF, Data]]`

                                                                                                                                                      Valentin Kasas @vil1@2016-12-29T20:54:10.722Z
well, I need an onsite teacher

                                                                                                                                                      Valentin Kasas @vil1@2016-12-29T20:54:11.294Z
anyway

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T20:54:26.481Z
heh, docs coming soon, I promise :D

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T20:54:34.232Z
And then scala-exercises!

                                                                                                                                                      Valentin Kasas @vil1@2016-12-29T20:54:46.457Z
let's try that transcataM stuff in the meantime

                                                                                                                                                      Valentin Kasas @vil1@2016-12-29T20:56:32.103Z
(that's the problem with me, as long as I get something that works for the problem at hand, I can bear not understanding *why* it works, wink @nuttycom ^^)

                                                                                                                                                      Valentin Kasas @vil1@2016-12-29T21:18:59.299Z
well, I may not have been precise enough

                                                                                                                                                      Valentin Kasas @vil1@2016-12-29T21:20:31.258Z
what I'm able to do is to build, say,  a `Rule[I, Array[X]]` from a `Rule[I, X]`

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T21:21:12.951Z
Ah, I _almost_ mentioned this, but then thought I had been confusing enough already ;)

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T21:22:37.429Z
So, just because `Rule` _has_ a monad, doesn’t mean you’re using it _as_ a monad. So it sounds like you want a simple `cata` with `SchemaF[Rule[I, Data]] => Rule[I, Data]`

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T21:23:20.733Z
So, your `A` is `Rule[I, Data]`.

                                                                                                                                                      Valentin Kasas @vil1@2016-12-29T21:23:42.990Z
hmm

                                                                                                                                                      Valentin Kasas @vil1@2016-12-29T21:23:53.652Z
(that's so much fun)

                                                                                                                                                      Valentin Kasas @vil1@2016-12-29T21:24:26.004Z
I need an `Algebra[SchemaF, Rule[I,Data]]`

                                                                                                                                                      Greg Pfeil @sellout@2016-12-29T21:24:31.202Z
Yup.

                                                                                                                                                      Valentin Kasas @vil1@2016-12-29T21:55:35.270Z
So that seems to work fine (compiles). But it makes me wonder how I can put other schemes to real-world use (all my seemingly complicated use-cases end up to be simple cata/ana-morphisms). But I may only be doing boring stuff

                                                                                                                                                      Valentin Kasas @vil1@2016-12-29T21:56:10.341Z
(at last am I enjoying it ^^)

                                                                                                                                                      Greg Pfeil @sellout@2016-12-30T13:50:08.473Z
@vil1 Heh, whenever I have to use a different scheme, I wonder “can I get this down to a `cata`?” ;) But I think the “compositional” schemes are the most useful – zygo, hylo, etc.

                                                                                                                                                      Rob Norris @tpolecat@2016-12-30T16:09:34.826Z
Turns out all I needed was cata btw. 

                                                                                                                                                      Greg Pfeil @sellout@2016-12-30T16:11:26.708Z
@sellout just starts deleting the other morphisms from Matryoshka.

                                                                                                                                                      Valentin Kasas @vil1@2016-12-30T16:13:15.412Z
So I'm nearly reaching my goal for that pet project (thanks to your advice). What's kind of fun is that I end up with mostly repetitive, boilerplate-y code (but with way less lines than in the original, recursion-by-hand code)

                                                                                                                                                      Rob Norris @tpolecat@2016-12-30T16:33:46.339Z
@sellout the key was to cata into function types … this lets you define top-down state passing from the bottom up. 

                                                                                                                                                      Greg Pfeil @sellout@2016-12-30T16:36:51.155Z
So, like with @vil1’s case, where it _looks_ like you have a `cataM` with `State`, but really the `State` is part of the `A`?

                                                                                                                                                      Greg Pfeil @sellout@2016-12-30T16:37:15.780Z
Actually, I guess looks like `Reader` in your case.

                                                                                                                                                      Rob Norris @tpolecat@2016-12-30T16:45:40.369Z
Yeah. It smelled like cataM with Kleisli but I have to observe the env so it ended up as normal cata into a function type. I'll decruft and make a gist once I have had more coffee. 

                                                                                                                                                      Greg Pfeil @sellout@2016-12-30T16:48:06.194Z
Yeah, I think I actually have the same problem with a function I’ve been trying to turn into an algebra. I’ll have to try that approach. Although, when @paulp saw me write an algebra that folded to a function, he gave me the 😱

                                                                                                                                                      Rob Norris @tpolecat@2016-12-30T16:53:35.788Z
:+1: 

                                                                                                                                                      Greg Pfeil @sellout@2016-12-30T17:58:07.683Z
@tpolecat Yep – just converted a troublesome function to `Algebra[F, A => B]`, and boom. It works. Thanks.

                                                                                                                                                      Rob Norris @tpolecat@2016-12-30T17:58:46.848Z
rock on

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-30T18:14:13.353Z
Damn, I've been doing that a lot lately as well but I gave up on fitting it into an algebra. Double stack-unsafe :O

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-30T18:14:36.543Z
Setter recursion, I've been calling it

                                                                                                                                                      Greg Pfeil @sellout@2016-12-30T18:15:11.730Z
:tim gunn: Make it work, people.

                                                                                                                                                      Edmund Noble @edmundnoble@2016-12-30T18:16:14.749Z
Yet another emoji missing from Unicode ;)

                                                                                                                                                      Mark de Jong @Fristi@2016-12-30T19:13:04.038Z
@vil1 Curious what you've coded, I am doing something similar.. deriving schema's, codecs, validators, etc from ADT's

                                                                                                                                                      Mark de Jong @Fristi@2016-12-30T19:15:13.050Z
For the schema part I need to rewrite some parts of my tree of data, that's where matryoshka comes in atm

                                                                                                                                                      Valentin Kasas @vil1@2016-12-31T11:07:43.610Z
@Fristi I have an external schema describing incoming data (flat files on HDFS or messages in kafka topics) and some additional metadata for each field (e.g. privacy levels) 
I use this schema to validate the data, process it (e.g. encrypt the private fields) and convert it to more useful formats (parquet, avro,  etc)

                                                                                                                                                      Valentin Kasas @vil1@2016-12-31T11:09:33.520Z
The schema is known only at runtime, and I've in fact many different sources (each with its specific schema) that I need to process with this generic mechanism

                                                                                                                                                      Mark de Jong @Fristi@2017-01-01T12:35:31.915Z
@vil1 Cool stuff! Sounds abit different from what I am doing, but also some overlap. I am nowhere near anything worth showing off, playing around with it and looking for small projects where I can learn from :-)

                                                                                                                                                      Paul Phillips @paulp@2017-01-01T20:13:56.273Z
@sellout in principle, shouldn't we work in type and expression languages which don't allow recursion at all, then exploit those non-recursive-by-construction pieces at a higher layer which exists only to articulate recursive structure? Is there some obstacle or undesirable property to it? 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-02T21:16:15.249Z
@paulp Like Morte? Or perhaps a language which compiles to Morte? I would definitely be interested in segregating recursive code.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-02T21:16:42.911Z
Excluding fixpoints from one part of your language and not allowing primitive recursion should be sufficient.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-02T21:17:43.854Z
Ah yeah, I meant to respond to this … I’ve made a couple steps toward a language (working name: Fix) that compiles to Morte, specifically to play with this idea.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-02T21:18:59.327Z
:D

                                                                                                                                                      Greg Pfeil @sellout@2017-01-02T21:19:40.922Z
You don’t even need to exclude fixpoints – you can implement Mu and Nu (but not Fix) just fine in such a language.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-02T21:20:19.323Z
But, that _doesn’t_ give you all generalized recursion schemes (I don’t think).

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-02T21:20:40.554Z
Because of mutual recursion?

                                                                                                                                                      Greg Pfeil @sellout@2017-01-02T21:20:41.622Z
Anyway, yeah, I would love to be able to spend more time on that.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-02T21:21:07.388Z
Oh, I hadn’t even thought about mutual recursion in it yet :D

                                                                                                                                                      Rob Norris @tpolecat@2017-01-02T21:21:19.472Z
Neato. I was obsessed with morte for an hour or two but got distracted as usual. 

                                                                                                                                                      Greg Pfeil @sellout@2017-01-02T21:22:27.442Z
It’s actually my second “recursion”-free language (the first is a process-calculus language, though, so it’s really replication-free, not recursion-free).

                                                                                                                                                      Miles Sabin @milessabin@2017-01-02T21:23:45.483Z
https://twitter.com/pigworker/status/814439099889254401

                                                                                                                                                      Greg Pfeil @sellout@2017-01-02T21:25:22.820Z
@milessabin https://github.com/slamdata/matryoshka/pull/28 – so close to mergeable. I’ve been using publishLocal to use it to convert stuff in Quasar, which really helps me see which pieces are needed to make it useful.

                                                                                                                                                      Miles Sabin @milessabin@2017-01-02T21:26:22.074Z
:clap:

                                                                                                                                                      Valentin Kasas @vil1@2017-01-03T09:17:21.842Z
What kind of trick should I use to grab some information from an upper node during a cata ? (I already know how to grab info from lower nodes using histo) 

                                                                                                                                                      Valentin Kasas @vil1@2017-01-03T09:19:26.379Z
I know it's not the way cata works, my understanding is that during a cata, the algebra is applied to the (recursive) result of its application to lower nodes

                                                                                                                                                      Valentin Kasas @vil1@2017-01-03T09:20:27.863Z
so my intuition is that my problem is a case of refold (maybe dyna) but the type signatures look not convincing (yet)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-03T18:08:54.240Z
@vil1 you'd like to grab info from the results you've already processed?

                                                                                                                                                      Valentin Kasas @vil1@2017-01-03T18:54:22.212Z
@edmundnoble not exactly (that is, not in the sense of histo, as far as I understand it). Basically, what I need is to know when processing (destructing) a node is the path to this node from the root of the whole structure

                                                                                                                                                      Valentin Kasas @vil1@2017-01-04T11:27:32.069Z
So finally, I obtained the desired result with a simple cata, as usual 😀

                                                                                                                                                      Greg Pfeil @sellout@2017-01-04T16:02:44.091Z
@vil1 heh, I promise you'll eventually get to use a different fold ;)

                                                                                                                                                      Valentin Kasas @vil1@2017-01-04T16:21:56.857Z
I'll keep on trying

                                                                                                                                                      Valentin Kasas @vil1@2017-01-04T16:25:03.600Z
But I'm considering getting a tatoo saying "in the end, it's always a cata"

                                                                                                                                                      Rob Norris @tpolecat@2017-01-04T23:46:41.738Z
@sellout [playing around with extractors](https://gist.github.com/tpolecat/ea87ce95f9b19143e98bdf447f07bb1a) for writing algebras ... not convinced yet but might be worth it.

                                                                                                                                                      Rob Norris @tpolecat@2017-01-04T23:47:26.704Z
I know haskell has pattern synonyms. Same kind of idea? I haven't used them.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-04T23:56:35.322Z
Yeah – now just gotta find a way to make it not break exhaustiveness checking ;)

                                                                                                                                                      Rob Norris @tpolecat@2017-01-04T23:59:11.583Z
@tpolecat puts a bucket over his head

                                                                                                                                                      Mark de Jong @Fristi@2017-01-05T13:16:18.387Z
While learning recursion-schemes I've found the blog posts of https://jtobin.io quite useful sofar

                                                                                                                                                      Greg Pfeil @sellout@2017-01-06T15:30:57.790Z
@Fristi Thanks for the PR!

                                                                                                                                                      Greg Pfeil @sellout@2017-01-06T15:38:02.051Z
Why does my computer only let me choose Celsius and Farenheit? I want Rankine, damn it!

                                                                                                                                                      Greg Pfeil @sellout@2017-01-06T15:38:48.608Z
Regardless, it was -9°F/-20°C this morning. Fun times getting the kids to walk to school 😆

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-06T15:44:23.844Z
Are you in Canada too? :D

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-06T15:44:26.157Z
Same over here

                                                                                                                                                      Greg Pfeil @sellout@2017-01-06T15:46:19.513Z
@edmundnoble Boulder, CO. Oh, Waterloo – awesome. Used to work with a bunch of Waterlooers back in my Amazon days. The most sought-after hires :)

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-06T15:56:18.785Z
@sellout personally, I **love** the Réaumur scale

                                                                                                                                                      Greg Pfeil @sellout@2017-01-06T15:57:26.943Z
@tscholak If 0 isn’t absolute, I don’t want it ;)

                                                                                                                                                      Greg Pfeil @sellout@2017-01-06T15:58:28.925Z
But, after that, I have very little opinion on how big 1° should be.

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-01-06T16:30:47.606Z
I used to live in Oregon but now 

                                                                                                                                                      Rob Norris @tpolecat@2017-01-06T16:58:11.512Z
Yeah we used to fight over the Waterloo people back in Austin. Really good rep. 

                                                                                                                                                      Mark de Jong @Fristi@2017-01-06T23:36:16.512Z
@sellout No problem! I'll look at the revision.md soon!

                                                                                                                                                      Greg Pfeil @sellout@2017-01-07T20:17:16.744Z
@Fristi You know, don’t worry about that revision file – I’m changing the way we handle it, so it should be unnecessary, and I’ll get it merged today.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-08T01:27:58.799Z
@sellout how is matryoshka-cats doing? shims looks to be updated

                                                                                                                                                      Greg Pfeil @sellout@2017-01-08T01:30:13.250Z
Heh – working on getting a $work release out in a week, so a bit bogged down. I have a branch with a lot of the requisite changes on it, but some stuff I was hoping to be able to do, I haven’t figured out yet.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-08T01:31:47.226Z
E.g. – rather than pushing `futu` into the -scalaz and -cats projects, I was hoping to generalize `Free` to `Recursive[T, CoEnv[A, F, ?]]`, so then it could be defined in -core, and work with any implementation of Free.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-08T03:20:30.557Z
Excellent, I have a few Free implementations that need to see the light of day ;)

                                                                                                                                                      Greg Pfeil @sellout@2017-01-08T03:23:23.383Z
Right? There’s three more in Matryoshka as well ;)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-08T03:25:04.440Z
Really? I can only find one.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-08T03:25:17.149Z
Oh one per fixpoint combinator :P

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-08T03:25:18.666Z
Oh u

                                                                                                                                                      Greg Pfeil @sellout@2017-01-08T03:25:24.894Z
Heh

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-08T03:25:40.233Z
I got one with reflection without remorse and one that also has map fusion over [here](https://github.com/edmundnoble/scabsbench/blob/master/core/shared/src/main/scala/scabs/free/FreeMonad.scala)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-08T03:25:58.395Z
(Mu sounds like it would also have map fusion though)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-08T03:26:43.943Z
And one church-encoded if all you care about is performance and not stack-safety (or allocations :P)

                                                                                                                                                      Mark de Jong @Fristi@2017-01-08T15:32:59.682Z
@sellout Aight great :-) thanks for the merge

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-10T05:30:24.884Z
Can someone help me gain some intuition (or point me to a blog post) on what EnvT is? In the docs it just says it is the `transformer for the (,) comonad`, but I don’t know what a comma comonad is either...

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-10T05:31:31.558Z
It's a writerT without the monoid requirement.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-10T05:31:42.646Z
The comma comonad is the reader comonad.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-10T05:32:29.437Z
Well, or the “environment” comonad – which is isomorphic to the reader monad.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-10T05:33:27.889Z
@gatorcse `(,)` is just meant to be `Tuple2` or whatever.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-10T05:33:31.582Z
It's making a function able to access an extra value, but by changing the input type rather than the output type.

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-10T05:34:41.143Z
Thanks team that helps!

                                                                                                                                                      Greg Pfeil @sellout@2017-01-10T05:37:11.292Z
Matryoshka uses it both as a comonad (in `gpara`), but also just for its structure as the pattern functor of Cofree.

                                                                                                                                                      Sumedh Mungee @smungee@2017-01-11T02:30:40.012Z
Is 0.16.3 published to maven yet?

                                                                                                                                                      Greg Pfeil @sellout@2017-01-11T03:19:51.719Z
@smungee Nope, sorry – I’ll get that out now.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-11T03:23:07.430Z
Oh right, sbt-microsites is broken with git worktree :/

                                                                                                                                                      Greg Pfeil @sellout@2017-01-11T03:23:19.352Z
Ok, I’ll get it out, it’ll just take a little longer.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-11T03:24:14.268Z
But I don’t think there’s much since the last published release – 0.16.1 – just a new entry in the README and a tut/microsite skeleton.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-11T03:24:45.221Z
So, nothing new in the published artifacts, I mean – not to diminish the contributions, which are _very_ appreciated.

                                                                                                                                                      Sumedh Mungee @smungee@2017-01-11T03:37:29.106Z
ok, great. I'll use 0.16.1 for now :)

                                                                                                                                                      Sumedh Mungee @smungee@2017-01-11T03:41:04.487Z
btw code that worked in 0.15.1 is throwing the following exceptions in 0.16.1. Has anyone seen this? 

                                                                                                                                                      Greg Pfeil @sellout@2017-01-11T03:42:59.140Z
@smungee There are definitely breaking changes between 0.15 and 0.16 – what are the exceptions?

                                                                                                                                                      Greg Pfeil @sellout@2017-01-11T03:43:11.499Z
Wait … throwing exceptions? Like, at runtime?

                                                                                                                                                      Sumedh Mungee @smungee@2017-01-11T03:45:07.492Z
sorry i meant, compilation errors:
```
matryoshka.Recursive.Ops[matryoshka.data.Fix[$file.ExprTest.Expr],$file.ExprTest.Expr]#transAna.type does not take parameters
val afterParsing = beforeParsing.transAna(parseExpression)
```


                                                                                                                                                      Greg Pfeil @sellout@2017-01-11T03:45:15.541Z
*phew*

                                                                                                                                                      Sumedh Mungee @smungee@2017-01-11T03:45:38.101Z
I had actually forgotten what runtime exceptions were :)

                                                                                                                                                      Greg Pfeil @sellout@2017-01-11T03:45:49.513Z
Yeah, me too for a second there :D

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-11T03:46:15.841Z
Hehehe that's what happens when you do enough FP ;)

                                                                                                                                                      Sumedh Mungee @smungee@2017-01-11T03:47:07.127Z
it makes you incapable of passing java phone screens :)

                                                                                                                                                      Greg Pfeil @sellout@2017-01-11T03:47:43.430Z
So, I think the thing there is that you need to tell `transAna` the result type – `transAna[Fix[Expr]]`, because where it used to transform within a fixed-point, possibly changing the functor, it’s now more general, and can generate any Corecursive type.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-11T03:48:25.176Z
There – this can be the first entry in Matryoshka’s clippy file :D

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-11T03:48:45.846Z
Mmmmmm. Nice.

                                                                                                                                                      Sumedh Mungee @smungee@2017-01-11T03:49:41.118Z
Awesome, that fixes it :)

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-11T16:13:29.242Z
What’s the current downloadable artifact, and is there a 2.12 build yet?

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-11T16:14:02.745Z
I see 2.11@16.1 in sonatype

                                                                                                                                                      Greg Pfeil @sellout@2017-01-11T16:22:13.173Z
@gatorcse Yeah, 0.16.1 is the latest. There’s no 2.12 yet, but I should have that out soon (been playing the depdendency matching game to get everything to work together).

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-11T16:23:12.017Z
Thanks, sounds like a fun game!

                                                                                                                                                      Sumedh Mungee @smungee@2017-01-12T20:05:33.733Z
Are there any examples that show something like `Fix[Option[Exp]]`? Like in the `Exp` example, if I had an `Option[A]` instead of an `A`:

 ```case class Mul[A](left: A, right: Option[A]) extends Exp[A]```

 Would that cause any issues? Does the helper look like this, then?

 ```def mul(left: Fix[Exp], right: Fix[Option[Exp]]) = Fix[Exp](Mul(left, right))```


                                                                                                                                                      Greg Pfeil @sellout@2017-01-12T20:07:46.339Z
@smungee That would be `Fix[Exp]`, with `Mul` having an `Option[Fix[Exp]]` parameter.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-12T20:07:55.769Z
A = Fix[Exp]

                                                                                                                                                      Sumedh Mungee @smungee@2017-01-12T20:11:25.582Z
Ah ok, will try that, thanks

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-17T20:15:02.626Z
Trying to learn about the different “container” types described in the README, and it talks about `F`, `M`, `N`, and `W`. There seems to be specific meaning attached to all of them that isn’t discussed in the README. I get what some of them are (`F`, is your fix-point type, `M` seems to be an (possibly effectful) result monad maybe (it only occurs on the right side of an arrow). Not sure about `W`, is that supposed to be some sort (possibly effectful) monad that the left side is wrapped up in? Seems like it’s a pretty important to understand them, as the various algebras are for different uses of those type arguments. Any help?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-17T20:16:02.689Z
It's a loosely held to convention but M is monads W is comonadic and F and G are both pattern functors.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-17T20:16:42.361Z
T is your fixpoint (like Fix or Mu or Nu) and F or G is the functor recursed on.

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-17T20:17:07.142Z
Sorry, by `G` above I mean `W`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-17T20:18:09.817Z
Ah yes well that makes sense because comonads typically appear on the left and monads on the right.

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-17T20:20:51.751Z
Thanks

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-17T20:21:33.408Z
Very welcome. I'm here for any other questions :)

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-17T20:22:45.425Z
Sorry for all my base level questions, I’m coming at this without the category-theory/haskell background that I think was the expected audience. It’s just the more I learn about this library and other “Free” stuff in the community, the more I see that there is a beautifully simply general eventsourcing library to be had there somewhere, and I’m trying to find it...

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-17T20:23:06.884Z
(hence my insistence on mixing the effectful stuff with this recursion scheme stuff)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-17T20:24:56.260Z
Event sourcing is just the update monad I thought? Free constructions are excellent to learn from and also provide a good CS focused intro to category theory.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-17T20:25:26.438Z
The update monad is basically when you emit updates to your state instead of emitting new state values directly, unfortunately there's not a huge amount of code 

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-17T21:29:16.632Z
That sounds interesting, have to look into that

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-17T21:30:57.562Z
If your updates are best expressed recursively then matryoshka will also likely be hugely helpful.

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-17T21:32:01.443Z
The idea I’m bouncing around is that with algebras/free/etc, your’re building up a data structure that represents your program, and then executing your algebra against it. Since you have a data structure, you can store that structure (your program) in a database. I want to be able to say “Load event stream from database as the stream of program steps to execute, and then just throw the algebra at it

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-17T21:33:50.445Z
Sure, I'm just wondering about the branching factor of your data structure.

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-17T21:33:52.967Z
I think they are recursive because I’m representing an append-only log, where each event happens on top of the last one. But I’m not entirely sure that I’m not trying to make a screw look like a nail so I can use my fancy hammer.

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-17T21:34:03.745Z
The structure should be strictly linear

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-17T21:34:16.344Z
Look like a single linked list

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-17T21:34:34.466Z
Have you taken a look at foldM?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-17T21:34:49.279Z
That folds a monad through a list. Might be helpful.

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-17T21:37:12.810Z
do you mean foldMapM (Can’t find foldM)? Seems pretty good thanks!

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-17T21:38:08.725Z
It may be foldLeftM, dunno where it is.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-17T21:38:17.900Z
FoldMapM is similar.

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-17T21:39:45.312Z
Ah, those are in ScalaZ

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-17T21:41:04.150Z
Yeppers, not in matryoshka, sorry for the ambiguity

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-17T21:42:40.937Z
no worries

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-17T22:27:47.620Z
Well if anyone in the SF bay area wants to help me hack on this, I’ll be at the meetup tonight

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-17T22:33:29.624Z
there's a matryoshka meetup in the SF bay area?

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-17T22:33:48.309Z
that's awesome

                                                                                                                                                      Greg Pfeil @sellout@2017-01-17T22:33:48.511Z
🤣

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-17T22:33:50.184Z
a general scala un-meetup

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-17T22:34:08.621Z
ah :D

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-17T22:34:13.937Z
which basically means intead of talks, we break off and do side projects, experiments, mini presentations, etc

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-17T22:34:47.296Z
Shameless plug (my office is hosting it): https://www.meetup.com/SF-Scala/events/236808083/

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-17T22:34:48.186Z
people from the haskell meetup in toronto are interested in matryoshka

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-17T22:35:04.911Z
woah big embedded cards...

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-17T22:38:41.445Z
Aw should've gone I was in town

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-17T22:39:02.232Z
which one?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-17T22:39:48.695Z
Toronna

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-17T22:39:54.044Z
the haskell meetup is tomorrow

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-17T22:40:13.763Z
Aw I left today :P

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-17T22:40:33.248Z
Some other time. Where was it?

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-17T22:40:38.234Z
bento miso

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-17T22:41:32.981Z
Oh wow cool. Any website?

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-17T22:41:45.762Z
https://bentomiso.com/events/haskell-meetup-2017-jan

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-17T22:41:57.147Z
Excellent. Thank you.

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-17T22:42:19.252Z
np

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-17T22:42:23.774Z
some other time mayhaps?

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-17T22:42:56.188Z
https://groups.google.com/forum/#!topic/toronto-haskell/ubAN0mM1RFQ

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-17T22:43:09.398Z
Oh hell yeah. I'd love to.

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-17T22:43:39.851Z
:+1:

                                                                                                                                                      Rob Norris @tpolecat@2017-01-19T17:51:15.737Z
Does matryoshka have a way to deal with mutually recursive types like users+groups? I can do it by inlining one into the other but that's kind of gross.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-19T17:53:31.030Z
https://github.com/slamdata/matryoshka/pull/28

                                                                                                                                                      Greg Pfeil @sellout@2017-01-19T17:53:48.317Z
I have a pile of unpushed changes to that branch.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-19T17:54:21.698Z
_Hopefully_ it’ll get merged next week, but trying to wrap up this release for $work first.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-19T17:54:45.106Z
But every time I think about it, everything spins toward PolyKinds ;)

                                                                                                                                                      Rob Norris @tpolecat@2017-01-19T18:03:33.112Z
:-)

                                                                                                                                                      Greg Pfeil @sellout@2017-01-19T18:34:48.159Z
Just had a discussion of PolyKinds, MonoidK, etc. at $work. And got to show @mandubian’s excellent “monad = endofunctor monoid” gist: https://gist.github.com/mandubian/dfd670f7740f47a1a2a7b662f828aac6#file-kp-monoid-scala-L52

                                                                                                                                                      Greg Pfeil @sellout@2017-01-19T18:35:30.006Z
(Although, @mandubian, you should really add `def join` to your Monad def, to show that it’s “just” mult, making the parallel to Monoid even clearer.)

                                                                                                                                                      Miles Sabin @milessabin@2017-01-19T19:23:30.328Z
@sellout what are your thoughts on the KP stuff now that you've had a chance to play with it? Is it enough to get useful work done?

                                                                                                                                                      Pascal Voitot @mandubian@2017-01-19T20:27:42.822Z
@sellout I haven't added that `join` because people in scala mostly use `flatMap`

                                                                                                                                                      Pascal Voitot @mandubian@2017-01-19T20:28:11.835Z
but I agree ;)

                                                                                                                                                      Pascal Voitot @mandubian@2017-01-19T20:30:02.535Z
yet I think this def is cool for education but a bit too abstract in practice certainly

                                                                                                                                                      Greg Pfeil @sellout@2017-01-19T20:45:39.983Z
@milessabin Yeah, I think between KP and interleaved implicits that Matryoshka code is going to change (be generalized and simplified) a ton.

                                                                                                                                                      Pascal Voitot @mandubian@2017-01-19T20:53:22.795Z
@sellout BTW, I had written a less generic but a bit more practical version of a KP monoid which would not be usable to represent monads https://gist.github.com/mandubian/083abf83798f35ed42a140755bd90a7f

                                                                                                                                                      Greg Pfeil @sellout@2017-01-19T22:46:01.327Z
@mandubian Why is that one more practical? To me, the `Monad extends Monoid` seems cleaner.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-19T22:51:26.988Z
Also, you can define `MonoidK[M[_]] extends Monoid[M, ~>, Prod[M, M, ?], Const[Unit, ?]]`, no?

                                                                                                                                                      Pascal Voitot @mandubian@2017-01-19T23:10:10.309Z
@sellout `⊗ <: AnyKind` doesn't represent the fact that it's an operation between 2 elements `M ⊗ M` and if you want to describe the category deriving from a Monoid, then it's blocking and I feel like this will be blocking in other cases

                                                                                                                                                      Greg Pfeil @sellout@2017-01-19T23:14:32.188Z
@mandubian Ah, I see … yeah, that’s the kind of thing I kept getting stuck on before, like I wanted to be able to say something like `⊗[M, M] <: AnyKind` … which is terrible syntax that you can hopefully decode.

                                                                                                                                                      Pascal Voitot @mandubian@2017-01-19T23:17:21.385Z
yep and you can't write it for now, clearly ;)

                                                                                                                                                      Pascal Voitot @mandubian@2017-01-19T23:17:57.070Z
it's not really deterministic actually

                                                                                                                                                      Greg Pfeil @sellout@2017-01-19T23:17:58.099Z
Yeah, but I am actually not too upset about the way you punted on it 😉

                                                                                                                                                      Pascal Voitot @mandubian@2017-01-19T23:18:36.149Z
if you have ideas that would seem good, don't hesitate to say

                                                                                                                                                      Pascal Voitot @mandubian@2017-01-19T23:18:41.214Z
this is a first version for KP

                                                                                                                                                      Greg Pfeil @sellout@2017-01-19T23:19:30.108Z
Oh, what you have now seems pretty great. I mean there are things I want to be able to do, like the above, but I have no idea how you would actually do it, and you’re already aware of them.

                                                                                                                                                      Pascal Voitot @mandubian@2017-01-19T23:21:30.704Z
if you see cases that seem inconsistent, don't hesitate to say... that's the most important, we need KP to be consistent in the features we allow

                                                                                                                                                      Alexander Konovalov @alexknvl@2017-01-20T03:10:26.928Z
Does anyone have (or could point to) an example of tying the knot with `matryoshka.data.Nu`?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-20T05:35:56.975Z
Tying the knot, @alexknvl? As in `def x = 1 #:: x`?

                                                                                                                                                      Alexander Konovalov @alexknvl@2017-01-20T05:43:22.039Z
Yes.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-20T05:43:55.716Z
There's a Cofree impl in matryoshka based on Nu.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-20T05:44:14.060Z
Cofree can give you lazy NELs.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-20T06:21:39.537Z
@alexknvl Something like
```scala
def repeat[A]: Coalgebra[(A, ?), A] = a => (a, a)
1.ana[Nu[(Int, ?)]](repeat)
```

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-20T07:10:51.442Z
But can you do Fibonacci? ;)

                                                                                                                                                      Greg Pfeil @sellout@2017-01-20T13:55:11.981Z
@edmundnoble I’m sure you’re kidding, but https://github.com/slamdata/matryoshka/blob/master/core/shared/src/main/scala/matryoshka/package.scala#L713, so `(0, 1).ana[Nu[(Int, ?)]](binarySequence(_ + _))`

                                                                                                                                                      Valentin Kasas @vil1@2017-01-20T14:39:34.007Z
Where can I learn about Mu and Nu, now that I've almost understood the point of Fix (almost no pun intended)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-20T18:41:18.402Z
@vil1 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-20T18:41:51.846Z
https://jyp.github.io/posts/controlled-fusion.html

                                                                                                                                                      Valentin Kasas @vil1@2017-01-20T18:44:50.099Z
Looks very promising. Thx a lot

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-20T18:45:33.405Z
Welcomes

                                                                                                                                                      Valentin Kasas @vil1@2017-01-20T18:49:16.547Z
I've no idea what it means to "polarize the type to deforest" but I'm not afraid 😁

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-20T18:50:37.694Z
On the Duality of Streams (same author) may help.

                                                                                                                                                      Valentin Kasas @vil1@2017-01-20T18:52:58.726Z
Ok

                                                                                                                                                      Greg Pfeil @sellout@2017-01-20T18:53:35.823Z
Also, feel free to add helpful refs to the README … which will be moved to tut docs, once I actually submit my PR that gives us actual tut docs.

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-20T23:22:13.726Z
Do I notice correctly that matryoshka no longer has its own implementation of `Free`, but instead just defers to the one in ScalaZ?

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-20T23:24:23.602Z
nm, found it

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-20T23:25:37.289Z
nm, no I didn’t...

                                                                                                                                                      Greg Pfeil @sellout@2017-01-20T23:47:47.017Z
@gatorcse It does have its own – in matryoshka.instances.fixedpoint, but it uses Scalaz’s elsewhere. That package is mostly meant for illustration at this point.

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-20T23:48:32.459Z
ah, there it is, thanks!

                                                                                                                                                      Tristan Lohman @gatorcse@2017-01-20T23:48:47.700Z
so I should probably use ScalaZ’s then?

                                                                                                                                                      Greg Pfeil @sellout@2017-01-20T23:49:03.606Z
I’d _like_ to generalize the Scalaz Free cases to `Birecursive.Aux[T, CoEnv[A, F, ?]]`, so it works with Cats’ Free, Matryoshka’s, etc. interchangably.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-20T23:49:10.953Z
@gatorcse Oh yeah, definitely.

                                                                                                                                                      Konstantin Läufer @klaeufer@2017-01-23T20:58:15.292Z
@sellout or others, I have a nice `fromInt: Coalgebra[Option, Int]` but can't figure out how to invoke `ana` on it. I tried `implicitly[Birecursive[Fix[Option]]].ana(7)(fromInt)` but it says `required: Int => _5.Base[Int] where val _5: matryoshka.Birecursive[matryoshka.data.Fix[Option]]`. Any help would be greatly appreciated.

                                                                                                                                                      Valentin Kasas @vil1@2017-01-23T21:17:07.316Z
maybe you can do something like `7.ana[Nu[Option]](fromInt)`, provided there's a `Functor[Option]` in scope

                                                                                                                                                      Konstantin Läufer @klaeufer@2017-01-23T21:49:21.675Z
Thanks, you're the man! That worked right away!
```
7.ana[Nat](fromInt)
res6: Nat = Fix(Some(Fix(Some(Fix(Some(Fix(Some(Fix(Some(Fix(Some(Fix(Some(Fix(None)))))))))))))))
```

                                                                                                                                                      Valentin Kasas @vil1@2017-01-23T21:51:01.553Z
Great  ! 

                                                                                                                                                      Greg Pfeil @sellout@2017-01-24T02:03:16.667Z
Ok, wow, this is connected to our work Slack, and some of the code showed up there like
```
7.ana<fromInt|Nat>
```

                                                                                                                                                      Greg Pfeil @sellout@2017-01-24T02:03:46.002Z
And I _thought_ I was fairly familiar with Scala by now …

                                                                                                                                                      Greg Pfeil @sellout@2017-01-24T02:05:31.038Z
@klaeufer Corecursive operations are available on any value, but you always have to explicitly supply the result type.

                                                                                                                                                      JerrySwan @JerrySwan@2017-01-26T10:34:39.192Z
Hi all. Newbie question. I know that there's already a matryoshka Nat type which is isomorphic to Option, but as an exercise, I've rolled my own NatF[A] (I can supply the definition but I guess it's obvious to most people), and am looking to express addition as a catamorphism. For generality, I've assumed that the type parameter forms a Monoid.

Q1. Is the following representative of the way these things should be done, or am I missing something?:
Q2. Can I get away with any fewer implicits (or less parametricity) than I am doing?
```
  def addViaCata[T](n: NatF[T], m: NatF[T])(
    implicit TR: Recursive.Aux[NatF[T], NatF],
    TC: Corecursive.Aux[T, NatF],    
    monoid: Monoid[T]): NatF[T] = {

    def algebra(m: NatF[T]): Algebra[NatF, NatF[T]] = { 
      case Z()  => m
      case S(x) => m match {
        case Z() => n
        case S(y) => S(S( x.embed |+| y ).embed )
      }
    }    
    n.cata { algebra(m) }
  }
```

                                                                                                                                                      Greg Pfeil @sellout@2017-01-26T13:00:45.351Z
A1. Yeah, pretty much. The one change is that all of your `NatF[T]` should be just `T`. `T` will eventually be specialized to something like `Fix[NatF]`.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-26T13:05:06.227Z
A2. You can get rid of `Monoid[T]`.  the `S(x)` case in `algebra` is doing too much work – `algebra` should look more like
```scala
case Z() => m
case s   => s.embed
```

                                                                                                                                                      Greg Pfeil @sellout@2017-01-26T13:05:29.774Z
@JerrySwan ↑

                                                                                                                                                      Greg Pfeil @sellout@2017-01-26T13:16:16.315Z
Let me know if anyone sees those messages I sent before this one – they _look_ like they sent, but my Gitter went weird for a bit there.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-26T13:29:07.653Z
@JerrySwan Using this, you can _define_ `Monoid[T]`, with `Z().embed` and `addViaCata`.

                                                                                                                                                      Valentin Kasas @vil1@2017-01-26T14:32:42.009Z
I don't understand the `case s => s.embed` part  (-_-)'

                                                                                                                                                      Greg Pfeil @sellout@2017-01-26T14:59:42.532Z
@vil1 I think it’s a bit confusing because you’re folding to the same type that you started with. But `cata` works from the leaves, right? So, adding `S(S(Z))` (which is really `Fix(S(Fix(S(Fix(Z)))))`) to … we’ll say `8` rather than writing it out, you first hit the `Z` case, and replace it with `8`. Then you hit the inner `S`, with `S(8)`, and you want to return `Fix(S(8))` (where `8` is _really_ `Fix(S(…))`), so `.embed` does that. Then you hit the outer `S` with `S(Fix(S(8)))`, so you just embed that.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-26T15:00:10.073Z
@vil1 Does that help? I’m not sure if making the one side _look like_ an int clarifies things.

                                                                                                                                                      Valentin Kasas @vil1@2017-01-26T15:52:09.824Z
One day, I'll remember that `cata` calls the algebra from the leaves up, one day

                                                                                                                                                      Valentin Kasas @vil1@2017-01-26T15:53:01.206Z
thanks, that makes perfect sense indeed

                                                                                                                                                      JerrySwan @JerrySwan@2017-01-26T16:45:48.162Z
@sellout - thanks a lot. For completeness, below is as far as I've now got, which leads to 2 more questions: 
1. I currently have the return type of fromInt as Nu[NatF]. Should I not prefer to have that as a NatF[Int]? 
2. The compiler is complaining about the lack of recursive/corecursive implicits. Where do I get these from?

```    
    sealed trait NatF[A]
    final case class Z[A]() extends NatF[A]
    final case class S[A](a: A) extends NatF[A]
    
    implicit val natFunctor = new scalaz.Functor[NatF] {
      override def map[A, B](fa: NatF[A])(f: (A) => B) = fa match {
        case Z()  => Z[B]()
        case S(a) => S(f(a))
      }
    }

    ///////////////////////////////
    
     def toInt[T](x: NatF[T])(implicit TR: Recursive.Aux[NatF[T], NatF]): Int =        
        x.cata[Int] { case Z()  => 0; case S(x) => 1 + x }
    
    def fromInt(x: Int)(
      implicit TC: Recursive.Aux[Int, NatF]): Nu[NatF] = {
      
      val coalgebra: Coalgebra[NatF,Int] = { 
        case 0    => Z()
        case s => S(s-1)
      }
      x.ana[Nu[NatF]] { coalgebra }
    }
    
    ///////////////////////////////

    def add[T](n: T, m: T)(
      implicit TR: Recursive.Aux[T, NatF],
        TC: Corecursive.Aux[T, NatF]): T = {

      def algebra(m: T): Algebra[NatF, T] = { 
        case Z()  => m
        case s  => s.embed       
      }    
      n.cata { algebra(m) }
    }  

    println( add( fromInt(1), fromInt(2) ) )
```
 

                                                                                                                                                      Greg Pfeil @sellout@2017-01-26T16:51:43.883Z
@JerrySwan 1. The return type of the coalgebra is `NatF[Int]`, but once it’s applied repeatedly by `ana`, the result of `fromInt` will be `Nu[NatF]`, as you have. 2. You need to import `matryoshka_` (for the type classes), `matryoshka.data._` (for the Fix/Mu/Nu instances), and `matryoshka.implicits._` (for the implicit conversions that inject `ana` etc. on arbitrary values).

                                                                                                                                                      JerrySwan @JerrySwan@2017-01-26T17:10:56.146Z
@sellout Thanks a lot - it also turns out that the implicit for ```fromInt``` was spurious. That now works (in the sense of printing out S(Nu)).  So, question now is  what do I need to do to make ```println( toInt( add( fromInt(1), fromInt(2) ) ) )``` work? Currently, I'm getting "type mismatch; found : matryoshka.data.Nu[NatF] required: NatF[?]". Sorry if this should be obvious: I'm hoping that once I see the process working end-to-end, I'll be able to generalize appropriately from there...

                                                                                                                                                      Greg Pfeil @sellout@2017-01-26T17:14:11.138Z
@JerrySwan Oh, yeah, I didn’t notice the implicit there – that implicit can’t exist … or, I guess maybe it could. You could define `Recursive[Int]` such that `project(t: Int) = t match { case 0 => Z(); case n => S(n - 1) }`, which is your `fromInt` (but notice that that function won’t terminate if you give it a negative Int)

                                                                                                                                                      Greg Pfeil @sellout@2017-01-26T17:15:27.278Z
@JerrySwan Your `NatF[T]`s in `toInt` should be just `T`

                                                                                                                                                      Valentin Kasas @vil1@2017-01-26T17:23:18.043Z
For what it's worth, I'd write `sealed trait NatF[+A]` and `case object Z extends NatF[Nothing]`, that would save some keystrokes elsewhere

                                                                                                                                                      Greg Pfeil @sellout@2017-01-26T17:27:19.318Z
Yeah … I’ve been meaning to try playing with variance in Matryoshka, but I usually end up running into a wall with it somewhere or other. One place we try to manage subtypes is https://github.com/slamdata/matryoshka/blob/master/core/shared/src/main/scala/matryoshka/implicits/package.scala#L28, but that won’t make `Z.embed` work, so I always need `Z[T]().embed` on leaf nodes. Definitely not ideal.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-26T17:28:34.873Z
We _should_ be able to make `Corecursive[T].embed(Z)` work, though, with something like `F[TT]` where `TT <~< T`.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-26T17:30:11.403Z
Actually, maybe even another version of `CorecursiveOps` that expects explicitly `F[Nothing]` and has the `def embed[T]` *shrug*

                                                                                                                                                      Greg Pfeil @sellout@2017-01-26T17:30:56.395Z
So, something I’d _like_ to try, but happy to get PRs to work better with those cases. SlamData doesn’t use subtyping, so we don’t generally see these cases in practice.

                                                                                                                                                      JerrySwan @JerrySwan@2017-01-26T17:43:39.544Z
@sellout @vil1 Thanks - now works and I'm starting to get a better feel for the required patterns...

                                                                                                                                                      JerrySwan @JerrySwan@2017-01-27T13:02:44.096Z
OK, stuck again ;-) Would anyone be kind enough to show how to express factorial as a para and/or hylo?

                                                                                                                                                      Valentin Kasas @vil1@2017-01-27T14:02:32.078Z
I can't. I've come to believe that "in the end it's always a cata", but YMMV

                                                                                                                                                      Greg Pfeil @sellout@2017-01-27T16:43:27.669Z
@JerrySwan Here it is as a `para`:
```scala
def factorial: GAlgebra[(Nat, ?), NatF, Nat] = {
  case Z()            => S(Z().embed).embed
  case S((prev, acc)) => (prev * acc) + acc
}
```
(defining `*` is left as an exercise for the reader 😄)

                                                                                                                                                      Greg Pfeil @sellout@2017-01-27T16:50:58.547Z
In English: `!0` is defined to be `1`, and the factorial of any other number, `n` is the previous factorial (`acc`) times `n` … so the latter case could be rewritten `S(prev).embed * acc`. And there _may_ be a way to write it using an elgot algebra rather than a generalized algebra, let me see …

                                                                                                                                                      Greg Pfeil @sellout@2017-01-27T16:53:15.759Z
Eh, it’s not immediately apparent to me.

                                                                                                                                                      Valentin Kasas @vil1@2017-01-27T16:55:33.879Z
Should I remember para as "recursion with an accumulator" ?

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-27T16:56:05.103Z
stupid question asked by someone who never did anything with `NatF` beyond tinkering: since factorial grows faster than any exponential, won't this break down more or less immediately?

                                                                                                                                                      Greg Pfeil @sellout@2017-01-27T16:56:17.748Z
Actually, the accumulator is really the `cata` part – the para is maintaining the original structure.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-27T16:56:28.154Z
@tscholak Oh, yes. Definitely.

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-27T16:56:56.217Z
ah ok, well then :D

                                                                                                                                                      Greg Pfeil @sellout@2017-01-27T16:57:10.686Z
the performance of `!Nat` is `!n` 😆

                                                                                                                                                      Valentin Kasas @vil1@2017-01-27T16:59:51.362Z
Maybe it's time for me to confess: I don't know how to read the cheat sheet (-_-)'

                                                                                                                                                      Greg Pfeil @sellout@2017-01-27T16:59:52.574Z
There are ways around that, though – Wadler (I think) has the concept of views, which is basically the mapping of an inductive structure onto a non-inductive one. E.g., Idris lets you use Nat, but compiles it to integers, so their performance scales (at least to the extent that you’ve mapped the operations – e.g., if you’ve mapped Nat `+` to Int `+`, but haven’t mapped `*`, then Nat `*` will be O(n), not O(1) … I think)

                                                                                                                                                      Greg Pfeil @sellout@2017-01-27T17:06:18.373Z
@vil1 I’m not surprised … but I would like it to be helpful. I was hoping the English on there was enough to assist, and the red highlights how each one differs from the basic cata / ana. And clearly there were things I didn’t know how to fit in 😆

                                                                                                                                                      Valentin Kasas @vil1@2017-01-27T17:08:49.974Z
Well, please take into account the fact that my brain still struggles to read haskell-ish type signatures (among other struggles) 

                                                                                                                                                      Valentin Kasas @vil1@2017-01-27T17:09:05.099Z
but lets take para as an example

                                                                                                                                                      Valentin Kasas @vil1@2017-01-27T17:13:06.380Z
I read `f (Fix f × a) → a` but I don't see the algebra in there

                                                                                                                                                      Greg Pfeil @sellout@2017-01-27T17:13:14.907Z
So, I think I can re-organize the cheat sheet a bit now, too. I haven’t really looked at it in a while.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-27T17:13:42.280Z
@vil1 If you ignore the characters in red, you’ll see `f a -> a` (or `F[A] => A` in Scala)

                                                                                                                                                      Valentin Kasas @vil1@2017-01-27T17:14:06.661Z
hmm, ok

                                                                                                                                                      Valentin Kasas @vil1@2017-01-27T17:14:36.027Z
so `f (Fix f × a) → a` is basically the algebra I need to pass to a para

                                                                                                                                                      Greg Pfeil @sellout@2017-01-27T17:16:17.816Z
Yeah, exactly.

                                                                                                                                                      Valentin Kasas @vil1@2017-01-27T17:17:09.307Z
Well, now it's obvious (I could have deduced that from the signature under cata)

                                                                                                                                                      Greg Pfeil @sellout@2017-01-27T17:17:26.414Z
the big “generalized” block shows the general form – which is `F[W[A]] => A`, where `W` is some `Comonad` (which is a cheeky pun on `M` being `Monad`).

                                                                                                                                                      Greg Pfeil @sellout@2017-01-27T17:18:34.051Z
For `cata` `W = Id`, for `para` `W = (Fix[F], ?)` (which is actually just a special case of `zygo` where `W = (B, ?)`).

                                                                                                                                                      Valentin Kasas @vil1@2017-01-27T17:18:44.398Z
(yep, "`W` is  co`M`" is rather clear)

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-27T17:19:43.660Z
`(Fix[F], ?)` is a comonad?

                                                                                                                                                      Valentin Kasas @vil1@2017-01-27T17:20:53.474Z
I think `(X, ?)` is a comonad for any `X` (you can always extract a `A` from a `(X, A)` for any `X`)

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-27T17:21:42.105Z
ah, thanks, now it's obvious

                                                                                                                                                      Valentin Kasas @vil1@2017-01-27T17:23:04.461Z
I guess `(?, X)` would be too, but kind-projector has limitations on the position of the `?` 

                                                                                                                                                      Greg Pfeil @sellout@2017-01-27T17:23:05.948Z
@tscholak Yeah, it’s called the “environment” comonad, isomorphic to the reader monad.

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-27T17:24:50.041Z
yeah, I remember now. I read runarorama's article on comonadic reader a while back

                                                                                                                                                      Valentin Kasas @vil1@2017-01-27T17:25:17.902Z
ok so it's quite clearer now : during a para, my algebra is called with a product of 1. the full structure below the current node & 2. the partial result of the application of the algebra to what's below the current node 

                                                                                                                                                      Greg Pfeil @sellout@2017-01-27T17:25:40.532Z
@vil1 Exactly :D

                                                                                                                                                      Greg Pfeil @sellout@2017-01-27T17:25:51.626Z
I think the cheat sheet may just need a bit of a legend attached.

                                                                                                                                                      Valentin Kasas @vil1@2017-01-27T17:26:07.835Z
Yep, that would help I think

                                                                                                                                                      Rob Norris @tpolecat@2017-01-27T18:51:06.148Z
ping https://www.reddit.com/r/scala/comments/5qiv1d/simple_real_world_matryoshka_example/

                                                                                                                                                      Greg Pfeil @sellout@2017-01-27T18:52:18.118Z
If there were just _one_ less word in that post, I’d link to Quasar 😆

                                                                                                                                                      Greg Pfeil @sellout@2017-01-27T18:56:38.392Z
@vil1 Well, I just made a pile of changes to the cheat sheet, but I’m not sure it helps. Maybe I should use layers, like those books with transparent pictures of the human body.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-27T18:57:17.227Z
First you just see cata / ana, then you see gcata + para, etc., then you see gpara, ghisto …

                                                                                                                                                      Valentin Kasas @vil1@2017-01-27T20:24:04.846Z
err, where can I see those changes ?

                                                                                                                                                      Greg Pfeil @sellout@2017-01-27T20:24:47.185Z
@vil1 Oh, sorry – just on my machine at the moment. I’ll publish it soon. A few more things to change, I think … like adding a legend :D

                                                                                                                                                      Valentin Kasas @vil1@2017-01-27T20:55:28.203Z
can't wait ^^

                                                                                                                                                      Valentin Kasas @vil1@2017-01-27T20:56:07.250Z
@tpolecat made my humble contribution https://www.reddit.com/r/scala/comments/5qiv1d/simple_real_world_matryoshka_example/dczrakd/

                                                                                                                                                      Greg Pfeil @sellout@2017-01-27T20:59:42.362Z
@vil1 Thanks 😃

                                                                                                                                                      Valentin Kasas @vil1@2017-01-27T21:11:34.234Z
(I subscribed to reddit only for that (yes I know it's 2017…))

                                                                                                                                                      JerrySwan @JerrySwan@2017-01-29T16:25:58.025Z
@sellout - thanks. Am I right in thinking that this requires the kind-projector compiler plugin?

                                                                                                                                                      Greg Pfeil @sellout@2017-01-29T16:36:30.975Z
@JerrySwan Yeah – it’s hard to write much FP code without it. I mean, you can, but it gets ugly fast.

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-29T16:54:13.349Z
hi, I've been teaching myself recursion schemes for the past few days.
I started by looking into recursion with `Fix[ListF[?, B]]` and some `Fix[ExprF]` with `ConstF` and `ProductF`.
I worked my way to a definition of a `fold` that works for both, i.e.
```scala
    def fold[B, C](l: Fix[ListF[?, B]])(zf: Algebra[ListF[?, B], C]): C =
      zf(map(l.unFix)(fold(_)(zf)))
```
and
```scala
    def fold[B](e: Fix[ExprF])(zf: Algebra[ExprF, B]): B =
      zf(map(e.unFix)(fold(_)(zf)))
```
Now I'm trying to repeat this exercise with `Free[ListF[?, B], A]` and `Free[ExprF, A]`.
However, this time, by following the types (and peeking into Matryoshka), I arrived at:
```scala
    def fold[A, B](e: Free[ExprF, A])(zf: Algebra[CoEnv[A, ExprF, ?], B]): B = {
      zf(map(CoEnv(e.resume.swap))(fold(_)(zf)))
    }
```
where
```scala
    def map[A, B, C](ef: CoEnv[A, ExprF, B])(f: B => C): CoEnv[A, ExprF, C] =
      CoEnv(ef.run.rightMap {
        case ConstF(v) => ConstF(v)
        case ProductF(l, r) => ProductF(f(l), f(r))
      })
```
What is the deeper reason for why I get `Algebra[CoEnv[A, ExprF, ?], B]` instead of `Algebra[ExprF, B]` here?
I understand that shaving off a layer of `Free` gives you *either* a value *or* another computation and that this has to be reflected in the types.
However, conceptually, I don't like that I seem to need different algebras for working with `Fix` and `Free`.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-29T17:18:44.808Z
@tscholak There are a few ways to deal with that –
1. while you can’t ignore the _either_ aspect when folding, I’ve considered adding a lower priority `Corecursive.Aux[Free[F, ?], F]` instance that _does_ allow you to ignore the extra structure when unfolding;
2. if you look for `matryoshka.interpret` (poorly named) and friends, you can use your regular `Algebra[ExprF, B]` and pair it with a function `A => B` to deal with the leaves of the Free; and
3. I swear there was a third thing, but I’ve forgotten what it was.

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-29T17:32:37.417Z
:D Thank you for your suggestions

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-29T17:39:04.581Z
another thing I have tried (but so far have not achieved) is to find and make explicit the connection between a (monadic) `Algebra` and a natural transformation `~>`

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-29T17:41:35.811Z
what I'm after in general is an understanding of the relationship between the interpreter pattern with `Free` and the recursion schemes found in Matryoshka

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-29T19:43:14.294Z
re: connection btw `Algebra` and `~>`:
```scala
    def mkInterpreter[B](zf: Algebra[ExprF, B])(implicit F: Functor[ExprF]) = new (ExprF ~> Const[B, ?]) {
      override def apply[A](ef: ExprF[A]): Const[B, A] = Const(zf(F.map(ef)(leafer)))

      def leafer[A](a: A): B = ???
    }
```
hmm, it seems I can't write a non-trivial `leafer`

                                                                                                                                                      Greg Pfeil @sellout@2017-01-29T19:48:37.136Z
@tscholak I _think_ that a Free interpreter is just a special case of `AlgebraM`. In Haskell you can write it like `forall a. AlgebraM m f a`, but unfortunately it’s not so direct in Scala. And not all `AlgebraM`s are `A`-agnostic, so mostly can’t be represented as natural transformations.

                                                                                                                                                      Torsten Scholak @tscholak@2017-01-29T19:54:56.482Z
I see. Thank you, that gives me something to think about

                                                                                                                                                      Olivier Mélois @Baccata@2017-01-29T20:59:30.262Z
Hi there, is Matryoshka published in any maven / ivy repository for scala 2.12 by any chance ?

                                                                                                                                                      Greg Pfeil @sellout@2017-01-29T21:10:56.571Z
@Baccata Ah, sorry – I always forget to publish. I'll get a 2.12 version out in an hour or so.

                                                                                                                                                      Olivier Mélois @Baccata@2017-01-29T21:13:10.869Z
@sellout :+1: cheers !

                                                                                                                                                      Greg Pfeil @sellout@2017-01-29T23:53:38.735Z
@Baccata ok, sorry, hopefully tonight, but having issues with publishing multiple versions and need to step away for a few hours.

                                                                                                                                                      Greg Pfeil @sellout@2017-01-30T02:55:41.295Z
@Baccata Ok – 0.16.5 is published for both 2.11 and 2.12

                                                                                                                                                      Olivier Mélois @Baccata@2017-01-30T12:09:26.725Z
@sellout thank you ! Apart from that, I have a question : I'm trying to model a recursive structure where recursive points can be parameterized. The goal would 
be for people to provide their custom algebras (such as KVStore below), and provide them with a common structure for composing them (think `Exp[A]`in matryoshka tests) 
```scala
sealed trait KVStore[F[_], A]
 case class Put[F[_]](key : F[String], value : F[String]) extends KVStore[F[_], String]
case class Get[F[_]](key : F[String] extends KVStore[F[_], Option[String]]
... 
```
I'm thinking that it must be possible to extract from such an ADT,  the coproduct `C` of all types involved in the operations, and by using a constant type, lift the values into `C` whilst retaining type-safety when composing operations. I instinctively believe that it's probably possible to provide a Functor for KVStore that acts on the `F[_]` type (through Const), and therefore allow the delegation of the recursion to a fixed-point (by saying F[_] == A)

So my question basically boils down to, would it be possible for a Fixed-Point type to carry a phantom type around ? 



                                                                                                                                                      Greg Pfeil @sellout@2017-01-30T18:23:56.016Z
@Baccata So, I don’t understand exactly what you’re trying to do, but it sounds roughly like mutual-recursion (but I’m probably wrong). If I’m _not_ wrong, look at https://github.com/slamdata/matryoshka/pull/28 for work about to get into Matryoshka – perhaps specifically https://github.com/sellout/matryoshka/blob/56c2ce8343d43c4513d890511c60fda4fbe79085/core/jvm/src/test/scala/matryoshka/mutu/Common.scala 

                                                                                                                                                      Olivier Mélois @Baccata@2017-01-30T19:03:46.404Z
@sellout, that's exactly what I want to do :smile: 

                                                                                                                                                      Olivier Mélois @Baccata@2017-01-30T19:09:05.471Z
ideally combined with shapeless to derive the HTraverse 

                                                                                                                                                      Olivier Mélois @Baccata@2017-01-30T19:16:19.040Z
(which would very likely be made possible if this issue was solved : https://github.com/milessabin/shapeless/issues/683) 

                                                                                                                                                      dwhitney @dwhitney@2017-01-30T19:17:09.871Z
@sellout did you see this? https://www.reddit.com/r/scala/comments/5qiv1d/simple_real_world_matryoshka_example/

                                                                                                                                                      Greg Pfeil @sellout@2017-01-30T19:41:14.502Z
@dwhitney Yeah, thanks. I could do a Matryoshka port of @tpolecat's talk if he's cool with it. Would be a good use of tut :smile: 

                                                                                                                                                      Paul Phillips @paulp@2017-01-30T19:41:35.189Z
You know a really compelling use case for recursion schemes would be type operations. So many scala compiler bugs are in the subtyping and equivalence logic - often tied up in when and how to handle recursive cases. All the recursion logic is ad hoc and embedded in variously named organically grown methods.

                                                                                                                                                      Rob Norris @tpolecat@2017-01-30T19:42:59.187Z
@sellout mi casa es tu casa

                                                                                                                                                      dwhitney @dwhitney@2017-01-30T19:47:25.176Z
w00t!

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-30T23:10:21.056Z
@paulp I'm going to look at making a scala compiler doing that once we have matryoshka-cats

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-30T23:10:41.210Z
Fusion then also becomes actually rigorous

                                                                                                                                                      Edmund Noble @edmundnoble@2017-01-30T23:11:29.430Z
Combined with tagless style it may be possible to add several tree types without forcing reallocation; for example, one pre-desugar, one post-, and one post-typer.

                                                                                                                                                      Paul Phillips @paulp@2017-01-30T23:23:26.964Z
@edmundnoble yes I had similar thoughts.

                                                                                                                                                      Greg Pfeil @sellout@2017-02-02T21:13:25.540Z
So … how much would it affect people if Matryoshka moved from Scalaz 7.2.8 to 7.3.0-M8?

                                                                                                                                                      Greg Pfeil @sellout@2017-02-02T21:14:38.160Z
Alternatives include building multiple artifacts and trying to get the change I need backported to the 7.2 line.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-02T21:14:55.056Z
Which change?

                                                                                                                                                      Greg Pfeil @sellout@2017-02-02T21:14:58.093Z
But bumping my dep is the easiest from my perspective.

                                                                                                                                                      Greg Pfeil @sellout@2017-02-02T21:15:36.232Z
@edmundnoble `Inject#unapply`. I actually only need it downstream in Quasar, but binary compatibility and all that.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-02T21:19:11.126Z
Oh my. That sounds very possible to add to 7.2

                                                                                                                                                      Greg Pfeil @sellout@2017-02-02T21:19:24.027Z
Yeah, it’d be trivial.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-02T21:19:28.966Z
Though of course, that depends on a good Samaritan ;)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-02T21:19:37.654Z
I'll take a look today

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-02T21:19:44.525Z
Couldn't be that bad

                                                                                                                                                      Greg Pfeil @sellout@2017-02-02T22:44:15.961Z
Holy crap, updating dependencies is a pain.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-02T23:10:42.669Z
Yup.

                                                                                                                                                      Konstantin Läufer @klaeufer@2017-02-06T14:55:22.000Z
Good morning...  I am converting some examples for my PL class from my own library to Matryoshka. Everything works great for functors based on case classes. But I am having trouble getting some of the implicit operations to work for bifunctors such as `case class NelF[A, B](head: A, tail: Option[B])`. Concretely, this works:
```RecursiveT[Fix].cataT[NelF[String, ?], Int](list1)(length)```
but not this:
```list1.cata(length)```
I am puzzled because I imported all the same stuff as for my simple `Expr` example. I am using 0.16.4, and the complete example is here: https://github.com/lucproglangcourse/matryoshka-examples-scala/blob/master/src/test/scala/NonEmptyList.scala#L98
Any help would be greatly appreciated.

                                                                                                                                                      Greg Pfeil @sellout@2017-02-06T15:45:36.625Z
@klaeufer Are you using something that has SI-2712 fixed? (Either the plugin, or some version of scalac that understands `-Ypartial-unification`?

                                                                                                                                                      Konstantin Läufer @klaeufer@2017-02-06T15:47:30.785Z
@sellout Probably not... Let me put that in place and try again in a little while. Thanks a lot!

                                                                                                                                                      Greg Pfeil @sellout@2017-02-06T16:08:18.098Z
@klaeufer Sure … one more thing that should be covered in the README …

                                                                                                                                                      Konstantin Läufer @klaeufer@2017-02-06T17:17:08.454Z
@sellout Maybe it's time to upgrade to 2.12.x. :anguished: 

                                                                                                                                                      Konstantin Läufer @klaeufer@2017-02-06T17:44:28.635Z
@sellout I set `scalaVersion := 2.12.1` and Matryoshka to `latest.integration` (0.16.5) and am getting this unresolved dependency: `org.scalacheck#scalacheck_2.12;1.14.0-861f58e-SNAPSHOT`. Same problem with 0.16.4 (though not with 2.11.8). Any ideas? Thanks again.

                                                                                                                                                      Konstantin Läufer @klaeufer@2017-02-06T17:44:51.650Z
Let me add the scalacheck snapshot resolver back...

                                                                                                                                                      Konstantin Läufer @klaeufer@2017-02-06T17:46:50.070Z
That didn't help either...

                                                                                                                                                      Konstantin Läufer @klaeufer@2017-02-06T17:47:00.587Z
Back later.

                                                                                                                                                      Greg Pfeil @sellout@2017-02-06T17:54:03.495Z
@klaeufer Yeah, ugh – see https://github.com/rickynils/scalacheck/pull/301#issuecomment-271103112 for why I need that snapshot (feel free to “upvote” that in some way). It’s a pain.

                                                                                                                                                      Greg Pfeil @sellout@2017-02-06T20:35:48.592Z
@klaeufer I _think_ you shouldn't need Scalacheck for only matryoshka-core. Are you also depending on matryoshka-scalacheck?

                                                                                                                                                      Konstantin Läufer @klaeufer@2017-02-06T21:46:56.124Z
Thanks a bunch, @sellout. My dependencies are now in sync with yours, and I just need to update my Scalacheck  code. (Yes, I do use matryoshka-scalacheck.)

                                                                                                                                                      Greg Pfeil @sellout@2017-02-06T21:47:27.337Z
Ok, I figured you probably were – just wanted to make sure I didn’t get the deps wrong somewhere :)

                                                                                                                                                      Konstantin Läufer @klaeufer@2017-02-06T21:54:03.368Z
:+1: 

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2017-02-06T23:48:05.709Z
Non technical question: Will someone bring a few matryoshka stickers to Scalar conference given that there are a few people from Slamdata speaking there?

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2017-02-06T23:50:50.096Z
I can offer Hascalator stickers in return :wink: 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-11T02:58:10.613Z
@sellout How is matryoshka-cats doing? Do you need any help?

                                                                                                                                                      Greg Pfeil @sellout@2017-02-11T23:23:26.117Z
@edmundnoble Hah! Yeah, I could probably at least bounce some ideas around to get it unstuck. But I'm in the mountains currently. Back on Tuesday morning.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-11T23:32:43.176Z
The mountains! Sounds awesome! :D

                                                                                                                                                      Paul Phillips @paulp@2017-02-12T03:16:37.778Z
literally

                                                                                                                                                      Valentin Kasas @vil1@2017-02-13T16:21:38.973Z
Hi there, I have a … thing, that looks rather recursive, but isn't really:
```scala
trait Lexer {
  def nextToken: Either[SyntaxError, (Token, Lexer)]
}
```


                                                                                                                                                      Valentin Kasas @vil1@2017-02-13T16:24:35.061Z
my idea is to start from a string, and recursive-scheme my way to a (non-recursive) data structure, parsing the string from JSON/CSV and validating its content along the way

                                                                                                                                                      Valentin Kasas @vil1@2017-02-13T16:25:13.690Z
as a bonus, I want to traverse the original string only once

                                                                                                                                                      Valentin Kasas @vil1@2017-02-13T16:26:43.755Z
I have a schema that will be used to build the validations I want to perform

                                                                                                                                                      Valentin Kasas @vil1@2017-02-13T16:29:52.970Z
so my idea is to do `String -ana-> Tokens -???-> JSON-like -???-> GenericData -cata-> Ouptut`

                                                                                                                                                      Valentin Kasas @vil1@2017-02-13T16:30:13.779Z
(the JSON-like step might be avoidable)

                                                                                                                                                      Valentin Kasas @vil1@2017-02-13T16:35:45.677Z
am I making any sense so far ? 

                                                                                                                                                      Greg Pfeil @sellout@2017-02-14T04:52:29.880Z
@vil1 I think so. But your `nextToken` implies an infinite stream of tokens, no? I think `nextToken: CoalgebraM[Either[SyntaxError, ?], ListF[Token,?], Lexer]` might be what you want.

                                                                                                                                                      Jonathan @b-studios@2017-02-14T10:33:53.383Z
@vil1 The difference between what you describe and the coalgebra suggested by @sellout is, that the first does not allow the lexer to indicate that the stream terminates without raising a syntax error. In @sellout's proposal on the other hand this is possible by choosing the Nil case of ListF.

                                                                                                                                                      Valentin Kasas @vil1@2017-02-14T10:37:10.192Z
well, I have a `RunningLexer` and an `ExhaustedLexer` lexer implementations, (basically, `RunningLexer#nextToken` ends up returning `Right((EOF, ExhaustedLexer))` eventually, while `ExhaustedLexer#nextToken` always returns `Right((EOF, ExhaustedLexer))`)

                                                                                                                                                      Valentin Kasas @vil1@2017-02-14T10:38:16.992Z
so the "stream" is indeed infinite, but I know that I can stop as soon as I encounter an `ExhaustedLexer`

                                                                                                                                                      Jonathan @b-studios@2017-02-14T11:19:01.874Z
@vil1 Ok, then @sellout's design makes sense. As a sidenote: Maybe you also want to look into iteratees (for instance this Scala implementation here: https://github.com/travisbrown/iteratee).

                                                                                                                                                      Valentin Kasas @vil1@2017-02-14T12:55:24.177Z
@sellout 's solution makes perfect sense (at least for the compiler) and yields something like : 

                                                                                                                                                      Valentin Kasas @vil1@2017-02-14T12:55:34.618Z
```scala
  val lexerCoalgebraM: CoalgebraM[Either[SyntaxError, ?], ListF[Token, ?], Lexer] = {
    case ExhaustedLexer => Right(NilF[Token, Lexer]())
    case l => l.apply.right.map((ConsF.apply[Token, Lexer] _).tupled)
  }
```

                                                                                                                                                      Valentin Kasas @vil1@2017-02-14T13:01:07.808Z
which (when I provide a `Corecursive.Aux[Lexer, ListF[Token, ?]]`) can in turn be used in a `lexer.ana[Lexer](lexerCoalgebraM)`, but that returns a `Either[SyntaxError, Lexer]` meaning that I "loose" my tokens list

                                                                                                                                                      Valentin Kasas @vil1@2017-02-14T13:01:46.797Z
OH !

                                                                                                                                                      Valentin Kasas @vil1@2017-02-14T13:03:34.499Z
but with a `listFToListAlgbera: AlgebraM[Either[SyntaxError, ?], ListF[Token, ?], List[Token]]` I can do `lexer.hyloM(listFToListAlgebra, lexerCoalgebraM)` and get back my `List[Token]`

                                                                                                                                                      Valentin Kasas @vil1@2017-02-14T13:03:56.166Z
(regardless of my poor naming skills)

                                                                                                                                                      Valentin Kasas @vil1@2017-02-14T13:36:45.530Z
So basically, I'm rather happy (and I got to use a hylo, which changes from my regular catas), now I *just* have to understand exactly what happens there, be right back in a week or two ;)

                                                                                                                                                      Jonathan @b-studios@2017-02-14T14:12:06.480Z
@vil1 I don't completely understand why you want to use lexer as a corecursive structure instead of using one for `ListF`? (disclaimer: I don't know the matryoshka api by heart) I would expect there already is an instance of Corecursive for List (or Stream, actually) that you could use to unfold into.

                                                                                                                                                      Jonathan @b-studios@2017-02-14T14:40:05.642Z
@vil1:
```scala
  import matryoshka.data.list._
  val l: Lexer = ???
  val r: Either[SyntaxError, List[Token]] = listCorecursive.anaM(l)(lexerCoalgebraM)
```


                                                                                                                                                      Valentin Kasas @vil1@2017-02-14T14:41:32.642Z
hmm I see (sort of)

                                                                                                                                                      Jonathan @b-studios@2017-02-14T14:42:29.405Z
You can understand `Lexer` as being the (internal) state of the coalgebra. You supply the initial one and then unfolding the coalgebra uses it internally to generate a list of tokens.

                                                                                                                                                      Valentin Kasas @vil1@2017-02-14T14:45:09.626Z
what I find disturbing is that I have two solutions to go from Lexer to List[Token] using two different schemes

                                                                                                                                                      Jonathan @b-studios@2017-02-14T14:45:10.966Z
@vil1 (btw. should `l.apply.` above in your implementation of `lexerCoalgebraM` be `l.nextToken`? 

                                                                                                                                                      Valentin Kasas @vil1@2017-02-14T14:46:01.841Z
you're right (I've renamed stuff along the way in my project)

                                                                                                                                                      Jonathan @b-studios@2017-02-14T14:46:47.652Z
I understand, that disturbance is perfectly normal. If you have a function like `coRec F -> coRec G` you can often choose whether you want to use the (co)recursive structure of F or G, either destructing F using a catamorphism or constructing G using an anamorphism.

                                                                                                                                                      Valentin Kasas @vil1@2017-02-14T14:58:41.045Z
Humm that's starting to make sense

                                                                                                                                                      Greg Pfeil @sellout@2017-02-14T14:58:56.477Z
@vil1 Also, if you `s/Lexer/String` in the coalgebra, then `type Lexer = CoalgebraM[Either[SyntaxError, ?], ListF[Token, ?], String]`.

                                                                                                                                                      Valentin Kasas @vil1@2017-02-14T15:00:10.121Z
corec F and corec G should be corec "in respect with" the same fix-point-thingy right  ? 

                                                                                                                                                      Valentin Kasas @vil1@2017-02-14T15:05:16.006Z
@sellout that would be even better, but right now my Lexer maintains a reference to the original String so I'm not sure it will be doable as it is. I might need a little more fidling to convince myself it is

                                                                                                                                                      Greg Pfeil @sellout@2017-02-14T15:15:06.049Z
@edmundnoble It _was_ awesome. https://twitter.com/sellout/status/831521196399292416

                                                                                                                                                      Jonathan @b-studios@2017-02-14T15:15:53.644Z
@vil1 what I tried to approximate by `corec F` would be the `FixF` in `Corecursive.Aux[FixF, F]`. e.g. FixF=List for F=ListF, etc.

                                                                                                                                                      Valentin Kasas @vil1@2017-02-14T15:19:55.321Z
(be right back, gotta do stuff for $work™)

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2017-02-17T20:23:53.007Z
Quick question in the definition of `hylo`:
```scala
 def hylo[F[_]: Functor, A, B](a: A)(f: Algebra[F, B], g: Coalgebra[F, A]): B =
    f(g(a) ∘ (hylo(_)(f, g)))
```
Why does `F` need to be a functor here?

                                                                                                                                                      Greg Pfeil @sellout@2017-02-17T20:52:55.180Z
@mgttlinger `g(a)` returns `F[A]`, which you then map over.

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2017-02-18T13:58:59.157Z
Ohhhh, is the `∘` a `map` call?

                                                                                                                                                      Greg Pfeil @sellout@2017-02-18T13:59:41.682Z
@mgttlinger Ah, yes – sorry, I Unicode all the things 😄

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2017-02-18T14:00:31.128Z
But why that symbol? Isn't that usually denoting function composition

                                                                                                                                                      Greg Pfeil @sellout@2017-02-18T14:01:17.372Z
@mgttlinger Composition is `map` on `A => ?`

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2017-02-18T14:02:59.515Z
I guess it is but I have never seen it used that way. Hence the confusion

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2017-02-18T14:03:24.332Z
Is that a thing to write it that way or just personal preference?

                                                                                                                                                      Torsten Scholak @tscholak@2017-02-18T14:03:48.699Z
It's a thing. I've seen it like that, too

                                                                                                                                                      Jonathan @b-studios@2017-02-18T14:45:22.728Z
I am also a bit confused. I do understand the argument of composition is map on the "reader" functor, but wouldnt you flip the arguments to the composition operator typically?

                                                                                                                                                      Jonathan @b-studios@2017-02-18T15:12:25.093Z
(Sorry, I appearently cant operate gitter on my mobile). For ´f: A -> B´ and `g: B -> C`, `f map g` would be equal to `g compose f`, right?

                                                                                                                                                      Greg Pfeil @sellout@2017-02-19T15:39:32.722Z
@b-studios I think you’re right. I remember asking about that in #scalaz ages ago, and not really getting much of a reasonable response …

                                                                                                                                                      Greg Pfeil @sellout@2017-02-19T15:40:30.743Z
But for composition, I tend to use the `Arrow` operators, `<<<` and `>>>`, because I find I often have to switch direction for inference to work, so having it be explicit is useful.

                                                                                                                                                      Jonathan @b-studios@2017-02-19T15:45:31.052Z
Inference wise, IIRC that was one reason (plus autocompletion) for a common use of the piping operator in F#.

                                                                                                                                                      Jonathan @b-studios@2017-02-19T15:45:34.103Z
http://stackoverflow.com/a/10096444

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-19T15:46:48.397Z
The lack of pipe operators in common usage in Scala is unfortunate, but this is what we get for separating methods and functions.

                                                                                                                                                      Jonathan @b-studios@2017-02-19T15:48:39.768Z
Regarding map: In ct literature, I also often encountered the circled semicolon which is reverse function composition. We just need to change the unicode of composition in Scalaz.

                                                                                                                                                      Jonathan @b-studios@2017-02-19T15:52:05.268Z
Obviously a pipe operator can be simulated using implicits. However, I don't know whether presentation compilers of IDEs are smart enough to give reasonable autocompletion in presence of the only half-baked implicit conversion.

                                                                                                                                                      Jonathan @b-studios@2017-02-20T12:14:41.641Z
@sellout I leisurely read a bit in the matryoshka code and stumbled about this comment on [`paraMerga`](https://github.com/slamdata/matryoshka/blob/master/core/shared/src/main/scala/matryoshka/Recursive.scala#L170)

```scala
// TODO: figure out how to represent this as a elgotHylo with mergeTuple
```

                                                                                                                                                      Jonathan @b-studios@2017-02-20T12:14:51.397Z
This triggered my ambition and so I thought about it a bit. In a nutshell: I think it is not possible.

                                                                                                                                                      Jonathan @b-studios@2017-02-20T12:15:07.711Z
Let's call `type Ctx[X] = (T, T, X)` the merging context.

It is not a problem to write an coalgebra `Coalgebra[Ctx ∘ Option ∘ Base, (T, T)]` using `mergeTuple`. But we cannot write it as an `ElgotCoalgebra[Ctx, Option ∘ Base]` since monadic return would need to make up two trees on the spot.

So I believe the only way one can massage the types into an ElgotHylo is `ElgotCoalgebra[Id, Ctx ∘ Option ∘ Base, (T, T)]` (and similarly for `ElgotAlgebra`), which just does not use the "Elgotiness" and hence corresponds to a standard hylo.


                                                                                                                                                      Jonathan @b-studios@2017-02-20T12:15:33.481Z
Sidenote: I could not find `elgotHylo` in the library and implemented it. Is it worth a PR?

                                                                                                                                                      Valentin Kasas @vil1@2017-02-20T19:04:23.385Z
Hi guys, guess who's stuck again :)

                                                                                                                                                      Valentin Kasas @vil1@2017-02-20T19:14:27.617Z
Previously in "Me trying to figure things out"… 
In S01E01, I managed to put together a `TypeF` pattern-functor that serves as a generic representation for schemas and `DataF` that does the same for data (instances of such schemas) and use algebras to `cata` those down to more "earthly" representations (parquet, avro, JSON, etc…)
In S01E02, I was able to tokenise a string representing a JSON-oid piece of data into a `List[Token]` using an hylomorphism that was later simplified to an anamorphism thanks to `matryoshka.data.list.listCorecursive`

                                                                                                                                                      Valentin Kasas @vil1@2017-02-20T19:23:03.587Z
Now S01E03 begins with me trying to find a way to use a `Fix[TypeF]` schema and parse my `List[Token]` in order to produce a `ValidationNel[TypeError, Fix[DataF]]`, and failing miserably so far…

                                                                                                                                                      Valentin Kasas @vil1@2017-02-20T19:56:53.005Z
My problem comes from the fact I (feel that I) need to "recurse" through two different structures at the same time

                                                                                                                                                      Valentin Kasas @vil1@2017-02-20T21:29:48.799Z
I've tried to `transAna` from `TypeF` to `DataF` but that would need to come up with an `AlgebraicTransform` that keeps track of what part of the `List[Token]` has already been consumed

                                                                                                                                                      Valentin Kasas @vil1@2017-02-20T21:34:11.202Z
Likewise, trying to find the right coalgebra to `ana` over the `List[Token]` while keeping track of  the stack of nested `TypeF` I am validating yields no result so far

                                                                                                                                                      Paul Phillips @paulp@2017-02-20T23:22:58.744Z
@vil1 unhelpful response, but are you publishing the episodes anywhere? I am interested in this season of figuring things out 

                                                                                                                                                      Greg Pfeil @sellout@2017-02-20T23:24:01.501Z
@b-studios Yeah, `elgotHylo` would be great … I’ll have to think for a bit longer to process the rest of your comments.

                                                                                                                                                      Jonathan @b-studios@2017-02-20T23:24:59.600Z
@sellout Don't worry, doesn't hurry -- And I will prepare a PR, as soon as I find the time. Btw, I used parts of the implementation of elgotHylo as motivating example in this blog post: https://gist.github.com/b-studios/b014cd52bf71aad14b033cb91d9e8fb7

                                                                                                                                                      Greg Pfeil @sellout@2017-02-20T23:26:19.846Z
@b-studios Heh, I had just opened that post from the link in typelevel/general. Cool.

                                                                                                                                                      Greg Pfeil @sellout@2017-02-20T23:26:42.452Z
@vil1 Do you have a gist or something with what you’re trying to do?

                                                                                                                                                      Jonathan @b-studios@2017-02-20T23:27:28.439Z
(Sorry for double posting, I just wanted to relate that to the elgotHylo :) )

                                                                                                                                                      Jonathan @b-studios@2017-02-21T00:12:16.951Z
@vil1 do I understand correctly, that your `Fix[TypeF]` serves as a domain specific grammar of the parser to parse `List[Token]`?

                                                                                                                                                      Jonathan @b-studios@2017-02-21T00:13:06.207Z
(Sorry, I missed episode 1)

                                                                                                                                                      Valentin Kasas @vil1@2017-02-21T09:05:21.684Z
@b-studios that's it, you can think of it as an extended JSON-schema against which I want to validate my input string (`List[Token]`)

                                                                                                                                                      Valentin Kasas @vil1@2017-02-21T09:10:29.788Z
( @paulp  I didn't write these down yet, but that sounds like a nice addition to my blog)

                                                                                                                                                      Jonathan @b-studios@2017-02-21T10:31:48.844Z
@vil1, so just to summarize again. There are three recursive datatypes involved, split by input-output in pseudo function notation: `(List[Token], Fix[TypeF]) => Fix[DataF]` (ignoring the `ValidationNel` which I don't understand, yet).

                                                                                                                                                      Valentin Kasas @vil1@2017-02-21T10:34:03.860Z
that's it ! (FTR `ValidationNel[TypeError, A]` is an `Applicative` version of  `Either[NonEmptyList[TypeError], A]` that allows accumulation of validation errors)

                                                                                                                                                      Valentin Kasas @vil1@2017-02-21T10:38:34.595Z
I will sum up things in a gist

                                                                                                                                                      Jonathan @b-studios@2017-02-21T10:38:36.483Z
Maybe you have heard of ["parsing-with-derivatives"](http://matt.might.net/papers/might2011derivatives.pdf), which might be relevant.

 In a nutshell, modulo technical details and adopted to the morphisms world, you can describe a parser as a coalgebra `parserCoalg: Fix[TypeF] => (Token => Fix[TypeF], ValidationNel[TypeError, A])`. That is, you can always retreive a result (which might be empty) or pass a new token to get an "updated grammar" which reflects the fact that a token has been consumed. You obtain the parser by unfolding `parserCoalg` and then folding the `List[Token]` using the first observation `Token => Fix[TypeF]`. Finally you extract the result using the second observation.

                                                                                                                                                      Jonathan @b-studios@2017-02-21T10:40:17.541Z
(I wrote a paper giving a Scala implementation of parsing with derivatives, which might be interesting for you: https://github.com/b-studios/fcd/blob/master/paper.pdf)

                                                                                                                                                      Valentin Kasas @vil1@2017-02-21T10:41:51.541Z
hmm that's rather mind-blowing, but makes sense (I guess)

                                                                                                                                                      Valentin Kasas @vil1@2017-02-21T10:42:32.889Z
a coalgebra giving another coalgebra (sort of)

                                                                                                                                                      Valentin Kasas @vil1@2017-02-21T10:46:29.880Z
hmm well, actually I don't get the meaning of the `Token => Fix[TypeF]`

                                                                                                                                                      Valentin Kasas @vil1@2017-02-21T10:49:52.310Z
shouldn't it be `Token => Fix[DataF]` ?

                                                                                                                                                      Jonathan @b-studios@2017-02-21T11:47:23.567Z
@vil1, It is much easier to first think about regular expressions (rather than CFGs) and recognizers (rather than parsers). The corresponding type then would be: `p: Regex => (Token => Regex, Boolean)`. 

Let's now take the regular expression `r: Regex` for the string `"abc"`.  The call `p(r)._1('a')` now returns an "updated" regular expression that only recognizes the remaining string `"bc"`, while `p(r)._2 == false`. In contrast,  `p(r)._1('x')` would yield the empty regular expression that can never recognize anything. Finally, `p(p(p(p(r)._1('a'))._1('b'))._1('c'))._2 == true`.

Unfolding the coalg (`unfold(p): Fix[(Token => ?, Boolean)]`) hides away the internal state, that is the updated description of the grammar. So we can have `unfold(p)._1('a')._1('b')._1('c')._2 == true`.

                                                                                                                                                      Valentin Kasas @vil1@2017-02-21T12:03:25.064Z
I see

                                                                                                                                                      Valentin Kasas @vil1@2017-02-21T12:05:56.003Z
That will make for a very good S01E03

                                                                                                                                                      Valentin Kasas @vil1@2017-02-21T12:18:45.865Z
I might need a little more time to digest all this though (including your paper)

                                                                                                                                                      Valentin Kasas @vil1@2017-02-21T12:23:52.931Z
Anyway, thanks a lot @b-studios  you'll definitely appear in the end credits for  "me trying to figure things out" series :)

                                                                                                                                                      Greg Pfeil @sellout@2017-02-21T13:49:31.796Z
@b-studios Oh, cool. I wrote a parsing-with-derivatives impl in Common Lisp after the original paper came out. Are you aware of @djspiewak’s new impl of it (http://parseback.io)? Do you think yours is “production-ready”?

                                                                                                                                                      Jonathan @b-studios@2017-02-21T13:53:00.367Z
Wow, thanks for the pointer to Daniel's implementation. I wasn't aware that he was working on a new implementation. To be fair, I would call my implementation not production ready as there are still way to many memory leaks. It is more serves as a proof of concept, that a notion of first-class-derivatives can be useful.

                                                                                                                                                      Olivier Mélois @Baccata@2017-02-22T09:05:41.939Z
Hey guys, I'm trying to get a feel for corecursivity.  Would it be possible to express the Pascal Triangle with one (or several) of the morphisms provided by matryoshka ? I don't feel it's possible, but I'd love to be proven wrong 

                                                                                                                                                      Paul Phillips @paulp@2017-02-22T09:56:08.686Z
@Baccata what makes you think it's not possible? Write it in terms of the rows, not the individual numbers. Then it's just a stream. 

                                                                                                                                                      Jonathan @b-studios@2017-02-22T09:57:08.588Z
... in addition every element in a row depends on the context which could be modeled using a comonad.

                                                                                                                                                      Olivier Mélois @Baccata@2017-02-22T10:17:02.958Z
@paulp the row modelling is pretty obvious indeed. I suppose my question wasn't precise enough, I was thinking about a model that would allow for exploring the graph in a downward | rightward manner. 
@b-studios yeah I guess keeping track of the context in some comonad is necessary, thanks for the tip 

                                                                                                                                                      Konstantin Läufer @klaeufer@2017-02-22T19:19:56.719Z
@sellout FYI, I have finished migrated my various F-algebra examples to Matryoshka. As I mentioned, these are for teaching (advanced undergrad + MS), so they are relatively basic. Any feedback would be appreciated. https://github.com/lucproglangcourse/matryoshka-examples-scala https://github.com/lucproglangcourse/expressions-algebraic-scala https://github.com/lucproglangcourse/simpleimperative-algebraic-scala

                                                                                                                                                      Valentin Kasas @vil1@2017-02-22T20:56:18.783Z
That looks extremely cool (from my noob POV)

                                                                                                                                                      Greg Pfeil @sellout@2017-02-22T20:59:12.901Z
@klaeufer I like that you’re using variance. I’ve been meaning to try that.

                                                                                                                                                      Greg Pfeil @sellout@2017-02-22T20:59:53.797Z
@klaeufer re: “Also gives rise to non-delayed Equal instance for ExprF but not Expr.” I think you _should_ get an `Equal[Expr]` instance from that … maybe just a missing import somewhere?

                                                                                                                                                      Valentin Kasas @vil1@2017-02-22T21:00:06.089Z
+1 for unicode-to-earthly-function-names

                                                                                                                                                      Valentin Kasas @vil1@2017-02-22T21:00:28.455Z
... Translation in comments

                                                                                                                                                      Konstantin Läufer @klaeufer@2017-02-22T21:03:43.296Z
@vil1 Are you OK with keeping the translations as comments? I really like the conciseness of the symbols but don't want to wade through slow-loading API docs...

                                                                                                                                                      Konstantin Läufer @klaeufer@2017-02-22T21:04:16.066Z
@sellout Thanks... I'll double-check on the Equal instance and let you know!

                                                                                                                                                      Valentin Kasas @vil1@2017-02-22T21:06:17.306Z
Yes absolutely, I'll get used to the unicode notation eventually, but having a cheat sheet in the comments is very handy

                                                                                                                                                      Konstantin Läufer @klaeufer@2017-02-22T21:57:50.724Z
@vil1 Excellent, I'll continue this practice.

                                                                                                                                                      Konstantin Läufer @klaeufer@2017-02-22T21:58:48.478Z
@sellout Confirmed! The derived instances are all good with 2.12.1 + partial unification. :smile: 

                                                                                                                                                      Greg Pfeil @sellout@2017-02-22T21:59:15.350Z
@klaeufer 🎉

                                                                                                                                                      Olivier Mélois @Baccata@2017-02-23T10:22:22.689Z
@sellout, I've pulled your PR for mutual recursion, and am trying to rebase it against master, but I'm having problems with the [Ctx](https://github.com/sellout/matryoshka/blob/56c2ce8343d43c4513d890511c60fda4fbe79085/core/shared/src/main/scala/matryoshka/mutu/Ctx.scala#L19) type (especially how pattern matching against `Hole`doesn't seem to work in 2.12. My knowledge of the compiler is very small, but according to your comment [there](https://github.com/sellout/matryoshka/blob/56c2ce8343d43c4513d890511c60fda4fbe79085/core/shared/src/main/scala/matryoshka/mutu/package.scala#L46), I assume that 2.11 was maybe transforming the unapply into a `instanceOf` call, which made it compile. 

Could you explain what you were trying through `Ctx`?  It somehow looks like a higher-order Free, but I'm not quite sure what the `H`type param is about . Could you enlight me on this ? 

                                                                                                                                                      Greg Pfeil @sellout@2017-02-23T14:44:31.063Z
@Baccata I have a bunch of updates to that branch that haven’t been pushed yet. I’ve had it `publishLocal`ed as I’ve worked on migrating work code to it, filling in useful bits. I’ll try to get that out today. Although I don’t know if it’s on 2.12 yet.

                                                                                                                                                      Olivier Mélois @Baccata@2017-02-23T14:45:57.921Z
@sellout cheers, looking forward to seeing it !

                                                                                                                                                      Greg Pfeil @sellout@2017-02-23T22:48:45.591Z
@Baccata So, I’m currently trying to figure out probably similar stuff to you 😆 I just asked some questions in #typelevel/scala. My use of GADTs seems to not work on the Typelevel fork … my guess is due to the SI-9760 fix.

                                                                                                                                                      Greg Pfeil @sellout@2017-02-23T22:49:59.095Z
Basically, I commented out the `free` bit, and everything else works except for tests. The problem is the tests use GADTs (as, I guess, Ctx does) and my current $work project doesn’t.

                                                                                                                                                      Olivier Mélois @Baccata@2017-02-24T09:39:26.857Z
opened a ticket with minimal example : typelevel/scala#137

                                                                                                                                                      Valentin Kasas @vil1@2017-02-24T18:22:31.718Z
Hi guys, I started to write a series of blog posts about "me trying to figure things out" in Matryoland. I intend to name the people who provided me we their help and advice (I especially think of @sellout, @edmundnoble and @b-studios), but I won't do so without your explicit agreement (FYI, my blog reaches a tremendous traffic of roughly 10 visitors a week :) )

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-24T18:23:38.287Z
@vil1 Go ahead, I'm here if you have any other questions while you're writing :)

                                                                                                                                                      Valentin Kasas @vil1@2017-02-24T18:24:23.778Z
I sure will ^^

                                                                                                                                                      Valentin Kasas @vil1@2017-02-24T18:25:55.577Z
(you'll have to wait a while for glory though, my plans for your character are for S01E02, and I've just published [the pilot](http://kanaka.io/blog/2017/02/24/Nesting-in-the-nest-of-Nesting-Dolls-pilot.html))

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-24T18:27:13.933Z
It's riveting reading, looking forward to it :)

                                                                                                                                                      Jonathan @b-studios@2017-02-24T18:27:43.774Z
I am also looking forward to it, agreement give :)

                                                                                                                                                      Jonathan @b-studios@2017-02-24T18:28:09.716Z
give -> given, sorry

                                                                                                                                                      Jonathan @b-studios@2017-02-24T18:32:07.798Z
Btw. I am thinking about giving a seminar at my university about morphisms and recursion schemes. I already have tons of interesting papers for that but still some that are "more approachable". Any good ideas?

                                                                                                                                                      Greg Pfeil @sellout@2017-02-24T18:32:52.927Z
@vil1 Fine by me :)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-24T18:33:06.832Z
@dispalt `transCata` is my second favorite recursion scheme because it lets you translate between fixpoints, which covers most "rewrite"-style recursion.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-24T18:33:22.808Z
@b-studios Show them a schema DSL ;)

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-24T18:33:36.309Z
yeah I am trying to do a tree simplification

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-24T18:33:52.192Z
or like collect all the leaves + one level up

                                                                                                                                                      Greg Pfeil @sellout@2017-02-24T18:33:53.166Z
@b-studios Have you seen Patrick Thomson’s stuff? http://blog.sumtypeofway.com

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-24T18:35:24.014Z
@dispalt Wait, so for tree functor `F` it's like `Fix[F] => Fix[F]`?

                                                                                                                                                      Jonathan @b-studios@2017-02-24T18:36:21.309Z
@sellout no, I have not. Thanks, will definitly look into it. But I am actually in search for easy to read papers published at some scientific conf.

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-24T18:36:23.788Z
more something like this, https://github.com/slamdata/matryoshka/blob/master/tests/shared/src/test/scala/matryoshka/spec.scala#L89

                                                                                                                                                      Jonathan @b-studios@2017-02-24T18:36:37.889Z
(since it is a seminar)

                                                                                                                                                      Greg Pfeil @sellout@2017-02-24T18:36:49.269Z
@b-studios I don’t _think_ I’ve found any accessible papers on the topic, unfortunately.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-24T18:37:24.196Z
@dispalt so as you can see that test uses `repeatedly` and `transCataT` to apply the `simplifyf` optimization.

                                                                                                                                                      Jonathan @b-studios@2017-02-24T18:37:43.543Z
Of course, there is Bananas and the like, but I would like to start a little slower.

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-24T18:37:50.285Z
ahh repeatedly

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-24T18:38:04.034Z
transCataT takes care of rewriting the bottom levels before rewriting the top levels, and repeatedly takes care of applying it until it doesn't apply anymore.

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-24T18:38:27.272Z
right, that's what I was missing

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-24T18:38:39.983Z
I have a ton of boilerplate to "keep going" right now

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-24T18:38:57.588Z
@b-studios Perhaps they've learned about less-generative kinds of recursion before, which you can appeal to? Tail-recursion, tail-recursion modulo cons, structural recursion...?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-24T18:39:25.489Z
@dispalt Yeah repeatedly will do that for you... unfortunately it's not tail-recursive, but it could be easily.

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-24T18:40:21.993Z
well I am not actually using matryoshka at the moment for simplicity-of-use sake, so if there is a simple tail recursive cats equiv I'd be happy to use that

                                                                                                                                                      Jonathan @b-studios@2017-02-24T18:41:54.330Z
@edmundnoble that might be an idea. I usually approach the topic with my students starting from the visitor pattern, going from internal visitors to catamorphisms.

                                                                                                                                                      Jonathan @b-studios@2017-02-24T18:44:03.078Z
But there is still the jump from recursive datatypes to functors. Maybe this could be closed with a paper on generic progr and pattern functors.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-24T18:44:30.254Z
Data types a la carte?

                                                                                                                                                      Greg Pfeil @sellout@2017-02-24T18:45:07.759Z
Yeah, I love that one.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-24T18:45:42.397Z
Perhaps when you say internal visitor you mean Boehm berarducci encoding? In that case that's another good angle to introduce pattern functors.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-24T18:46:32.561Z
@dispalt you can write it yourself in three lines or so. There's a copy in edmundnoble/slate.

                                                                                                                                                      Jonathan @b-studios@2017-02-24T18:47:12.578Z
Re Datatypes a la carte: thats a good one, yes. But now I remember: I once saw one introducing generic programming in Scala which was a kind of easy read.

                                                                                                                                                      Jonathan @b-studios@2017-02-24T18:49:01.140Z
@sellout in your talk (IIRC march) you allude to Datatypes ALC. Did you implement some compiler extension for your examples? Those look really cool

                                                                                                                                                      Greg Pfeil @sellout@2017-02-24T18:49:42.920Z
@b-studios Ahahaha – no, that was slide magic ;) It doesn’t actually work that nicely, and it haunts me because people ask.

                                                                                                                                                      Greg Pfeil @sellout@2017-02-24T18:49:52.370Z
I mean, the technique works, but the syntax is longer.

                                                                                                                                                      Jonathan @b-studios@2017-02-24T18:50:22.320Z
Hah, I see... Lesson learnt: never cheat on slides

                                                                                                                                                      Greg Pfeil @sellout@2017-02-24T18:50:40.428Z
It’s hard not to cheat on Scala slides, though!

                                                                                                                                                      Jonathan @b-studios@2017-02-24T18:51:54.923Z
Sad but true.

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-24T19:00:02.771Z
@edmundnoble thanks!

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-24T19:00:13.454Z
Very welcome :)

                                                                                                                                                      Greg Pfeil @sellout@2017-02-24T19:59:13.189Z
@edmundnoble So, would making `Option.fold` `@inline` fix the tailrec issue?

                                                                                                                                                      Valentin Kasas @vil1@2017-02-24T19:59:13.882Z
Some use `tut` to check their slides, like an anti-cheating warranty

                                                                                                                                                      Greg Pfeil @sellout@2017-02-24T19:59:33.872Z
@vil1 Yeah, I’ve started using tut (and org-babel) to keep me honest there.

                                                                                                                                                      Valentin Kasas @vil1@2017-02-24T20:01:23.615Z
(not sure about the problem with `Option.fold` but `@inline` is only a best-effort of the compiler)

                                                                                                                                                      Greg Pfeil @sellout@2017-02-24T20:01:51.568Z
@vil1 Right, but `@tailrec` would tell you if it didn't manage to inline in that case.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-24T20:08:48.545Z
@sellout Not that I know of.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-24T20:09:01.219Z
This is a common issue with `@tailrec` as far as I know.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-24T20:10:40.329Z
There is no "best-effort" when it comes to inlining.

                                                                                                                                                      Valentin Kasas @vil1@2017-02-24T20:18:49.345Z
Interestingly, the question was asked at our local meetup yesterday. Someone put forward the proposition that the compiler is not guarrantied to inline methods from libraries (but I speak without firm knowledge there)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-24T20:19:28.327Z
Well if you don't have the source, the compiler cannot inline *any* methods from a library.

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-24T22:08:15.311Z
@edmundnoble you haven't done histo anywhere right?

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-24T22:24:09.390Z
if I had a grammar like [this](https://gist.github.com/dispalt/b53b38572337c7c5aa703dbc7ae3f9e1) and wanted to pull out just constants (like the function below) what type would I use.  I was thinking `histo` since it'd be `Expr[Expr[A]]` => `A`

                                                                                                                                                      Greg Pfeil @sellout@2017-02-24T22:26:23.647Z
@dispalt I think you want `para` for that – `Expr[(Fix[Expr], List[(RuleKey, Interval[Num])])] => List[(RuleKey, Interval[Num])]`

                                                                                                                                                      Greg Pfeil @sellout@2017-02-24T22:26:49.876Z
Or a bit less noisily: `Expr[(Fix[Expr], A)] => A`

                                                                                                                                                      Greg Pfeil @sellout@2017-02-24T22:27:46.921Z
@dispalt `histo` would work, but that keeps the entire tree of intermediate results as well.

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-24T22:29:24.806Z
@sellout thanks Greg, Ill check that out

                                                                                                                                                      Greg Pfeil @sellout@2017-02-24T22:31:17.559Z
Oh, and the base case isn’t `Nil`, but `case x => x.fold`

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-24T22:36:46.565Z
`para` definitely seems like the right solution

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-24T22:37:06.669Z
Im using a `cofree` structure, but that shouldn't matter right?

                                                                                                                                                      Greg Pfeil @sellout@2017-02-24T22:51:50.229Z
@dispalt Not too much … it changes the shape of the function a bit … instead of `Expr` you have `EnvT[<whatever your annotation type is>, Expr, ?]` and instead of `Fix`, it’ll be `Cofree`. I’ve been considering adding a lower-priority `Recursive.Aux[Cofree[F, A], F]` instance (in addition to the current `Birecursive.Aux[Cofree[F, A], EnvT[A, F, ?]]` instance). Which would perhaps make your case simpler.

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-24T22:53:07.379Z
Im actually not really using the annotation part much at all, so I might just nuke it for simplicity sake and pull it it in to the ast

                                                                                                                                                      Greg Pfeil @sellout@2017-02-24T22:55:16.088Z
So, with the proposed instance, you _should_ be able to use the same algebra for Fix and Cofree … which is how it was in the bad old days of much less general fixed points.

                                                                                                                                                      jeremyrsmith @jeremyrsmith@2017-02-24T23:45:30.469Z
@edmundnoble I think they do inline bytecode from libraries in some cases (only with `-opt` IIRC)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-24T23:49:15.135Z
oooooo interesting @jeremyrsmith.

                                                                                                                                                      jeremyrsmith @jeremyrsmith@2017-02-25T00:05:17.564Z
I don’t know what those cases are, just like I don’t know what the cases are when `@inline` actually does something :)

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-25T00:13:46.663Z
how do you make a `Monoid` on a recursive type?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-25T00:14:16.574Z
@dispalt `Delay`?

                                                                                                                                                      Greg Pfeil @sellout@2017-02-25T02:36:22.906Z
@dispalt Yeah, if you want a Monoid on `Fix[F]`, you need to define `Delay[Monoid, F]`, and also define `(implicit T: Recursive.Aux[T, F], F: Delay[Monoid, F]): Monoid[T]` … at least, that’s a fairly generic way to go about it. I would put the latter definition into Matryoshka itself.

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-25T05:09:46.008Z
yeah interesting...

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-25T05:10:02.270Z
still kinda feeling my way around with braille, so thanks for the help

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-25T05:10:12.364Z
@edmundnoble what would this look like for cofree? https://github.com/edmundnoble/slate/blob/411a171167baf2337d9321b27e09f191320324b2/qq/shared/src/main/scala/qq/util/Recursion.scala#L77

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-25T05:10:29.739Z
Oh, `cata2M`?

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-25T05:10:37.045Z
yeah I am about to use it

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-25T05:10:42.407Z
and I see your comment

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-25T05:10:50.786Z
Hehehe I don't use it in my codebase I just wrote it to see if I could ;)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-25T05:11:04.374Z
With a cofree, hmmmm

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-25T05:11:34.849Z
would this be right? https://gist.github.com/dispalt/a21182a3ea2088feb5b52df4d48ad90b

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-25T05:11:49.480Z
or am I misinterpreting tailForced

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-25T05:12:00.515Z
Shame is I don't use matryoshka in here yet because there's no matryoshka-cats :'(

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-25T05:12:04.603Z
No you aren't, that looks right to me

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-25T05:12:22.878Z
If you are using that RecursiveFunction stuff

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-25T05:12:50.609Z
same for me =( its a good exercise to try to understand this stuff better 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-25T05:13:07.877Z
:cough: @sellout :cough: 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-25T05:13:26.691Z
;)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-25T05:13:42.824Z
What's cata2M being used for?

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-25T05:14:22.871Z
well I wanted to basically look inside a piece of the ast as I am interpreting it

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-25T05:14:36.674Z
Expr[Expr[A]] => A

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-25T05:14:50.847Z
it looks like para

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-25T05:17:43.554Z
Ah righto

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-25T05:18:01.049Z
It's cheeky-cata

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-25T05:20:11.666Z
Twice the unlayering, same price

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-25T05:21:26.208Z
"cheeky"

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-25T05:21:59.085Z
Yes, slightly disrespectable but still not primitive recursion ;)

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-25T05:22:09.105Z
=)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-25T05:23:00.852Z
All jokes aside, I think perhaps coming up with fancy names for recursion schemes has unfortunately taken priority over coming up with fancy *descriptors* for recursion schemes.

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-25T05:23:13.267Z
yeah

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-25T05:23:22.159Z
It'd be nice to know at a glance which are similar and how.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-25T05:23:43.655Z
Instead of like... it's `histo`! Of course it's got access to  *past* values!

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-25T05:24:23.241Z
I like the taxonomy aspect in that it gives concise wording to complex things

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-25T05:24:43.568Z
but it'd be nice to even more

                                                                                                                                                      Edmund Noble @edmundnoble@2017-02-25T05:35:06.151Z
Yeah. Maybe a couple more periodic tables ;) 

                                                                                                                                                      Greg Pfeil @sellout@2017-02-26T15:02:36.799Z
Two 3rd-party PRs within an hour of each other? Feels like Matryoshka is a thing now 😄

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2017-02-26T15:11:04.383Z
I feel like matryoshka is becoming the next thing now that free monads are considered somewhat "normal"

                                                                                                                                                      Jonathan @b-studios@2017-02-26T15:28:40.357Z
I am still waiting for the Cofree Comand hype:)

                                                                                                                                                      Valentin Kasas @vil1@2017-02-26T16:18:27.669Z
@mgttlinger I have the exact same feeling

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2017-02-26T16:19:58.358Z
@vil1 Is your scalar talk going in that direction?

                                                                                                                                                      Valentin Kasas @vil1@2017-02-26T16:22:18.258Z
Hmm well, not really. But recursion-schemes/matryoshka might be mentioned at some point

                                                                                                                                                      Valentin Kasas @vil1@2017-02-26T16:23:49.166Z
For the moment, it's more like "Lambda Man vs The Gang of Four (horsemen of Apocalypse)"

                                                                                                                                                      Merlin Göttlinger @mgttlinger@2017-02-26T16:24:16.246Z
:smile:  Looking forward to that

                                                                                                                                                      Valentin Kasas @vil1@2017-02-26T16:28:04.755Z
I'll try not to disappoint you then, but do not expect anything very technical though

                                                                                                                                                      Greg Pfeil @sellout@2017-02-26T16:40:31.736Z
@Baccata I submitted a patch for SI-10208 last night … but Jira keeps giving me an error when I try to comment. The fix is at https://github.com/scala/scala/pull/5744

                                                                                                                                                      Olivier Mélois @Baccata@2017-02-26T16:55:52.791Z
@sellout awesome ! I'd be curious to know how you tracked it down, as I'm at total noob when it comes to the compiler's internals. In any case, cheers for that ! 

                                                                                                                                                      Greg Pfeil @sellout@2017-02-26T16:59:34.982Z
@Baccata I too am a noob at it – but I'm happy to write down what I did. I'll try to do it today before I forget everything :smile: 

                                                                                                                                                      Greg Pfeil @sellout@2017-02-26T17:26:10.319Z
Apparently Jira tells you that the server’s down if you try to submit a comment with an emoji in it …

                                                                                                                                                      dwhitney @dwhitney@2017-02-26T17:26:39.709Z
^^ not a bug

                                                                                                                                                      dwhitney @dwhitney@2017-02-26T17:26:46.290Z
;)

                                                                                                                                                      Greg Pfeil @sellout@2017-02-26T17:42:32.397Z
Wouldn't mind someone talking about recursion schemes at http://www.nescala.org/#cfs, since I can't go 😢 (submissions due tonight)

                                                                                                                                                      Valentin Kasas @vil1@2017-02-26T17:46:21.370Z
Hold my beer … (nah just kidding, that would be preposterous)

                                                                                                                                                      Jonathan @b-studios@2017-02-26T18:10:13.421Z
Does anyone have good examples for usages of elgotAna and elgotCata? I can only come up with contrived ones.

                                                                                                                                                      Jonathan @b-studios@2017-02-26T18:10:50.008Z
Bonuspoints: the example use the same Base functor so I can combine them with elgotHylo.

                                                                                                                                                      Jonathan @b-studios@2017-02-26T18:14:00.881Z
Especially the distributive laws restrict my example search space.

                                                                                                                                                      Greg Pfeil @sellout@2017-02-26T18:24:33.057Z
@b-studios The Quasar code base probably uses some elgot stuff somewhere.

                                                                                                                                                      Greg Pfeil @sellout@2017-02-26T18:25:19.424Z
@b-studios There must be _some_ elgot test in Matryosha, no? Since elgotCata is just a generalization of any elgot variant of a fold.

                                                                                                                                                      Jonathan @b-studios@2017-02-27T09:24:08.025Z
@sellout Yeah, you are right, though there are no usages of `elgotCata` at least I could find instances of `coelgot`as special cases in the tests.

                                                                                                                                                      Jonathan @b-studios@2017-02-27T16:56:27.460Z
In the end I couldn't come up with anything other then using the algebra distributive law as zygo and the coalgebra distr as gApo. 

                                                                                                                                                      Paul Phillips @paulp@2017-02-27T19:31:47.702Z
Trying to program with algebras I have a lot of trouble with the absence of any enforcement regarding where recursion is introduced. I wonder if a compiler plugin would be worth the trouble.

                                                                                                                                                      Jonathan @b-studios@2017-02-27T19:53:50.519Z
@paulp What you say sounds interesting, but I don't quite understand. Isn't the idea of recursion schemes to separate recursion from other code. Shouldn't that make it easier to track down recursion? 

                                                                                                                                                      Paul Phillips @paulp@2017-02-27T19:55:29.760Z
Indeed that is the idea. The problem is the language offers you zero support in this. There's nothing which distinguishes a thing which takes a single step from a thing which takes all the steps. It's like programming in an untyped language in that sense.

                                                                                                                                                      Paul Phillips @paulp@2017-02-27T19:55:45.172Z
Like, I don't want recursive references to even exist, except in the few circumstances where recursion is intentionally being introduced.

                                                                                                                                                      Paul Phillips @paulp@2017-02-27T19:55:59.253Z
Neither recursive calls nor recursive types.

                                                                                                                                                      Jonathan @b-studios@2017-02-27T20:00:09.179Z
Ah, I see. Originally the idea was actually to fully **replace** recursive definitions by x-morphisms as primitives. Too bad, Scala supports recursive definitions.

                                                                                                                                                      Paul Phillips @paulp@2017-02-27T20:19:14.435Z
And there's a similar problem with effects, and yet another with evaluation strategies, and yet another with data vs codata.

                                                                                                                                                      Valentin Kasas @vil1@2017-02-27T20:45:23.231Z
Couldn't this be circumvented with something like wart remover + `-X-fatal-warnings`  ? 

                                                                                                                                                      Greg Pfeil @sellout@2017-02-27T20:45:58.446Z
@vil1 You mean defining `org.wartremover.warts.Recursion`?

                                                                                                                                                      Greg Pfeil @sellout@2017-02-27T20:46:13.811Z
That’s a hell of a wart 😄

                                                                                                                                                      Paul Phillips @paulp@2017-02-27T20:52:03.322Z
@sellout with fatal warnings yeah, but I would gladly take the non-fatal one, at least if I could scope it a little.

                                                                                                                                                      Paul Phillips @paulp@2017-02-27T20:53:15.476Z
@vil1 but maybe you're right - I forget in what conditions the trees are when wart remover gets its hands on them, but at least direct recursion should be detectable if the trees are attributed. Indirect recursion is as always going to be a challenge.

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-02-28T15:23:10.643Z
@edmundnoble with your `cataM` from slate, how would you make something like `project` in matryoshka work?

                                                                                                                                                      Valentin Kasas @vil1@2017-02-28T16:38:45.639Z
@paulp I have no idea either. I was mostly thinking out loud. My guess was "if IDEA can detect recursion, some compiler plugin can too"

                                                                                                                                                      Greg Pfeil @sellout@2017-02-28T17:57:45.824Z
BTW, new releases of Matryoshka are published to sonatype automatically as soon as a PR is merged. It’s so nice. Thanks to @drostron.

                                                                                                                                                      Dave Rostron @drostron@2017-02-28T17:58:17.645Z
😃

                                                                                                                                                      Sukant Hajra @shajra@2017-02-28T18:48:16.508Z
sellout: in a SNAPSHOT dependency?

                                                                                                                                                      Sukant Hajra @shajra@2017-02-28T18:48:31.349Z
or do you use a git-describe version-bumping scheme?

                                                                                                                                                      Sukant Hajra @shajra@2017-02-28T18:48:39.766Z
(sorry, I could look it up... being lazy)

                                                                                                                                                      Greg Pfeil @sellout@2017-02-28T18:52:50.844Z
@shajra More like the latter – we use GitHub labels to indicate whether a PR should bump the major/minor/revision bits.

                                                                                                                                                      Sukant Hajra @shajra@2017-02-28T19:10:11.160Z
sellout: smart.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-01T18:22:52.354Z
@dispalt What do you mean?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-01T18:24:52.355Z
@paulp pretty please, we need a plugin that doesn't allow general recursion :D

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-03-01T22:22:35.763Z
@edmundnoble I was trying to figure out how to write `isLeaf` given your "slate" micro-matryoshka :smile:

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-01T22:25:13.026Z
This chestnut?

```scala
  def isLeaf(t: T)(implicit BF: Functor[Base], B: Foldable[Base]): Boolean =
    !Tag.unwrap(project(t).foldMap(_ => true.disjunction))
```


                                                                                                                                                      Dan Di Spaltro @dispalt@2017-03-01T22:25:29.529Z
yeah

                                                                                                                                                      Greg Pfeil @sellout@2017-03-01T22:25:48.618Z
I really don’t like that definition.

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-03-01T22:26:12.967Z
its by no means critical, I just don't really get `project` so I figured a real quest would help me unlock the understanding

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-01T22:26:16.565Z
Should it be possible to `cataM` to do it?

                                                                                                                                                      Greg Pfeil @sellout@2017-03-01T22:28:06.492Z
Well, you shouldn’t need Functor, at least – just `_.project.size ≟ 0` (size might not be the right name for that function …)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-01T22:28:20.962Z
Could we perhaps help more directly with your understanding of `project` (and dually `embed`)? There's a commutative square somewhere that explains their relationship with each other, `cata` and `ana`. 

                                                                                                                                                      Greg Pfeil @sellout@2017-03-01T22:28:36.941Z
Or you can do it with `_.foldRight(true)(_ => false)`

                                                                                                                                                      Greg Pfeil @sellout@2017-03-01T22:28:43.123Z
(still need project, though)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-01T22:29:03.834Z
I'd do that. `foldMap` doesn't handle laziness (in cats ;))

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-01T22:29:36.030Z
In essence `project` starts a recursive call, and `embed` finishes a recursive call.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-01T22:30:26.269Z
`cata(embed) == id` and `ana(project) == id`

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-03-01T22:30:49.387Z
interesting, yeah I think Ill try to play around with matryoshka to get a better grasp on it

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-03-01T22:36:40.263Z
that all makes sense, I guess I should just go through the code a bit more to understand

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T00:48:51.107Z
@edmundnoble well the basic mechanism is easy enough:  https://gist.github.com/paulp/de91a5eec027c128f6b28dfe5f563e78

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T00:49:16.937Z
But the question is what exactly to exclude.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-02T00:49:58.863Z
@paulp 🤗

                                                                                                                                                      Greg Pfeil @sellout@2017-03-02T00:50:02.808Z
Exclude nothing!

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-02T00:50:26.510Z
What would you exclude? Honestly I can't think of anything. Except maybe `@tailrec` annotated.

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T00:50:27.446Z
which got me pretty far

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T00:50:28.700Z
I suppressed warnings on (Co)Recursive(T) and the matryoshka package object

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T00:50:34.699Z
obviously that particular library would have special dispensation.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-02T00:52:26.882Z
@paulp honestly, we can eliminate a lot more general recursion there. E.g., the default impls of cata/ana can be moved to `RecursiveT[Fix]` … because `Fix` is a terrible thing ;)

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T00:52:48.849Z
Okay, I'll generate the whole list and you can see what if anything bears exclusion.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-02T00:53:18.565Z
I have noticed that I steal a bunch of adverbs from recent context – like, I wouldn’t have written “honestly” there if it wasn’t in my subconscious.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-02T00:53:33.681Z
What's wrong with `Fix`? `project` and `embed` actually have decent performance.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-02T00:53:50.475Z
@edmundnoble Just that it’s generally recursive.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-02T00:54:31.510Z
Ah right. May be reaching, but does that imply that `Nu` with `project` is stack-safe?

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T00:54:51.167Z
https://gist.github.com/paulp/3763704bdd57cdbc81625168ad483712

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T00:55:41.674Z
It's also entirely possible my mechanism for detecting recursive calls has both false positives and false negatives. All reports welcome.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-02T00:56:24.784Z
They all look legit to me. Could be moved to `CorecursiveT[Fix]`.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-02T00:56:56.478Z
We *should* be able to implement all of them in terms of `ana` I think but it won't be as performant.

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T00:58:20.749Z
@edmundnoble in case it's not apparent the amount gitter inlines into the room is only a small fraction of what's in the gist.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-02T00:58:43.234Z
Oh damn. I'll dive in for real :P

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-02T00:59:07.369Z
Aw with dupes :'(

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-02T00:59:25.824Z
Honestly we need someone to fix the scala.js plugin so that the same errors don't get emitted twice.

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T01:00:22.728Z
oh is that it - I can just run the compile on the jvm side.

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T01:00:31.343Z
I'm still not used to all the js inflicted pain.

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T01:02:04.366Z
@edmundnoble https://gist.github.com/paulp/3763704bdd57cdbc81625168ad483712

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-02T01:02:51.619Z
Thanks :D 

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T01:02:59.512Z
That loses the stuff in "shared", so there's a bit more

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T01:03:43.340Z
at least, I think it loses some stuff. There were mentions of CorecursiveT before, which seem no longer there.

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T01:03:56.161Z
no, there is one.

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T01:04:16.501Z
so that may be everything.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-02T01:09:35.942Z
This is very motivational.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-02T01:12:25.638Z
@paulp all of the occurrences look legit. Still included `@tailrec` methods though.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-02T01:13:42.243Z
(only one I know of is `repeatedly`, but it's in there)

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T01:13:59.343Z
Oh yes - I can exclude tailrec marked methods, though that will still warn about tail-recursive methods which aren't marked tailrec. There's no way to know which those are until the tail call transformation happens, much later.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-02T01:14:17.214Z
I think that's a good thing.

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T01:14:34.060Z
Sure, then you can mark them, as is useful.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-02T01:46:54.473Z
@paulp Why does the message say “unmarked”?

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T02:17:03.035Z
@sellout with the presumption that there could be a `@tailrec` style annotation, marking the method. It means nothing, basically.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-02T03:54:39.366Z
@sellout one day, we may introduce a recursion method with a reified stack that does not depend on the way a method is called. Then the annotation becomes more useful.

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T05:54:03.951Z
@edmundnoble just for comparison's sake, I ran it on the scala stdlib: https://gist.github.com/paulp/05482043c91c694923dfacf31fa1e5e6

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T05:54:11.269Z
still need to exclude `@tailrec` though.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-02T05:57:58.282Z
Oof. I didn't know `LongMap` wasn't stack-safe...

                                                                                                                                                      Paul Phillips @paulp@2017-03-02T07:30:41.749Z
@edmundnoble Depends on what you're seeing.
```
  // Basically this uses a simple stack to emulate conversion over the tree. However
  // because we know that Longs are only 64 bits we can have at most 64 LongMap.Bins and
  // one LongMap.Tip sitting on the tree at any point. Therefore we know the maximum stack
  // depth is 65
```

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-02T21:45:48.777Z
Oof. Should've looked closer :P

                                                                                                                                                      Sumedh Mungee @smungee@2017-03-03T21:50:44.938Z
Not sure if this is relevant here, but given two trees of type Fix[Exp], is there some way to efficiently (or even not so efficiently, i'd settle for easily) find the longest subtree in common?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-03T21:57:29.372Z
@smungee Not efficiently (that I know of)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-03T22:00:37.607Z
Not even very easily. You'd have to roll your own recursive method that uses `Recursive.children`.

                                                                                                                                                      Sumedh Mungee @smungee@2017-03-03T22:05:07.377Z
Will `Recursive.universe` give me all possible subtrees? Can I sort that by length and find the longest match?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-03T22:05:34.083Z
Yes. Won't be fast.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-03T22:05:58.204Z
It's a combinatorial explosion.

                                                                                                                                                      Sumedh Mungee @smungee@2017-03-03T22:06:04.066Z
Yeah

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-03T22:06:56.202Z
I don't think you need to sort it.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-03T22:07:03.221Z
It will be in order of length already.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-03T22:07:17.585Z
Urgh actually never mind it won't.

                                                                                                                                                      Sumedh Mungee @smungee@2017-03-03T22:07:37.443Z
it's basically in top-down order, but not necessarily in order of length, i think

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-03T22:07:45.854Z
Yeah, exactly.

                                                                                                                                                      Sumedh Mungee @smungee@2017-03-03T22:08:47.332Z
hmm, thanks.. I'll use .universe for now, and if I find a more efficient way, will see if i can generalize it enough to contribute back

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-03T22:09:11.353Z
Should be able to count the length while traversing.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-03T22:09:13.212Z
Good luck :)

                                                                                                                                                      Sumedh Mungee @smungee@2017-03-03T22:39:11.545Z
btw, in general, i wonder if there's interest or value in implementing these sorts of standard tree algorithms on top of matryoshka. 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-03T22:39:34.274Z
@smungee I could see that being the case, if not in matryoshka itself in matryoshka-tree or something.

                                                                                                                                                      Sumedh Mungee @smungee@2017-03-03T22:40:53.165Z
Yeah, exactly. I'm sold on matryoshka just for the abstraction benefits, but I find that when I'm trying to sell it to my coworkers, they seem to expect that they will get all this for free..

                                                                                                                                                      Valentin Kasas @vil1@2017-03-06T14:10:32.972Z
I published [S01E01](http://kanaka.io/blog/2017/03/05/Nesting-in-the-nest-of-Nesting-Dolls-S01E01.html) of my series about matryoshka, any (negative/constructive) feedback would be much appreciated 

                                                                                                                                                      Torsten Scholak @tscholak@2017-03-06T15:29:10.818Z
well, I must congratulate you on your code font choice

                                                                                                                                                      Valentin Kasas @vil1@2017-03-06T15:30:19.269Z
Ah ah

                                                                                                                                                      Valentin Kasas @vil1@2017-03-06T15:30:33.119Z
PragmataPro  ? 

                                                                                                                                                      Valentin Kasas @vil1@2017-03-06T15:35:46.520Z
Actually, it's not served from the website so only the happy owners can enjoy it

                                                                                                                                                      Torsten Scholak @tscholak@2017-03-06T15:39:40.555Z
yeah, I'm using it in VIM and IntelliJ

                                                                                                                                                      Valentin Kasas @vil1@2017-03-06T15:41:01.384Z
I see. There is quite no going back once you tasted it

                                                                                                                                                      Torsten Scholak @tscholak@2017-03-06T15:41:57.241Z
agreed

                                                                                                                                                      Torsten Scholak @tscholak@2017-03-06T15:42:08.527Z
it's unfortuntate that many editors don't support ligatures yet

                                                                                                                                                      Valentin Kasas @vil1@2017-03-06T15:43:14.854Z
I might go through the hassle of encoding it to the web at some point, since the license seems to allow that

                                                                                                                                                      Valentin Kasas @vil1@2017-03-06T15:44:04.688Z
Haskell for Mac supports it (with manual config), Sublime Text too

                                                                                                                                                      Torsten Scholak @tscholak@2017-03-06T15:44:43.321Z
Sublime Text? Not for me :/

                                                                                                                                                      Torsten Scholak @tscholak@2017-03-06T15:46:04.042Z
I also have it configured in Haskell for Mac, but the ligatures don't work :/

                                                                                                                                                      Valentin Kasas @vil1@2017-03-06T15:47:35.691Z
hmm spoke too fast about Sublime

                                                                                                                                                      Valentin Kasas @vil1@2017-03-06T15:48:58.265Z
for Haskell for Mac I had to edit a file manually fo use PragmataPro rather than PragmataPro Mono

                                                                                                                                                      Torsten Scholak @tscholak@2017-03-06T15:49:38.518Z
oh, interesting

                                                                                                                                                      Valentin Kasas @vil1@2017-03-06T15:50:13.048Z
more precisely, I had to issue : 
```
defaults write com.haskellformac.Haskell.basic FontName PragmataPro
```

                                                                                                                                                      Torsten Scholak @tscholak@2017-03-06T15:50:38.841Z
that did it

                                                                                                                                                      Torsten Scholak @tscholak@2017-03-06T15:50:42.769Z
wow, thanks!

                                                                                                                                                      Valentin Kasas @vil1@2017-03-06T15:51:12.119Z
all credit goes to the support of H4M

                                                                                                                                                      Torsten Scholak @tscholak@2017-03-06T15:51:46.699Z
;) looking forward to reading your series

                                                                                                                                                      Valentin Kasas @vil1@2017-03-06T15:53:37.933Z
thx ! next instalment might come in a few weeks though

                                                                                                                                                      Greg Pfeil @sellout@2017-03-07T22:35:56.176Z
I’m implementing some of @ekmett’s suggestions. It’s simple enough for gcata, gana, and cataM, but anaM and both elgots are a bit more complicated, since they effectively operate over a different functor, and the functor is part of the type class in Matryoshka’s representation.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-07T22:49:03.702Z
@edmundnoble You can take another look at stack safety afterward 😆

                                                                                                                                                      Greg Pfeil @sellout@2017-03-07T23:17:46.645Z
BTW, this change also makes me more motivated to implement adjoint folds, since it’s now more glaring where the non-conforming cases are.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-07T23:37:47.386Z
@paulp Already fixing the warnings from your Recursion wart: https://github.com/sellout/matryoshka/commit/ac8da1cdd7bdfdc59a6a1ad15d98c9397aee0686

                                                                                                                                                      Paul Phillips @paulp@2017-03-07T23:39:33.571Z
@sellout nice. I'll run it again once you get this round merged.

                                                                                                                                                      Paul Phillips @paulp@2017-03-08T06:41:48.014Z
https://github.com/wartremover/wartremover/pull/341

                                                                                                                                                      Paul Phillips @paulp@2017-03-08T06:45:11.060Z
@sellout https://gist.github.com/paulp/86aeeb76bc3892e4d1e7de065ad7e5c8 running it agains that PR.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-08T14:04:01.302Z
Cool – slightly better than expected :smile: 

                                                                                                                                                      Olivier Mélois @Baccata@2017-03-08T15:28:05.280Z
so is there a plan to make hylo tailrec / stacksafe ? 

                                                                                                                                                      Greg Pfeil @sellout@2017-03-08T15:30:37.792Z
@Baccata There’s a _desire_ – I don’t think there’s a _plan_ yet, though 😆

                                                                                                                                                      Greg Pfeil @sellout@2017-03-08T15:35:27.027Z
*sigh* Gitter just loses messages when you’re on flaky wifi …

                                                                                                                                                      Greg Pfeil @sellout@2017-03-08T15:36:20.432Z
Anyway … Mu/Nu override cata/ana, so part of this refactoring is to use those overridden versions more often, avoiding the non-stack-safe hylo.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-08T15:36:50.677Z
That’s why things like `gcata` are implemented in terms of `cata` instead of `ghylo`, even though it means duplicating some of the `ghylo` complexity.

                                                                                                                                                      Olivier Mélois @Baccata@2017-03-08T15:38:05.443Z
and that's why Fix should be avoided in general I suppose 

                                                                                                                                                      Greg Pfeil @sellout@2017-03-08T15:48:12.290Z
Yeah – I don’t think you can implement Fix in Idris (without `partial`) 😄

                                                                                                                                                      Jonathan @b-studios@2017-03-08T20:17:33.122Z
@sellout RE [`elgotAna`](https://github.com/slamdata/matryoshka/pull/69#issuecomment-285141160) I think maybe could work like:

```scala
def elgotAna[N[_]: Monad, A](
  a: A)(
  k: DistributiveLaw[N, Base], ψ: ElgotCoalgebra[N, Base, A])(
implicit BF: Functor[Base]):
  T = {
    val f: N[Base[A]] => Base[N[Base[A]]] =
      nfa => {
        val fna = k(nfa)
        BF.map(fna) { na => na.flatMap {
          a => ψ(a)
        }}
      }
    ana(ψ(a))(f)
  }
```
Disclaimer: I haven't tested it myself, yet (and the code is quite sketchy).

                                                                                                                                                      Jonathan @b-studios@2017-03-08T21:20:22.545Z
@sellout Or a bit shorter:
```scala
... = ana(ψ(a)) { nfa => k(nfa) ∘ { _ >>= ψ } }
```
Just checked against the `MatryoshkaSpecs` test suite and it seems to work.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-08T21:23:16.167Z
@b-studios 💯

                                                                                                                                                      Jonathan @b-studios@2017-03-08T21:27:09.706Z
(`elgotCata` should be trivially dual :) )

                                                                                                                                                      Greg Pfeil @sellout@2017-03-08T21:29:50.840Z
@b-studios Clever approach, BTW – I just kept getting stuck on “how do I use an `F` that’s different than `Base`?”

                                                                                                                                                      Greg Pfeil @sellout@2017-03-08T21:30:33.708Z
We have the same problem with `anaM`, BTW, if you’re looking for work 😆

                                                                                                                                                      Greg Pfeil @sellout@2017-03-08T21:30:58.097Z
You’re planning to add the elgot bits to your current PR?

                                                                                                                                                      Jonathan @b-studios@2017-03-08T21:35:25.531Z
Yes, I am planning to do this. But I dont' manage before tomorrow, I fear.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-08T21:35:37.910Z
@b-studios Oh, no rush. Just curious.

                                                                                                                                                      Jonathan @b-studios@2017-03-08T21:57:05.827Z
@sellout I am pretty sure this can be expressed more concisely, but here is the code for `elgotCata`:

```scala
g(cata[W[Base[A]]](t) { fwfa => k(fwfa ∘ { _ cobind g }) })
```

                                                                                                                                                      Jonathan @b-studios@2017-03-08T21:57:43.256Z
Maybe I misunderstood you before: Should I add these as part of the PR?

                                                                                                                                                      Greg Pfeil @sellout@2017-03-08T22:06:05.573Z
@b-studios Yeah, feel free to add it, or open another one, or tell me to just do it myself 😄 as long as it gets in there somehow.

                                                                                                                                                      Jonathan @b-studios@2017-03-08T22:19:40.214Z
@sellout Ok, I'll try to do it tomorrow.

                                                                                                                                                      Jonathan @b-studios@2017-03-08T22:19:41.167Z
 Btw, I am not sure `anaM` is possible. How would you distribute the monad over base? The `coalgebraM` gives us `A => M[Base[A]]` but `ana` takes `B => Base[B]` (for some B). So somehow we need to get the monad into base. With the `elgot` variants we have the distributive law for that purpose.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-08T22:34:20.999Z
Yeah, exactly. ¯\\\_(ツ)_/¯ So for now (in my PR) I have it implemented in terms of `hyloM`. Better than nothing. Maybe it’s something that’ll work with adjoint folds, like pre/postpro and mutu.

                                                                                                                                                      Paul Phillips @paulp@2017-03-08T23:40:31.263Z
@b-studios I feel like it can be done. Given the `A => M[Base[A]]` you need to fuse `M` and `Base` into one functor e.g. `type MB[X] = M[Base[X]]` and then obtain a `Corecursive` instance for that, which I haven't worked out how to do but I think should be possible to derive from the functor and the monad. In other words when you call `ana` it will be on a different instance, and `Base` will mean a different type. In the new instance , what was here a `CoalgebraM` is just a `Coalgebra`.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-09T00:00:54.154Z
@paulp Yeah, I did implement `kleisliCorecursive` and manage to do that. The problem was then I couldn’t figure out how to get it to take advantage of the `Nu` definition of ana in that case. Like I now had a `Corecursive.Aux[M[T], (M ∘ F)]`, but I need it to use the ana from T somehow.

                                                                                                                                                      Paul Phillips @paulp@2017-03-09T00:02:54.341Z
@sellout Can we get back from Corecursive to CorecursiveT?

                                                                                                                                                      Greg Pfeil @sellout@2017-03-09T00:03:29.592Z
@paulp Nope. Not all things that are Corecursive are CorecursiveT.

                                                                                                                                                      Paul Phillips @paulp@2017-03-09T00:04:02.973Z
but, hypothetically for those that are, that would solve the problem you're describing?

                                                                                                                                                      Greg Pfeil @sellout@2017-03-09T00:05:13.591Z
I’m not sure. But if so, we could always have CorecursiveT override anaM in that way, and at least things that _are_ CorecursiveT would have anaM defined in terms of ana.

                                                                                                                                                      Paul Phillips @paulp@2017-03-09T00:06:18.350Z
I'll look at it s'more.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-09T00:06:48.850Z
That’s what I like to hear 😆

                                                                                                                                                      Alex Gryzlov @clayrat@2017-03-09T12:31:41.901Z
will https://github.com/slamdata/purescript-matryoshka be maintained in the longer run?

                                                                                                                                                      Alex Gryzlov @clayrat@2017-03-09T12:32:54.167Z
guess it's more of a question for @garyb

                                                                                                                                                      Jonathan @b-studios@2017-03-09T16:03:36.846Z
@sellout  I believe PR #69 is ready to be merged. I hope I took all your remarks into account.

                                                                                                                                                      Jonathan @b-studios@2017-03-09T16:10:43.265Z
Thanks for merging :)

                                                                                                                                                      Greg Pfeil @sellout@2017-03-09T16:11:15.532Z
Thanks for contributing! 0.17.2 should be on sonatype shortly.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-09T19:39:24.569Z
@clayrat I don’t see why it wouldn’t be. Not sure if SlamData is using it in production, but we maintain both it and the Scala version, and the Scala version is _definitely_ sticking around.

                                                                                                                                                      Alex Gryzlov @clayrat@2017-03-09T19:40:32.449Z
yeah, I'm not worried about the scala one, just curious about the ps one

                                                                                                                                                      Greg Pfeil @sellout@2017-03-09T19:41:16.672Z
I would probably support the PS one if it ended up abandoned somehow.

                                                                                                                                                      Alex Gryzlov @clayrat@2017-03-09T20:07:20.234Z
ok great!

                                                                                                                                                      Emrys Ingersoll @wemrysi@2017-03-11T00:35:29.018Z
So, I have a problem that would appear solvable via something like, for example,
```
def coalg: Coalgebra[CoEnv[Int, F, ?], Int] = ???
def grow(i: Int): Free[F, Int] = i.ana(coalg) >>= grow
```
and I am wondering if there is a way to avoid the direct monadic recursion in `grow`, I suspect there is but I haven't figured it out, any suggestions?

                                                                                                                                                      Greg Pfeil @sellout@2017-03-11T03:22:04.803Z
@wemrysi So, you could have to call `grow` an unbounded number of times, until there’s no `Int` left, right? Do you at least have some guarantee that the `Int` gets smaller?

                                                                                                                                                      Greg Pfeil @sellout@2017-03-11T03:24:42.066Z
The closest thing I can think of is `gapo`, which takes a `GCoalgebra[Int \/ ?, F, Int]` (`Int => Int \/ F[Int]`) and then takes a second `Coalgebra[F, Int]` to handle any `-\/` that was returned by the first one.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-11T03:25:05.423Z
But that only gives you one secondary step.

                                                                                                                                                      Emrys Ingersoll @wemrysi@2017-03-11T15:58:24.144Z
@sellout Yes, in practice the type isn't actually an `Int`, I should have just used a type parameter in my example as I was trying to minimize what I perceived the challenge to be, but I do have a guarantee that the recursion will stop. Maybe I'm looking for some sort of refold as the `Int` in my example is actually `(T, T)` where `Recursive.Aux[T, F]`. This may all be pointing to the fact I need to rethink the problem at hand, thanks for the `gapo` pointer, I'll have a look.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-11T16:10:50.455Z
I think my comments hold regardless of the type substituted for `Int` … in fact, “smaller” is easier to define for structural types than for `Int` :)

                                                                                                                                                      Germán Ferrari @gerferra@2017-03-16T01:03:31.811Z
Hi. Troubleshooting an error I found that matryoshka jvm artifact has scala.js dependencies ...

                                                                                                                                                      Germán Ferrari @gerferra@2017-03-16T01:04:08.703Z
The scala.js dependencies include .class files and are causing problems because sbt can't evict binary compatible versions of such libraries

                                                                                                                                                      Germán Ferrari @gerferra@2017-03-16T01:04:24.978Z
and sbt-assembly fails on merge because duplicated .class files are not equals ...  

                                                                                                                                                      Greg Pfeil @sellout@2017-03-16T01:21:23.901Z
@gerferra Ok, I don’t know much about scala.js … it seems like those deps shouldn’t be in the artifact at all, right?

                                                                                                                                                      Germán Ferrari @gerferra@2017-03-16T01:21:41.118Z
I think so

                                                                                                                                                      Germán Ferrari @gerferra@2017-03-16T01:21:56.890Z
Should I open an issue?

                                                                                                                                                      Greg Pfeil @sellout@2017-03-16T01:22:18.553Z
Sure. Thanks.

                                                                                                                                                      Germán Ferrari @gerferra@2017-03-16T01:38:02.586Z
Done :smile: 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-23T13:43:48.254Z
Don't scala.js dependencies always have .class files? Hmmmm...

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-23T13:44:10.216Z
Thought that was for autocomplete.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-23T13:47:29.483Z
@edmundnoble Issue has already been resolved – we were doing Scala.js cross-versioning wrong briefly.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-23T13:47:50.251Z
Ah righto :)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-23T13:47:55.646Z
Are you here in the crowd?

                                                                                                                                                      Greg Pfeil @sellout@2017-03-23T13:48:15.379Z
No 😢

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-23T13:48:47.936Z
Aw :'(

                                                                                                                                                      Greg Pfeil @sellout@2017-03-23T16:57:50.552Z
Was just discussing this elsewhere, but it seems like a good idea to bring up here …

                                                                                                                                                      Greg Pfeil @sellout@2017-03-23T17:00:21.245Z
We recently added `NelF[A, B] = Init(A, B) | Last(A)` (the pattern functor for `NonEmptyList`). It’s isomorphic to `(A, Option[B])`, which is a type SlamData uses elsewhere in Quasar, independently of Matryoshka. It would be great to come up with a better name for that particular functor, not so tied to `NonEmptyList` to use in both situations.

                                                                                                                                                      Valentin Kasas @vil1@2017-03-23T17:23:39.159Z
AtLeastOne  ? 

                                                                                                                                                      Greg Pfeil @sellout@2017-03-23T17:34:39.735Z
Hrmm, sounds like `OneAnd` … which could maybe be generalized to `OneAnd[F[_], A, B](head: A, tail: F[B])`? So, `OneAnd[Option, ?, ?]`

                                                                                                                                                      Valentin Kasas @vil1@2017-03-23T17:36:27.428Z
Isn't OneAnd a cats thing  ? 

                                                                                                                                                      Greg Pfeil @sellout@2017-03-23T17:36:53.661Z
But I feel like both `AtLeastOne` and `OneAnd` sound like “more of the same”, which is what I want to get away from. E.g., we have a case where it’s like `(JavaScript, Option[Expr])` where we _hopefully_ have an efficient expression to use in some contexts, but if not we can always fall back to JS.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-23T17:37:04.209Z
@vil1 Scalaz has it, too. But I _think_ it was in Cats first.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-23T17:37:31.102Z
Mmmm, in Scalaz 7.0.3 … so maybe that was first?

                                                                                                                                                      Valentin Kasas @vil1@2017-03-23T17:41:36.976Z
Well, that exceeds my ability to name things

                                                                                                                                                      Greg Pfeil @sellout@2017-03-23T17:43:19.013Z
`AndMaybe[JavaScript, Expr]` :D

                                                                                                                                                      Greg Pfeil @sellout@2017-03-23T17:43:35.288Z
`JavaScript AndMaybe Expr`

                                                                                                                                                      Greg Pfeil @sellout@2017-03-23T17:44:31.111Z
`NEL[A] = Mu[A AndMaybe ?]`

                                                                                                                                                      Valentin Kasas @vil1@2017-03-23T17:44:44.927Z
`Perhaps` Xb

                                                                                                                                                      Greg Pfeil @sellout@2017-03-23T17:49:04.544Z
Is the syntax I’m using there actually valid?

                                                                                                                                                      Valentin Kasas @vil1@2017-03-23T18:07:39.625Z
I think you can infix any type with two parameters

                                                                                                                                                      Torsten Scholak @tscholak@2017-03-23T18:07:49.805Z
yeah, this will work

                                                                                                                                                      Greg Pfeil @sellout@2017-03-27T19:23:57.005Z
@edmundnoble Did you have to make `repeatedly` a method for it to be tailrec?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-27T20:13:12.597Z
Uh... yes.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-27T20:15:14.139Z
Oh, right … because you can’t call the function returned by `repeatedly` after calling repeatedly …

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-27T20:15:45.941Z
The `tailrec` would just apply to constructing the function object otherwise, yeah.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-27T20:16:49.312Z
Well damn. It just broke a bunch of stuff in Quasar, where we do point free things with it.

                                                                                                                                                      Greg Pfeil @sellout@2017-03-27T20:18:06.878Z
I wonder if it’s worth having `@tailrec def repeatedlyʹ` and `def repeatedly(f: A => Option[A]): A => A = repeatedlyʹ(f)(_)` 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-03-27T20:41:52.286Z
Hehehe is perhaps more worth it to change the parser so eta expansion is more inferrable ;)

                                                                                                                                                      Greg Pfeil @sellout@2017-03-27T20:53:59.540Z
@edmundnoble Indeed. That’d be nice.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-03T01:12:41.816Z
With a Cats port of Matryoshka, I want to change `Algebra[F, A]` from `F[A] => A` to `F[Eval[A]] => A`. Thoughts?

                                                                                                                                                      Greg Pfeil @sellout@2017-04-03T01:14:21.465Z
or `F[Eval[A]] => Eval[A]`

                                                                                                                                                      Greg Pfeil @sellout@2017-04-03T01:17:36.180Z
Actually, I guess we can leave that case up to the algebra definer …

                                                                                                                                                      Greg Pfeil @sellout@2017-04-03T02:07:36.426Z
Going through other cases, it seems that I don’t need to modify Matryoshka at all, which is good. I’ve wanted lazy algebras frequently, but without `Eval` it hasn’t really been an option (`=> A` is way too restrictive).

                                                                                                                                                      Greg Pfeil @sellout@2017-04-03T22:44:45.126Z
@edmundnoble I know you have Opinions on this – in Matryoshka, we prefer `Cord` for `Show` instances, since we may end up building big trees and don’t want to do naïve concatenation. But I know `scalaz.Cord` has problems, and there is no `cats.Cord`. So, should I just implement `Show` using `Strings` and not worry about it, or what?

                                                                                                                                                      Cody Allen @ceedubs@2017-04-03T22:53:17.398Z
take this with a grain of salt, but FWIW I suspect that for the foreseeable future strings will be faster than any sort of `Cord` on the JVM (so not specific to `scalaz.Cord`)

                                                                                                                                                      Greg Pfeil @sellout@2017-04-03T22:55:21.242Z
@ceedubs The other thing I was thinking was having a `ShowF` type class that returned something like a `List[String]`, and the show instance for `Recursive` types would require `ShowF` on the pattern functor.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-03T22:57:43.384Z
We already require a special formulation of `Show` (and `Eq`, etc.) on the pattern functors to avoid infinite recursion in implicit resolution. We currently do something like `Show ~> (Show ∘ F)`, but `Lazy[Show[A]]` and `ShowF` are other options.

                                                                                                                                                      Cody Allen @ceedubs@2017-04-03T22:58:25.207Z
would the `List` be used like a stack? You’d probably want to avoid appends

                                                                                                                                                      Greg Pfeil @sellout@2017-04-03T22:59:45.987Z
@ceedubs Oh, I imagine append would be the primary dealie.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-03T23:00:07.530Z
Look, I’ve made it this far without understanding anything about the JVM …

                                                                                                                                                      Cody Allen @ceedubs@2017-04-03T23:01:18.761Z
:)

                                                                                                                                                      Cody Allen @ceedubs@2017-04-03T23:01:36.391Z
well with `List` append it isn’t specific to the JVM, is it? append is O(n) for a singly-linked list

                                                                                                                                                      Greg Pfeil @sellout@2017-04-03T23:02:10.962Z
@ceedubs Oh, yeah, it doesn’t have to be `List` – could be `Vector` or whatever – I just didn’t want to write `Seq` 😆

                                                                                                                                                      Cody Allen @ceedubs@2017-04-03T23:02:28.276Z
gotcha :)

                                                                                                                                                      Greg Pfeil @sellout@2017-04-03T23:02:50.490Z
scalaz.Cord uses a FingerTree, right?

                                                                                                                                                      Cody Allen @ceedubs@2017-04-03T23:02:53.568Z
yeah

                                                                                                                                                      Greg Pfeil @sellout@2017-04-03T23:03:19.168Z
Is there a HAMT floating around somewhere? How does that do?

                                                                                                                                                      Cody Allen @ceedubs@2017-04-03T23:03:35.259Z
so is your collection vs straight `String` idea meant for performance reasons or to avoid stack overflows or what?

                                                                                                                                                      Cody Allen @ceedubs@2017-04-03T23:04:50.593Z
I think that the hash map in the scala std lib is a HAMT

                                                                                                                                                      Greg Pfeil @sellout@2017-04-03T23:05:13.706Z
Yeah, I just figured for performance. I don’t really mean to dive into this – was just wondering if a lot of String concatenation was the way to go for now.

                                                                                                                                                      Cody Allen @ceedubs@2017-04-03T23:05:43.934Z
sorry to send the conversation down a rabbit hole

                                                                                                                                                      Greg Pfeil @sellout@2017-04-03T23:05:54.253Z
AFAIK, you only `Show` things  for debugging anyway, right?

                                                                                                                                                      Cody Allen @ceedubs@2017-04-03T23:06:23.858Z
I just know that in some work code I used `scalaz.DList` for a log and it ended up being _pretty_ bad for performance

                                                                                                                                                      Cody Allen @ceedubs@2017-04-03T23:06:44.355Z
Are you asking about me specifically? :D

                                                                                                                                                      Greg Pfeil @sellout@2017-04-03T23:08:52.985Z
Heh, no – the, uh, general “you”.

                                                                                                                                                      Cody Allen @ceedubs@2017-04-03T23:09:26.050Z
that’s the direction that Cats attempts to steer people

                                                                                                                                                      Cody Allen @ceedubs@2017-04-03T23:10:52.123Z
a few people (including me) voted for not having it in cats at one point, but some people wanted it and it seemed to be fairly benign

                                                                                                                                                      Greg Pfeil @sellout@2017-04-03T23:12:00.787Z
Yeah, we actually tend not to use it much – for recursive stuff, we usually debug with a tree-renderer.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-03T23:15:22.715Z
@sellout Actually yes I have an opinion on this.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-03T23:15:29.906Z
Cord is not only incredibly slow, but not stack-safe.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-03T23:15:41.925Z
Vector[String] is the best solution until Steque is mainline.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-03T23:15:57.060Z
@edmundnoble And how long until Steque?

                                                                                                                                                      Greg Pfeil @sellout@2017-04-03T23:16:30.070Z
Because I already have to wait on PRs in Cats & Newts, before I can get Monocle updated, before I can get Matryoshka updated.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-03T23:16:33.146Z
2.13.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-03T23:16:36.931Z
Just Vector[String] it up.

                                                                                                                                                      Cody Allen @ceedubs@2017-04-03T23:17:04.098Z
and hopefully your users aren’t on scala 2.10 where vector concatenation is O(n^2) :cry: 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-03T23:17:11.820Z
Jesus. I really hope not.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-03T23:17:19.136Z
Didn't know that was the case.

                                                                                                                                                      Cody Allen @ceedubs@2017-04-03T23:18:25.203Z
there was a fix for 2.11. I’m not sure why it never got backported to 2.10. But I guess with pretty-printing you are _probably_ usually doing single-element appends as opposed to concatenation, which isn’t too bad

                                                                                                                                                      Greg Pfeil @sellout@2017-04-03T23:18:40.717Z
@ceedubs Oh, I tried to get Matryoshka to work on 2.10, but the compiler just silently crashes, so I gave up.

                                                                                                                                                      Cody Allen @ceedubs@2017-04-03T23:18:58.218Z
well I guess you don’t have to worry about that issue then :P

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-03T23:19:06.160Z
Eff crashes even on 2.11/2.12. Such is life.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-03T23:19:11.064Z
The compiler, that is.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-03T23:19:26.913Z
In *user code*, that is.

                                                                                                                                                      Aldo Stracquadanio @Astrac@2017-04-05T17:11:19.930Z
Hi, I am pretty curious about matryoshka and I was trying to play with it today; I boiled down my idea to a very simple example to get started, which is basically a tree defined as:

```
case class Level[T](output: String, sublevels: Seq[T])
```

Now I want to write an algebra to traverse this and create a string where the nesting is represented with indentation. My first attempt was just to run `cata` on this algebra:

```
val stringAlgebra: Algebra[Level, String] = {
  case Level(output, sublevels) => s"${output}\n${sublevels.map(l => s"\t$l").mkString("\n")}"
}
```

This didn't work because the output had at most one level of indentation; I found then the `attributeTopDown` function and I tried to use it to add the depth to each instance as in:

```
  def depth[T[_[_]], F[_]]: (Int, F[T[F]]) => Int = (i, _) => i + 1
  val x: Cofree[Level, Int] = example.attributeTopDown(0)(depth)
```

                                                                                                                                                      Aldo Stracquadanio @Astrac@2017-04-05T17:13:29.964Z
now the problem is that I have `Cofree` and I lost my `Fix[Level]`, so I can't use `cata` any more with the algebra I provided; I have an intuition that there should be some way to go from this `Cofree` to something like `Fix[LevelWithDepth]` where `LevelWithDepth` is defined as:
```
case class LevelWithDepth[T](depth: Int, output: String, sublevels: Seq[T])
```

                                                                                                                                                      Aldo Stracquadanio @Astrac@2017-04-05T17:13:49.293Z
and then define a proper algebra for this data type

                                                                                                                                                      Aldo Stracquadanio @Astrac@2017-04-05T17:14:01.268Z
does anyone have any advice on this?

                                                                                                                                                      Greg Pfeil @sellout@2017-04-05T17:18:48.542Z
@Astrac In your first example, you could “map” over all the _lines_ in each sublevel, adding `\t` to each one.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-05T17:21:23.336Z
You can also do the cata approach on your attributed Cofree, though – Just that the algebra is no longer `Level[String] => String`, but `EnvT[Int, Level, String] => String`, where `envt.run` will get you `(Int, Level[String])`, or you can extract the components with `envt.ask` and `envt.lower`, respectively.

                                                                                                                                                      Aldo Stracquadanio @Astrac@2017-04-05T22:20:19.568Z
thanks for the answer! I am not sure that I understand how to add the `\t` using map, when I build my data structure I do the following:

```
  val example = level(
    "foo",
    level("bar")
 :: level("baz",
         level("qix")
      :: level("qux") :: Nil) :: Nil)
```

This doesn't have a `map` function and if I use `unFix` I will need to do the recursion at the value level, which I would like to avoid.

                                                                                                                                                      Aldo Stracquadanio @Astrac@2017-04-05T22:22:56.487Z
about the `Cofree`, that seems to be exactly what I wanted but when I try to call `.cata` on it it seems that I can't find the proper implicit conversion. I have these imports:

```
import matryoshka._
import matryoshka.data.cofree._
import matryoshka.data.Fix
import matryoshka.implicits._
import scalaz._
import Scalaz._
```

am I missing something here?

                                                                                                                                                      Aldo Stracquadanio @Astrac@2017-04-05T23:05:50.156Z
OK, thanks to the pointer about the `EnvT` type I managed to track the missing `.cata` on cofree down to not having enabled the higher order unification flag on my build, many thanks for the help!

                                                                                                                                                      Greg Pfeil @sellout@2017-04-05T23:13:18.524Z
@Astrac Sorry, I didn’t mean a literal `map` – more `s/\n/\t\n/g`.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-05T23:14:43.050Z
I should also update the README to be clearer about the SI-2712 fix.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-05T23:16:57.256Z
Since these days most people don’t actually need the plugin, but the compiler flag.

                                                                                                                                                      Aldo Stracquadanio @Astrac@2017-04-06T16:43:06.201Z
yes, I didn't realise that even using the typelevel compiler on 2.12 it was still mandatory

                                                                                                                                                      Aldo Stracquadanio @Astrac@2017-04-06T16:44:06.158Z
I think that I have an intuition about `Cofree`, i.e. the fact that it is a generalised recursion where at each step we attach a label to the value we are recurring over

                                                                                                                                                      Aldo Stracquadanio @Astrac@2017-04-06T16:44:58.093Z
I am wondering, is there a way to get back to `Fix` from it by some algebra that takes the `EnvT`, runs it and creates some other recursive data type out of it?

                                                                                                                                                      Greg Pfeil @sellout@2017-04-06T16:47:40.681Z
@Astrac You can do `cofree.transCata(EnvT.lower)`, which is basically `cofee.cata(EnvT.lower >>> (_.embed))`

                                                                                                                                                      Greg Pfeil @sellout@2017-04-06T16:51:31.356Z
But … if you want to then do `cata` over your `Fix`, you could do `cofree.cata(deattribute(myFAlgebra))` – which is the fusion of `cofree.transCata(EnvT.lower).cata(myFAlgebra)`.

                                                                                                                                                      Aldo Stracquadanio @Astrac@2017-04-06T16:53:40.164Z
many thanks! I'll definitely need to do some research about the various bits involved, I'm sure that it's going to be fun :+1: 

                                                                                                                                                      Greg Pfeil @sellout@2017-04-06T16:54:16.656Z
It would be _really_ nice if we could automatically rewrite to get fusion (scala-meta?).

                                                                                                                                                      Paul Phillips @paulp@2017-04-07T20:07:33.624Z
@sellout https://github.com/paulp/fusion/blob/master/src/main/scala/Fusion.scala

                                                                                                                                                      Paul Phillips @paulp@2017-04-07T20:07:50.919Z
That's a demo doing it with collections map and filter. It could be put to much better use.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-08T01:21:52.769Z
@sellout people call that "final-tagless" :)

                                                                                                                                                      Greg Pfeil @sellout@2017-04-08T02:37:05.194Z
@edmundnoble I am waiting for a `matryoshka.tagless` PR 😄

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-08T02:37:19.583Z
It is actually just "remove the entire library from your dependency chain"

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-08T02:37:35.347Z
Final tagless subsumes recursion schemes and initial algebras.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-08T02:46:25.843Z
Right … so then a few questions: 1. why do you care about Matryoshka, then; 2. doesn’t final tagless make analysis more difficult; and 3. in a strongly normalizing language, would you still choose a tagless representation?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-08T02:49:21.601Z
1. is because of 2. Analysis is only made difficult by the lack of nested pattern matching, which is possible to systematically replace with stateful traversal... but is still less easy to read.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-08T02:50:06.600Z
Ok, good … as that was (probably obviously) my suspicion.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-08T02:50:10.359Z
With 3 you have an interesting question. I have personally never used tagless with anything that isn't strongly-normalizing.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-08T02:50:36.670Z
Is that not something like a termination guarantee?

                                                                                                                                                      Greg Pfeil @sellout@2017-04-08T02:50:55.708Z
Well, I meant _in_ a strongly normalizing language, not _for_ a strongly normalizing language.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-08T02:51:06.875Z
Like, Scala isn’t strongly normalizing.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-08T02:51:14.041Z
But you use tagless in Scala.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-08T02:51:45.281Z
Oh yes, I see.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-08T02:51:59.827Z
But my language “Fix” _is_ strongly normalizing. (“is” may be a stronger word than I should use 😆)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-08T02:52:00.109Z
Yes, finally tagless is also nice in that it means your programs obviously terminate.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-08T02:53:23.476Z
So I have not *used* it in a total setting, but at least that seems to be the case to me.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-08T03:06:07.225Z
Since finally tagless is just a church encoding and church encoding guarantees structural recursion or guarded corecursion terminate (i.e. see Morte)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-08T03:06:53.113Z
(http://www.haskellforall.com/2014/09/morte-intermediate-language-for-super.html)

                                                                                                                                                      Greg Pfeil @sellout@2017-04-08T03:08:36.868Z
Yeah, Morte is the target of Fix.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-08T03:08:46.045Z
OOOOOOOO

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-08T03:08:56.071Z
Sorry. Just got excited :D

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-08T03:09:01.186Z
That sounds awesome.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-08T03:30:34.346Z
I agree 😆 Need to find more time for it, though … maybe once everything is moved to Cats and I get my higher-kinded GADT PR merged into some version of scalac.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-14T23:55:59.481Z
Really wish someone would fix #44 … maybe interleaved implicits will do that.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-14T23:56:13.129Z
Yeah. Hope so.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-15T00:09:32.949Z
Ok, I thought I fixed it (at least got farther than before), but now I get a runtime `java.lang.NoSuchMethodError` …

                                                                                                                                                      Greg Pfeil @sellout@2017-04-15T00:37:24.145Z
I … I think I may have fixed it?

                                                                                                                                                      Greg Pfeil @sellout@2017-04-15T00:37:29.727Z
In a very terrible way.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-15T00:37:33.890Z
LOL

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-15T00:37:34.751Z
Oh no

                                                                                                                                                      Greg Pfeil @sellout@2017-04-15T00:37:35.351Z
Implicits everywhere!

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-15T00:37:42.912Z
Did you make an implicit which does subtyping's job?

                                                                                                                                                      Greg Pfeil @sellout@2017-04-15T00:37:53.678Z
Yes.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-15T00:37:58.437Z
A few.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-15T00:38:02.967Z
Maybe I don’t need them all …

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-15T00:38:07.167Z
Wow! And @paulp said it couldn't work! ;)

                                                                                                                                                      Greg Pfeil @sellout@2017-04-15T02:18:11.106Z
I kinda still don’t trust that it’s actually working … but it seems to be.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-15T02:18:22.555Z
This is nice. Cleans up a ton of constraints.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-15T02:18:51.925Z
And lets me override para/apo definitions for Birecursive types (i.e., almost all of them).

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-15T02:19:10.518Z
Aw *heck* yeah.

                                                                                                                                                      Paul Phillips @paulp@2017-04-15T08:14:12.869Z
I remember saying I couldn't make it work. I can't deny saying it couldn't work but I can't remember either. 

                                                                                                                                                      Greg Pfeil @sellout@2017-04-15T13:24:47.181Z
Well, today I should have a PR you can both take a look at, and _hopefully_ suggest some improvements.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-17T17:49:24.152Z
After my weekend hacking, Matryoshka only has six instances of general recursion left. Down from 40 before the weekend, and from 60+ before @paulp introduced the Recursion wart.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-17T19:42:27.721Z
**\[Jean-Remi Desjardins, SlamData Inc.\]** Only 6!? That's awesome!

                                                                                                                                                      Greg Pfeil @sellout@2017-04-18T03:28:58.753Z
@jr Hoping to get to one … or maybe zero, if I can get someone to magic me up the rewrite to auto-`hylo` `cata <<< ana`.

                                                                                                                                                      Greg Pfeil @sellout@2017-04-18T04:12:16.761Z
**\[Jean-Remi Desjardins, SlamData Inc.\]** zero!? You’ll have to explain that one to me over lunch one of these days

                                                                                                                                                      Edmund Noble @edmundnoble@2017-04-18T06:04:08.719Z
Or perhaps even in this channel ;)

                                                                                                                                                      Greg Pfeil @sellout@2017-04-19T16:53:24.739Z
Or in the docs 😄

                                                                                                                                                      Greg Pfeil @sellout@2017-04-21T15:39:36.708Z
```scala
     def fill[N, L, A]
       (n: N)
       (elem: => A)
       (implicit N: Recursive.Aux[N, Option], L: Corecursive.Aux[L, ListF[A, ?]])
         : L =
       n.transAna[L](tuple(elem))
```

                                                                                                                                                      Greg Pfeil @sellout@2017-04-21T15:39:47.405Z
No, _you’re_ overabstracting!

                                                                                                                                                      Paul Phillips @paulp@2017-05-03T06:41:16.571Z
@sellout have you read https://pdfs.semanticscholar.org/b1a0/735cb001845c1f2c260e07f68acd0ea06e30.pdf  ? If you've never seen it, you'll thank me for the pointer.

                                                                                                                                                      Greg Pfeil @sellout@2017-05-03T16:42:11.152Z
@paulp Hah, nice! The title sounds familiar, but I’m certain I haven’t read this.

                                                                                                                                                      Paul Phillips @paulp@2017-05-03T18:43:38.008Z
@sellout Published in 2003.

                                                                                                                                                      Jonathan @b-studios@2017-05-09T13:44:13.277Z
Nice, Torsten sits in the office above me but I also haven't read that paper before :)

                                                                                                                                                      Torsten Scholak @tscholak@2017-05-09T14:59:43.466Z
? oh, right, different Torsten

                                                                                                                                                      Greg Pfeil @sellout@2017-05-09T15:37:03.365Z
@tscholak Heh, yeah, I had to check after @b-studios’ comment :D

                                                                                                                                                      Torsten Scholak @tscholak@2017-05-09T15:38:35.955Z
I trust you survived your mountainkayakbike adventure?

                                                                                                                                                      Greg Pfeil @sellout@2017-05-09T15:48:53.712Z
Heh, there was no adventure yesterday – got stormy right after I got it loaded up. But _maybe_ tomorrow if the weather is ok (which it probably won’t be). I have a rafting/foraging trip planned for Friday, too, which is supposed to be sunny.

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-12T18:17:42.479Z
I've started experimenting with recursion schemes and have found them pretty useful.
I'm trying to define a recursion scheme for a more complicated infinite recursive data structure:
```scala
object example {

  case class Foo[A](f: () => A)
  case class Bar[A](f: () => A)

  def recurseFoo = Foo(() => recurseBar) // Foo[Bar[Foo[Bar[Foo[...]]]]]
  def recurseBar = Bar(() => recurseFoo) // Bar[Foo[Bar[Foo[Bar[...]]]
}
```
Obviously, the code doesn't compile.
I can't use `Fix` for this, since I have an `F[G[F[...]]]` as opposed to a single recursive type.  Does anyone have pointers on what I could use?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-12T18:18:40.842Z
`type FooBar[A] = Foo[Bar[A]]`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-12T18:19:05.284Z
Unless this is what @sellout is talking about with his mutual recursion stuff.

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-12T18:19:33.855Z
In practice, I have lots of `Foo` `Bar` types

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-12T18:20:11.061Z
so I don't think it would work out

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-12T18:20:26.414Z
but I'll give it a go and see...

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-12T18:27:57.913Z
That doesn't work - `recurseFoo` may have the recursive type on `FooBar`, but `recurseBar` has the recursive type on `BarFoo`

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-12T18:30:06.857Z
I'm guessing [this pull request](https://github.com/slamdata/matryoshka/pull/28/files) is mutual recursion?  I'll take a look at it

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-12T21:09:25.175Z
Yeah my mistake, doesn't really make sense. You need to be able to embed both Foo *and* Bar, not Foo *of* Bar.

                                                                                                                                                      Greg Pfeil @sellout@2017-05-13T03:48:37.000Z
@zainab-ali Yep – sounds like you want that pull request.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-13T04:19:24.085Z
What about `Fix` over a `Coproduct`?

                                                                                                                                                      Greg Pfeil @sellout@2017-05-13T16:35:11.267Z
@edmundnoble @zainab-ali Ah, yeah, you can use Fix over Coproduct if you don’t care about the ordering. If you need it to alternate, you need mutual recursion (if you are ok with not tracking that alternation in the types, you can still get away with Coproduct).

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-13T20:22:52.989Z
In the end I managed to change my problem such that it didn't need mutual recursion, so it's all good there for now.  Coproducts are a good idea - I'll probably go with that later.

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-13T20:24:08.382Z
I've been playing around with para for educational purposes.  I'm trying to write a factorial like [this one](https://jtobin.io/practical-recursion-schemes).  I've got this far:

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-13T20:24:40.821Z
```scala
  val toNat: Int => Nat[Int] = {
    case 0 => Zero()
    case n => Succ(n - 1)  
  }

  val toInt: Nat[Int] => Int = {
    case Zero() => 0
    case Succ(n) => n + 1
  }

  val factorial: Nat[(Fix[Nat], Int)] => Int = {
    case Zero() => 1
    case Succ((n, i)) => cata(n)(toInt) * i
  }
  def para[F[_]: Functor, A](fix: Fix[F])(galgebra: F[(Fix[F], A)] => A): A = ???
  para(ana(5)(toNat))(factorial)
```

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-13T20:26:18.988Z
`para` is easy enough to write - the signature's the same as in Matryoshka with an explicit `Fix`.

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-13T20:27:33.103Z
The problem is with `factorial`.  I can't think of a way of writing it without relying on `cata`, but that defeats the point of it, doesn't it?  After all, the algebras are supposed to be completely separate from the recursive logic, aren't they?

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-13T20:30:12.538Z
For the record, the above code works, but from the article, `factorial` should be defined based on `toInt` alone.  I'm not sure how to achieve this.

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-13T20:32:41.458Z
Are my signatures wrong?  I have a gut feeling that `factorial` should have the signature `Nat[(Nat[Int], Int)] => Int`

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-13T21:16:32.852Z
It looks like my implementation was actually correct - I just misread the article

                                                                                                                                                      Greg Pfeil @sellout@2017-05-13T21:22:47.092Z
@zainab-ali I would consider factorial and toInt to be independent. I.e, factorial should be `Nat[(Fix[Nat], Fix[Nat])] => Fix[Nat]`  – then you can do `5.ana(toNat).para(factorial).cata(toInt)` (and fusion can simplify that a bit). But, even with that you’ll use `*` and `+` on `Nat` which are also defined as folds, so I don’t think you’ll get the recursion out of there easily.

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-13T21:48:51.129Z
I'll need some time to digest that  :persevere: 

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-13T21:49:55.989Z
but I get the point

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-13T21:49:59.607Z
thanks!

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-13T22:30:52.023Z
@sellout can we get a `matryoshka-refined` with a `RecursiveT` instance for positive integers?

                                                                                                                                                      Greg Pfeil @sellout@2017-05-13T22:33:26.231Z
@edmundnoble There's an open issue, I think.

                                                                                                                                                      Greg Pfeil @sellout@2017-05-13T22:35:00.574Z
#81

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-13T22:43:42.809Z
Ooooof I see. Nice.

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-15T21:31:06.294Z
I'm trying to map over the values in binary tree defined as follows:
```scala
sealed trait BTree[A, B]
case class Leaf[A, B](value: A) extends BTree[A, B]
case class Node[A, B](l: B, r: B) extends BTree[A, B]
```
I'm mapping over it using the catamorphism:
```scala
def mapValues[A, B, F[_[_]]](f: A => B)(implicit R: CorecursiveT[F]): BTree[A, F[BTree[B, ?]]] => F[BTree[B, ?]] = ???
```

Is there a better way of doing this?  I'm wondering if there's something that could map over a general recursive data structure given some natural transformation `BTree[A, ?] ~> BTree[B, ?]`

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-18T13:54:34.798Z
I'm a bit puzzled about catamorphism composition...

If a have a recursive structure `Foo[A]`, I can compose algebras of the form `Algebra[Foo, Fix[Foo]]` together and then `cata` using the result.
This is known as the *catamorphism compose law*.  I'm guessing that I can't compose the following catamorphisms:
```scala
val fooBar: Algebra[Foo, Fix[Bar]] = ...
val barBaz: Algebra[Bar, Fix[Baz]] = ...

val fooBaz: Algebra[Foo, Fix[Baz]] = ??? // I don't think this is possible
```

In my case,  the following is also true:
```scala
type Foo[A] = BTree[Int, A]
type Bar[A] = BTree[Double, A]
type Baz[A] = BTree[String, A]
```
And the algebras are created using `mapValues` referenced from above.
So I can actually compose using function composition, but not using the catamorphism compose law.

Is there an additional constraint I could apply to the algebras to make them compose in the same way that function composition would?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-18T14:03:24.751Z
```scala
eps :: f :~> g => 
cata phi . cata (In . eps) =
cata (phi . eps)
```

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-18T14:03:50.437Z
So you're going to have to add a `andThen(Fix(_))` somewhere in there.

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-18T14:12:12.882Z
I'm guessing that's Haskell?  My Haskell is conversational at best.  I'll give it a try, if it's as simple as that.


                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-18T14:19:40.549Z
I'm still having trouble :worried: 
```scala
  def fooBar: Foo[Fix[Bar]] => Fix[Bar] = ...
  def barBaz: Bar[Fix[Baz]] => Fix[Baz] = ...

  val fixFoo: Fix[Foo] = ..
  fixFoo.cata(fooBar).cata(barBaz)

  def fooBaz: Foo[Fix[Baz]] => Fix[Baz] = ???
```

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-18T14:20:52.165Z
I'm struggling to think of an implementation of `fooBaz` that will compile

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-18T14:33:22.271Z
I don't believe algebras compose.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-18T14:33:28.097Z
That `eps` seems to be a natural transformation.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-18T14:34:02.107Z
This "cata composition law" is not something I've heard of.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-18T14:34:15.171Z
`cata` is a consumer. Two consumers cannot be fused into one.

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-18T14:35:39.962Z
Tim Williams referred to it as that, but looking at the [Bananas and Lenses paper](https://pdfs.semanticscholar.org/fec6/b29569eac1a340990bb07e90355efd2434ec.pdf), it's called the fusion law.

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-18T14:35:53.986Z
I also don't think it's possible to compose two general algebras

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-18T14:36:09.832Z
I think it only works when they have exactly the same form

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-18T14:36:27.696Z
"The Fusion Law for catamorphisms can be used to transform
the composition of a function with a catamorphism into a single catamorphism, so that
intermediate values can be avoided."

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-18T14:36:40.009Z
"A function" is not very specific.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-18T14:38:32.263Z
Sorry, haven't read this paper.

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-18T14:39:15.602Z
As yet, I lack the technical expertise to understand it

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-18T14:39:25.207Z
But I think it means:

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-18T14:42:00.812Z
```scala
def foo0: Foo[Fix[Foo]] => Fix[Foo]] = ...
def foo1: Foo[Fix[Foo]] => Fix[Foo]] = ...
fixFoo.cata(foo0).cata(foo1) 
fixFoo.cata(foo0.andThen(fix => foo1(fix.unfix)))
```

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-18T14:42:10.500Z
Yeah that makes sense to me.

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-18T14:42:55.197Z
I also don't see how composing catas of other forms will work.  I'll try making sense of it with natural transformations.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-18T14:49:15.932Z
I don't either. Good luck :)

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-18T14:51:53.276Z
I see! I can just compose the natural transformations as normal.
```scala
  def fooBar: Foo ~> Bar = ...
  def barBaz: Bar ~> Baz = ...
  val fixFoo: Fix[Foo] = ...
  fixFoo.cata[Fix[Baz]](fix => Fix(fooBar.andThen(barBaz)[Fix[Baz]](fix)))
```

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-18T14:52:12.729Z
Thanks! I'm not sure why I missed that approach :smiley: 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-18T15:19:34.750Z
Ah yeah if you've got that :D

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-18T15:20:31.985Z
I don't know in general if you can substitute algebras into fixpoint types with natural transformations.

                                                                                                                                                      Greg Pfeil @sellout@2017-05-18T22:52:00.114Z
Well, that was neat – had a recursive function that I was trying to debug ∵ infinite loop. Got frustrated, basically copy/pasted it into an Algebra, just making it compile. As far as I could tell, I fixed nothing. But I ran the tests again, everything worked.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-19T05:21:47.649Z
Hehehehe

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-19T05:21:51.811Z
That's awesome

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:07:32.503Z
hi guys

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-22T19:07:44.994Z
Ohai

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:07:59.841Z
would matryoshka be good base to implement something similar to https://github.com/paularmstrong/normalizr 

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:08:07.285Z
which in essence

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:08:31.162Z
allows to take a general graph like structure comprised of uniform entities

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:08:49.482Z
and flatten it a bit with “references"

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:09:15.362Z
in essence

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:09:22.393Z
rewrite JSON of structure

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:09:26.050Z
```
{
  "id": "123",
  "author": {
    "id": "1",
    "name": "Paul"
  },
  "title": "My awesome blog post",
  "comments": [
    {
      "id": "324",
      "commenter": {
        "id": "2",
        "name": "Nicole"
      }
    }
  ]
}
```

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-22T19:09:29.821Z
I think you can do this, using the state or update monad to manage ID generation and Cofree as the data type annotating the nodes with id's.

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:09:34.378Z
to 

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:09:38.149Z
```
{
  result: "123",
  entities: {
    "articles": { 
      "123": { 
        id: "123",
        author: "1",
        title: "My awesome blog post",
        comments: [ "324" ]
      }
    },
    "users": {
      "1": { "id": "1", "name": "Paul" },
      "2": { "id": "2", "name": "Nicole" }
    },
    "comments": {
      "324": { id: "324", "commenter": "2" }
    }
  }
}
```

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-22T19:09:53.878Z
This seems very possible to me.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-22T19:10:07.030Z
Though you will have to use macros to generate the resulting case class.

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:10:28.458Z
id generation?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-22T19:10:49.024Z
Oh the id's are in the input. Never mind, no need to generate them.

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:10:52.481Z
the library does use schemas

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:11:13.124Z
which for me perhaps can be the defined case classes

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:11:23.027Z
so, with a given set of case classes 

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:11:34.446Z
which are the types of a normaliser

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:11:48.558Z
it can instantiate internally the marshalers 

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:11:54.361Z
(thinking circe here)

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:12:53.727Z
@edmundnoble "I think you can do this, using the state or update monad to manage ID generation and Cofree as the data type annotating the nodes with id’s."

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:13:16.560Z
can you elaborate a bit, it’s like you’re speaking martian here

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:13:18.479Z
:D

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-22T19:13:49.558Z
Yeah, disregard that. This looks to be possible without matryoshka.

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:13:59.518Z
and additionally, are you saying I don’t need matryoshka?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-22T19:14:17.503Z
Just make a schema type which represents this info at the type level. 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-22T19:14:35.926Z
There's no need to introduce matryoshka here, because there is really no recursion.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-22T19:14:49.868Z
You have a fixed data depth in, and fixed data depth out.

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:15:31.053Z
ok, but what if there are case classes which link to case classes or for example instances at different levels which can be reference only once in the entities bucket?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-22T19:15:45.826Z
The case classes do not refer to themselves, though?

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:15:52.580Z
not in this example

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-22T19:16:06.169Z
I don't think you need matryoshka here. What you need is shapeless.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-22T19:16:57.731Z
You need to construct new types which are the same as the original types but with references to other case classes removed. That, shapeless can do (actually, you may also need macros)

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:17:00.917Z
to generalise the case classes?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-22T19:17:08.969Z
Exactly.

                                                                                                                                                      Srepfler Srdan @schrepfler@2017-05-22T19:18:04.257Z
ok, so I can then map on individual records and recurse at whatever level?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-22T19:35:47.574Z
Yeah, use type classes and recurse on the instances from other instances.

                                                                                                                                                      Andi Miller @andimiller@2017-05-23T23:55:21.482Z
are there any parser combinator libraries which play nicely with matryoshka?

                                                                                                                                                      Andi Miller @andimiller@2017-05-23T23:56:02.050Z
or does it rely on being defined at compile time?

                                                                                                                                                      Andi Miller @andimiller@2017-05-24T00:36:15.563Z
ah nice it worked with fastparse if I made all my parsers defs and added the T argument

                                                                                                                                                      Greg Pfeil @sellout@2017-05-24T02:03:44.582Z
@andimiller Yeah, and I’m writing some parsers that are more like `Parser ~> (Parser ∘ F)`, so you can then get a `Corecursive.Aux[T, F] => Parser[T]`

                                                                                                                                                      Greg Pfeil @sellout@2017-05-24T02:03:58.993Z
But that works with basically any parser combinators.

                                                                                                                                                      Greg Pfeil @sellout@2017-05-24T02:07:31.378Z
A nice (IMO) consequence of that is that it forces your parser to be pretty simple. I.e., you end up with an “outer” AST that aligns with your parser rules, and you can define that using a Coproduct, so you can desugar the more superficial components away.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-24T04:31:33.405Z
Or you can *pass your final tagless interpreter to your parser and fuse your parser with your compiler*

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-24T04:31:40.994Z
But that's none of my business :frog:

                                                                                                                                                      Alec Zorab @AlecZorab@2017-05-24T12:00:45.214Z
@edmundnoble come back when you can do nested pattern matches ;)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-24T13:40:41.208Z
My weakness!

                                                                                                                                                      Jonathan @b-studios@2017-05-24T15:07:40.261Z
RE: nested pattern matches. Just transform your algebra carrier to account for the match ;)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-24T15:07:55.697Z
I mean you *can* do it. It's just more complicated.

                                                                                                                                                      Jonathan @b-studios@2017-05-24T15:08:52.636Z
Yeah. I was once thinking about writing a matching language that results in a modified carrier.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-24T15:09:06.485Z
I'd use it. Just add StateT.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-24T15:09:34.731Z
(if you're doing HK-final-tagless)

                                                                                                                                                      Jonathan @b-studios@2017-05-24T15:20:15.821Z
Are you suggesting to store the pattern matching status in State?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-24T15:20:31.726Z
Yes, if you're using `F[_]`. Otherwise you'd just tuple it with your carrier.

                                                                                                                                                      Jonathan @b-studios@2017-05-24T15:21:50.985Z
Hmm, I guess I still don't fully get it. I assumed tupling would be enough since pattern matching can be performed bottom up.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-24T15:22:28.420Z
`trait FT[F[_]]` StateT over the F. `trait FT[A]` tuple with the A.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-24T15:22:35.151Z
Tupling doesn't form a monad.

                                                                                                                                                      Jonathan @b-studios@2017-05-24T15:26:24.482Z
Ah I see. Usually I don't assume apriori that F has to be a monad. Until it does :)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-24T15:29:55.690Z
True. But it also doesn't form an Applicative ;)

                                                                                                                                                      Jean-Rémi Desjardins @jedesah@2017-05-26T17:48:37.067Z
@sellout (or anyone else) What’s the recursion scheme I need in order to handle a `Let` statement in a expression language when trying to write an `eval` function. I’m thinking it’s something with an Elgot algebra but am a little stumped at what exactly I am likely to need so that I can handle the ` case Id` elegantly

                                                                                                                                                      Jean-Rémi Desjardins @jedesah@2017-05-26T17:49:27.735Z
Maybe also there is a much easier way :smile: 

                                                                                                                                                      Greg Pfeil @sellout@2017-05-26T20:24:14.030Z
Bindings are hard … it’s something that @wemrysi and I have talked about doing, with integrating the ABT and Matryoshka work.

                                                                                                                                                      Greg Pfeil @sellout@2017-05-26T20:25:21.761Z
Currently, with `Let`, I _think_ you need to use something `hylo`-y – collecting bindings on the way to the leaves, then substituting them on the way back down.

                                                                                                                                                      Greg Pfeil @sellout@2017-05-26T20:26:35.628Z
Maybe `hyloM` with `MonadState[M, Map[Identifier, Value]]`

                                                                                                                                                      Jean-Rémi Desjardins @jedesah@2017-05-27T03:51:19.672Z
@sellout @cristoph My friend Samuel has a proficiency with recursion schemes, not only was he able to explain to me what `futumorphism` probably does just by looking at the signature but he also came up with a really elegant solution to writing an `eval` function for a language AST with a `Let` binding

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-27T03:51:48.766Z
futumorphism just looks into the *future*

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-27T03:51:57.409Z
And histomorphism looks into *history*

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-27T03:52:20.216Z
The names are actually so obvious that they wrap back around and become confusing ;)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-27T03:53:10.557Z
(well, futumorphism more *creates* the future)

                                                                                                                                                      Jean-Rémi Desjardins @jedesah@2017-05-27T03:54:18.668Z
@edmundnoble Now that I am pretty sure I understand what futumorphism does I would’t say that it “looks into the future”, I find that somewhat misleading. I would formulate my intution more like it "allows you to build more then one level deep at any given step in the recursion"

                                                                                                                                                      Jean-Rémi Desjardins @jedesah@2017-05-27T03:54:45.073Z
Haha, okay, I like “create the future”  a little better :smile: 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-27T03:55:14.206Z
Hehe well, it works nicely when you combine them into a chronomorphism which can look into the past and create the future (because *time*)

                                                                                                                                                      Jean-Rémi Desjardins @jedesah@2017-05-27T03:59:22.579Z
@edmundnoble This all came about because @christoph and I were trying to wrap our heads around `chronomorphism` as a solution to this `Let` problem I mentioned earlier to @sellout  but it turns out a simple `cata` did the trick:

                                                                                                                                                      Jean-Rémi Desjardins @jedesah@2017-05-27T03:59:43.610Z
```scala
type Scope[A] = Reader[Map[Id[Nothing], Int], A]

def eval(expr: Fix[Expr]): Int =  {
  expr.cata[Scope[Int]]  {
    case NumLit(value)    => value.point[Scope]
    case Add(left, right) => (left |@| right)(_ + _)
    case Div(left, right) => (left |@| right)(_ / _)
    case Id(value)        => Reader(scope => scope(Id(value)))
    case Let(id, as, in)  => Reader(scope => in(scope + (id -> as(scope))))
  }.run(Map.empty)
}
```

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-27T04:02:00.992Z
Makes sense, though you could `cataM` it up I think as well with State and it might be clearer.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-27T04:02:09.990Z
Not sure what `Id[Nothing]` means in this case though.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-27T04:04:04.840Z
Got to admire the SlamData-style spacing.

                                                                                                                                                      Jean-Rémi Desjardins @jedesah@2017-05-27T04:04:46.655Z
@edmundnoble I don’t think you can use `cataM` because you need access to in the `Id` and `Let` case but I could be wrong

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-27T04:05:18.632Z
Not with Reader, I mean. State.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-27T04:05:35.254Z
Cause with Reader you need to be able to use `local` or some variety.

                                                                                                                                                      Jean-Rémi Desjardins @jedesah@2017-05-27T04:05:39.142Z
Also `Id[Nothing]` is just because `Id[A](value: String)` is part of the AST but for scope we really don’t care what `A`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-27T04:05:46.821Z
Ah right.

                                                                                                                                                      Jean-Rémi Desjardins @jedesah@2017-05-27T04:05:47.764Z
Ah, I see, ya perhaps!

                                                                                                                                                      Greg Pfeil @sellout@2017-05-27T05:27:23.421Z
@jedesah Ah, right – I had this discussion with @tpolecat at SBtB, too. But yeah, basically making your carrier be `B => A`  instead of `A` you can pass state top-down while folding bottom-up.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-27T05:36:28.152Z
Final-tagless style ;)

                                                                                                                                                      Rob Norris @tpolecat@2017-05-27T05:39:00.688Z
Oh great so you mention me and I show up just in time for Mr Tagless. 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-27T05:53:44.869Z
<3

                                                                                                                                                      Jean-Rémi Desjardins @jedesah@2017-05-27T13:45:34.881Z
A few people asked me after my workshop to post the solutions to the exercise problems somewhere online. I said I would upload a repo but then I was thinking I could create an `example` project in Matryoska and stick them there, seems that would be better than a random repo lying around. A few people I talked to yesterday were frustrated at the lack of examples. I’ll just go ahead and prepare a PR unless there is some strong objection

                                                                                                                                                      Greg Pfeil @sellout@2017-05-27T14:00:11.399Z
@jedesah How about adding them to the `docs` project, using tut?

                                                                                                                                                      Torsten Scholak @tscholak@2017-05-27T14:09:58.296Z
I'd be interested in the exercises without solutions :)

                                                                                                                                                      Greg Pfeil @sellout@2017-05-27T14:17:16.521Z
@tscholak Like scala-exercises (#50), or even more solution-less?

                                                                                                                                                      Torsten Scholak @tscholak@2017-05-27T14:25:51.150Z
You mean 47deg style?

                                                                                                                                                      Torsten Scholak @tscholak@2017-05-27T14:26:11.831Z
They are too easy.

                                                                                                                                                      Torsten Scholak @tscholak@2017-05-27T14:26:31.166Z
More like the red book

                                                                                                                                                      Greg Pfeil @sellout@2017-05-27T14:27:13.607Z
@tscholak Yeah, integrated with the 47deg tooling. Are they inherently easy, or are there just no “deep” exercises that have been written?

                                                                                                                                                      Greg Pfeil @sellout@2017-05-27T14:28:21.776Z
Like could red book style exercises be written using scala-exercises? If a successful answer is judged by some property tests, it seems like scale-exercises is a good mechanism (but I haven’t looked into how it works at all).

                                                                                                                                                      Torsten Scholak @tscholak@2017-05-27T14:35:06.961Z
I believe the 47deg scala exercises tend to be very easy because they give you already the right structure. You just have to prove that you understand the structure, usually by filling in a small gap in the code.

                                                                                                                                                      Torsten Scholak @tscholak@2017-05-27T14:35:54.157Z
It would be great if there were exercises that let you arrive at the structure eventually, step by step, by exploration and frustration

                                                                                                                                                      Torsten Scholak @tscholak@2017-05-27T14:38:30.942Z
I have something in mind, I can describe this later in more detail 

                                                                                                                                                      Torsten Scholak @tscholak@2017-05-27T14:38:40.384Z
I'm on my phone right now

                                                                                                                                                      Greg Pfeil @sellout@2017-05-27T14:38:41.104Z
Yeah – so is that not possible with scala-exercises? E.g., adding a new property test that needs to be satisfied at each step, forcing you to refine your implementation.

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-27T17:44:08.977Z
@jedesah I also ran a [recursion schemes workshop](https://github.com/to-ithaca/hack-the-tower-recursion-schemes/tree/master/src/main/scala/recursion) a while back :smiley:   
I'm also in the process of writing a fairly short tutorial, but it'll be more along the lines of a port of Jared Tobin's Haskell ones.  
Out of interest, what level was your audience?  I found that most people got stuck at `Fix` if they hadn't seen it before.

                                                                                                                                                      Zainab Ali @zainab-ali@2017-05-27T17:46:30.086Z
I'd also agree with having an `example` module to put these kinds of code snippets in.  

                                                                                                                                                      Raúl Raja Martínez @raulraja@2017-05-29T08:51:36.767Z
@tscholak @sellout If there is anything that need to change in Scala Exercises to adapt to a particular style that is better suited for Matryoshka let me know and we can look into it. Right now the supported style is `fill in this hole with an answer` where the answer can be any scala expression you expect a user to know based on a problem description.

                                                                                                                                                      jeremyrsmith @jeremyrsmith@2017-05-30T18:16:54.010Z
Is there any plan to allow cats instead of scalaz? Or is cats missing something that’s needed?

                                                                                                                                                      jeremyrsmith @jeremyrsmith@2017-05-30T18:17:40.861Z
finding myself in a situation with a fixpoint AST and thought I could avoid reinventing stuff

                                                                                                                                                      Valentin Kasas @vil1@2017-05-30T18:39:03.007Z
I know that a matryoshka-cats is on its way, but I've no idea of the ETA, perhaps you can find a way using https://github.com/djspiewak/shims

                                                                                                                                                      Valentin Kasas @vil1@2017-05-30T18:41:00.066Z
Dunno if anyone has attempted such thing before though

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-30T18:52:14.673Z
Fairly sure @sellout is working on it

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-30T18:52:19.672Z
It needs a couple things first

                                                                                                                                                      Edmund Noble @edmundnoble@2017-05-30T18:57:47.488Z
Cats I mean

                                                                                                                                                      Greg Pfeil @sellout@2017-05-30T20:03:00.858Z
@jeremyrsmith #74

                                                                                                                                                      Greg Pfeil @sellout@2017-05-30T20:03:44.010Z
@jeremyrsmith Ported versions of Monocle and Matryoshka are waiting for one last PR to get merged into Cats and released.

                                                                                                                                                      andy scott @andyscott@2017-05-31T05:09:01.514Z
I have a mini port of the core code to cats; its trivial to Port many missing pieces on an as needed basis

                                                                                                                                                      andy scott @andyscott@2017-05-31T05:10:27.604Z
Mini port = everything in one file, and just a few hundred lines 

                                                                                                                                                      andy scott @andyscott@2017-05-31T10:28:42.610Z
On that note… @sellout can you take a look at https://github.com/47deg/iota/issues/37 ? I want to ensure we properly attribue for the derived code we’re using.

                                                                                                                                                      Jean-Rémi Desjardins @jedesah@2017-05-31T16:44:24.498Z
I’m not good at keeping up with Gitter. I’ll try and do a better job.

@raulraja Last time I had a look at scala exercises the issue was that while you can insert an arbitrarly complex expression in the holes they are rendered very small making it awkward to expect big expressions in them or did I miss something and is the size of the input field configurable?

@sellout I'll try and add them to `docs` using `tut`.

@tscholak I can dump the exercises in `docs` (or in `examples` if that fails) with solutions. I’ll try and decouple somehow the problem statement from the solutions but if you have a better idea on how to do that, you will be more than welcome to make a PR to improve wtv I come up with.

                                                                                                                                                      Torsten Scholak @tscholak@2017-05-31T16:50:51.653Z
@jedesah that would certainly be helpful. It's hard to explain what I have in mind without reciting all of it. The thing is I have a wealth of scattered notes that I produced while I was learning this myself. I need to find the time to blog about this...

                                                                                                                                                      andy scott @andyscott@2017-06-03T12:55:23.075Z
I have a Cofree fixed point structure for `TreeF[A]` and I’d like to  transform the associated cofree value for certain nodes `FooF[A]` (and all child nodes of those nodes). Is there an obvious operation for this?

                                                                                                                                                      Greg Pfeil @sellout@2017-06-03T15:41:04.028Z
@andyscott on my phone, but you may want something like `Algebra[EnvT[Value, TreeF, ?], Boolean => Cofree[TreeF, Value]]`

                                                                                                                                                      Greg Pfeil @sellout@2017-06-03T15:41:41.525Z
Where the Boolean indicates whether you're at a child of FooF.

                                                                                                                                                      andy scott @andyscott@2017-06-04T14:39:14.408Z
@sellout Awesome. How would I apply that transformation?

                                                                                                                                                      andy scott @andyscott@2017-06-04T14:40:31.111Z
I’m still a Matryoshka/general recursion n00b.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-04T15:07:57.885Z
`_.cata(transformValue)(false)` – the `cata` returns a `Boolean => Cofree`, and at the root, you aren’t a child of FooF, so you apply it with `false`.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-04T15:11:52.825Z
@andyscott ↑

                                                                                                                                                      andy scott @andyscott@2017-06-04T15:13:26.893Z
Very cool. Conceptually this makes sense but it’s going to take me a bit to fully digest it :).

                                                                                                                                                      Yilin Wei @yilinwei@2017-06-10T11:47:15.181Z
Should I not be using the `BirecursiveT`/`RecursiveT` typeclasses and prefer writing `.Aux` per fix point structure instead?

                                                                                                                                                      Yilin Wei @yilinwei@2017-06-10T11:48:23.760Z
got the use case of doing a few `cata` transforming to different fix point data structures.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-10T15:03:08.004Z
@yilinwei Correct. The `…T` ones will eventually go away (once mutual-recursion is handled properly), and they’re much less general.

                                                                                                                                                      Yilin Wei @yilinwei@2017-06-10T15:07:52.378Z
@sellout gotcha, apologies for the question but I've got this algebra which feels wrong (it uses the stack per list element) and I was wondering if I should be using a different recusion scheme.

                                                                                                                                                      Yilin Wei @yilinwei@2017-06-10T15:07:53.856Z
https://gist.github.com/yilinwei/b2483fbf4b28b1a302169c86f73ca1ea

                                                                                                                                                      Yilin Wei @yilinwei@2017-06-10T15:09:03.987Z
The `Option` signals the root element of the list. I've got an alternate one which uses 2 cata's (one to convert to a `RoseTree`) and then a `Show` but not sure whether there's a better way of doing it.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-10T15:15:19.815Z
Ok, I see. I do tend to break things down into multiple algebras when possible – especially in the case where `A` is a function. Can you add the RoseTree version to the gist?

                                                                                                                                                      Yilin Wei @yilinwei@2017-06-10T15:16:38.079Z
https://gist.github.com/yilinwei/c1375c480b8af4e7c98670e946299883

                                                                                                                                                      Yilin Wei @yilinwei@2017-06-10T15:16:57.975Z
(hence the question about the `T` variants)

                                                                                                                                                      Yilin Wei @yilinwei@2017-06-10T15:17:38.833Z
I've got some inference headaches which is why the types are there; but it should just be embed

                                                                                                                                                      urosn @urosn@2017-06-12T18:21:44.747Z
Does anyone work with (Co)Elgot algebras?

                                                                                                                                                      Greg Pfeil @sellout@2017-06-12T18:45:46.123Z
Maaaaaaybe

                                                                                                                                                      Greg Pfeil @sellout@2017-06-12T18:46:17.958Z
Heh, I just saw the mention in scala/scala

                                                                                                                                                      urosn @urosn@2017-06-12T18:47:54.554Z
@sellout I would like to ask if you/anyone see advantages working with such structures?

                                                                                                                                                      Greg Pfeil @sellout@2017-06-12T18:49:51.218Z
@urosn Elgot in particular? They’re useful in some cases, but most of the advantages are applicable to any generalized folds. For one thing, we have fixed various bugs just by mechanically converting a directly-recursive operation to an algebra. When I was doing the conversion, I didn’t even notice the bugs, but when recompiling, suddenly pending tests were passing.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-12T18:49:59.029Z
So, not having to think about recursion is nice.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-12T18:51:27.014Z
And then there’s the composability/fusion stuff. Which, in addition to reducing number of passes over the data gives you somewhere to push some of the complexity that is removed from the algebras. E.g., if you want to compose a bunch of algebras and _one_ of them needs State, you handle lifting the others into state when you compose them. And it means the others can be used in more places.

                                                                                                                                                      urosn @urosn@2017-06-12T18:52:54.620Z
@sellout Your point is that code is cleaner, faster, and less error prone?

                                                                                                                                                      Greg Pfeil @sellout@2017-06-12T18:54:46.434Z
Yeah, although faster is with a grain of salt … in the talk I gave at Typelevel Philly last year, I kind of talked about some compiler approaches. A monolithic compiler is probably fastest, but the other aspects become much worse. Splitting it into many passes improves clarity, but loses performance. Recursion schemes, IMO, make it even cleaner than traditional many-pass, plus regains _some_ of the performance.

                                                                                                                                                      urosn @urosn@2017-06-12T18:57:06.262Z
@sellout So code is at the same speed but cleaner and less error prone?

                                                                                                                                                      Greg Pfeil @sellout@2017-06-12T18:57:58.987Z
Sure, I’ll take that :D

                                                                                                                                                      urosn @urosn@2017-06-12T18:58:00.255Z
@sellout BTW I like modular compilers because they will allow us to use macros better. You won't only develop code which will be compiled but code which will be executed during compilation.

                                                                                                                                                      urosn @urosn@2017-06-12T18:58:29.295Z
It will be new way of thinking about software development.

                                                                                                                                                      urosn @urosn@2017-06-12T19:08:10.527Z
@sellout You mentioned typelevel.org. To whom belongs that organisation (which company)?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-12T19:08:18.595Z
Typelevel

                                                                                                                                                      urosn @urosn@2017-06-12T19:09:03.847Z
@edmundnoble Typelevel company doesn'e exsist!

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-12T19:09:58.708Z
It's not part of a company. Just a community.

                                                                                                                                                      urosn @urosn@2017-06-12T19:10:20.676Z
@edmundnoble  But who is sponsoring?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-12T19:12:04.235Z
What do you mean? Typelevel is only a community. If you mean typelevel events, they all have different sponsors.

                                                                                                                                                      urosn @urosn@2017-06-12T19:13:50.366Z
@edmundnoble Ususally some community is being created/backed by one or more companies.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-12T19:15:03.729Z
Not this one. As far as I know.

                                                                                                                                                      urosn @urosn@2017-06-12T19:55:52.729Z
While I am here I would like to ask about using topological structures in software development? What do you think about it?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-12T20:02:42.651Z
I don't know of any that are useful; the notion of a monotone function and open set could be useful, but most of the applications that I encounter for topology in computer science involve reasoning about the termination of algorithms.

                                                                                                                                                      Alec Zorab @AlecZorab@2017-06-13T08:59:52.304Z
@urosn @edmundnoble more a conversation for typlevel/general, but there is actually a registered company behind typelevel, though it's only there for paperwork purposes.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-13T09:00:35.441Z
Ah, makes sense. Thanks for the info.

                                                                                                                                                      urosn @urosn@2017-06-14T21:05:40.418Z
Hi all, Is there some book explaining GRS and Trav . (ideally with examples) where I can learn from? Thanks!

                                                                                                                                                      Greg Pfeil @sellout@2017-06-15T23:37:32.906Z
I almost bought one of these today, simply for the name: http://www.aboutorchids.com/blog/2016/05/23/purple-zygo-orchids/

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-15T23:38:55.087Z
Oooooo I would

                                                                                                                                                      Greg Pfeil @sellout@2017-06-15T23:41:35.423Z
Maybe next time. I have trouble with more than one plant at a time.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-15T23:42:59.632Z
I had a Darwin orchid that I killed pretty quickly (https://en.wikipedia.org/wiki/Angraecum_sesquipedale)

                                                                                                                                                      Greg Pfeil @sellout@2017-06-15T23:43:23.750Z
I loved that story long before I cared about orchids.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-16T00:45:46.261Z
@urosn Sorry – I don’t know of any book. The matryoshka README mentions a few papers and talks.

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-06-28T17:39:32.864Z
@edmundnoble btw, I've been using your micro-matryoshka with great success =)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-28T17:39:58.272Z
Wonderful :) what exactly was in there? Just cata and Fix?

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-06-28T17:42:00.092Z
cata/M, fix, cofree (yours in cats), and transAna 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-28T17:42:43.075Z
Nice, that's one of the benefits of recursion schemes; it's one of those libraries you can use without depending on it, like lens ;)

                                                                                                                                                      Dan Di Spaltro @dispalt@2017-06-28T17:45:03.626Z
totally

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T21:41:22.833Z
o/

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T21:41:45.931Z
Hey, I hope what's remaining of this conversation reinvigorates @sellout's efforts to add mutual recursion ;)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T21:42:28.175Z
Heh... Maybe it will :p give me a minute to mess with this `Fix2` doohickey and see what happens

                                                                                                                                                      Emrys Ingersoll @wemrysi@2017-06-29T21:42:34.803Z
 I _think_ he's blocked on scalac...

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T21:42:42.170Z
Oh crap

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T21:42:49.679Z
Gotta rewrite `cata`. Should I change it to `cata2` or something?

                                                                                                                                                      Emrys Ingersoll @wemrysi@2017-06-29T21:42:51.364Z
As we have all sorts of motivation in quasar

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T21:43:08.211Z
Also @edmundnoble I checked about 2 hours ago.  He's blocked by scalac.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T21:43:11.205Z
@Jacoby6000 I would rename it to that, yes

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T21:43:13.123Z
Aw

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T21:43:33.230Z
Well, I suppose this is just another usecase

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T21:44:16.700Z
Well, this doesn't feel right at all.
`    def cata2[B, C](f: QueryValue[A, B, C] => (B, C)): (B, C) =`

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T21:44:48.672Z
Oh... will it take two algebras now?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T21:45:40.793Z
I think one algebra returning (B, C) and two algebras returning respectively a B and a C are going to work out the same here

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T21:46:18.792Z
ah, i see.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T21:46:36.989Z
glad my intuition was correct, even if it felt wrong :) 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T21:49:09.653Z
No, two separate algebras definitely makes more sense

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T21:49:17.428Z
(at least, here)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T21:49:45.484Z
maybe... I'm not sure what the return type would be

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T21:51:27.118Z
Either?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T21:55:59.981Z
I think (B, C) makes sense here

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T21:56:07.040Z
Actually

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T21:56:16.863Z
Uh actually yes, I'd say Either makes more sense

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T21:59:56.818Z
Problem seems to be that you end up with `F[A, Either[A, B]]` or `F[Either[A, B], Either[A, B]]` From there, you can't really do anything, so the function cant run recursively

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T22:00:01.540Z
I'm not sure if the first or second one is right, but neither are really useful

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T22:04:12.990Z
Yeah

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T22:04:18.433Z
I think the mutual recursion stuff is needed :/

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T22:04:27.602Z
If you're willing to look at the PR for ideas

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T22:04:34.834Z
I'll do that

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T22:04:55.938Z
In any case, I've probably multiplied my understanding of ASTs, Free, Fix, and CoFree about 10 fold in the last few days.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T22:05:17.536Z
:+1: :+1: :+1: :+1: 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T22:14:27.619Z
I don't think I'll ever stare insanity in the eyes so closely ever again

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T22:14:34.898Z
this mutually recursive stuff is mind-boggling

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T22:20:00.554Z
LOL

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T22:20:02.574Z
I agree

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T22:24:03.624Z
@sellout's name must be alluding to the way he sold his soul to the devil to be able to parse and understand these things. 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T22:26:42.962Z
I think he studied under Robert Harper, which *may* be analogous ;)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T22:31:34.873Z
does there exist a type equality for `F[_] =:= G[_]` ?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T22:31:44.911Z
Not in the stdlib

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T22:32:38.363Z
:thumbsup: 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T22:32:58.684Z
You can make one

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T22:33:12.240Z
fs2 has one


                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T22:33:13.009Z
I'm going to make sure it's necessary first.. I might not need it

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T22:33:18.283Z
Okeys

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T22:33:33.175Z
```scala
trait Sub1[F[_], G[_]] {
  def subst[T[_[_]](tfa: T[F]): T[G]
}
```

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T22:46:54.621Z
Alright, so I think I've almost got something.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T22:46:58.914Z
I have 
```scala
  trait Foo[A, B, C]
  implicit def hax[A, B, C](implicit ev: B =:= QueryComparison[B, C], ev2: C  =:= QueryValue[A, B, C]) =
    new Foo[A, QueryComparison[B, C], QueryValue[A, B, C]] {}
```

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T22:47:19.217Z
meaning, I've got the mutual recursion proof.. Now I just need to figure out how to expand B and C.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T22:48:32.149Z
ehh. gotta through fix in there

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T23:15:40.255Z
@edmundnoble I think it's going to work... For some reason, scala is okay with this
```
  type QC[A] = Fix[QueryComparison[A, ?]]
  type QV[A] = Fix[QueryValue[A, QC[QV[A]], ?]]
```

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T23:15:48.564Z
Before I thought that would just fail..

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T23:15:54.953Z
Working on getting types to infer

                                                                                                                                                      Emrys Ingersoll @wemrysi@2017-06-29T23:22:15.615Z
I didn't think you could construct a recursive alias like that...

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T23:22:39.304Z
I didn't either. Maybe I'm going crosseyed reading this weird errors

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T23:23:17.455Z
oh, yup.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T23:23:24.548Z
```
[error] /Users/jacobbarber/projects/scoobie/core/src/main/scala/scoobie/ast.scala:282: illegal cyclic reference involving type QV
[error]   type QV[A] = Fix[QueryValue[A, QC[QV[A]], ?]]
```

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T23:23:32.002Z
I thought something was weird.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T23:24:21.700Z
There's gotta be a way to trick the compiler

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T23:31:35.012Z
Make a new datatype?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T23:31:42.064Z
To wrap QV

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T23:35:26.682Z
Can you give me an example?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T23:35:56.627Z
Also, admire my error https://hastebin.com/uzupohihad.rb

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T23:36:01.200Z
```scala
case class QV[A](unwrap: Fix[QueryValue[A, QC[QV[A]], ?]])
```

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T23:36:28.347Z
ah

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T23:37:54.895Z
So, why is that supported at the value level, but not the type level?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-29T23:39:38.161Z
Equirecursive vs isorecursive types

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T23:51:29.939Z
Doesn't seem to work, because Fix isn't wrapped in QV in the third parameter :/ 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-29T23:53:28.015Z
Oh wait, maybe I'm just dumb

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T01:16:46.927Z
WOO I THINK I DID IT

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T01:16:54.918Z
It's a bit different though

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T01:16:58.109Z
let me double check

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-30T01:17:48.450Z
Ooooo

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T02:11:55.696Z
Of all the days to not be logged into Gitter …

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T02:12:13.453Z
@Jacoby6000 Is there a beginning of this conversation somewhere else?

                                                                                                                                                      Emily Pillmore @emilypi@2017-06-30T02:12:40.132Z
nice @Jacoby6000 

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T02:13:17.980Z
And yeah, mutual recursion is blocked on Scala. I need to get back to my Scala PRs … hopefully soon. As @wemrysi mentioned, it would be very nice at work to have it.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T02:14:34.693Z
@edmundnoble I wish I’d studied under Harper. I only went to programmer trade school and dropped out.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T02:37:36.110Z
@sellout the conversation is a bit spread around #scalaz, typelevel/cats, and here :p 

@edmundnoble I think I've got a thing working, provided I can figure out how to prove this:
```scala
                    toFixedComparison: B =:= Fix[QueryComparison[C, ?]],
                    toFixedValue: C =:= Fix[QueryValue[A, B, ?]],
                    toC: Fix[QueryValue[A, B, ?]] =:= C,
                    toB: Fix[QueryComparison[C, ?]] =:= B) = {
```

I was able to get scala to be okay with the mutual recursion by never explicitly saying that things are mutually recursive, and just implying it.

Here's what I have... It's ugly and it's bad and I'm sorry.

I got around mutual recursion by replacing `Fix` for one of my ASTs with this `ANSIValue` case class (which can probably be generalized further)

```scala
  case class ANSIValue[A](unfix: QueryValue[A, Fix[QueryComparison[ANSIValue[A], ?]], ANSIValue[A]]) extends AnyVal {
    def fixed[B, C](implicit
                    toFixedComparison: B =:= Fix[QueryComparison[C, ?]],
                    toFixedValue: C =:= Fix[QueryValue[A, B, ?]],
                    toC: Fix[QueryValue[A, B, ?]] =:= C,
                    toB: Fix[QueryComparison[C, ?]] =:= B) = {

      type AST = Fix[QueryValue[A, B, ?]]
      type CMP = Fix[QueryComparison[C, ?]]

      def fixComparison(cmp: Fix[QueryComparison[ANSIValue[A], ?]]): CMP =
        Fix(cmp.f.leftMap(x => fixValue(x)).rightMap(v => fixComparison(v)))

      def fixValue(v: ANSIValue[A]): C =
        v.unfix match {
          case QueryFunction(path, args) => toC(Fix(QueryFunction(path, args.map(x => toFixedValue(fixValue(x))))))
          case QueryPathValue(p) => toC(Fix(QueryPathValue[A, B, AST](p)))
          case QueryValueBinOp(l, r, op) => toC(Fix(QueryValueBinOp(toFixedValue(fixValue(l)), toFixedValue(fixValue(r)), op)))
          case QueryParameter(p) => toC(Fix(QueryParameter[A, B, AST](p)))
          case _: QueryNull[_, _, _] => toC(Fix(QueryNull[A, B, AST]))
          case QuerySelect(table, values, joins, filter, sorts, groupings, offset, limit) =>
            toC(Fix(QuerySelect(
              QueryProjectOne(fixValue(table.selection), table.alias),
              values.map(_.map(x => toFixedValue(fixValue(x)))),
              joins.map(
                _.leftMap(x => toFixedValue(fixValue(x)))
                  .rightMap[B](x => toB(fixComparison(x)))
              ),
              fixComparison(filter),
              sorts,
              groupings,
              offset,
              limit
            )))
          }

      val fixedStuff = fixValue(this)
      toFixedValue(fixedStuff)
    }

  }
```

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T02:38:47.499Z
Now my problem is 
```
Cannot prove that B =:= scoobie.ast.Fix[[β$2$]scoobie.ast.QueryComparison[C,β$2$]].
[error]   simpleSelect.fixed.cata[String] {
```

So my efforts are still probably for nothing :p 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T02:41:07.692Z
if I can get `fixed` to work, then I'll be back in a standard mutually recursive fixed point scenario, and I can just use `cata` to start collapsing things.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T02:42:49.961Z
I'm about 99% sure that all i did was move the problem

                                                                                                                                                      Emily Pillmore @emilypi@2017-06-30T02:43:38.278Z
hahaha

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T02:47:01.887Z
I think at this point it'd be easier to just go hack on scalac >.> 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T02:47:14.890Z
That thing I made is a mess

                                                                                                                                                      Emily Pillmore @emilypi@2017-06-30T02:48:13.760Z
ANTLR plugins for mutually recursive types

                                                                                                                                                      Emily Pillmore @emilypi@2017-06-30T02:48:15.853Z
lol

                                                                                                                                                      jeremyrsmith @jeremyrsmith@2017-06-30T04:27:00.637Z
To understand recursive types, you first must understand recursive types

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T17:33:07.378Z
Damn this recursive type thing is really erking me. It's like I'm THIS CLOSE || to a solution, and the compiler just won't let me do it.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T17:33:37.886Z
@Jacoby6000 goes and looks at the scalac issues and tries to help or something

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T17:33:46.891Z
@Jacoby6000 What are you trying to do? I see a bunch of solution attempts, but no description of the problem.

                                                                                                                                                      Emily Pillmore @emilypi@2017-06-30T17:33:50.494Z
does Eta support mutually recursive types?

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T17:34:16.764Z
@emilypi In fixed-point style? If it supports GADTs, then it should.

                                                                                                                                                      Emily Pillmore @emilypi@2017-06-30T17:34:54.062Z
That’s what I’m wondering - if it supports GADTs and rankN type extensions

                                                                                                                                                      Emily Pillmore @emilypi@2017-06-30T17:36:20.938Z
i don’t know how comfy @Jacoby6000 is with it, but it might be worth it if your PR’s in aren’t going to approved anytime soon (i think they are, but if it’s teh case…)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T17:36:39.819Z
@sellout I have two structures  `QueryValue[A, B, C]`, and `QueryComparison[A, B]`.  
I want them to be mutually recursive like:

```scala
type ANSIQueryValue[A] = Fix[QueryValue[A, ANSIQueryComparison[A], ?]]
type ANSIQueryComparison[A] = Fix[QueryComparison[ANSIQueryValue[A], ?]]
```

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T17:38:19.492Z
`QueryComparison[A, B]` takes structures with shape `B` and compares values of type `A`.
`QueryValue[A, B, C]` takes values of type `A` and composes them with structures of type `C`.   type `B` is in there, because my AST has a case where a comparison can be represented in the tree.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T17:38:32.077Z
Ok, so … you mean you want them to have both _alternating_ and _self_ recursion?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T17:38:48.465Z
I suppose so.. if that's what the above implies.  That sounds right.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T17:39:12.818Z
What do the constructors from QueryValue and QueryComparison look like?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T17:40:01.717Z
https://github.com/Jacoby6000/scoobie/blob/feature/%2340-adjust-ast-to-support-fixpoint/core/src/main/scala/scoobie/ast.scala

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T17:40:12.225Z
that's the whole definition

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T17:40:26.915Z
they're both ADTs

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T17:42:14.144Z
type `B` in `QueryValue` is only used on the `QuerySelect` node

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T17:46:01.198Z
I want a type where QueryComparisons compare values of type QueryValue, and I want a QueryValue where the where/filter clauses are represented by QueryComparisons.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T17:47:33.280Z
Ok, yeah, just get my PR merged 😆

                                                                                                                                                      Emily Pillmore @emilypi@2017-06-30T17:47:52.205Z
that was a beast of a PR

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T17:47:57.256Z
@emilypi I think you misread that ;)

                                                                                                                                                      Emily Pillmore @emilypi@2017-06-30T17:48:10.809Z
aw shit

                                                                                                                                                      Emily Pillmore @emilypi@2017-06-30T17:48:12.690Z
hahaha

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T17:48:39.200Z
Might be able to play with it _next_ weekend. We’ll see.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T17:49:01.915Z
The worst part is, there was a time when it worked. Perhaps Scala 2.11.7?

                                                                                                                                                      Emily Pillmore @emilypi@2017-06-30T17:49:01.034Z
I’m in space i’m so tired - and at work haha

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T17:49:01.915Z
The worst part is, there was a time when it worked. Perhaps Scala 2.11.7?

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T17:49:35.251Z
But then Miles fixed some other piece of GADT handling, and it broke a piece of it we needed.

                                                                                                                                                      Emily Pillmore @emilypi@2017-06-30T17:49:50.720Z
was it a 2712 problem?

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T17:50:09.412Z
No – actually, Matryoshka needs the 2712 fix in order to do almost anything.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T17:51:09.785Z
If I had been more prompt in 1. getting mutual-recursion merged into Matryoshka and 2. getting Matryoshka into the community build, it would have been noticed.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T17:51:43.506Z
So you're saying that it's impossible for now :/ Is there any more work that needs to be done with the PR, or do we just need to yell at some people to merge it?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T17:51:51.645Z
Is it available in the typelevel fork?

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T17:52:05.060Z
@Jacoby6000 Well, not impossible, but impossible in a purely fixed-point approach.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T17:52:21.588Z
We hack around the lack of mutual-rec at work a bunch. There are a few techniques, each painful in their own way.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T17:52:45.396Z
If I stared at yours for a while, I could _probably_ figure out how to apply some of them.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T17:52:54.718Z
But I should really just fix scalac …

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T17:53:19.052Z
There’s some more work on the PR, but Jason has given some useful pointers. I just have to apply them.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T17:53:34.852Z
I just want it to work now :cry:  lol 

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T17:53:58.292Z
No, it’s similarly broken in the Typelevel fork. I was hoping Miles would include it, but I guess he figured there was to much left to do for it to be considered acceptable in its current state.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T17:54:28.342Z
I see.

So, after the PR, what will change that will make it possible?   If I can't have cyclic references in types, how do I even define the type?

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T17:59:14.603Z
You need to use higher-order functors, basically. Which means, roughly, instead of `QueryValue[A, B, C]`, you would have `Query[A[_], I]` and would do something like `case class QueryNot[A[_]](value: A[Value]) extends Query[A, Comparison]`

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T17:59:53.763Z
I.e., you have one big AST, and you use the `I` position in `Query` to indicate which subset of the AST can be used in each recursive position.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T18:00:56.249Z
So, `QueryNot` is a `Query[_, Comparison]`, `QueryFunction` would `extend Query[A, Value]`.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T18:01:21.704Z
Where `Value`/`Comparison`/etc. is a simple enumeration.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T18:03:54.111Z
Does that make sense at all?

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T18:08:29.647Z
In `QueryNot[A[_]](value: A[Value]) ` that means that `value` can only hold AST nodes that `extend Query[A, Value]`, so rather than having a homogenous AST, you partition it into pieces depending on which nodes are valid where. And you can actually make nodes flexible, too. Like, you could do `QueryBinOp[A[_], I](left: A[I], right: A[I], op: I) extends Query[A, I]` – so, if you build that node with Comparisons, then it’s a node of type `Query[A, Comparison]`, but if you build it with Values, then it’s of type `Query[A, Value]`, and you’ve just combined both of your BinOp nodes into one.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T18:12:28.717Z
BTW, in that case, `Value` is `QueryValueArithmeticOperator` and `Comparison` is `QueryComparisonValueOperator `. So the type does double duty both as an actual type and the partitioner.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T18:12:52.717Z
I am probably just digging a deeper hole …

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T18:14:42.085Z
This seems obvious to me now, but I know I was super-lost when I first started trying to figure it out.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:18:37.284Z
I think it makes sense. Will doing this afford me the flexibility to extend the AST? My current AST represents ANSI SQL, that's sufficient for now... but I'd like to be able to extend it at some point, so that there are supersets for postgres or mysql.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:23:39.461Z
If I were to take your suggestion about using operands as the partitioner, would that mean that the operands would just have to be subtypes of their respective trees?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:23:50.031Z
so `ArithmeticOperator` would extend `Value`?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:27:12.458Z
also, would these new `Comparison`, and `Value` classes just be traits that do nothing?

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T18:37:46.186Z
On my phone now. Can answer better later, but yes – you can use Coproduct to extend your ADT in a way that's orthogonal to the type partitioning.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:38:03.079Z
awesome :)

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T18:39:15.231Z
They could be traits that do nothing, but I was thinking you could just rename the operator traits to Value/Comparison. I think there are better options, but that was quick & dirty.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:40:23.384Z
Ah okay, so that would _work_ but I don't think I want it to behave that way. I'll start with what you've given me and refine it as my understanding improves

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:41:22.840Z
Funny thing about this is that a little ahile ago, I had the shape `F[G[_], A]` representing QueryValue and QueryComparison :p 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:41:53.665Z
Granted, I didn't do it the same way you suggested.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T18:42:11.764Z
Like, if you just made Value/Comparison unused traits, then you could define a single `sealed trait Operator[I]` with the specific objects extending `Operator[Value]` or `Operator[Comparison]`, and you would use `Operator[I]` as the parameter type in `QueryBinOp`.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:42:50.662Z
Oooooh I like that

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T18:43:15.618Z
Type indexes are fun 😄

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:43:36.446Z
That was my next question... why is it called `I`. You just answered that :p 

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T18:43:54.018Z
👍🏾

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:44:33.896Z
Should I define the Index as covariant? That makes sense in my head but I'm unsure

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T18:47:49.773Z
Heh – good question. That's on my list of things to experiment with.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:48:06.316Z
:thumbsup:  

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:48:12.424Z
I think I've ran in to my first issue

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:49:06.833Z
I've got `QueryParameter[A[_]] `, but `QueryParameter` is a leaf node that should be able to accept some other type, not an AST.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T18:49:11.425Z
We want to index using the type system for our language, so you can't construct incorrectly-typed ASTs, but we can either have a limited form of our type system, or have it be covariant.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:49:53.888Z
ah I see

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T18:51:42.136Z
You can just add another type param in that case, so you have `sealed trait Query[PARAM, REC[_], INDEX]`

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:51:47.888Z
Ah alright

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:51:51.904Z
makes senes

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:52:17.048Z
This is a new structure to me, so I'm not sure where it makes sense to tack things on just yet. I think I'm getting it though

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T18:52:53.047Z
Then with mutual recursion you would do `HFix[Query[Int, ?[_], ?]]` (for Int-typed parameters)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:53:04.959Z
HFix?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:53:12.153Z
oh i see

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T18:53:20.452Z
That's like Fix for mutual recursion.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:55:10.291Z
it's like  `case class HFix[F[_[_], _](f: F[HFix[F], F])` or something...  ( i know that's wrong, but maybe it's close. lol)

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T18:55:15.796Z
Technically, `HFix[Query[Int, ?[_], ?], Value]`, because you need to tell it what the final type of the Recursive expression will be.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:55:22.548Z
OH

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:55:28.979Z
that's what I was missing :D

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T18:55:43.121Z
Yeah, sorry. I blame my phone ;)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:55:53.299Z
`case class HFix[F[_[_], _], A](f: F[HFix[F], A])`

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T18:56:01.841Z
Boom!

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T18:57:07.546Z
You need `F[HFix[F, ?], A]`, but clearly you get it.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T18:57:20.278Z
:thumbsup: 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T19:02:50.981Z
Once I do all this legwork, I understand that it still wont work, because scalac.. but, are there proper ways to build catamorphisms for these shapes?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T19:33:01.763Z
What wonderful compiler errors I have!

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T19:45:04.600Z
I think I've got it. 
```scala
  type ANSIQuery[A] = HFix[Query[A, ?[_], ?], A]
```
compiles and stuff.
Updated [here](https://github.com/Jacoby6000/scoobie/blob/feature/%2340-adjust-ast-to-support-fixpoint/core/src/main/scala/scoobie/ast.scala)


                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T19:47:47.081Z
Going to try to tackle cata

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T19:53:32.898Z
You can find `cata` etc. here: https://github.com/slamdata/matryoshka/pull/28/files

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T19:53:46.581Z
Note that basically all the folds, etc. are now NaturalTransformations.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T19:54:37.762Z
kind-projector has a nice syntax for defining them, like `λ[F ~> G](fa => ???)` rather than actually having to define a new instance and declare the apply method, etc.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T19:55:09.976Z
I have a ton of changes to that PR that I should push, but I’ve hesitated just because I can’t really verify that it works now.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T19:55:29.282Z
Instead of λ I can just use `Lambda`, right? I haven't figured out how to type λ yet.  lol

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T19:55:38.029Z
Yep, I think that works.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T19:55:48.596Z
Definitely there is _some_ ASCII name that works.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T19:57:07.153Z
This is my second time looking at that PR, and none of it is any more clear than last time :sweat_smile:  I need to learn my vocab so I don't have to jump around a whole bunch.  All I know right now is `Algebra[F, A] === F[A] => A`. lol

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T19:58:15.719Z
Right, except for higher-kinds, it’s `Algebra[F[_[_], _], A[_]] === F[A, ?] ~> A` :D

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T19:58:46.107Z
Wouldnt that be AlgebraF then?

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T19:58:47.264Z
Same thing, but each type moves one step up the functor ladder, leaving room for the type index.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T19:58:51.589Z
or AlgebraM.. 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T19:58:55.894Z
I don't know how to name things

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T19:59:07.114Z
Yeah, we could call it that. `AlgebraM` is `F[A] => M[A]`

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T19:59:30.306Z
Isn't that just a natural transformation O_o 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T19:59:31.694Z
oh wait no

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T19:59:39.623Z
Right now it’s `matryoshka.Algebra` vs `matryoshka.mutu.Algebra` ;) It probably should have a different name.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T19:59:41.699Z
That'd just be `F ~> M`

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:00:18.219Z
AH I SEE NOW. So in my case, cata takes this higher kinded algebra, rather than the non-mutu algebra

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T20:00:29.867Z
Right – it’s still the same `F[A] => A`, but the result can be in a monad, and the fold takes care of flat mapping over it at each step.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:00:37.040Z
right, got it :)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-30T20:01:01.692Z
`T[F, ?] ~> (M of F)#l` or something?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-30T20:01:11.360Z
Where `of` is your magical compose symbol

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T20:01:14.233Z
Yeah, exactly. There should be more distinct names. Some of them are distinct, like `HFix`, but a lot just trample on the “regular” names.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:01:16.663Z
And now I see that the Algebra type parameters essentially mimics the version of Fix that you're using.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T20:01:42.280Z
@edmundnoble Yeah, that’s the higher-kinded version of `AlgebraM`.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T20:02:13.626Z
From the PR: `type AlgebraM[M[_], F[_[_], _], E[_]] = F[E, ?] ~> (M ∘ E)#λ`

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T20:03:02.576Z
You know … maybe I should revisit this PR, taking advantage of PolyKinds …

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T20:03:12.540Z
That was definitely the plan at some point.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:04:33.024Z
```scala
type of[F[_], G[_] {
  type λ[A] = F[G[A]]
}
```
correct?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-30T20:04:46.322Z
Si

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-30T20:04:57.373Z
I always just use `l` though, might change given my new unicode aliases

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:05:23.751Z
what do you mean by that?

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T20:05:30.591Z
@Jacoby6000 Did you just learn how to type lambdas? 😄

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-30T20:05:31.642Z
`type l[A]`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-30T20:05:52.256Z
(oh you need another equals sign up there to the right of `G[_]`)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:05:55.237Z
@sellout nah, I have spent years practicing, training, and honing my abilities to copy and paste.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T20:05:57.293Z
🙄

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:06:19.865Z
I can't figure it out on a mac keyboard for the life of me

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:06:31.590Z
I always want to do alt+y , but that's just yen. ¥

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T20:06:39.037Z
@Jacoby6000 The cheaty way is Cmd-Ctrl-Space

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:06:52.782Z
ƛ

                                                                                                                                                      Tristan Lohman @gatorcse@2017-06-30T20:07:05.690Z
𝝀

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T20:07:11.512Z
Actually, Unicode doesn’t know how to spell, so it’s “lamda”

                                                                                                                                                      Tristan Lohman @gatorcse@2017-06-30T20:07:18.684Z
trick is just figuring out which one works

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-30T20:07:28.906Z
Lambor λ

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:07:41.555Z
when I do cmd-ctrl-space, it gives me... "capital lambda" it looks like.  lol

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:07:54.814Z
ƛ

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-30T20:07:58.415Z
You want *lamda*

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:08:14.196Z
𝝀

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:08:21.683Z
why do I keep thinking it's a sheep?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:08:31.585Z
where did that "B" come from?

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T20:08:36.035Z
@Jacoby6000 You’re right, Unicode is wrong.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:08:39.371Z
oh

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:08:45.891Z
now i see what you're saying

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:08:48.234Z
lol

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:09:34.658Z
And now I see what you mean by you have to figure out which one works...  there's 5 or 6

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-30T20:09:54.398Z
λ this is the one true lambda

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:10:08.329Z
and what's the right way to type it?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:10:22.240Z


                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-30T20:10:46.859Z
Second from the left, on the top

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:10:49.607Z
If I don't figure it out, I'm just gonna use ¥ everywhere, and do a find/replace after. lol

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-30T20:10:50.253Z
[![image.png](https://files.gitter.im/slamdata/matryoshka/wHhj/thumb/image.png)](https://files.gitter.im/slamdata/matryoshka/wHhj/image.png)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:11:48.399Z
@Jacoby6000 does this thing https://apple.stackexchange.com/questions/230422/type-lambda-%CE%BB-on-a-mac

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T20:12:28.683Z
“greek small letter lamda”

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:25:41.873Z
So.. For my specific case, I have

```scala
  trait ~>[F[_], G[_]] {
    def apply[A](fa: F[A]): G[A]
  }

  type Algebra[F[_[_], _], E[_]] = F[E, ?] ~> E

  implicit class FixedQueryCata[T](val fixed: FixedQuery[T]) extends AnyVal {
    def cata[A[_]](f: Algebra[Query[T, ?[_], ?], A]): HFix[Query[T, ?[_], ?], ?] ~> A = {

    }
  }
```

Which means I have to define something that will, when given an Algebra, generate a natural transformation that will convert a recursive HFix'd AST to just an AST containing some values?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:26:57.644Z
I'm defining it in a funky way (inside that implicit class) just for while I learn.. It's easier for me to wrap my head around it this way

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:38:17.926Z
Ahhhh and to do that, I'm now having to pattern match on a higher order ADT, which is where the scalac patches come in

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:38:19.119Z
I see now.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:38:30.418Z
unfortunate :/ 

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T20:39:01.462Z
Bingo.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:40:11.253Z
This error is bizarre though
```
[error] /Users/jacobbarber/projects/scoobie/core/src/main/scala/scoobie/ast.scala:150: pattern var p in method apply is never used; `p@_' suppresses this warning
[error]         case p @ Parameter(_) => f(p)
```
My implementation is probably wrong, but that's definitely the wrong message

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:41:15.229Z
I'm going to try to implement it how I think it should be done, regardless of scalac's yelling

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-30T20:45:48.854Z
That is *so* bizarre.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-30T20:46:03.287Z
In all of the GADT breakage cases I know of I could make one or two casts to fix it

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:50:02.912Z
I guess that's technically a warning.. Here's everything that was wrong when I got that:

```
[error] /Users/jacobbarber/projects/scoobie/core/src/main/scala/scoobie/ast.scala:150: type mismatch;
[error]  found   : scoobie.ast.Parameter[T,[A(in class HFix)]scoobie.ast.HFix[[β$13$[_$5], γ$14$]scoobie.ast.Query[T,β$13$,γ$14$],A(in class HFix)]]
[error]  required: scoobie.ast.Query[T,A(in method cata),U]
[error]         case p @ Parameter(_) => f(p)
[error]                                    ^
[info] scoobie.ast.Parameter[T,[A(in class HFix)]scoobie.ast.HFix[[β$13$[_$5], γ$14$]scoobie.ast.Query[T,β$13$,γ$14$],A(in class HFix)]] <: scoobie.ast.Query[T,A(in method cata),U]?
[info]   A(in method cata)[_] <: scoobie.ast.HFix[[β$13$[_$5], γ$14$]scoobie.ast.Query[T,β$13$,γ$14$],_]?
[info]   false
[info] false
[error] /Users/jacobbarber/projects/scoobie/core/src/main/scala/scoobie/ast.scala:150: pattern var p in method apply is never used; `p@_' suppresses this warning
[error]         case p @ Parameter(_) => f(p)
[error]              ^
[error] two errors found
```

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-30T20:50:28.528Z
I think the first is probably the most helpful error... the second error is `false`?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:50:56.528Z
That other stuff is logs coming from the compiler AST. i think some debugging stuff.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:51:07.262Z
at least, the `info` parts are

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T20:51:48.387Z
I think it's because of 
```
        "-explaintypes",                     // Explain type errors in more detail.
```

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T21:00:10.327Z
@sellout am I on the right track here?
```scala
  implicit class FixedQueryCata[T](val fixed: FixedQuery[T]) extends AnyVal {
    def cata[A[_]](f: Algebra[Query[T, ?[_], ?], A]): HFix[Query[T, ?[_], ?], ?] ~> A = new (HFix[Query[T, ?[_], ?], ?] ~> A) {
      def apply[U](fixed: HFix[Query[T, ?[_], ?], U] ): A[U] = fixed.unfix match {
        // leaves
        case param @ Parameter(_) => f(param)
        case path @ PathValue(_)  => f(path)
        case _: Null[_, _]        => Null[T, U]

        case ValueBinOp(l, r, op) => f(ValueBinOp(l.cata(f), r.cata(f), op))
        case Function(path, args) => f(Function(path, args.map(_.cata(f))))
      }
    }
  }
```

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T21:01:40.004Z
feels right.. because each parent node needs to recursively call cata(f) until you've gotten to the leaf nodes, and then you apply the algebra to the leaf nodes to transofrm them.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T21:06:39.733Z
@Jacoby6000 Yes, except that the apply will be an algebra, so it should look like ```

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T21:07:22.551Z
```
def apply[U](fa: Query[T, A, U] ): A[U] = fa match {
```

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T21:08:34.319Z
Wait … maybe I’m missing what you’re doing here … what is `f`?

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T21:08:50.026Z
Because it looks like `f` is your algebra.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T21:09:00.337Z
yeah it is.. Sorry, I left out some context

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T21:09:04.596Z
editing..

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T21:09:13.476Z
Ok, so this apply is really your `cata`?

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T21:09:20.072Z
But specialized on this particular functor.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T21:09:45.922Z
I updated it.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T21:09:52.844Z
If you define an `HFunctor` class, like in the Matryoshka PR, then you can make an instance of it for Query, and then define a generic cata.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-06-30T21:10:11.375Z
Then HTraverse for cataM ;)

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T21:10:13.854Z
But yeah, that looks like a specialized cata.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T21:10:19.956Z
@edmundnoble Indeed :D

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T21:10:56.128Z
For now I'm just trying to wrap my head around things.. As long as the concrete case looks good, I suppose I'll go and work on HFunctor.  That'll break it down a bit and probably make it simpler, too

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T21:11:13.313Z
I'm just glad that my stuff is properly fitting together :D

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T21:19:28.783Z
It seems like to get the fullest out of this, I'd really just end up re-implementing large chunks of the mutu branch of matryoshka. lol

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T21:26:24.160Z
Yeah …

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T21:26:43.462Z
I mean, you can probably clone that branch, use it on Scala 2.11.7, and be fine.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T21:37:02.000Z
Ehhhh.... I'm trying to write a lib with crossbuilds. that'd be less than ideal.  :/ 

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T21:38:02.499Z
Yeah :/

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T21:38:31.110Z
Well, if there's some way I can help with the scalac issues, I'd love to.  Obviously I'm not expert here though :sweat_smile: 

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T21:42:12.640Z
Yeah, if you see that issue (I forget the number off the top of my head), Jason has like his own branch with an alternative approach that may be solid already – it at least needs more tests.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T21:43:11.981Z
I'll see what I can do :)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T21:44:57.554Z
Do the slamdata people get to work with stuff like this all the time?

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T21:47:27.004Z
Yup.

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T21:47:56.004Z
One of my coworkers just submitted a change to Matryoshka today. Hard to find a place in our code that doesn’t depend on it.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T21:49:48.720Z
That's awesome :o I'm glad that  there are places out there that work like this.  

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T22:01:12.072Z
I'm building retronym's branch. I'll see if my usecase works with his stuff. If it does/doesn't, I'll look in to building a minimal failing case scenario that I can try to work in to a PR for his branch or something... I've never messed with scalac directly though, so I'm not sure how all that works.  I'll dig through the contributors guide and whatnot and see what I can do


                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T22:21:15.378Z
@Jacoby6000 Awesome, thanks!

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T22:21:39.503Z
Yeah, and Miles has a great post called something like “from zero to Scalac PR in an hour”

                                                                                                                                                      Tristan Lohman @gatorcse@2017-06-30T22:50:30.853Z
Know of any companies in the Seattle area that are doing this stuff?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-06-30T23:00:07.029Z
Or the Portland area?


                                                                                                                                                      Torsten Scholak @tscholak@2017-06-30T23:13:57.870Z
Or the Toronto or Montreal area?

                                                                                                                                                      Greg Pfeil @sellout@2017-06-30T23:15:07.897Z
😂

                                                                                                                                                      andy scott @andyscott@2017-06-30T23:22:59.325Z
@gatorcse 47 degrees is in Seattle

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-01T03:17:40.296Z
@sellout, so.. if I am able to get this to work using either your fork, or retronyms, is it binary compatible with other 2.12 versions? Meaning, could I build it and then publish it to maven and let users just use regular ol 2.12.2?   This is of course assuming I have a dsl in place for building the queries, so they don't have to worry about that. 

                                                                                                                                                      Greg Pfeil @sellout@2017-07-01T04:47:32.198Z
@Jacoby6000 Yeah, it should be.

                                                                                                                                                      Zainab Ali @zainab-ali@2017-07-01T19:20:19.313Z
Does anyone know of a recursion scheme that picks out a trail in a recursive structure, from top down?  A bit like this:
```scala
  def extract[F[_], A](f: Fix[F] => Fix[F] Either A)(fix: Fix[F]): A = {
    f(fix) match {
      case Left(fix) => extract(f)(fix)
      case Right(a) => a
    }
  }
```

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-01T21:09:10.330Z
I'm not an expert.. but I think you're looking for a catamorphism (or cata). Given a Fix[F] and an algebra F[A] => A, you'll get back an A. 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-01T21:10:55.480Z
cata will traverse your tree til if finds leaf nodes, and then it'll run your algebra on it recursively to collapse the structure. 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-01T21:11:09.935Z
I think this will not fit into the shape of cata

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-01T21:11:13.646Z
@zainab-ali ^

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-01T21:12:06.361Z
This is a sort of "explore" function, which follows a "path" made of "steps" formed by `f` calls and returns the value at the end

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-01T21:13:28.111Z
I think you'd need a semigroup or something to do that, right? Because there could be multiple leafs. 

                                                                                                                                                      Zainab Ali @zainab-ali@2017-07-01T21:13:56.268Z
The key difference between this and a `cata` is that it starts at the root, and only follows a single path.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-01T21:15:18.214Z
@Jacoby6000 It returns only a single value, not a leaf

                                                                                                                                                      Zainab Ali @zainab-ali@2017-07-01T21:16:25.307Z
Is there a recursion scheme for this kind of thing?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-01T21:23:03.288Z
Not AFAIK, no.

                                                                                                                                                      Zainab Ali @zainab-ali@2017-07-01T21:25:47.289Z
I guess it doesn't need use any properties of recursion schemes whatsoever:
```scala
  def explore[B, A](f: B => B Either A)(b: B): A =
    f(b) match {
      case Left(b) => explore(f)(b)
      case Right(a) => a
    }
```
`f` then needs to know it's acting on `Fix[F]`, but I can't see a way of implementing it without that knowledge anyway

                                                                                                                                                      Zainab Ali @zainab-ali@2017-07-01T21:26:52.809Z
thanks for the insights though :smiley: 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-01T21:27:21.107Z
I think this may be related to some kind of comonad

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-01T21:27:31.969Z
Or monad

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-01T21:27:50.921Z
Oh LOL

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-01T21:27:54.230Z
This is just `tailrec`

                                                                                                                                                      Zainab Ali @zainab-ali@2017-07-01T21:28:03.886Z
yep

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-01T21:28:12.353Z
Like `tailrecM` without the `M`

                                                                                                                                                      Zainab Ali @zainab-ali@2017-07-01T21:33:49.957Z
So I can just use `tailRecM` with `Id` and it does the trick.  Thanks!

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-01T21:34:18.373Z
Welcome :)

                                                                                                                                                      Zainab Ali @zainab-ali@2017-07-01T21:42:38.304Z
@sellout any thoughts on having an examples module #86?  I have a ton of examples gathering dust

                                                                                                                                                      Greg Pfeil @sellout@2017-07-01T22:56:08.017Z
@zainab-ali Oh, I thought there was discussion on that … maybe just in my head. Yes, please!

                                                                                                                                                      Greg Pfeil @sellout@2017-07-01T23:00:57.265Z
@zainab-ali That looks like an anamorphism with `A / ?` as the functor. Aka, a partial function – check Matryoshka.instances.fixedpoint

                                                                                                                                                      Greg Pfeil @sellout@2017-07-01T23:01:30.792Z
`A \/ ?`

                                                                                                                                                      Zainab Ali @zainab-ali@2017-07-02T12:04:36.744Z
So I can use `Either` to represent a path through the data structure, with `Right` representing another node and `Left` being the leaf, and then extract the final value by folding over it.  The whole thing reduces to a hylo:
```scala
  def explore: Fix[F] => A Either Fix[F] = ???
  def merge: A Either A => A = ???
  val a: A = fix.hylo(merge, explore)
```
That's a really interesting way of thinking about it

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-03T16:44:41.263Z
@Jacoby6000 decides he's going to hang around this channel to lurk. Lots of cool stuff to learn


                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-03T16:54:20.214Z
Hm.. I just realized something. 

@sellout, if I have a mutually recursive AST, and I write a catamorphism for it, I end up with a natural transformation. From there, how do I fold it in to a single value?  I think I'm caught up in type-soup and I'm having trouble processing how that natural transformation is useful in the context of a mutually recursive AST.


                                                                                                                                                      Greg Pfeil @sellout@2017-07-03T18:49:36.947Z
@Jacoby6000 You can use `Const` – `F ~> Const[Int, ?]`. There should be an example in the tests on that branch somewhere.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-03T19:05:39.366Z
:thumbsup: 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-04T04:53:49.684Z
-snip-
I went and commented on the scala PR.

                                                                                                                                                      andy scott @andyscott@2017-07-06T05:16:24.205Z
I have a parser implemented as an unfold with using a `CoalgebraM`. I’d like to augment the parser to include some meta information— such as source positions. I was thinking of unfolding into `Cofree` instead of `Fix`. Is this a good idea? And if so, what’s the appropriate way to ammend my code?

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T14:09:53.516Z
@andyscott Yeah, that sounds right … You basically want to change from `F` to `EnvT[Pos, F, ?]` as your functor.

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T14:10:27.167Z
There is a `Birecursive.Aux[Cofree[F, A], EnvT[A, F, ?]]` instance.

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T14:12:11.861Z
@Jacoby6000 Thanks for the PR comment.

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T14:12:53.303Z
`EnvT` is in `matryoshka.patterns`.

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:04:48.476Z
@sellout awesome, thanks!

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:04:52.645Z
Naturally I have more questions, though.

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T16:05:02.432Z
@andyscott I was hoping you would :D

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:06:13.636Z
How can I go from `Fix[NodeF]` to `Cofree[NodeF, …]` where I have some constant value I want to assign to every node?

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:06:59.121Z
After that I need to select nodes of a certain type an then assign values similar to how you’ve implemented `attributedTopDown`. Except I just want to attribute down from certain nodes in the tree.

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:07:25.638Z
(Also I got the above code working from last night, but I wound up staying up a bit late :) )

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T16:08:03.990Z
for the first case: `_.transCata[Cofree[F, A]](fa => EnvT((constantVal, fa)))`

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-06T16:09:08.530Z
When building a DSL for a mutually recursive AST, should the DSL return values of `A[I]` or `AST[A[_], I]`?

                                                                                                                                                      Emily Pillmore @emilypi@2017-07-06T16:09:10.269Z
Hello, Matryoshka

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T16:11:04.960Z
@Jacoby6000 I _think_ the latter, and then you would fold that down to `A[I]`, for some `A` like `Id` or `Const[B, ?]`

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-06T16:11:45.819Z
So then the DSL should also accept values of `AST[A[_], I]`, and then do the intermediate lifting required during compositions?

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T16:12:03.509Z
@Jacoby6000 You can see the latest discussion in #typelevel/general for some related stuff.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-06T16:12:08.876Z
Oh okay :)

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T16:12:11.682Z
@Jacoby6000 I might need to see some code. I’m not sure.

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:12:54.204Z
@sellout How can I translplant all the matroyshka knowledge from your brain into mine?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-06T16:15:29.436Z
@sellout [this file](https://github.com/Jacoby6000/scoobie/blob/feature/%2340-adjust-ast-to-support-fixpoint/plugins/dsl/mild-sql-dsl/src/main/scala/scoobie/snacks/mild/sql/primitives.scala) is pretty small and represents what I'm currently doing pretty well.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-06T16:15:48.519Z
I still need to reduce the footprint of my binary operators, I know :p

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-06T16:17:49.586Z
`QueryProjection[T, A[_]]` `QueryComparison[T, A[_]]` and `QueryValue[T, A[_]]` are type aliases for `Query[T, A, IDX]`

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T16:23:23.892Z
@andyscott Hah! That is something I am trying to figure out. Maybe I can get @davegurnell to write a book on it …

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:24:36.561Z
Ha, yeah :).

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:25:13.085Z
I’m amazed at how impossibly hard this stuff is (maybe because it’s kinda hard, and encoding in Scala is ugly). But once you “get it”, it isn’t too bad.

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:25:39.326Z
The problem for me right now is I only “get” …. 15% or some other arbitrarily low percent of the codebase.

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T16:26:13.375Z
Yeah, encoding in Scala is tough, but getting better. (and there are other compiler features that will help – like interspersed implicit lists, etc.)

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T16:27:56.129Z
I really need to sit down and write some better introductory material, because you can see that basically everything in `Recursive` is defined in terms of `cata` – it’s just a matter of pushing around the extra {co}monads, and `cata` is done in terms of `hylo` by default. So you only need to understand `hylo` and the rest is free ;) It took me two years to get to that point, though 😆

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:28:34.749Z
On that note— what is the reasoning for `[Co|Bi][Rr]ecursiveT` transformers? The source mentions inference I believe, but doesn’t say much more than that.

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:30:00.929Z
It took me a 9 hour plane ride to understand the fundamentals. Maybe half of that I spent rewriting Matroshka from scratch (for Cats, making sure I understood everything) and the other half watching dumb movies as relief for my brain.

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T16:30:38.879Z
Oh, they’re not really “transformers”, that is just an abuse of the `T` suffix. Basically, `Recursive` used to be defined the way `RecursiveT` is now, and it basically allows Quasar to keep faking mutual recursion the way we have been for ages. We could fake it differently and get rid of the `*T` types, but I’d rather just get the mutual recursion stuff in and then use that for real.

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T16:30:54.121Z
So, all the `T` stuff should be ignored by other users, basically.

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:30:56.832Z
And the whole time I was reflecting back to your talk at the TL Summit in Philly.

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:31:40.024Z
Aah. And uhh… an example of my partial knowledge: what’s mutual recursion in the context of matroyshoka?

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T16:32:55.007Z
@andyscott Heh, I regret a bunch of the shortcuts I took in that talk. Was done to fit stuff in slides, but I’ve been talking people back from the fake syntax of it ever since.

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:33:37.688Z
Don’t worry, I _didn’t understand anything you said_ during that talk because I was just getting started down the FP route.

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:34:31.291Z
I should have been sitting in a basic FP talk and instead I was learning about general recursion :)

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:36:53.947Z
Returning to my question from earlier, how can I statefully top down modify the attributes of certain branches of my tree? I can select the first node in a branch just by the type of that node.

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:39:23.647Z
`attributeTopDownM` the whole tree? or is there a way to select branches before switching to some other fold?

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T16:39:40.604Z
@andyscott So, mutual recursion lets you restrict which nodes can occur in which locations in a tree. E.g., expressions vs statements, so you can have a type like
```scala
sealed abstract class AST[A[_], I]
final case class BinOp[A](op: Operator, l: A[Expression], r: A[Expression]) extends AST[A, Expression]
final case class Assign[A](name: String, A[Expression]) extends A[Statement]
final case class Block[A](stmts: List[A[Statement]], result: A[Expression]) extends A[Expression]
```

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T16:40:01.472Z
So now you have a type index that indicates whether expressions or statements can occur at each point in the tree.

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:40:10.747Z
Aah

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:40:30.049Z
That makes sense

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T16:42:51.734Z
Ok, so yeah … I would do `attributeTopDownM` over the whole tree, probably – and you might even just start that with your `Fix[F]` and have `case _ => constantValue` rather than first converting to Cofree, then updating some attributes.

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T16:45:56.412Z
`attributeTopDown` isn’t something I use, so I’m curious to see your use case. It predates Matryoshka as a recursion scheme library. I.e., I wonder if after I see what you do with it, there might be a different approach using more of the “core” transformations.

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:46:15.626Z
I can explain my exact use case and show you all the code

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T16:46:36.895Z
And you can see that even `attributeTopDown` is defined using `ana`.

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:46:58.091Z
Yep

                                                                                                                                                      andy scott @andyscott@2017-07-06T16:51:25.000Z
Semi related— is there any chance I could get you to comment on https://github.com/frees-io/iota/issues/37 regarding proper attribution of the Matroyshka based source code we’ve put together?

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T17:04:03.229Z
@andyscott Oh, thanks for mentioning. I missed that.

                                                                                                                                                      andy scott @andyscott@2017-07-06T17:10:24.108Z
Yep. Thanks @sellout.

                                                                                                                                                      andy scott @andyscott@2017-07-06T17:10:52.512Z
Everything I’ve been asking about in here has been related to work for that project :)

                                                                                                                                                      Greg Pfeil @sellout@2017-07-06T17:15:08.793Z
@andyscott Well, that’s exciting :D

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-08T19:23:19.645Z
Woo! got my DSL working. Thanks for all your help so far :) Tonight I'm going to re-build the interpreters to use `cata`, and then I'm going to work on trying to extend the AST to be able to include more nodes. I think the shape for that would be... 

```scala
type MutuCoproduct[F[_[_], _], G[_[_], _]] = {
  type 𝝀[A[_], I] = HFix[F[A, I] :+: G[A, I]]
}
```

or something... The `F[A, I] :+: G[A, I]` is wrong for sure. I think that the mutu branch includes `+^+` which might be what I need.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-08T19:38:00.654Z
And then the new AST nodes would extend their respective indexes from the base tree, and then create any new indexes that are necessary. 

                                                                                                                                                      Greg Pfeil @sellout@2017-07-08T19:39:44.545Z
Yeah, I think `^+^` is what you want. As a mnemonic, I just used `^` instead of other delimiters to mean “higher-kinded”. And glad to hear you’ve actually gotten this working :D

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-08T19:46:51.582Z
It's still a POC til the interpreters work and I can successfully extend the AST p

I'm not completely happy with the way that the DSL works, because it's got far too many implicit conversions, and the current state of retronyms branch forced me to make some architectural sacrifices (easy to undo once things are more stable). Only the core had to be built with the experimental version so far though, and that's good. I suspect my interpreters (things invoking cata) might also need it. I'm gonna try to fix the compiler myself if it causes me much more grief :sweat_smile: 

                                                                                                                                                      Greg Pfeil @sellout@2017-07-08T19:49:34.563Z
@Jacoby6000 I’ll have some time around the 16th to put some work into my Scala PRs again.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-08T21:54:04.972Z
I'll still probably poke around. I'd like to get to the point where I can at least comprehend what scalac is doing :) 

                                                                                                                                                      Greg Pfeil @sellout@2017-07-08T21:55:18.873Z
@Jacoby6000 I definitely won’t complain if you get it sorted out before I get to it 😄

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-09T00:22:30.635Z
@sellout I've started to write my interpreter, and I'm not sure this is right.

```scala
  def interpretQuery[I, F[_[_[_], _], _]]
                    (query: F[Query[T, ?[_], ?], I])
                    (implicit queryFunctor: HFunctor[QueryAST[T]#of],
                              hRecursive: HRecursive[F]): T = {
```
That's my signature.  What I don't like about it, is I don't know how I'll be able to compose this interpreters with other interpreters (interpreters for the extended versions of the AST), because I have `F[Query[...], I]`. Unless there is some way to go from `F[A ^+^ B] => F[A]`, I'm not sure how this would work.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-09T00:29:33.645Z
Ah I see. I've gotten too specific too quickly.  In the tests, you combine an algebra for both types to create an `Algebra[A ^+^ B]`

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-09T00:29:54.785Z
This is so cool. Just a week ago I said this was all madness but it's making sense :D 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-09T00:46:38.602Z
so really then... my `interpretQuery` function should be called something like `ansiAlgebra`, and it should return an `Algebra[Query[T, ?[_], ?], A]`

                                                                                                                                                      Greg Pfeil @sellout@2017-07-09T01:58:50.903Z
@Jacoby6000 👍🏾 Right on the money.

                                                                                                                                                      Greg Pfeil @sellout@2017-07-09T02:00:06.913Z
@Jacoby6000 An early mistake I made often was to immediately define `def foo = _.cata(fooAlgebra)`, rather than just exposing the algebra and composing it like that.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-09T02:31:54.586Z
sounds like the mistake I was about to make :sweat_smile: Good to know that I'm not the only one who went there first.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-09T04:12:29.923Z
Alright, ran in to a fun problem. 

So.. in SQL, whenever you have a `NULL`, you gotta do `IS NULL` rather than `= NULL`.  The way I was handling this before was checking if the left or right side of an equals comparison contained null, and then generating the query accordingly..  So the structure 
```
BinOp(left, Null, Equal)
```
would become
```
$left IS NULL
```
Now, those constructs are gone because cata works from the bottom up.  Do I just accept some parameter to define null equality so that I can do `if(isNull(right))` ? Or is there a way to define a `cata` algebra whose behavior changes based on nested constructs? 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-09T04:13:15.654Z
Bust out `para`?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-09T04:13:25.808Z
@Jacoby6000 looks up para

                                                                                                                                                      Greg Pfeil @sellout@2017-07-09T04:14:08.356Z
Yeah, funny, this same conversation came up at SlamData this week.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-09T04:14:55.920Z
Why can't I ever have new and unique problems?! :laughing: 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-09T04:15:10.971Z
Is `para` the way you guys started handling it?

                                                                                                                                                      Greg Pfeil @sellout@2017-07-09T04:17:13.540Z
Basically, if pattern-matching on your representation is easy enough, you can still use cata and just match on the already-folded bits. But if not, then para lets you match on the original AST while you fold.

                                                                                                                                                      Greg Pfeil @sellout@2017-07-09T04:17:33.416Z
So we do it both ways, depending on the structures.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-09T04:18:48.560Z
ah. my case needs para then. I'm assuming I'll need to define some sort of unapply for anything with an `HProject` instance?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-09T04:19:27.160Z
Since I don't know anything about my output representation (besides that it's semigroupal)

                                                                                                                                                      Greg Pfeil @sellout@2017-07-09T04:19:27.918Z
Ah, yes.

                                                                                                                                                      Greg Pfeil @sellout@2017-07-09T04:19:52.747Z
There is one (called `Embed`) in the non-mutu part of Matryoshka.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-09T04:20:04.471Z
:thumbsup: 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-09T04:21:16.830Z
So then.. from what I understand, para will provide you with a tuple where one side is the node currently being "visited", and the other side is the cata result from the underlying nodes?

                                                                                                                                                      Greg Pfeil @sellout@2017-07-09T04:21:57.945Z
Yep.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-09T04:22:21.197Z
Woo! This stuff gets more intuitive as you learn more of it.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-09T04:58:59.713Z
Ah dang.  I think that the compiler stuff starts to fall apart whenever you try to build the GAlgebra for it.  

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-09T05:43:36.493Z
Interestingly enough, it seems like this stuff actually didn't work even before the regression that occured. In 2.11.8, you can't define `cata`.

```
[error] /home/jbarber/projects/scoobie/core/src/main/scala/scoobie/ast.scala:216: no type parameters for method hmap: (f: scoobie.cata.~>[F,G])scoobie.cata.~>[[β$11$]F[F,β$11$],[β$12$]F[G,β$12$]] exist so that it can be applied to arguments (scoobie.cata.~>[[β$14$]T[F,β$14$],A])
[error]  --- because ---
[error] argument expression's type is not compatible with formal parameter type;
[error]  found   : scoobie.cata.~>[[β$14$]T[F,β$14$],A]
[error]  required: scoobie.cata.~>[?F,?G]
[error]           φ(HFunctor[F].hmap(cata(φ))(hproject(t)))
[error]                         ^
```

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-09T07:18:23.925Z
Yeah, definitely stuck now. Going to have to dig in to the compiler.
```
[error] /home/jbarber/projects/scoobie/plugins/dialects/ansi-sql/src/main/scala/scoobie/doobie/doo/ansi/SqlInterpreter.scala:85: constructor cannot be instantiated to expected type;
[error]  found   : scoobie.ast.Parameter[T(in class Parameter),A(in class Parameter)]
[error]  required: scoobie.ast.Query[T(in class SqlInterpreter),[β$1$](F[[A(in type of)[_], I]scoobie.ast.Query[T(in class SqlInterpreter),A(in type of),I],β$1$], T(in class SqlInterpreter)),?I1] where type ?I1 <: I (this is a GADT skolem)
[error]           case Parameter(param) => param
[error]                ^
```

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-10T19:52:43.175Z
When learning to hack on the compiler, I managed to learn how to write type lambdas.   Dear lord, thank the Heavens for Kind Projector. 

                                                                                                                                                      Greg Pfeil @sellout@2017-07-10T20:19:02.907Z
@Jacoby6000 Right?

                                                                                                                                                      Valentin Kasas @vil1@2017-07-12T08:40:20.193Z
Hi there,  before I proceed with dumber questions, here's a slightly interesting one : is there a `para <<< ana` kind of refold ?

                                                                                                                                                      Greg Pfeil @sellout@2017-07-12T13:45:48.123Z
@vil1 I don't think so, but you can use ghylo with Id and (T, ?) as N and W.

                                                                                                                                                      Greg Pfeil @sellout@2017-07-12T13:46:35.792Z
The others are basically just aliases to that, for combinations that have been given a name.

                                                                                                                                                      Valentin Kasas @vil1@2017-07-12T13:46:40.781Z
Oh yeah, of course

                                                                                                                                                      Valentin Kasas @vil1@2017-07-12T13:49:50.738Z
(modulo some `DistributiveLaw`s)

                                                                                                                                                      Valentin Kasas @vil1@2017-07-12T13:58:51.715Z
That's what I love with this channel : I spend literally hours trying to achieve something on my own, then @sellout or @edmundnoble comes up saying "you should look at XYZ" and it seems so obvious  *afterwards*

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-12T17:32:36.834Z
@vil1 preach

                                                                                                                                                      Emily Pillmore @emilypi@2017-07-12T19:47:17.070Z
Muh troeskuh

                                                                                                                                                      Valentin Kasas @vil1@2017-07-12T21:16:48.682Z
@vil1 is not sure what that meant

                                                                                                                                                      Valentin Kasas @vil1@2017-07-12T21:21:15.230Z
I'm not sure I can provide a `DistributiveLaw[(T, ?),F]` either, so I might keep my current two-step solution for the moment

                                                                                                                                                      Greg Pfeil @sellout@2017-07-12T21:21:38.255Z
@vil1 Why not? `distPara` and `distAna` already exist.

                                                                                                                                                      Valentin Kasas @vil1@2017-07-12T21:22:22.807Z
Hu

                                                                                                                                                      Valentin Kasas @vil1@2017-07-12T21:22:56.672Z
@vil1 frantically opens his laptop again

                                                                                                                                                      Valentin Kasas @vil1@2017-07-12T21:35:39.743Z
ok, so now this is like magic and I'll have a hard time sleeping on this

                                                                                                                                                      Valentin Kasas @vil1@2017-07-12T21:35:46.037Z
but thanks a lot !

                                                                                                                                                      Torsten Scholak @tscholak@2017-07-18T16:48:39.763Z
@sellout removed as member?

                                                                                                                                                      Torsten Scholak @tscholak@2017-07-18T16:55:53.505Z
https://twitter.com/sellout/status/885927741895450625

                                                                                                                                                      Torsten Scholak @tscholak@2017-07-18T16:56:10.802Z
I guess it's the truth

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-18T16:59:35.694Z
In this day and age, it's a wonder somebody as brilliant as Greg stayed at the same place for 3 years :p 

                                                                                                                                                      Sumedh Mungee @smungee@2017-07-19T01:12:00.263Z
I recently updated matryoshka from 0.19.0 and 0.21.0, and some code that used to work earlier is now broken. Here's the error

                                                                                                                                                      Sumedh Mungee @smungee@2017-07-19T01:13:42.092Z
```
SyntaxParserTree.scala:206: matryoshka.repeatedly.type does not take parameters
[error]     def translation[T[_[_]]: RecursiveT: CorecursiveT]: Expr[T[Expr]] ⇒ Expr[T[Expr]] = repeatedly(translationOpt)
```
`translationOpt` has the signature:
```
     def translationOpt[T](implicit TR: Recursive.Aux[T, Expr],
                           TC: Corecursive.Aux[T, Expr]): Expr[T] ⇒ Option[Expr[T]] = {
```

                                                                                                                                                      Sumedh Mungee @smungee@2017-07-19T01:14:04.216Z
this code works fine in 0.19.0 ^^

                                                                                                                                                      Greg Pfeil @sellout@2017-07-19T02:15:03.237Z
@smungee Ah yes – `repeatedly` changed – it now requires a type parameter for the result type, like `repeatedly[matryoshka.instances.fixedpoint.Partial[Expr[T[Expr]]]](translationOpt)`, and since it’s now properly defined as a partial function, you’ll need to either propagate that `Partial`, or use `.unsafePerformSync` on it.

                                                                                                                                                      Greg Pfeil @sellout@2017-07-19T02:18:15.613Z
Also, in v0.21, `Birecursive` should now work, so you might want to do
```scala
def translation[T](implicit T: Birecursive[T, Expr]): Expr[T] ⇒ Expr[T] =
  repeatedly[Partial[Expr[T]]](translationOpt).unsafePerformSync
```
and
```scala
def translationOpt[T](implicit T: Birecursive.Aux[T, Expr]): Expr[T] ⇒ Option[Expr[T]] = {
```

                                                                                                                                                      Sumedh Mungee @smungee@2017-07-19T04:41:03.117Z
@sellout Great, adding the `Partial` types worked. WIll also try `Birecursive`

                                                                                                                                                      Greg Pfeil @sellout@2017-07-19T04:41:16.575Z
Nice!

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:07:14.518Z
If you have a bijection on two separate ASTs, what kinds of things can you do with that?  I can imagine maybe using CoFree to annotate one of the ASTs with what its bijection with the other might be, but that only makes sense if your nodes basically have a 1:1 mapping. What kind of morphisms would you use to go between the two? 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:07:32.176Z
And how might you map the relevant parts of each AST to the nodes of the other?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:07:53.835Z
s/map/associate/g

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:17:12.081Z
A bijection means a 1:1 mapping, if I'm not mistaken.

                                                                                                                                                      Emily Pillmore @emilypi@2017-07-28T07:17:19.410Z
You probably can't do much with it, since working with a bijection would forget the structure of the syntax tree. Interested to see what others have to say

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:17:44.914Z
Bijections can't forget structure because they're invertible though, I thought

                                                                                                                                                      Emily Pillmore @emilypi@2017-07-28T07:18:14.196Z
But it's a bijection on the set of nodes, he said

                                                                                                                                                      Emily Pillmore @emilypi@2017-07-28T07:18:29.791Z
Bijections don't in general preserve structure. Isomorphisms do.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:18:56.492Z
Yeah, this definitely isn't an isomorphism, but bijection might be the wrong word. 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:19:23.772Z
Right but what structure? That'd be a property shared in common in a category you're working in

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:19:31.180Z
What do you mean by bijection then?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:19:34.404Z
Maybe give a type to it?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:20:52.654Z
I'm working on building some ASTs related to music. The AST representing a score isn't super useful to a computer, because it's all absolutes and that's painful to work with. So I'm going to make a thing to convert it in to relative pitches, where it's easier to work with. Also, chords go from being some number of independent nodes to being a single node which represents the shape of the chord.  Stuff like that 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:21:38.116Z
What do the branches in your AST look like?

                                                                                                                                                      Emily Pillmore @emilypi@2017-07-28T07:21:49.531Z
I'm sleep, will check in in the morning

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:22:14.738Z
I haven't fully developed the AST yet. I just started tonight and got in bed a few minutes ago. Right now I'm just interested in the theory 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:24:18.135Z
I think what I'm getting at is, I have two completely unique structures, however, given one you can derive the other. 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:25:50.958Z
In a recursive AST, what would the morphism between these two structures be called?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:26:12.023Z
Well, can you go the other way?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:26:45.475Z
Yes 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:27:30.411Z
Well, you have to be provided one extra piece of information (the key) but yeah given that input you can. 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:27:47.244Z
So I think what @emilypi was getting at is that if you have an isomorphism that given a single node of one AST gives you a single node of another AST that would be a... maybe isomorphism in some category, or perhaps that's the bijection

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:27:56.716Z
But overall you have an isomorphism between AST types

                                                                                                                                                      Emily Pillmore @emilypi@2017-07-28T07:29:52.867Z
it'd just end up looking like a graph automorphism i'd think

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:31:30.980Z
It's a tree, though, is there a more specific category to work in?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:31:42.334Z
Also how could it be an automorphism when it's between two different types?

                                                                                                                                                      Emily Pillmore @emilypi@2017-07-28T07:32:46.108Z
wouldn't it just be Ast -> Ast?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:33:16.527Z
From what I understand it's more a information-rich AST on the relative pitch side

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:33:23.826Z
"chords go from being some number of independent nodes to being a single node which represents the shape of the chord"

                                                                                                                                                      Emily Pillmore @emilypi@2017-07-28T07:34:14.090Z
ah shit i missed that

                                                                                                                                                      Emily Pillmore @emilypi@2017-07-28T07:35:01.406Z
I'll give it some more thought tomorrow

                                                                                                                                                      Emily Pillmore @emilypi@2017-07-28T07:35:03.205Z
it's 3am

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:35:12.851Z
`Fix[AST1] -> (key, Fix[AST2])` and `(key, Fix[AST2]) -> Fix[AST1]`

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:35:38.585Z
(On mobile so my symbols and whatnot aren't accurate because I cba)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:35:47.580Z
Yeah I mean you could consider the key and AST2 as separate, but I don't know how useful that is

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:36:24.167Z
You could annotate an AST1 with lazily evaluated subtrees converted to AST2 or something

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:36:31.995Z
The implication is that you can provide any key given the relative AST and generate an absolute AST for that key :p

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:36:40.377Z
Actually no you can't, because the key requires the entire tree if I'm not mistaken

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:37:51.611Z
Not sure what you mean by that 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:38:08.159Z
Well, do you need to see the whole absolute AST to find its key?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:39:04.855Z
Oh, no. Only the initial key matters, and that can be found in a node that should be almost surface level 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:39:35.938Z
Ohhh I see. Then yes, you could if you like annotate every node's subtrees with the subtrees converted to relative

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:39:48.594Z
But I don't see how that would be useful really

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:40:26.732Z
I mean you also have a `(AST1[Fix[AST2]], key) => Fix[AST2]`, no?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:40:27.085Z
:thumbsup: so then.. I guess this really is just a function A => B and B => A? 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:41:21.123Z
Did you mean to put AST2 inside of the AST1 Fix?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:41:31.322Z
Yeah.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:41:35.608Z
I'm not sure if I'll be able to do that yet. Intuition tells me no 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:41:53.497Z
Like you can flatten a single layer of `AST1` into the `Fix[AST2]`, given the surface key

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:42:24.803Z
Oh nvm turn that all around, that wouldn't make sense

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:43:06.021Z
`(AST2[Fix[AST1]], key) => Fix[AST1]`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:43:28.177Z
You can flatten a single layer of `AST2` because it contains enough info to give you multiple layers of `AST1`

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:43:36.960Z
Ahhhhhhhhh yes. 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:44:37.448Z
Yeah so this I think reifies the notion of "viewing" an `AST2` tree as a bunch of `AST1` layers lazily, without performing the conversion upfront

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:45:00.565Z
Lazily assuming you're not using `Fix`

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:45:13.867Z
So CoFree then? 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:45:16.738Z
You can look at currying things with `transCata` for inspiration if interested here

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:45:19.586Z
No, Mu or Nu

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:45:24.463Z
Ah okay :h 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:45:51.229Z
Cofree is just mu or nu over a pattern functor, I just don't yet understand the difference enough

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:46:25.717Z
I think you're supposed to use one to express folds and another for unfolds, and then annihilate them together and what executes at runtime is effectively a hylomorphism

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:46:32.189Z
But I would need... some verification there ;)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:46:46.617Z
:thumbsup: thanks for the insight! I'm sure I'll be back with more whenever I've solidified the ASTs. For now I need to sleep.  

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-07-28T07:46:54.906Z
I got some things to go look up in the morning 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-07-28T07:46:57.652Z
Yeah jeez me too

                                                                                                                                                      Juan Pablo Santos @jsantos17@2017-07-29T00:46:31.322Z
For each scheme that take a GAlgebra, could we have  an equivalent scheme that takes an ElgotAlgebra instead?

                                                                                                                                                      Greg Pfeil @sellout@2017-07-29T08:07:58.505Z
@jsantos17 Yep. They've been added on-demand, but they’re basically all specializations of elgotCata/elgotAna.

                                                                                                                                                      Sumedh Mungee @smungee@2017-07-31T23:44:50.321Z
Are there any examples on using trampolining with `cata`?

                                                                                                                                                      Sumedh Mungee @smungee@2017-07-31T23:45:13.458Z
Like for this test case, if I had a really huge tree, how would I make it work with trampolining?

                                                                                                                                                      Sumedh Mungee @smungee@2017-07-31T23:45:43.294Z
```
       val exp = mul(mul(num(12), mul(num(12), num(8))), mul(num(12), num(8)))
       exp.cata(height) must equal(3)
```


                                                                                                                                                      Greg Pfeil @sellout@2017-08-01T06:53:53.473Z
  @smungee I think you want to use `cataM` with `Free.Trampoline` as the M.

                                                                                                                                                      Sumedh Mungee @smungee@2017-08-01T07:07:19.600Z
@sellout Yeah I sort of guessed that, but I wasn't able to get the types to work.. Two main issues 1) cataM needs an AlgebraM, and I'm not sure how I can "lift" height to be an AlgebraM. and 2) What's the second type parameter to cataM (I guessed it should be the A that the Algebra produces, in this case height produces an Int?)

                                                                                                                                                      Sumedh Mungee @smungee@2017-08-01T07:09:48.994Z
like I tried ```exp.cataM[Trampoline, Int](f => Trampoline.delay(f.height))``` but that's obviously wrong

                                                                                                                                                      Greg Pfeil @sellout@2017-08-01T07:48:29.214Z
@smungee It’s a little awkward because of the way `height` is defined, but I think `exp.cataM(f => Trampoline.delay(height[Expr](f)))` (maybe you also need the type annotation on `cataM`, but I’d hope not).

                                                                                                                                                      Greg Pfeil @sellout@2017-08-01T07:50:07.480Z
If `height` was `def height[F[_]: Foldable](fa: F[Int]): Int`, you could do `Trampoline.delay(height(f))`, but then there might be other contexts that need to explicitly convert `height` to a function.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-01T11:06:11.474Z
Hmm, does that mean that matryoshka's schemes are stack-safe iff the target effect is stack-safe? 

                                                                                                                                                      Greg Pfeil @sellout@2017-08-01T12:16:28.242Z
@tscholak Now that you mention it … I think that it’s not. I’ve only poked at it a little, but I think you actually need to do something like `exp.hyloM(f => Trampoline.delay(height(f)), a => Trampoline.delay(a.project))` for it to be stack-safe. It was something I was waiting on the switch to Cats/Eval to experiment with more.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-01T12:36:18.615Z
Interesting, ok. Ok, cataM is implemented in terms of cata and not hyloM

                                                                                                                                                      Greg Pfeil @sellout@2017-08-01T12:37:11.813Z
Yeah … and even if it was using `hyloM`, I think it still wouldn’t work, because `Monad[Trampoline].pure` isn’t `delay` … is it?

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-01T12:37:42.388Z
Hmmm

                                                                                                                                                      Greg Pfeil @sellout@2017-08-01T12:38:39.242Z
And the reason it’s implemented in terms of `cata` is so that a Recursive instance (e.g., `Mu`) can override `cata` and that override cascades over all (well, most) folds.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-01T12:41:12.422Z
I think the monad instance for trampoline is that of Free

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-01T12:41:22.552Z
So no, it's not delay

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-01T12:50:45.164Z
This overriding is an interesting choice

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-01T12:51:25.996Z
Since cata is not the most general fold

                                                                                                                                                      Greg Pfeil @sellout@2017-08-01T12:54:21.605Z
You mean rather than say defining `gElgotCataM` and then defining all the other folds by supplying `Id` for some of the types?

                                                                                                                                                      Greg Pfeil @sellout@2017-08-01T12:54:44.101Z
But `cata` is just as general as that, it turns out.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-01T13:03:25.507Z
Hah

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-01T13:03:28.535Z
Ok

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-01T14:16:40.498Z
@sellout I guess this is witnessed by code which I could check out, but is there any deeper reason for it? for cata being as general as gElgotCataM and other monstrosities?

                                                                                                                                                      Juan Pablo Santos @jsantos17@2017-08-01T16:19:59.053Z
@sellout so we could have a function to convert a ElgotAlgebra to GAlgebra? Same with AlgebraicGTransform? I mostly ask because I'm finding the elgot generalized algebras much nicer to work than with generalized algebras. But that might be because I'm still learning Matryoshka

                                                                                                                                                      Juan Pablo Santos @jsantos17@2017-08-01T16:58:22.497Z
Also, wouldn't the be an alternative to adding more elgot generalized schemes on demand?

                                                                                                                                                      Greg Pfeil @sellout@2017-08-01T21:38:19.762Z
@jsantos17 Well, you could, but it probably wouldn’t work the way you were hoping. First, you could lower `ElgotAlgebra[W, F, A]` to `Algebra[F, W[F[A]]]`, then that could be treated as a `GAlgebra[Id, F, W[F[A]]]` … so yes – you could pass something to `gcata` that would behave the same as what you were originally passing to `elgotCata`, but it loses clarity along the way.

                                                                                                                                                      Greg Pfeil @sellout@2017-08-01T21:40:12.446Z
If we had better inference, I’d toss away most of the specialized things like `_.elgotFutu(alg)` and just use `_.elgotCata(distFutu, arg)`, but in Scala that leads to way too many type annotations (at least so far).

                                                                                                                                                      Sumedh Mungee @smungee@2017-08-02T07:24:44.649Z
@sellout Thanks!! Getting closer to getting `cataM` working with `Trampoline`, but I can't figure out the type annotations for `cataM`

                                                                                                                                                      Sumedh Mungee @smungee@2017-08-02T07:25:40.530Z
```
[error] missing parameter type
[error]         x.cataM(f ⇒ Trampoline.delay(height[Expr](f)))
[error]                 ^
```


                                                                                                                                                      Sumedh Mungee @smungee@2017-08-02T07:26:21.356Z
`cataM[Trampoline, Int]` doesn't work.. Nor does `cataM[Trampoline, Algebra[Expr, Int]]`..

                                                                                                                                                      Greg Pfeil @sellout@2017-08-02T08:03:08.289Z
@smungee What error do you get with `[Trampoline, Int]`? Same one?

                                                                                                                                                      Sumedh Mungee @smungee@2017-08-02T08:05:55.281Z
```
[error]  found   : Expr[Int]
[error]  required: scalaz.Foldable[Expr]
[error]         x.cataM[Trampoline, Int](f ⇒ Trampoline.delay(height[Expr](f)))
[error]                                                                    ^
```


                                                                                                                                                      Sumedh Mungee @smungee@2017-08-02T08:06:28.982Z
x is a `Fix[Expr]`

                                                                                                                                                      Greg Pfeil @sellout@2017-08-02T08:06:50.552Z
@smungee Ah, sorry! I think you need `height[Expr].apply(f)`.

                                                                                                                                                      Greg Pfeil @sellout@2017-08-02T08:08:54.581Z
I should really change the definition of `height`. That constraint really gets in the way if you try to call `height` directly.

                                                                                                                                                      Sumedh Mungee @smungee@2017-08-02T08:09:55.625Z
aha! that compiles, but i still see the stack overflow error.. 

                                                                                                                                                      Sumedh Mungee @smungee@2017-08-02T08:10:18.447Z
do I need `hyloM`? You said earlier, `I think you actually need to do something like exp.hyloM(f => Trampoline.delay(height(f)), a => Trampoline.delay(a.project)) for it to be stack-safe."`

                                                                                                                                                      Greg Pfeil @sellout@2017-08-02T08:10:51.741Z
@smungee Yeah, I think that’s necessary 😕

                                                                                                                                                      Sumedh Mungee @smungee@2017-08-02T08:11:01.368Z
ok let me try that

                                                                                                                                                      Sumedh Mungee @smungee@2017-08-02T08:11:22.797Z
i have a tree of height 1900, which wont really happen in production, but I'm trying to understand trampolining :)

                                                                                                                                                      Sumedh Mungee @smungee@2017-08-02T08:15:01.859Z
yep, `hyloM` works great! 

                                                                                                                                                      Greg Pfeil @sellout@2017-08-02T08:31:12.659Z
Yeah, as @tscholak said, I was hoping to figure out how to make it so “schemes are stack-safe iff the target effect is stack-safe,” but I’m not sure how to make that happen, so there may need to be trampolines everywhere, or a parallel set of folds (hey, what’s one more dimension of duplication?), or something. Or Trampoline/Eval needs to delay on `pure` …

                                                                                                                                                      Edmund Noble @edmundnoble@2017-08-02T13:55:00.770Z
I think this is a bit of a fundamental issue, unfortunately. `ContT` is in the exact same situation.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-08-02T14:01:09.768Z
So a parallel set of folds would likely be the solution.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-08-02T14:01:56.010Z
I also think there may be a stack-machine variant of `cata` which works if you have a `Traverse` instance as well and is more efficient than trampolining.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-02T17:39:27.188Z
btw @sellout I took a few swings at working on scala/scala#5744, but I'm just not familiar enough with the enigma that is scalac. Most I achieved was figuring out where the changes need to happen. I just don't really know what those changes are, and  scalac is nigh on impossible to debug..  Add to that the fact that no IDEs seem to understand it, and without getting really familiar with the codebase I'm surprised anybody gets anything done in there.  lol

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-03T22:21:23.750Z
Does Matryoshka provide anything for something like a stateful unfold?

                                                                                                                                                      Greg Pfeil @sellout@2017-08-03T22:23:38.070Z
@Jacoby6000 You can do `_.anaM[T](coalg: A => State[B, F[A]])`

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-03T22:23:57.577Z
Yup, that looks about right

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-03T22:24:00.618Z
thanks!

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-03T23:38:56.185Z
Hm... So will I just call this function and pass in the new state after every iteration? I think I may have misunderstood

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-03T23:39:38.682Z
```scala
  def unfoldMidi[F[_[_]], G[_]: Traverse](file: MidiFile)(implicit corecursive: Corecursive.Aux[F[Segment], G]) =
    file.anaM[F[Segment]].apply[State[UnfoldState, ?], G]{ file =>
      ??
    }
```
I got that so far



                                                                                                                                                      Edmund Noble @edmundnoble@2017-08-04T04:37:17.253Z
Your coalgebra will return a stateful computation (with `CoalgebraM` specialized to `State`, `A => S => (S, F[A])`)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-08-04T04:37:20.990Z
They're all chained together

                                                                                                                                                      Edmund Noble @edmundnoble@2017-08-08T12:33:19.538Z
Does it make sense to come up with a version of `Mu` and `Nu` with `para` and `apo` as primitives, like a Scott encoding?

                                                                                                                                                      Greg Pfeil @sellout@2017-08-08T12:36:18.994Z
@edmundnoble Yeah, that seems totally reasonable.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T17:47:47.150Z
Can somebody explain to me how an unfold works? I get `cata` and how an `F[A] => A` becomes useful given a recursive `F[G[F]]`, but I can't understand how an `A => F[A]` comes to be a recursive `F[G[F]]`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-08-10T18:44:54.414Z
`F[G[F]]` isn't how it looks though, it's `F[F[F[F[F[F[......]]]]]`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-08-10T18:45:02.256Z
`hylo` can be used to implement either

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T19:08:46.709Z
@edmundnoble don't you have to have a Fix or CoFree or Free or something between each of those Fs?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T19:08:52.093Z
that's why I used F[G[F]]

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T19:09:04.110Z
In any case, I still don't understand how that works :p 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-08-10T19:17:09.665Z
Oh right

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T19:20:10.599Z
@Jacoby6000 But you usually talk about `G[F]`, not `F[G[F]]` (where G is some fixed-point operator). So, when you think about `cata(alg: F[A] => A): G[F] => A`, that can be implemented as `hylo(alg, project)` (and is, in Matryoshka).

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T19:20:38.100Z
:thumbsup: 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T19:20:43.385Z
got it

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T19:20:52.507Z
So, `project` is actually a `Coalgebra[F, G[F]]` itself (`G[F] => F[G[F]]`)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T19:21:07.629Z
interesting

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T19:21:19.076Z
(coalgebra being what you use for an unfold)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T19:22:02.011Z
right... I'm trying to write an `anaM` right now, and I'm struggling to understand how `A => M[G[A]]` can wind up yielding `M[F[G]]`

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T19:22:05.575Z
Another example in Matryoshka is `Nat.fromInt: Coalgebra[Option, Int]` (ok, that’s a little more complicated because of negative numbers)

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T19:22:56.222Z
So, when you do 3.ana(Nat.fromInt), it’s actually `3.hylo(embed, Nat.fromInt)`

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T19:23:35.224Z
guess I should go try to figure out how hylo works then :p 

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T19:23:36.060Z
So, first, it does `3 => Some(2)`, then `2 => Some(1)` then `1 => Some(0)`, then `0 => None`

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T19:24:07.156Z
So you end up with a tree that looks like `Some(Some(Some(None)))` at the “halfway point” of the hylomorphism.

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T19:24:49.072Z
Then, you walk back up the tree, using `embed` at each step, so then you have `Fix(Some(Fix(Some(Fix(Some(Fix(None)))))))`

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T19:24:59.256Z
Which is `Fix[Option]`

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T19:26:45.009Z
Ah... So it takes what's inside and then performs the hylo again on whatever was inside the previous result

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T19:26:55.957Z
Yeah.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T19:27:50.604Z
hm... maybe I won't need `State` like i had thought, then. As long as I can do `F[CurrentUnfoldState]` basically.

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T19:28:25.090Z
And you end up with a tree _without_ any fixed point operator in it yet – but you can’t actually return it, because you might have some branches that are of type `F[F[Nothing]]` and others that are `F[F[F[F[Nothing]]]]` … or something like that, so you gotta use the fixed-point operator to unify all those trees of arbitrary depth before you actually return from each nested call.

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T19:28:58.160Z
@Jacoby6000 Yeah, that sounds likely.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T19:29:05.884Z
right, that part actually makes sense to me.. It was the building of a tree from an `A => F[A]` that confused me

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T19:35:04.014Z
@sellout is there some kind of convention for dealing with errors during unfolds?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T19:35:33.747Z
I'm guessing you'd use an anaM with an Either

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T19:35:44.275Z
@Jacoby6000 Yeah, exactly.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T19:35:51.530Z
:thumbsup: 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T19:37:04.433Z
Cool. This seems simple enough, now that I get it :) 

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T19:37:16.051Z
💃🏽

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T20:27:09.150Z
Oh boy. this is harder than I thought.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T20:27:12.927Z
think I actually need an apo

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T20:27:38.668Z
I need to be able to partially construct branches and then finish them off later when I get more information

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T20:27:53.972Z
also, i need to continue building partially constructed branches before they're complete

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T20:28:06.665Z
@Jacoby6000 You mean you want to emit more than one node at a time, but still have `A`s nested at some depth?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T20:30:14.382Z
No.. for example, I'll see a `NoteOn` event for a note, say.. `F`. Then after awhile, I'll receive another `NoteOn` event for `G`. A while later, I get a `NoteOff` for `G` and then after that I get `NoteOff` for `F`. I can't fully construct my node for `F`, until after the note off event, but I need that to come before the `G`. However, my `G` was ready to be fully constructed before my `F` was.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T20:31:15.535Z
Maybe I need an intermediate tree or soemthing

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T20:33:19.556Z
I'm trying to turn [this](https://github.com/Jacoby6000/maestro-midi/blob/master/core/src/main/scala/com/github/jacoby6000/maestro/midi/data.scala) in to [this](https://github.com/Jacoby6000/music-asts/blob/master/src/main/scala/com/github/jacoby6000/music/core/ast.scala)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T20:33:54.357Z
The big problem is that, one is a format which is just a stream of events with delta times, and the other has no notion of time.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T20:56:24.308Z
I was hoping an unfold would do what I want, but it seems that I was wrong :p 

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T20:57:22.082Z
@Jacoby6000 So, you have a MIDI stream, and are turning it into an AST. You see `NoteOn(F)`, and create an (incomplete) `LeafNote(F)`, then you see `NoteOn(G)` and actually want to _replace_ the `LeafNote(F)` with `Together(LeafNote(F), LeafNote(G))` (with still-undefined durations for those leaves)?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T20:57:50.328Z
essentially 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T20:57:51.797Z
yeah

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T20:57:53.604Z
Ok, cool.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T20:58:51.429Z
if they have different delta times for note on, then it'd be Sequence(LeafNote(F), LeafNote(G)) but still the same idea.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T20:59:26.680Z
I'm not 100% sure my music AST is sufficient yet.  This is the ultimate test.  lol

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T20:59:30.467Z
I mean, I don’t have a solution for you off the top of my head, but at least I see what you’re trying to do. And is this actually a _stream_ – I.e, you’re trying to handle it as it’s coming in, or are you post-processing some complete sequence of events?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T20:59:46.701Z
No, I've got a file that i've already parsed and I have all the data.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T20:59:53.275Z
so post-processing

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T21:00:05.099Z
streaming comes..... maybe never. lol

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T21:02:00.648Z
Ok, so one thing that is an option in that case is handling it as a _fold_ (which I’m not sure fixes any of your issues, but maybe gives you a new direction to think in) – a List is already recursive, so you could fold from the end of the list, making a completely subtree from each node.

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T21:02:31.353Z
But I don’t think that particularly helps either, since you start with a NoteOff and still might run into other things before you have a NoteOn for the same note.

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T21:03:34.454Z
Definitely having some other intermediate representation is an option – doing something that creates a new List with atomic note values first.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T21:03:54.033Z
yeah, that's what I'm starting to lean toward..

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T21:04:51.812Z
Not that Matryoshka supports it (yet), but once you try dealing with streaming, there is an approach called a metamorphism that might be a good fit.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T21:06:00.761Z
If i annotate those with delta times, then I can filter the List[Event] to remove all note on/off events, and then I can build a single track using `(List[(Note, Time)], List[Event]) => Music[(List[(Note, Time)], List[Event])]`, where i trim off notes and events as i go.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T21:06:34.356Z
I didn't even know you could fold partially complete structures.  that's cool

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T21:07:10.757Z
I used to work on https://opusmodus.com, so this kind of problem _should_ be in my wheelhouse.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T21:07:31.171Z
OOoooooH looks cool

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T21:07:56.716Z
that's basically what I'm trying to make, but with scala DSLs 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T21:07:58.343Z
 \>.>

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-10T21:08:39.606Z
had no idea it existed

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T21:11:12.139Z
Well, there is definitely a lot of odd stuff in that project that I’m pretty sure I would do very differently now (and if I had had more control). But it was the brainchild of this composer and it has a lot of that Lispy DWYM magic that should have been transformed away into a nice AST but never was.

                                                                                                                                                      Greg Pfeil @sellout@2017-08-10T21:11:17.093Z
But it was pretty fun, though.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-14T08:35:08.729Z
I've got a basic question. I have a structure, `T[F]` (with `T[_[_]]` a fixed point type and `F[_]` a pattern functor), that I want to transform into another structure, `T[G]`.  The rules for that transformation are such that the number of layers in the resulting structure are not necessarily the same as in the source structure. Furthermore, some rules require the inspection of not only one layer of the original structure, but two. Right now I don't know how to proceed. I'd be glad if I could get some advice.

                                                                                                                                                      Greg Pfeil @sellout@2017-08-14T11:32:12.699Z
@tscholak It might depend on a few other things, but I think you might want `futu` or `transFutu(f: F[T[F]] => G[Free[G, T[F]]]): T[F] => T[G]`.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-14T12:53:32.002Z
Ah, I'll look into that. What I need to do does neither fit the algebra nor the coalgebra pattern

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-14T12:53:36.497Z
Thank you

                                                                                                                                                      Greg Pfeil @sellout@2017-08-14T12:59:42.700Z
Something that tripped me up a lot early on is that you can treat your tree as an “atomic” type. I.e., the `A` in `A => F[A]` (or its dual). In your case, the “number of layers are not the same” (`Free`) aspect of `futu` sounds the most critical. I.e., it sounds like you can traverse the structure in either direction, and if you traverse top-down, you get the “require the inspection of not only one layer” (`histo`) aspect for free.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-14T13:00:24.404Z
would it help if I told you what the rules are?

                                                                                                                                                      Greg Pfeil @sellout@2017-08-14T13:00:44.952Z
This is one of those cases where I wonder if metamorphisms would help, but that isn’t part of Matryoshka’s general approach, and I haven’t put much work into figuring out how to implement them yet.

                                                                                                                                                      Greg Pfeil @sellout@2017-08-14T13:01:15.887Z
@tscholak I couldn’t hurt …

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-14T13:01:51.413Z
`F` contains something called `PartialF`...

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-14T13:01:57.642Z
`G` doesn't.

                                                                                                                                                      Greg Pfeil @sellout@2017-08-14T13:02:08.930Z
I should try to make up some decision tree for finding schemes that work in different situations :D

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-14T13:03:06.700Z
the function that I'm looking for will evaluate `PartialF` by calculating the partial derivative of the structure (an expression tree) with respect to a variable.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-14T13:04:43.452Z
that means I have to implement things like the product rule 

                                                                                                                                                      Greg Pfeil @sellout@2017-08-14T13:09:19.218Z
So, you’d rewrite something like `PartialF(x, ProdF(a, b))` to `ProdF(PartialF(x, a), PartialF(x, b))`?

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-14T13:11:02.327Z
not quite, but yeah: `SumF(ProdF(a, PartialF(x, b)), ProdF(PartialF(x, a), b))`

                                                                                                                                                      Greg Pfeil @sellout@2017-08-14T13:11:34.499Z
Ah, right … /me brushes up on calc.

                                                                                                                                                      Greg Pfeil @sellout@2017-08-14T13:12:48.440Z
Anyway, yeah, this idea of pushing something toward the leaves fits well with the unfolding of `futu`, so I think that’s probably a good bet.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-14T13:13:09.284Z
so, yeah, I have to match on two layers, e.g. `PartialF(x, ProdF(a, b))`, and I'll produce one or more layers 

                                                                                                                                                      Greg Pfeil @sellout@2017-08-14T13:13:49.259Z
Yeah, `futu` works as long as you produce _at least_ one layer of `G` at each step.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-14T13:14:27.118Z
do I need the variant with `Free`?

                                                                                                                                                      Greg Pfeil @sellout@2017-08-14T13:14:56.463Z
I think `transFutu` is a good fit (just a bit of sugar over `futu` to make writing the coalgebra easier).

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-14T13:16:20.539Z
cool, that is great advice

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-14T13:16:22.828Z
:)

                                                                                                                                                      Greg Pfeil @sellout@2017-08-14T13:17:46.746Z
Yeah – futu implies Free. In the product case, you would return something like `Free.roll(SumF(Free.roll(ProdF(Free.point(a), Free.point(PartialF(x, b).embed))), Free.roll(ProdF(Free.point(PartialF(x, a).embed), Free.point(b))))` (the syntax there isn’t the nicest, but basically you `roll` the `G` nodes and `point` the remaining `T[F]` on each branch).

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-14T13:19:12.593Z
yes! that should work. I'm happy :D

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-14T13:28:33.185Z
does futu go bottom up or top down?

                                                                                                                                                      Greg Pfeil @sellout@2017-08-14T13:28:39.114Z
top-down

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-14T13:29:25.480Z
thx

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-14T18:35:09.614Z
@sellout I still haven't been able to come up with a solution i'm happy with (in my music thing). Would it be easier if I turned my MidiFile datastructure in to a recursive one somehow and then did a refold?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-14T18:51:23.328Z
Eh. Gonna make a recursive intermediate format.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-14T18:55:13.027Z
@Jacoby6000 https://www.youtube.com/watch?v=WWaLxFIVX1s

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-14T18:55:50.354Z
That's about how I feel on the inside :sweat_smile: 

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-14T18:56:09.039Z
good.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-14T18:58:58.000Z
I wonder if this is normal... You take a size-efficient yet un-principled binary format, parse it in to a concrete structure, and then fold the concrete structure in to a principled structure, then you can work with it.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-14T19:59:49.641Z
Am I reading Futu correctly in that it requires your AST to have a Traverse instance?

                                                                                                                                                      Greg Pfeil @sellout@2017-08-14T20:04:49.122Z
@Jacoby6000 Hrmm, are you looking at `futuM`?

                                                                                                                                                      Greg Pfeil @sellout@2017-08-14T20:05:41.567Z
Only the monadic {un}folds should require Traverse (but, in general, having a Traverse instance for your AST is reasonable).

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-14T20:06:34.776Z
Ah yeah, it is futuM

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-14T20:07:02.659Z
And futu will always end up as a Free encoding, right?

                                                                                                                                                      Greg Pfeil @sellout@2017-08-14T20:08:28.738Z
Well, when the unfold is complete, you should have just `T[G]`, the Free will be gone. It’s only needed for the individual steps of the algebra.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-14T20:10:18.236Z
Alright that's what I figured... for some reason I thought that I didn't see a spot for a recursive encoding in the signature.. when I get back to the computer I'll squint at it some more. I'm sure I'll get it now that I understand the Traverse part. 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-08-14T20:14:06.145Z
Are there any recursion schemes that require a monad instance for your pattern functor?

                                                                                                                                                      Greg Pfeil @sellout@2017-08-14T20:15:05.492Z
I don’t think so.

                                                                                                                                                      Tristan Lohman @gatorcse@2017-08-15T00:00:04.976Z
I’m reading the Matryoshka README (again). Is it possible to get a simple explanation/examples of the differences between `Fix`/`Mu`/`Nu`?

                                                                                                                                                      Greg Pfeil @sellout@2017-08-15T03:23:09.083Z
@gatorcse `Fix` is the “direct” recursive definition – which makes it good for explanation, but not stack-safe or anything. `Nu` is lazy, so useful for potentially-infinite structures (streams, etc.), and `Mu` is the dual of `Nu`. In Scala, `Fix` is similar to `Mu`, in Haskell, `Fix` is similar to `Nu`, because it uses the default evaluation (eager/lazy) of the language.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-15T18:02:24.797Z
@sellout dunno if you're interested, but Dotty seems to support mutually recursive ASTs. 

https://scastie.scala-lang.org/XbNz8MJ5TFycluoKETPl1A

This explodes if you make the index covariant, though.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-15T18:03:30.853Z
(I've found covariant indexes to be helpful... but evil)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-15T18:04:42.360Z
I was able to get around the variance by defining an invariant type alias when building the HFunctor.. Like 

```
  type InvariantExpr[A[_], I] = Expr[A, I]
```

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-15T18:04:55.970Z
Since the HFunctor can't change the Index type, this works out perfectly.

                                                                                                                                                      Greg Pfeil @sellout@2017-08-15T19:06:13.505Z
@Jacoby6000 nice. I should try out dotty at some point.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-08-15T19:31:22.356Z
Be careful if you do.  I definitely wouldn't say it's at a stable point. Especially with this kind of generic programming... A lot of times compiler errors manifest as unhelpful exceptions. 

                                                                                                                                                      Tristan Lohman @gatorcse@2017-08-15T21:48:34.777Z
@sellout Thanks!

                                                                                                                                                      Greg Pfeil @sellout@2017-08-15T22:26:24.790Z
@gatorcse Please feel free to ask more if that doesn’t clear it up. Like, I definitely missed mentioning that `Nu` and `Mu` are defined without recursion.

                                                                                                                                                      Tristan Lohman @gatorcse@2017-08-15T22:40:08.640Z
Combining your comment with some Stuff-I-Read-On-The-Internet, specifically about `Mu` representing a fold, and `Nu` representing an unfold: `Mu` represents data that can be reduced to a value (folded), where `Nu` represents a value that can build up a data structure, sort of like a generator. In Scala, they can actually share a lot of behavior due to typey stuff, but that is there base semantic definition.

                                                                                                                                                      Tristan Lohman @gatorcse@2017-08-15T22:40:15.928Z
Feel free to red pen all over that

                                                                                                                                                      Tristan Lohman @gatorcse@2017-08-15T23:04:21.951Z
Also, to any newcomers reading the above statement, that is a wildly uneducated guess describing my current understanding of the data types, not an authoratative explanation by any means

                                                                                                                                                      Greg Pfeil @sellout@2017-08-15T23:04:57.497Z
@gatorcse Sounds good to me 👍🏾

                                                                                                                                                      Tristan Lohman @gatorcse@2017-08-15T23:06:01.223Z
woah, really?

                                                                                                                                                      Tristan Lohman @gatorcse@2017-08-15T23:07:05.954Z
@gatorcse Unlocked achievement: Initial grokking of Matryoshka

                                                                                                                                                      Greg Pfeil @sellout@2017-08-15T23:07:24.779Z
👏🏽

                                                                                                                                                      Tristan Lohman @gatorcse@2017-08-15T23:07:55.917Z
Anyone experiment with implementing event-sourcing as `Mu`?

                                                                                                                                                      Tristan Lohman @gatorcse@2017-08-15T23:08:57.804Z
I feel like there’s a nice parallel with event-sourcing/cqrs, with the event stream represented as a recursive data structure, and various algebras/folds as the queries

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-16T08:55:07.751Z
Hi, I've been looking into the quasar source code, specifically the Json/EJson parts. My ADTs have a similar makeup; there's a common ADT, `CommonF`, and an extension to it, `ExtensionF`. I'd like to write explicit open recursive expressions with the coproduct of these types, `ExprF`, `type ExprF[A] = Coproduct[ExtensionF, CommonF, A]`. Currently, this leads to very awkward code, because I have to wrap `ExtensionF` instances in `TC.embed(Coproduct.left[CommonF](e))` and `CommonF` instances in  `TC.embed(Coproduct.right[ExtensionF](e))`, where `TC: Corecursive.Aux[T, ExprF]`. Is there a better way?

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-16T08:58:03.616Z
I was hoping that there's some implicit magic that I can pull into scope because I have the following injections:
```scala
val commonExprF: CommonF :<: ExprF = implicitly[CommonF :<: ExprF]
val extendedExprF: ExtensionF :<: ExprF = implicitly[ExtensionF :<: ExprF]
```

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-16T09:13:31.554Z
hm, I just saw that, in quasar, there are these helper functions:
```scala
    def fromCommon[T](c: Common[T])(implicit T: Corecursive.Aux[T, EJson]): T =
      CommonEJson(c).embed

    def fromExt[T](e: Extension[T])(implicit T: Corecursive.Aux[T, EJson]): T =
      ExtEJson(e).embed
```

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-16T09:22:57.924Z
yay, making these `implicit def`s is a win

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-16T10:35:18.244Z
@sellout I have a first prototype now, https://github.com/tscholak/autodiff

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-16T10:35:47.269Z
it works, but only for first derivatives.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-16T10:36:35.185Z
that's because the futu goes from top to bottom. if it were the bottom-up, the current code would already work for higher order derivatives.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-16T10:37:16.604Z
I don't see a way of fixing this without introducing recursion in the `CoalgebraicGTransform`, https://github.com/tscholak/autodiff/blob/master/src/main/scala/autodiff/evaluate.scala#L12

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-16T10:53:26.981Z
as you can see, the case `PartialF(PartialF(...))` is not handled yet

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-16T11:04:48.644Z
neither is `PartialF(PartialF(PartialF(...)))` ;)

                                                                                                                                                      Greg Pfeil @sellout@2017-08-16T16:36:31.675Z
@tscholak I'm on the beach, but I would recommend defining your algebra as a type class with instances for Common, Extension, and Coproduct[F, G, ?].

                                                                                                                                                      Greg Pfeil @sellout@2017-08-16T16:36:44.121Z
More later 😄

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-17T06:51:59.934Z
:D

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-19T12:53:54.816Z
:palm_tree: 

                                                                                                                                                      Greg Pfeil @sellout@2017-08-19T14:05:57.971Z
@tscholak Sorry, back 😃

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-19T14:06:25.942Z
np, I'm on vacation, too :D

                                                                                                                                                      Greg Pfeil @sellout@2017-08-19T14:07:13.519Z
So, anyway, doing that type class approach makes it so you can use the algebra for arbitrary coproducts, as long as each component has an instance. And Matryoshka (or _something_) should allow the Coproduct instance to be derived (as is commonly done in Haskell).

                                                                                                                                                      Greg Pfeil @sellout@2017-08-19T14:09:16.535Z
So yeah, `PartialF(PartialF` is a problem … not sure this is a great solution, but if you could collapse `PartialF(x, PartialF(y, z))` to `PartialF(List(x, y), z)` …

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-19T14:09:41.370Z
yeah, so that's the thing. I can't do that.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-19T14:11:01.834Z
or, rather, let's say, that just postpones the problem

                                                                                                                                                      Greg Pfeil @sellout@2017-08-19T14:12:39.989Z
So, in the abstract, what is the solution?

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-19T14:13:14.523Z
I'd like to go bottom up

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-19T14:14:17.643Z
I think that bottom-up will also have some advantages for other things like `SimplifyF` that simplifies expressions

                                                                                                                                                      Greg Pfeil @sellout@2017-08-19T14:14:21.287Z
That’s possible … but then what do you do about `Partial(Prod`?

                                                                                                                                                      Greg Pfeil @sellout@2017-08-19T14:14:38.712Z
Because you’ll hit the `Prod` first, not knowing that it has a `Partial` outside it.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-19T14:14:53.003Z
I'd leave the `Prod` as is in that case

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-19T14:15:15.175Z
when I hit the `Partial` eventually, I'll do something about it

                                                                                                                                                      Greg Pfeil @sellout@2017-08-19T14:16:19.505Z
And what if there is no `Partial` outside it?

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-19T14:16:27.377Z
it stays

                                                                                                                                                      Greg Pfeil @sellout@2017-08-19T14:16:41.355Z
Oh! So Prod is in both the input and output functor.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-19T14:16:44.115Z
the futu trafo is just supposed to eliminate the Partials from the tree

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-19T14:16:48.425Z
yes :)

                                                                                                                                                      Greg Pfeil @sellout@2017-08-19T14:17:05.650Z
Right, right … so the algebra on the Common part is basically identity.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-19T14:18:31.773Z
correct

                                                                                                                                                      Greg Pfeil @sellout@2017-08-19T14:22:07.383Z
Ok, cool. So yeah, you can do bottom-up, make a type class with an operation of type `Transform[Fix[Common], F, Common]`, and the instance where `F = Common` is literally identity.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-19T14:23:09.811Z
hmm, can I still emit more than one layer with `Transform`? I'm using `Free.roll` right now to do that.

                                                                                                                                                      Greg Pfeil @sellout@2017-08-19T14:23:54.479Z
Yep – just have to use `.embed` instead of `Free.roll`.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-19T14:25:04.663Z
cool. I'll try that.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-19T14:25:07.871Z
:D

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-19T14:25:10.100Z
thank you!

                                                                                                                                                      Greg Pfeil @sellout@2017-08-19T14:25:19.163Z
And you could generalize it further,  with `Transform[Fix[G], F, G] ` given `Common :<: G`. That becomes useful if you have a bunch of variations of the Coproduct and you only care about a subset of it (as Quasar often does).

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-19T14:25:53.927Z
oh, I guess I can have a look there to get an idea

                                                                                                                                                      Greg Pfeil @sellout@2017-08-19T14:26:31.905Z
Yeah … although Quasar often has extra complexity, so clarity is lost. Need more examples.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-19T14:28:38.776Z
hm, I'm happy to provide what I'm working on right now as an example.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-19T14:29:04.870Z
it's just a little exercise

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-19T14:32:19.626Z
I'd like to add "backpropagation" to the code eventually. That means I need an algebra / a cata with memoization.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-26T19:31:19.975Z
@sellout you were right. doing it bottom-up introduced other problems which were even greater than what I had encountered with the top-down approach.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-26T19:33:10.001Z
I ended up exploring the collapse idea, `PartialF(PartialF(...))` to `PartialF(..., 2)`, which works elegantly.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-26T19:34:08.806Z
thank you for suggesting it. I didn't believe initially that it would be helpful, but it is :)

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-26T19:35:39.355Z
it's here, https://github.com/tscholak/autodiff/blob/09e607a9f4dff9560e493ed1e3eaaa9877594e1c/src/main/scala/autodiff/manipulate.scala#L41, if you want to check it out

                                                                                                                                                      Greg Pfeil @sellout@2017-08-26T20:21:16.454Z
@tscholak 💯

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:00:31.240Z
Hi there

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:01:25.612Z
Is there a way/scheme that allows one to simultaneously got through two recursive structures (provided the two share a similar … structure) ?

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:03:12.601Z
concretely, I have a spark `Row` + `StructType` and I'd want to transform that to an avro `GenericRecord` +  `Schema`

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:04:33.870Z
I have internal functors `DataF[A]` and `SchemaF[A]` that mimic `Row/GenericRecord` and `StructType/Schema` respectively

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:05:59.504Z
more precisely, I have a `Birecursive.Aux[Schema, SchemaF]` and a `Birecursive.Aux[StructType, SchemaF]` instances

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T13:06:10.157Z
Hi Valentin, is this related to your old gist, https://gist.github.com/vil1/493c6c5cc8d236d7dcf42a350fe5ab7a ?

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:06:27.171Z
definitely ^^

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:06:57.801Z
although things might have evolved a bit since then, but that's part of the same adventure

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:09:26.585Z
(BTW, we're about to ship some of that to production!)

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T13:17:22.657Z
I don't have an answer for you, @sellout might know immediately. but let me think about this quickly...

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:18:07.953Z
my first idea was something like `type DataWithSchema[A] = (DataF[A], SchemaF[A])`

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:18:22.062Z
but that doesn't look very tractable

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T13:18:27.781Z
so your rows are adhering to the structtype, but they may not fully specify it implicitly

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:19:36.024Z
that's it, thanks to these super-javay-untyped API, I cannot decompose a `Row` (or a `GenericRecord`) without the aid of the associated schema

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T13:19:38.111Z
same for the avro records, they adhere to the schema, but their "hull" defines the schema in general only partially

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T13:20:04.181Z
oh, I see

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:20:08.008Z
that's it

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:20:34.503Z
a `Row` is basically an `Array[Any]`

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T13:20:43.162Z
ah, right, it's totally untyped

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T13:24:39.451Z
ok

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T13:26:38.622Z
you can unfold the structtype into a recursive structure in the SchemaF and then fold that structure into the avro schema

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T13:28:04.956Z
and, in principle, this transformation should contain all you need to transform any spark row into an avro record

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:30:32.679Z
struttype -> schemaf -> avro is done already

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:30:59.222Z
but row and genericrecord are different flavours of untyped

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:31:26.568Z
so i need to convert them as well

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T13:31:48.595Z
yeah, so the first, the coalgebra for structtype -> schemaf, is there a way to use it to define the row -> dataf coalgebra?

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T13:34:21.451Z
I want a whiteboard ^_^

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:34:34.762Z
^^

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:35:33.855Z
well there is no way to (properly) define the row -> dataf coalg, because you need a schema (structtype) in order to unpack the row structure

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T13:47:01.108Z
ok, does a schemaf instance define the row -> dataf coalg?

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:55:59.638Z
ow, that's a neat idea! having a `def rowToData: Coalgebra[DataF, Row]` inside of `SchemaF`

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:56:58.642Z
I'll try that, thx !

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T13:57:16.087Z
seems that could work

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:58:01.792Z
hmm, well

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:59:24.897Z
actually `SchemaF` is just a trait, what I'd need would rather be an `Algebra[SchemaF, Coalgebra[?, Row]]` 

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T13:59:29.598Z
I thought actually more like `Algebra[SchemaF, Coalgebra[DataF, Row]]`

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T13:59:48.727Z
yep likewise, modulo the my typos

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:00:00.604Z
that's double the fun

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:00:18.994Z
yes, exactly

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:01:35.290Z
doubles the fun, halves the "coworker-friendliness" 

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:02:17.610Z
let's do that

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:05:04.511Z
:+1:

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:15:24.435Z
wait a minute, `SchemaF` is just a trait, nothing extends from it?

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:16:17.191Z
it's an ADT

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:16:35.394Z
ok, so there are case classes that extend from it?

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:16:36.808Z
a recursive one

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:16:39.774Z
yep

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:17:22.718Z
like `final case class ArrayF[A](elements: A) extends SchemaF[A]` and so on

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:18:12.174Z
what's the relationship between SchemaF and DataF? SchemaF should be expressive enough to represent all possible spark structtypes and avro schemas.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:22:49.722Z
in particular, I'm confused about the duplication of type information that you might have when you have both a SchemaF and a DataF instance.

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:23:19.022Z
is DataF untyped?

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:23:20.291Z
schemaf represents the structures

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:23:34.473Z
dataf represents the "instances" of such schemas

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:24:51.502Z
on the same principle, it's `DataF[A]` with subclasses like `ArrayData[A](elements: List[A]) extends DataF[A]`

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:25:25.908Z
(the main structural difference is that schemaf has also some metadata attached)

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:25:27.679Z
how do you represent, say, an array of ints?

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:25:47.498Z
a value of such? 

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:25:55.682Z
both, schema and data

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:26:42.002Z
ow, I miss-typed earlier, lemme fix that ArrayF definition

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:27:38.583Z
so, schema would be:` ArrayF(IntF().embed).embed` or smth?

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:27:44.803Z
so `ArrayF(IntType()))` and `ArrayData(List(IntValue(1), IntValue(2)))` (eluding the fixpoint)

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:27:56.214Z
yep that's it

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:29:10.586Z
ah, I see. ok

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:30:41.098Z
so, simply spoken, you are building the type info of `List[Int]` in the schemaf structure, and the values in the dataf structure, got it

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:31:08.948Z
you're right

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:31:09.200Z
do you even need `IntValue`? can't you just use `Value(v: Any)`?

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:31:29.974Z
hmm nope

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:31:30.322Z
since the type is in the SchemaF

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:32:01.946Z
I have another layer of complexity I didn't mention

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:33:08.134Z
I also use the SchemaF + DataF to produce a validation (in term of  `jto.validation.Rule`) and I therefore need leaf values to be correctly typed

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:34:37.747Z
hmmm

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:35:26.386Z
I'm just seeing this leaf type info as some sort of duplication

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:36:07.157Z
you have to make sure that this is consistent

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:37:06.758Z
oh sorry, I've said wrong things (I don't even remember my own code ...) 

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:37:33.352Z
:D

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:37:38.378Z
in the schema tree, leaves are of type `ValueF`, with a field telling which type the value is

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:38:20.188Z
a string?

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:38:20.973Z
but on the data part, I'll definitely need specific leaves for each value type (int, bool, etc)

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:38:42.457Z
yes, a string (should be some kind of enum though)

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:40:24.892Z
ok

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:41:22.387Z
have you by chance explored the option of annotating each DataF node with its schema?

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T14:43:12.946Z
let's say, in the case of `ArrayData`, it would have an additional field that contains a recursive structure describing the schema of the children

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:44:44.743Z
I'm actually in the process of defining `DataF` (we have a working version, but not "functorized" and which doesn't use recursion schemes)

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:46:19.867Z
I've considered the idea of having some kind of data+internal-schema product, but it didn't seem really practical 

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T14:46:38.064Z
(I may be wrong about that last statement)

                                                                                                                                                      Greg Pfeil @sellout@2017-08-30T14:59:47.300Z
@vil1 I haven’t entirely caught up yet, but I’m surprised you have two Birecursive instances with the same functor. At a minimum, that implies that Schema and StructType are isomorphic. Are they?

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T15:01:55.836Z
God how can I say so much s**t

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T15:02:13.597Z
so let's correct myself

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T15:03:28.375Z
(the (only) birecursive instance I have is irrelevant, it's between my old, mundane-recursive representation and my new, recursive-scheme compliant one)

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T15:03:59.572Z
and I have algebras from SchemaF to StructType and to avro.Schema

                                                                                                                                                      Greg Pfeil @sellout@2017-08-30T15:04:14.237Z
Ok, cool – that makes sense.

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T15:04:16.101Z
sorry I mixed that up

                                                                                                                                                      Greg Pfeil @sellout@2017-08-30T15:04:57.290Z
No worries, sorry for being pedantic 😄

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T15:05:41.023Z
being right isn't isomorphic to being pedantic in my book ^^

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T15:08:06.944Z
anyway, I'm still trying @tscholak's idea : writing a `Algebra[SchemaF, Coalgebra[DataF, Row]]`

                                                                                                                                                      Greg Pfeil @sellout@2017-08-30T15:11:02.857Z
Yeah, that idea seems neat. I like it :D

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T15:15:30.131Z
I called that the  "double the fun" solution

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T15:16:16.960Z
but I had the intuition that, given a Row+StructType, I could get a GenericData+Schema with a single hylo

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T15:16:38.261Z
which will not be the case with that solution

                                                                                                                                                      Greg Pfeil @sellout@2017-08-30T15:35:40.660Z
@vil1 Yeah, I don’t think that is very easy. Since you need the Schema before you can determine how to handle the Row, right?

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T15:36:09.636Z
that's the essence of the problem yes

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T15:36:28.064Z
(same goes for genericRecord/avro.Schema)

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T15:55:13.229Z
recursing through the schema should be fast, no?

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T15:55:45.031Z
it would not be that much of an efficiency benefit if you rolled that -- both rows and structtype -- in one attempt

                                                                                                                                                      Greg Pfeil @sellout@2017-08-30T16:03:24.333Z
Right, if you actually did Schema and Data in parallel, you’d re-traverse Schema for each row, no? Rather than traversing it once to generate the function that transforms any row.

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T16:14:38.437Z
you're right: I have one schema on startup, and many data afterwards

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T16:15:28.245Z
so "making a plan" first and using that to then transform the incoming data makes perfect, operational sense

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T16:17:39.826Z
but conceptually it felt more compelling to have a single hylo

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T16:20:32.614Z
Anyway, I think I'll need more time to think about all that

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T16:20:48.569Z
You both gave me good lead though, thanks

                                                                                                                                                      Torsten Scholak @tscholak@2017-08-30T16:21:16.151Z
let us know what you come up with :)

                                                                                                                                                      Valentin Kasas @vil1@2017-08-30T16:21:31.117Z
I surely will

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T16:55:56.480Z
Hi! I'm trying to implement a simple nanopass compiler using recursion schemes. I've worked out the mechanics of ana, cata, and para. I can modify the AST in place using cata and Algebra[AST, AST[_]]. I can also collect information about the AST using cataM and AlgebraM[Writer[...], AST, AST[_]]. Haven't really figured out what I'd want to use ana and para for, but I got some stuff to compile with them.

I've got some other operations I'm not really sure how to encode. I'd like to make sure that class declarations only occur on the top level. I think histo would be the tool for that, because I want to see the node's ancestors in the tree, but I haven't figured out the mechanics of that.

I'd also like to construct hierarchical symbol tables (I think I can manage that with cata - I'm coming to think I should extend my AST in some way to be able to embed the tables in the AST), and then somehow make those tables available during recursion. It feels like that might be achievable with zygo, but I haven't been able to assemble anything that quite makes sense

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T16:56:42.142Z
AST is here https://github.com/DanielPorter/fno/blob/master/src/main/scala/prestwood/PrestwoodAST.scala

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T16:56:58.503Z
any pushes in the right direction would be appreciated

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T17:38:59.671Z
If you want to have a heterogeneous type for your tree you need mutual recursion

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T17:39:50.975Z
is that in reference to my comment about embedding the tables in the AST?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T17:40:08.812Z
No, the invariant "class declarations only occur on the top level"

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T17:43:51.501Z
okay, either i'm not understanding, or i didn't phrase that well. likely both. i'm not saying class declarations must be the top node, i just want them to have only AndThen ancestors. I'm not grokking how that would make them heterogeneous

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T17:44:13.423Z
Oh my bad. Top-level should be fine.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T17:45:06.771Z
I don't see what histo would have to do with that, you'd just have `case class ClassDecl[T[_[_]]](name: String, mods: Modifiers, tree: T[AndThen])` 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T17:45:11.668Z
What is `AndThen`?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T17:45:18.560Z
Looking at your link now

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T17:46:05.633Z
AndThen is just a node in a balanced tree

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T17:46:27.993Z
named AndThen because i find it easier to think about

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T17:47:35.550Z
Right so class declarations being at the top level means an entire program is just a list of class declarations

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T17:47:40.750Z
Is that correct?

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T17:49:09.504Z
Ahh, no. I think introducing "top level" was a mistake.  Lines 11 and 12 would constitute a valid program:

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T17:49:09.866Z
https://github.com/DanielPorter/fno/blob/master/src/test/scala/PrestwoodParserSpec.scala

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T17:49:24.293Z
top level in the sense of the program, not in the AST

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T17:49:47.096Z
class declarations must be top level, however it is not the case that every top level expression must be a class declaration

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T17:50:05.372Z
Right, so it depends how many invariants here you want to capture in the AST type.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T17:50:48.359Z
If you want it to be impossible to include class declarations at any level other than the top level you're going to have to do runtime checking.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T17:50:58.929Z
Which you're going to have to do anyway to type check this.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T17:51:46.973Z
So what you need here is a) a method to remove non-top-level class declarations and b) a method to collect all of your class declarations, yes?

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T17:52:53.562Z
Well, I've managed to achieve (b) here, https://github.com/DanielPorter/fno/blob/master/src/main/scala/prestwood/PrestwoodAST.scala#L107

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T17:53:10.107Z
using cataM with a writer monad

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T17:53:16.537Z
Right that's the way I would do it too

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T17:54:02.482Z
regarding A, i'm not sure i want to remove them, i do however want to locate them

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T17:54:16.810Z
Locate them as top-level or not top-level?

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T17:54:23.799Z
as not-top level

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T17:54:50.570Z
Sorry that was ambiguous, I mean you want to detect whether or not there are non-top-level class decls?

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T17:55:31.437Z
yes. i would like to ascertain for each class declaration if it is "top level" or not, and for ones which are, i'd like to generate an error message for them

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T17:55:44.912Z
ahh

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T17:55:51.658Z
for ones which are not top level*

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T17:56:03.548Z
i.e. you can't place a class declaration in a block

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T17:56:27.556Z
(because scoping is hard and it sounds like a lot of work)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T17:56:40.903Z
Yeah

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T17:57:45.588Z
I'd say maybe look at `transCataTM`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T17:59:13.376Z
Use Either as your error monad, inspect two layers into the structure to find if you have a `ClassDeclaration` inside another layer which is not an `AndThen`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T18:00:35.516Z
That may not work. Maybe use the `Env` comonad with a boolean in your environment which determines "top-level" and a generalized catamorphism

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:03:29.616Z
would either short circuit?

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:03:39.373Z
i.e. only report the first failure?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T18:15:51.262Z
Yes

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T18:16:14.096Z
You could try something without an `M` on the end, then you can convert it to `Validated` for multiple-branch levels of the tree and accumulate errors

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:16:49.188Z
that sounds like a plausible approach

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:17:30.072Z
the type signature of transCataTM has this Corecursive.Aux business

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:17:58.218Z
unclear to me what i need to do to create one of those

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T18:18:08.386Z
Recursive means "I can pull an F[_] out of a T[F], to make a F[T[F]]"

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T18:18:23.285Z
Corecursive means "I can push an F[_] into an F[T[F]], to make a T[F]"

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T18:18:34.165Z
You're using Fix

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T18:18:36.791Z
Which has both

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:19:31.326Z
alright, so it's a freebie

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:23:58.225Z
okay. so i'm working through trying to use just the plain transCata, and i'm getting confused

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:32:39.030Z
when i try to call `ast.transCata(someplausiblefunction)` it tells me that transCata doesn't take parameters. looking at the definition, that looks true - it's an object whose apply method takes only a type parameter U. But there is another function transCata that takes (t: T)(f: Base[U] => G[U]). don't really understand the function or signature

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:33:34.946Z
Greg Pfeil's talk on matroyshka has an example of doing... i think the thing i'm trying to do: `val desugar: Fix[Let :+: If :+: Lambda] => Fix[Lambda] =
  _.transCata(expandIf <<< expandLet)`

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:33:55.072Z
but i don't know what the :+: symbols mean. i've gathered that <<< is function composition

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:44:08.445Z
haha, well, i got transCataTM working

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:44:11.655Z
so there's that

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T18:44:25.397Z
:+: means "or"

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T18:44:44.521Z
In that `(F :+: G)[A]` is an `F[A]` or `G[A]`

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:46:07.412Z
gotcha. is that importable? it's a hard operator to google for

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T18:46:24.741Z
I'm not sure actually where it's from, it may be in matryoshka

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:47:12.553Z
hm. git search doesn't find it in the codebase

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:47:37.646Z
nor in scalaz's

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:48:49.234Z
so i think that transcataTM is not what i want. If I use transcataTM, i have to write this invariant (if i'm using that word correctly) in terms of every AST node type which is *not* a class declaration

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T18:49:02.693Z
Why is that?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T18:49:16.564Z
Btw it's from Quasar, a project which uses matryoshka

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:49:24.606Z
ahhh, thanks

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:49:44.282Z
well you're talking about checking the children, right?

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:49:56.294Z
so if i have an andThen, i need to check the children

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:50:00.813Z
or if i have a block, i need to check the children

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:51:18.308Z
but have to write code for each node that can contain subnodes

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:52:26.152Z
whereas if i can express it in terms of parents of the Class Declaration, i only have to write it for class declarations, and as i expand my AST, i don't have to go expand my function

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T18:52:53.079Z
I don't see how that would be possible

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T18:52:57.320Z
Here's my recommendation

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T18:53:10.435Z
Come up with a "children" function that returns all of the `A`'s in a `PrescottAST[A]`

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:55:14.975Z
wouldn't histo allow you to see the parents?

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:57:12.289Z
haven't figured out the mechanics of how to use it, but if you use something like case x => Monad(x) for all of the non-ClassDeclarations, you could grab the lineage for the ClassDeclaration case?

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:57:23.179Z
or am i misunderstanding what histo gets you

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T18:59:02.911Z
`histo` gives you the earlier results of the fold

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:59:32.644Z
ahh, but it still traverses from bottom to top

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T18:59:49.549Z
so you still can't see

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T18:59:50.240Z
I mean if you want top to bottom you have some other options

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T18:59:59.632Z
`transAna` in particular

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T19:00:04.287Z
Which is just `transCata` but top to bottom

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T19:01:50.352Z
okay, that might do the trick

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T19:03:15.222Z
an aside - is there a way to get intellij to recognize these implicits for syntax highlighting? it suggests transCata etc but then after a while decides they're not valid methods

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T19:03:42.673Z
Nope

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T19:03:43.459Z
I wish

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T19:04:01.449Z
dang. that's pretty goofy

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T19:04:16.123Z
IntelliJ only gets goofier the more you use implicits and type members

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T19:04:50.712Z
haha. it's also been slaughtering my battery since i started using matroyshka

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T19:05:11.414Z
the price we pay for java interop, i guess

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T19:05:13.839Z
Yeah I bet. This is why a lot of people use vim and stuff

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T19:05:25.428Z
It's not Java interop really, a lot of scala's problems have nothing to do with Java interop

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T19:05:31.699Z
And Scala/Java interop is... not great, anyway

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T19:08:39.702Z
so what i really want is top to bottom *and* history

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T19:09:06.893Z
it looks like `futumorphism` might be the thing

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T19:09:13.504Z
Futumorphism gives you the *future*

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T19:09:21.873Z
So it may not be what you want

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T19:09:25.335Z
But not sure

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T19:10:16.203Z
hm. looks worth checking. i'm noting that it requires a `GCoalgebraM[Free[F, ?], M, F, A]`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T19:10:35.683Z
Yeah a coalgebra, so that's constructing a structure, not tearing it down

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T19:11:27.299Z
hm. right. so my target structure is the same as the structure i'm consuming

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T19:11:45.037Z
i have an AST, i don't really care about the target

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T19:12:03.042Z
i just want to capture some information in a monad

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T19:12:23.619Z
I'd really recommend coming up with a `children` function and doing this bottom-up

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T19:12:25.808Z
so if i can recurse from

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T19:12:34.070Z
haha. alright.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T19:13:00.434Z
I'm not an expert by far, I'm really still a novice, so I apologize if my advice is in general insufficient

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T19:13:41.368Z
is cool. my opposition to the children function is that i end up recursing the AST multiple times that way

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T19:13:55.752Z
The children function is only for a single layer

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-02T19:14:15.011Z
ah, not so bad, then

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T19:15:17.403Z
Yeah it's just `F[A] => List[A]`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T19:15:22.521Z
Not `Fix[F] => List[F[_]]`

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-02T20:52:18.784Z
Hey Edmund, can you tell me if histo can be used to efficiently evaluate recursive structures via memoization?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T20:52:32.770Z
Evaluate?

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-02T20:53:13.676Z
Yeah, as in fold

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T20:55:10.437Z
I think that could have a lot of meanings

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T20:55:23.153Z
Histo keeps around every answer to earlier calls to the algebra

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T20:55:38.648Z
So if you need that info then histo can prevent you from recalculating it

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-02T20:57:20.490Z
Let's say you have an Ast for mathematical operations like sum, multiply, negate, sine, etc. and you like to fold over an algebra that evaluates these. Can histo reuse results from identical subtrees hat have already been evaluated?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T20:57:33.840Z
Not in a simple way.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T20:57:50.476Z
I'd use a state monad over a map from subtrees to results.

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-02T20:58:46.129Z
Yeah, state monad was my first thought, too. When I read about histo, though, i thought this sort of thing comes for free with it. Guess not

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T20:59:17.451Z
Well you'd have to retraverse the Cofree finding subtrees equivalent to the one under consideration

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T20:59:46.057Z
I think you could come up with a recursion scheme which generally just memoizes an extant one

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T21:00:09.754Z
But that means using something like `transCata`, because you need to view the entirety of the tree under you

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T21:00:20.573Z
Maybe even `transAna` because that's top-down

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-02T21:04:17.502Z
Hmmm, ok. With coffee the idea is then to annotate each node of the tree with the results of the cata applied to the their sub trees?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-02T21:17:50.966Z
Yep

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T21:03:07.817Z
so i can use the transCata etc methods, but i can't run anything that's defined in idOps

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T21:04:07.379Z
not enough value parameters provided

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T21:04:13.320Z
i think it's the corecursive instance

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:23:21.793Z
if i had to guess i'd guess i'm missing some important typeclass

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:23:44.646Z
clicking around the source for how corecursive auxes come into being is unilluminating, though

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T22:25:34.866Z
Fix has a Birecursive instance

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T22:25:46.650Z
Birecursive is a subtype of Recursive and Corecursive

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:26:14.790Z
okay, lemme recreate it real quick here

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:30:20.508Z
``` 
 type FAST = Fix[PrestwoodAST]
  def coab: Coalgebra[List, FAST] = {
    case x => List(x)
  }

  def coabfail(ast: FAST) = ast.ana[FAST](coab)
```

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:31:25.071Z
"Error:(219, 42) could not find implicit value for parameter T: matryoshka.Corecursive.Aux[prestwood.PrestwoodAST.FAST,slamdata.Predef.List]
  def coabfail(ast: FAST) = ast.ana[FAST](coab)"

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:31:41.286Z
"Error:(219, 42) not enough arguments for method apply: (implicit evidence$19: scalaz.Functor[slamdata.Predef.List], implicit T: matryoshka.Corecursive.Aux[prestwood.PrestwoodAST.FAST,slamdata.Predef.List])prestwood.PrestwoodAST.FAST in class PartiallyApplied.
Unspecified value parameter T.
  def coabfail(ast: FAST) = ast.ana[FAST](coab)"

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T22:33:06.412Z
You need a Coalgebra[FAST, List[FAST[_]]] I think

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:35:31.080Z
fast doesn't have any holes

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:40:12.634Z
looking around at the exp implementation in the docs, i see that they're creating a couple of implicits - arbitrary, equal

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:40:22.418Z
that i'm not. i've just implemented map and traverse

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:40:30.172Z
i don't grok what those are for

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T22:40:46.090Z
Oh not FAST

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T22:40:50.488Z
I mean `PrestwoodAST`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T22:40:56.424Z
`Fix` does not belong in the `Coalgebra`

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:44:15.129Z
```
  def coab: Coalgebra[List, PrestwoodAST[_]] = {
    case x => List(x)
  }


  def coabfail(ast: FAST) = ast.ana[FAST](coab)
```

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:44:26.926Z
Error:(220, 43) type mismatch;
 found   : matryoshka.Coalgebra[slamdata.Predef.List,prestwood.PrestwoodAST[_]]
    (which expands to)  prestwood.PrestwoodAST[_] => List[prestwood.PrestwoodAST[_]]
 required: matryoshka.Coalgebra[?,prestwood.PrestwoodAST.FAST]
    (which expands to)  matryoshka.data.Fix[prestwood.PrestwoodAST] => ?
  def coabfail(ast: FAST) = ast.ana[FAST](coab)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T22:44:32.341Z
Wait, what are you trying to do?

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:44:34.897Z
adamant that it doesn't like that, either

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:44:43.708Z
i am just trying to get this coalgebra to compile

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T22:44:43.957Z
Coalgebras build structures, they don't take them down

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:45:10.661Z
the compiler seems to like the coalgebra okay

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:45:31.414Z
sorry, i'm working on just getting ana to compile

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T22:45:50.070Z
Okay but what is ana supposed to do

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T22:45:52.692Z
Describe it to me

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:45:56.520Z
what i believe that should do is wrap every element of the AST in a list

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:46:01.020Z
and then only return one of them

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:46:32.063Z
presumably one of the tails, because it goes top to bottom

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T22:46:46.950Z
ana does not consume a structure at all

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:46:59.993Z
not really, no

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:47:14.213Z
just going for a "okay this compiles, now let's make it dance" approach

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:48:23.154Z
(also, you were right about the children method yestereday. thanks for the help :).)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T22:49:57.433Z
Your type annotations are wrong because `ana`'s type argument should be a `Fix[F]` which it can recursively build

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T22:50:03.995Z
And that's what it will return, too

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T22:50:28.540Z
And the coalgebra it wants will be a `Coalgebra[F, A]`, where `A` is the type of `x` in `x.ana`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T22:51:07.585Z
All `ana` will give you is a recursive structure, that is an entire `Fix[F]` or similar

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:52:13.523Z
hm. FAST is Fix[PrestwoodAST]

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T22:52:22.966Z
So you're constructing a `FAST`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T22:52:37.963Z
So there's no List in there, right, because you're using a `FAST` as the argument to construct another `FAST`

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:53:58.822Z
Okay, so it can't return a List[Fix[..]]

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:56:16.514Z
ahhh. okay. that kinda makes sense. so it's just not a well-formed operation - starting with the type i'm trying to end with dorks it up

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:57:39.079Z
Well then. I'll stop trying to do that.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T22:57:56.897Z
You've got it exactly

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T22:58:43.340Z
much obliged.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:00:10.671Z
so towards my goal of having writing a compiler - i'd like to be able to arbitrarily annotate the AST. the internet says histo might be good for that, but the examples i've got are a little too haskell for my consumption

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:00:57.234Z
does that sound like the right direction to head in? Cofree?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:02:52.170Z
Cofree yes, histo no

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:03:11.611Z
Histo is also destructive, it takes `Cofree` as a parameter and doesn't have it as a result

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:04:10.347Z
So you want to take your `Fix[F]` and make it a `Fix[Lambda[X => (A, F[X])]]`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:05:32.196Z
The relationship with cofree here is that `Cofree[F, X]` is the same as `Fix[Lambda[A => (X, F[A]]`

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:05:54.558Z
hm.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:10:23.153Z
So you want to deconstruct your `Fix[F]` and reconstruct a `Fix[G]`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:11:36.457Z
`Lambda[A => (X, F[A])` is the same as `EnvT[F, X, ?]` btw

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:12:48.844Z
hm. okay. i don't recognize lambda or EnvT

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:13:40.111Z
Oh okay

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:13:45.445Z
https://github.com/non/kind-projector

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:14:01.924Z
I recommend getting familiar with this compiler plugin, you need it to write any complex type constructors in Scala

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:14:17.857Z
will do

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:14:49.395Z
so i don't see anything that really hints at that operation in the "recursion scheme" cheat sheet

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:15:06.637Z
`meta` is the same thing there

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:15:09.270Z
If you're on the Kmett one

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:16:43.025Z
the one on the metroyshka github? i see ana followed by cata there

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:18:03.170Z
That should be cata followed by ana

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:19:02.967Z
[![image.png](https://files.gitter.im/slamdata/matryoshka/SnDD/thumb/image.png)](https://files.gitter.im/slamdata/matryoshka/SnDD/image.png)

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:20:01.898Z
okay, noted. might need to fix that cheat sheet :)

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:20:16.427Z
i'm also noting that meta doesn't seem to be implemented?

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:20:26.612Z
is there some more general scheme i want to use?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:20:31.568Z
The thing is there's two ways to define meta

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:20:33.873Z
That aren't equivalent

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:20:38.091Z
transCata and transAna

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:23:21.971Z
so transCata takes F[U] => G[U]

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:23:44.610Z
Yeah, so I'm assuming what you need to label an `F[_]` is the `F[_]` itself

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:24:15.425Z
i think so. just going to label based on info in the AST

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:24:37.709Z
You don't need all of the `Fix[F]` children, right?

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:25:20.464Z
erm, oh. i'm not sure. i was leaning towards yes, i do

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:25:38.402Z
i wanted to do the annotation based on children to build up a local symbol table in blocks

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:29:09.715Z
I have an idea which may make this easier for you

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:29:24.885Z
i am all ears

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:30:30.775Z
Actually wait, is there no scoping by `{ }` in your language?

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:30:56.553Z
well, since we last talked, i decided, yeah, i do want that within function blocks

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:31:28.645Z
Right so that means you're going to have some kind of representation of `{ }` occurrences in your AST if you're gonna have enough information in your symbol table

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:31:50.423Z
ya, and i have a Block node

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:31:56.981Z
i could attach it there

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:33:07.790Z
ideally i'd like to make it visible to the children, though. if i'm invoking a function in a particular context, i'd like to know if the parameters have been defined

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:33:34.566Z
Right so your annotation calculation needs to be aware of the annotation directly above

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:33:46.348Z
at least, yes

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:38:14.007Z
Well actually the annotation directly before

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:38:32.688Z
I'm kind of stuck on this, I don't see how this would work for a statement-oriented language

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:39:24.811Z
so... here's what i'm imagining

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:41:11.041Z
```
class DigitalOcean(apikey: String) {
    def createVM() {
        CMD("curl digitalocean.com?$apikey")
    }
}
```

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:41:32.619Z
ahh. lemme edit that

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:43:10.917Z
so when i'm looking at the function definition, i'd like to verify whether or not apikey is a valid identifier

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:43:58.409Z
the class's declaration block would have apikey as a symbol

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:44:11.759Z
but the function definition would need access to the table

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:44:48.795Z
idk. i could probably encode it differently. that's just how i've been thinking about doing it

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:46:09.618Z
i am decidedly just making this up as i go along :)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:46:27.144Z
Right so I think what you want here is bottom-up, which means you're going to have to start with `ana`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:47:44.333Z
You're going to have to calculate a `(SymbolTable, F[SymbolTable]) => SymbolTable` which produces the "next" SymbolTable from the current one and the ones below

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:48:42.612Z
Actually it's going to have to produce the *new current* `SymbolTable` as well as the *next* `SymbolTable`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:49:20.039Z
So `(SymbolTable, F[SymbolTable]) => (SymbolTable, SymbolTable)`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:50:31.726Z
The method that you use needs to take as parameters a `Fix[PrescottAST]` and a starting `SymbolTable` (which will be the empty table), and that function above

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:51:04.367Z
It will return `Fix[EnvT[PrescottAST, SymbolTable, ?]]`

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:53:09.115Z
hmm. okay. i... kind of see it

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:55:03.937Z
what's the hole at the end about?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:55:27.915Z
`Fix(EnvT(PrescottAST, SymbolTable, _))` kind of thing

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:56:13.178Z
Unnamed lambda

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-03T23:56:30.056Z
```scala
type ETP[A] = EnvT[PrescottAST, SymbolTable, A]
Fix[ETP]
```

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:56:42.393Z
ah, gotcha.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-03T23:59:34.357Z
so transAna takes a function from F[T]=>G[T]. Does that mean I need a function that looks like
```
def f:((SymbolTable, F[SymbolTable]) => (SymbolTable, SymbolTable), SymbolTable) => (Fix[PrestwoodAST] => Fix[EnvT[PrescottAST, SymbolTable, ?]])
```

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T00:00:19.322Z
Whoa

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T00:00:22.374Z
I don't think so

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T00:00:33.042Z
Wait uh

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T00:01:14.557Z
I believe so

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T00:01:55.518Z
haha, alright. then i am going to charge ahead in that direction and see what falls out

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T00:02:54.759Z
thanks again for the help, edmund!

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T00:04:32.618Z
You're welcome :)

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T00:42:58.654Z
are there any conveniences for constructing cofree values?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:01:34.613Z
A `Corecursive[F, Cofree[F, A]]`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:01:50.570Z
Also some methods on `Cofree` itself

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:05:44.568Z
man i am confused

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:06:49.459Z
so i decided to momentarily ditch the symbol table - annotating the tree with anything at all would be sufficient for the moment

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:07:04.485Z
```
  type ETP = Lambda[A => (Int, PrestwoodAST[A])]

  def ta: (Fix[PrestwoodAST] => Fix[ETP])= {
    case a @ Fix(Assignment(x, y)) => EnvT()
      Fix(Cofree.apply(0, StringLiteral[Cofree[PrestwoodAST, Int]]("asdf")))
      //Fix(EnvT(f(0), Assignment[Cofree[PrestwoodAST, Int]](x, Cofree(f(1), PrestwoodAST.StringLiteral[Cofree[PrestwoodAST, Int]]("asdf")))))
  }
```

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:07:29.697Z
^^ confused scribbles

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:07:32.468Z
What you're doing with `type ETP` doesn't work, because the only types that exist in Scala are fully-applied to their arguments

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:07:49.184Z
So like, `type ETP[A] = (Int, PrestwoodAST[A])` works

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:11:27.804Z
hm

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:15:16.073Z
so cofree and envt are interchangeable here?

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:25:45.017Z
ahhh. okay. so i think we were making at least one error here. The type of transAna is G[U] => T[U], i.e. we would be losing the fix

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:26:01.340Z
What is the type of `transAna`?

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:26:33.044Z
oh, sorry. the type of the function it accepts - (f: F[T] => G[T])

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:26:59.454Z
So the function can't observe any full trees, just a single layer of the tree's structure

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:27:35.503Z
But ultimately what it returns is still a full tree

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:28:43.561Z
but so... is having in that function signature correct?

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:28:52.222Z
i was able to make the red squigglies go away when i removed it

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:28:59.468Z
```
  def ta: Fix[PrestwoodAST] => Cofree[PrestwoodAST, Int] = {
    case Fix(Assignment(x, y)) =>
      Cofree.apply(0, Assignment[Cofree[PrestwoodAST, Int]](Id[Cofree[PrestwoodAST, Int]]("String"), Cofree(0, StringLiteral[Cofree[PrestwoodAST, Int]]("okay"))))
  }
```

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:29:29.322Z
So your function should be `PrestwoodAST ~> ETP`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:30:05.435Z
Er wait sorry

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:31:10.915Z
`PrestwoodAST[Cofree[PrestwoodAST, Int]] => (Int, Cofree[PrestwoodAST, Int])`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:31:31.560Z
So you peel off one layer and put it back on as a new `Int`

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:32:54.129Z
and it's accumulating all of the results within the cofree structure (~magically)?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:33:38.692Z
Well you have a `Fix[PrestwoodAST]` right

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:33:47.788Z
right

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:33:50.236Z
not so much magic

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:33:55.243Z
You `unFix` that to a `PrestwoodAST[Fix[PrestwoodAST]]`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:34:25.388Z
Then you reach in that `PrestwoodAST` level using `map`, and you feed that `Fix[PrestwoodAST]` inside to the function you're defining right now

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:34:30.801Z
Recursively

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:34:43.643Z
Now you have a `PrestwoodAST[Cofree[PrestwoodAST, Int]]`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:35:14.992Z
Crap okay my other type is still not right :P

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:35:27.998Z
`PrestwoodAST[Cofree[PrestwoodAST, Int]] => (Int, PrestwoodAST[Cofree[PrestwoodAST, Int]])`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:35:58.115Z
Because you're keeping that structure around, right, you're just adding some extra structure on top (the `(Int, ?)`)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:36:11.068Z
So you take that `PrestwoodAST[Cofree[PrestwoodAST, Int]]` you had, right

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:36:17.970Z
Apply the function the user provided to that

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:36:28.329Z
Now you have an `(Int, PrestwoodAST[Cofree[PrestwoodAST, Int]])`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:37:11.718Z
Cofree has this instance of `Corecursive`, but the `G` it has which you can "put inside" a `Cofree[F, A]` is `(Int, F[?])`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:37:34.359Z
So it uses that method to get back out a `Cofree[PrestwoodAST, Int]` and you're done!

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:39:12.929Z
hahaha. easy peasy.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:39:53.623Z
so just as a test of that, tried to compile this

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:40:06.128Z
```
  def omfg: PrestwoodAST[Cofree[PrestwoodAST, Int]] => (Int, PrestwoodAST[Cofree[PrestwoodAST, Int]])= {
    case a @ Assignment(x, y) => (0, a)
  }

  def plzwork(ast: FAST) = ast.transAna[FAST](omfg)

```

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:40:35.320Z
Error:(209, 47) type mismatch;
 found   : prestwood.PrestwoodAST[scalaz.Cofree[prestwood.PrestwoodAST,slamdata.Predef.Int]] => (slamdata.Predef.Int, prestwood.PrestwoodAST[scalaz.Cofree[prestwood.PrestwoodAST,slamdata.Predef.Int]])
    (which expands to)  prestwood.PrestwoodAST[scalaz.Cofree[prestwood.PrestwoodAST,Int]] => (Int, prestwood.PrestwoodAST[scalaz.Cofree[prestwood.PrestwoodAST,Int]])
 required: prestwood.PrestwoodAST[prestwood.PrestwoodAST.FAST] => ?
    (which expands to)  prestwood.PrestwoodAST[matryoshka.data.Fix[prestwood.PrestwoodAST]] => ?
  def plzwork(ast: FAST) = ast.transAna[FAST](omfg)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:41:02.541Z
`transAna[Cofree[PrestwoodAST, Int]]`

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:42:00.257Z
okay, so i need to make that initial Fix[Prestwood] that gets passed in into a Cofree before i can do this

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:42:54.670Z
Yeah, isn't that `ast`?

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:43:23.194Z
ast is Fix[PrestwoodAST], or FAST

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:43:39.736Z
need to transform that somehow

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:44:04.550Z
Not `transAna`?

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:44:20.557Z
i don't follow

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:44:31.042Z
I don't follow what you're saying

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:44:57.480Z
```
  def plz: PrestwoodAST[Cofree[PrestwoodAST, Int]] => (Int, PrestwoodAST[Cofree[PrestwoodAST, Int]])= {
    case a @ Assignment(x, y) => (0, a)
  }

  def plzwork(ast: FAST) =  ast.transAna[Cofree[PrestwoodAST, Int]](plz)
```

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:45:02.568Z
is no bueno

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:45:17.726Z
Error:(209, 69) type mismatch;
 found   : prestwood.PrestwoodAST[scalaz.Cofree[prestwood.PrestwoodAST,slamdata.Predef.Int]] => (slamdata.Predef.Int, prestwood.PrestwoodAST[scalaz.Cofree[prestwood.PrestwoodAST,slamdata.Predef.Int]])
    (which expands to)  prestwood.PrestwoodAST[scalaz.Cofree[prestwood.PrestwoodAST,Int]] => (Int, prestwood.PrestwoodAST[scalaz.Cofree[prestwood.PrestwoodAST,Int]])
 required: prestwood.PrestwoodAST[prestwood.PrestwoodAST.FAST] => ?
    (which expands to)  prestwood.PrestwoodAST[matryoshka.data.Fix[prestwood.PrestwoodAST]] => ?
  def plzwork(ast: FAST) =  ast.transAna[Cofree[PrestwoodAST, Int]](omfg)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:45:18.101Z
what is `omfg` here

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:46:13.979Z
sorry, was renaming it

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:46:17.041Z
plz=omfg

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:48:03.719Z
so i'm trying to transform my Fix[PrestwoodAST] by using the transAna function, and traversing it with "plz", a function from Prestwood[Cofree etc] to (Int, Prestwood[Cofree etc])

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:48:26.143Z
i don't really understand where the initial cofree value is supposed to come from

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:48:36.667Z
or if i'm creating one on each level

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:49:43.476Z
or if i should have already converted the AST from Prestwood[Fix[Prestwood]] to Prestwood[Cofree[Prestwood, Int]]

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:50:12.259Z
No, this is the recursion in `transAna` doing this

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:50:38.992Z
So the problem here is I made a mistake, you have to use `EnvT` and not `(A, F[?])`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:50:46.958Z
They're the same, just different types

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:51:18.143Z
> You `unFix` that to a `PrestwoodAST[Fix[PrestwoodAST]]`
Then you reach in that `PrestwoodAST` level using `map`, and you feed that `Fix[PrestwoodAST]` inside to the function you're defining right now
Recursively
Now you have a `PrestwoodAST[Cofree[PrestwoodAST, Int]]`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:51:32.302Z
This part is in `transAna`

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T01:52:07.432Z
ahhh.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T01:54:26.869Z
So `PrestwoodAST[Cofree[PrestwoodAST, Int]] => EnvT[PrestwoodAST, Int, Cofree[PrestwoodAST, Int]]`

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T02:01:26.441Z
man, still no dice.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T02:01:37.401Z
?

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T02:01:47.549Z
The first type parameter to EnvT is E, and doesn't have any holes

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T02:01:53.800Z
Oh okay

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T02:01:56.220Z
Put Int first 

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T02:02:09.729Z
i swapped them, that looked okay

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T02:02:31.455Z
but didn't compile - 

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T02:02:37.362Z
```
  def plz: PrestwoodAST[Cofree[PrestwoodAST, Int]] => EnvT[Int, PrestwoodAST, Cofree[PrestwoodAST, Int]] = {
    case a @ Assignment(x, y) => EnvT((0, a))
  }

  def plzwork(ast: FAST) =  ast.transAna[Cofree[PrestwoodAST, Int]](plz)
```

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T02:02:51.592Z
Error:(211, 69) type mismatch;
 found   : prestwood.PrestwoodAST[scalaz.Cofree[prestwood.PrestwoodAST,slamdata.Predef.Int]] => matryoshka.patterns.EnvT[slamdata.Predef.Int,prestwood.PrestwoodAST,scalaz.Cofree[prestwood.PrestwoodAST,slamdata.Predef.Int]]
    (which expands to)  prestwood.PrestwoodAST[scalaz.Cofree[prestwood.PrestwoodAST,Int]] => matryoshka.patterns.EnvT[Int,prestwood.PrestwoodAST,scalaz.Cofree[prestwood.PrestwoodAST,Int]]
 required: prestwood.PrestwoodAST[prestwood.PrestwoodAST.FAST] => ?
    (which expands to)  prestwood.PrestwoodAST[matryoshka.data.Fix[prestwood.PrestwoodAST]] => ?
  def plzwork(ast: FAST) =  ast.transAna[Cofree[PrestwoodAST, Int]](plz)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T02:04:50.363Z
You need some more type arguments I think

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T02:05:49.199Z
Add `[EnvT[Int, PrestwoodAST, ?]]` after the first set of type arguments to `transAna`

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T02:07:06.548Z
hm, says wrong number of type parameters

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T02:07:12.293Z
```
  def plzwork(ast: FAST) =  ast.transAna[Cofree[PrestwoodAST, Int], EnvT[Int, PrestwoodAST, ?]](plz)
```

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T02:08:03.668Z
oh. placed them after, got a different error

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T02:08:11.220Z
looks more promising

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T02:08:12.459Z
Error:(209, 97) type mismatch;
 found   : prestwood.PrestwoodAST[scalaz.Cofree[prestwood.PrestwoodAST,slamdata.Predef.Int]] => matryoshka.patterns.EnvT[slamdata.Predef.Int,prestwood.PrestwoodAST,scalaz.Cofree[prestwood.PrestwoodAST,slamdata.Predef.Int]]
    (which expands to)  prestwood.PrestwoodAST[scalaz.Cofree[prestwood.PrestwoodAST,Int]] => matryoshka.patterns.EnvT[Int,prestwood.PrestwoodAST,scalaz.Cofree[prestwood.PrestwoodAST,Int]]
 required: prestwood.PrestwoodAST[prestwood.PrestwoodAST.FAST] => matryoshka.patterns.EnvT[Int,prestwood.PrestwoodAST,prestwood.PrestwoodAST.FAST]
    (which expands to)  prestwood.PrestwoodAST[matryoshka.data.Fix[prestwood.PrestwoodAST]] => matryoshka.patterns.EnvT[Int,prestwood.PrestwoodAST,matryoshka.data.Fix[prestwood.PrestwoodAST]]
  def plzwork(ast: FAST) =  ast.transAna[Cofree[PrestwoodAST, Int]][EnvT[Int, PrestwoodAST, ?]](plz)

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T02:30:28.089Z
Ahhhh! It worked! 
```
  type envt[A] = EnvT[Int, PrestwoodAST, A]
  def maybe2: PrestwoodAST[Fix[PrestwoodAST]] => EnvT[Int, PrestwoodAST, FAST] = {
    case x => EnvT(0, x)
  }

    def plzwork(ast: FAST) =  ast.transAna[Cofree[PrestwoodAST, Int]][envt](maybe2)
```

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T02:55:00.030Z
It's so good! thanks so much for your help, @edmundnoble Cofree still wigs me out, and figuring out how to do anything with it is gonna take a minute, but it feels great to have that running. putting arbitrary integers on all of the things!

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T02:55:39.852Z
You're so welcome :) hopefully Cofree doesn't elude you for too long, it's very similar to Fix

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T03:04:56.122Z
oh, also - it looks like we had the type signature right, but for transCata, and not transAna

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T03:05:08.214Z
Oh wow did I flip it

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T03:05:09.951Z
```
  def maybe3: PrestwoodAST[Cofree[PrestwoodAST, Int]] => EnvT[Int, PrestwoodAST, Cofree[PrestwoodAST, Int]] = {
    case b @Block(a) => EnvT(a.length, b)
    case at @ AndThen(_, _) => EnvT(2, at)
    case x => EnvT(1, x)
  }
  def plzwork2(ast: FAST): Cofree[PrestwoodAST, Int] =  ast.transCata[Cofree[PrestwoodAST, Int]][envt](maybe3)
```

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T03:05:26.332Z
yeah, that one compiles :D

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T03:05:38.628Z
Oh wow, interesting

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T03:05:47.317Z
i... i'm going to figure out how to  make a gist

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T03:06:21.412Z
seems silly not to have a cookbook for these things

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T03:06:46.001Z
IMO most of them might not need to exist, they're all just cata or ana anyway

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T03:07:27.805Z
very possible.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T03:07:47.447Z
but also, i'm at about the 30 hour mark on reading/writing recursion schemes

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T03:08:05.601Z
I'd recommend writing the schemes yourself in terms of cata and ana

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T03:08:16.293Z
Writing cata and ana themselves first

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T03:08:26.337Z
sounds like a very useful exercise

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T03:08:58.702Z
less fun if it's not magic, tho

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T03:09:08.613Z
lmao

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T03:27:00.221Z
alright. hard won lessons of this holiday weekend, immortalized: https://gist.github.com/DanielPorter/460ff5e4c5246ef680e053d95bd5a010

                                                                                                                                                      Valentin Kasas @vil1@2017-09-04T15:05:23.440Z
Hi. I managed to allocate some time for my data+schema traversal problem.
reminder: I have two carrier functors, namely `SchemaF` and `DataF`. `SchemaF`, along with the respective (co)algebras, allows me to transform spark's `StructType` to avro's `Schema` and vice versa. I want to to the same for data and transform spark's `GenericRowWithSchema` to avro's `GenericContainer`. 

                                                                                                                                                      Valentin Kasas @vil1@2017-09-04T15:06:52.388Z
Last time, I mistakenly thought that I needed the schema while, eg, destructing a `GenericContainer` to make a `DataF`. That was a mistake since `GenericContainer` embeds a schema

                                                                                                                                                      Valentin Kasas @vil1@2017-09-04T15:07:58.969Z
So I was able to write an instance of `Recursive.Aux[GenericContainer, DataF]` without any serious trouble

                                                                                                                                                      Valentin Kasas @vil1@2017-09-04T15:08:58.946Z
But I still have a problem when I want to go the other way around, namely implementing an `Algebra[DataF, GenericContainer]`

                                                                                                                                                      Valentin Kasas @vil1@2017-09-04T15:10:58.526Z
I could infer the schema from the data in most cases, but there are some edge cases where this is impossible. For example when I have an empty array in my data, I cannot infer the schema for that array from the data alone

                                                                                                                                                      Valentin Kasas @vil1@2017-09-04T15:12:01.363Z
So I'm back to my initial problem : traversing a `DataF`and the corresponding `SchemaF` at the same time

                                                                                                                                                      Valentin Kasas @vil1@2017-09-04T15:16:05.490Z
I've tried to implement a `Algebra[SchemaF, Algebra[DataF, GenericContainer]]` which sounded promising at first, but failed since at each level of my `SchemaF` I cannot use the `Algebra[DataF, GenericContainer]` I've built bellow to make a "bigger" `Algebra[DataF, GenericContainer]`

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T15:35:02.803Z
@vil1 don't think i have anything constructive to add, but i'm interested in seeing what other people are doing/hitting their heads on. any chance your code is in a repo somewhere i could see?

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T15:36:10.127Z
if i'm understanding correctly, it sounds a lot like you're facing the same problem that i'm facing - i want to aggregate information from root nodes up to child nodes of my AST, but there's no clear mechanism to do that

                                                                                                                                                      Valentin Kasas @vil1@2017-09-04T15:36:12.598Z
for the moment that's proprietary work I'm afraid

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T15:36:19.753Z
fair :)

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T15:36:50.572Z
i keep wanting to accumulate the information in a writer monad, but there's no way to let each successive layer see that writer monad, you don't get access to it until after the traversal is complete

                                                                                                                                                      Valentin Kasas @vil1@2017-09-04T15:37:57.515Z
that's indeed similar

                                                                                                                                                      Valentin Kasas @vil1@2017-09-04T15:38:51.328Z
FWIW, I know that both instances of DataF and SchemaF ought to share a common (or at least very similar) structure

                                                                                                                                                      Valentin Kasas @vil1@2017-09-04T15:40:37.727Z
I've also considered building an intermediate DataWithSchema that would hold the same fields as DataF plus a Fix[SchemaF], but in hindsight it's just restating the same problem 

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T15:48:27.519Z
hm. so i've started working with cofree, which has coflatmap, which lets you apply a function to each node in the tree. I'm not completely sure if this buys me anything, but i'm imagining i could annotate each node with the entire structure, thereby giving it access to the parents

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T15:48:34.490Z
it seems horribly inefficient

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T15:49:21.260Z
the idea is stemming from http://blog.higher-order.com/ where he talks about doing a graph decomposition in a similar way

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T15:50:06.013Z
i've been idly contemplating if what i really want is a graph and not an AST

                                                                                                                                                      Valentin Kasas @vil1@2017-09-04T16:18:57.048Z
idly contemplating, that's what I do best

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T17:14:09.392Z
trying is the first step towards failure

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-04T17:20:08.274Z
Ha, I've been reading the comonadic graph decomposition post last week, too :D

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-04T17:26:40.272Z
I don't know if my recent adventures with open recursion are useful to you, but just in case, you can find them here: https://github.com/tscholak/autodiff

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T17:26:57.348Z
can't hurt

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T17:27:32.193Z
don't see a readme - would you be so generous as to give me a high level of what you're doing?

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-04T17:47:26.396Z
Very briefly, it's an attempt to do computer algebra using open recursion. The Ast is a set of simple mathematical operations like negation, summation, multiplication, etc. Autodiff refers to automatic differentiation. I am able to compute (higher order) derivatives of recursive expressions over the operation.

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-04T17:49:17.195Z
Later I am going to implement optimization algorithms like gradient descent that need the first derivatives (gradients) of a mathematical function

                                                                                                                                                      Valentin Kasas @vil1@2017-09-04T17:56:23.880Z
I'll try to digest Runar's post, see you in a month ^^

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-04T18:03:18.425Z
Lol

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T18:06:37.352Z
@DanielPorter I think a graph may be useful for some operations, consider that Ensime uses a graph database internally

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T21:44:31.092Z
So i've been wrestling with this all day, and while i haven't solved it, i think i have distilled the issue i keep running into into a simple case.

Given an AST, how can i annotate the depth of each node, starting from zero?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T21:56:48.057Z
```scala
type PrescottASTInt[A] = EnvT[Int, PrescottAST, A]
type FASTI[A] = Fix[PrescottASTInt]
def annotateDepth(fast: FAST, depth: Int = 0): FASTI = fast.unFix match {
  case Block(b) => Fix[PrescottASTInt](EnvT(depth, Block(annotateDepth(b, depth + 1))))
}
```

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T21:59:34.044Z
so that's general recursion. is this unachievable with recursion schemes?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T21:59:43.957Z
No, it's not

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T21:59:53.049Z
I'm just showing you what it will be when you've inlined the scheme ;)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T22:00:20.836Z
There are a couple of things you can abstract over, here

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T22:00:55.269Z
ahh, alright :) in that case, yes, that definitely looks like what i'm after.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T22:01:38.984Z
I would take a look at `gana` or `gcata` maybe

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T22:02:21.642Z
how does one generate a distributive law?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-04T22:02:38.977Z
Look in the `matryoshka` package for some you may want

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T22:03:40.212Z
ahhhh. okay

                                                                                                                                                      Greg Pfeil @sellout@2017-09-04T23:03:32.441Z
@DanielPorter For _height_ it’s already there as `_.transCata(attributeAlgebra(height))`. You could then map over that, converting height to depth. Doing depth directly is a bit more complicated, as it’s corecursive. So you might have to do it with `Coalgebra[EnvT[Int, PrescottAST, ?], FAST]` as in @edmundnoble’s example.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T23:07:24.748Z
oh, cool. hadn't run across that.

I'm really using this as the simple case for how to see information from ancestors

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-04T23:08:36.051Z
so coalgebra's probably the path forward

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T00:15:23.498Z
Hm. still fairly befuddled. 

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T00:16:56.695Z
Wrote a dumb little coalgebra. this is obviously not fit for purpose, as i'm just wrapping it with an integer
```
  type FAST = Fix[PrestwoodAST]
  type PrestwoodASTI[A] = EnvT[Int, PrestwoodAST, A]
  def x: Coalgebra[PrestwoodASTI, FAST] = {
    case Fix(x) => EnvT(1, x)
  }
```

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T00:19:05.927Z
Wrote a GCoalgebra, but i'm not grokking the mechanics, and i'm getting a no implicit monad found for PrestwoodASTI
```
  type FASTI[A] = Fix[PrestwoodASTI]
  type FAST = Fix[PrestwoodAST]
  type PrestwoodASTI[A] = EnvT[Int, PrestwoodAST, A]
  def x: GCoalgebra[PrestwoodASTI, FASTI, FAST] = {
    case Fix(Assignment(Id(id), expr)) => Fix[PrestwoodASTI](EnvT(1, Id[Fix[PrestwoodASTI]]("")))
  }

  def dl = new DistributiveLaw[PrestwoodASTI, FASTI] {
    def apply[A](fa: PrestwoodASTI[FASTI[A]]): FASTI[A] = {
      Fix(fa)
    }
  }

  def ganarun(ast: FAST) = ast.gana[FASTI[FAST]][PrestwoodASTI, FASTI](dl, x)
```

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T00:22:48.582Z
which... looking at EnvT's definition, it says it's the tuple comonad, not a monad, so that makes sense

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T00:34:03.696Z
how does the value get carried from parent to child here?

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-05T00:44:15.735Z
hey @DanielPorter, trying to read your code. can you turn on scala syntax highlighting for your snippets? you can do that by adding the word "scala" immediately after the initial three accents

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T00:45:03.102Z
Okay! Won't let me edit it now, will repost:
```scala
  type FASTI[A] = Fix[PrestwoodASTI]
  type FAST = Fix[PrestwoodAST]
  type PrestwoodASTI[A] = EnvT[Int, PrestwoodAST, A]
  def x: GCoalgebra[PrestwoodASTI, FASTI, FAST] = {
    case Fix(Assignment(Id(id), expr)) => Fix[PrestwoodASTI](EnvT(1, Id[Fix[PrestwoodASTI]]("")))
  }

  def dl = new DistributiveLaw[PrestwoodASTI, FASTI] {
    def apply[A](fa: PrestwoodASTI[FASTI[A]]): FASTI[A] = {
      Fix(fa)
    }
  }

  def ganarun(ast: FAST) = ast.gana[FASTI[FAST]][PrestwoodASTI, FASTI](dl, x)
```

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-05T00:45:12.799Z
cool, thx

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T00:54:04.816Z
and so if the context isn't clear, my goal here is something that will annotate the AST with depth, as a jumping off point for being able to implement more interesting things which require access to information supplied by ancestors

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-05T00:54:49.829Z
I'll try to do the same with my ast tonight, maybe we can figure out together what's going on

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T00:55:09.376Z
:)

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T00:55:17.856Z
gonna be up for a couple more hours

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-05T00:55:51.486Z
me too. can I suggest you get the kind projector plugin? add `addCompilerPlugin("org.spire-math" %% "kind-projector" % "0.9.4")` to `build.sbt`.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T00:56:27.297Z
yeah, did so as per edmund's suggestion, but i guess it's not that useful if you don't use it..

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-05T00:56:28.514Z
then you can just write `Coalgebra[EnvT[Int, ExprF, ?], ...etc]`

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-05T00:56:43.408Z
`ExprF` is my ast

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-05T00:57:19.161Z
you can basically inline the type definition, and holes become `?`

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-05T00:57:35.666Z
I'll be back after dinner.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T00:57:42.532Z
okay! i'll be around

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-05T01:52:48.425Z
k, I'm back

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T01:52:59.776Z
so i've been staring at hylo hoping some meaning will fall out, and it... kind of has. I at least think i grok what hylo does, now. 

Hylo accepts a:A, psi, and phi. It applies psi to a which yields a functor, F[A]. It then maps over that functor, and applies hylo(a, psi, phi) to each a that gets returned, or in my case, each child. Eventually the mapping over the functor stops yielding results, and the results all have phi applied to them. 

So if you were going to encode passing information from one invocation of psi to the next, that functor's map function would have to yield that information. So that's where something like EnvT would come in, but its' map isn't sufficient -
```scala
  def map[B](f: A => B)(implicit W: Functor[W]): EnvT[E, W, B] =
    envT((run._1, run._2.map(f)))
}
```
it simply preserves the first value, and in the case where i'm just setting 1 for everything, you just recursively assign 1 to everything. So ideally then you'd want a functor that when mapped over returns an EnvT.



                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T01:53:17.743Z
ah, just collecting my thoughts here

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-05T01:55:54.232Z
hylo is a fusion of fold and unfold

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T01:56:47.692Z
Yeah, understood. I'm trying to use gana, but I got to hylo by recursively following the definitions

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-05T01:57:58.532Z
semantically hylo should be the same as doing cata and ana in succession

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-05T01:59:01.310Z
cf.
```scala
  def ana[A](a: A)(f: Coalgebra[Base, A])(implicit BF: Functor[Base]): T =
    hylo(a)(embed, f)
```
and
```scala
  def cata[A](t: T)(f: Algebra[Base, A])(implicit BF: Functor[Base]): A =
    hylo(t)(f, project)
```

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T02:00:57.914Z
hm, okay, so you're just passing in project and embed to make the corresponding traversal no-op-ish

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-05T02:01:29.099Z
yes, it's how `ana` and `cata` are defined in the `Recursive`/`Corecursive` traits

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T02:30:19.817Z
so reading how gana is implemented - you pass in a value A, which gana lifts into monad N, and passes to ana. It also passes an anonymous psi function, which maps over that monad, and applies the GCoalgebra to it that you passed in. This presumably yields N[Base[A]], where base is some functor, perhaps the Fix[AST] in my case? It applies the distributive law k to N[Base[A]], which should yield Base[N[A]]. It then maps over Base[N[A]] and calls join, which.. i'm a little confused about. the definition seems to be that it's doing liskov substitution, but i don't know what that means in this context

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T02:32:57.532Z
i looked around at your AST. my math background is a little lacking so it's rather intimidating

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-05T02:34:37.275Z
I'm trying to figure out what one is supposed to do with the GCoalgebra... not much luck yet, there are only two occurrences in Quasar, and they are both convoluted

                                                                                                                                                      Greg Pfeil @sellout@2017-09-05T02:34:43.805Z
@DanielPorter Sorry, I think I led you a bit astray – I accidentally dropped the depth counter when showing the coalgebra made from @edmundnoble’s example.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-05T02:35:13.701Z
You want perhaps:
```scala
def depth[T, F[_]: Functor](implicit T: Recursive.Aux[T, F])
    : Coalgebra[EnvT[Int, F, ?], (Int, T)] = {
  case (i, t) => EnvT(i, t.project strengthL (i + 1))
}
```

                                                                                                                                                      Greg Pfeil @sellout@2017-09-05T02:35:41.329Z
Then you would do `(0, myTree).ana[Cofree[F, Int]](depth)`

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T02:36:33.021Z
Ahhhh. Okay.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-05T02:42:08.534Z
You could also do the dual …
```scala
def depth[F[_]]: Algebra[F, Int => Cofree[F, Int]] =
  f => i => Cofree(i, f.map(_(i + 1)))
```

                                                                                                                                                      Greg Pfeil @sellout@2017-09-05T02:42:33.809Z
Which you then call as `myTree.cata(depth)(0)`

                                                                                                                                                      Greg Pfeil @sellout@2017-09-05T02:43:15.506Z
And that could also be generalized from Cofree to anything Corecursive with `EnvT` as its functor.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-05T02:45:23.488Z
In this case, it doesn’t matter much, but there are other times when you’re forced to go one direction or the other, so this shows you how to pass data from the root to the leaves regardless of which direction you traverse the nodes.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T02:46:10.272Z
okay, thanks so much. #1 isn't compiling, getting an implicit divergence error, and i need to spend some more time with these to make sense of them

                                                                                                                                                      Greg Pfeil @sellout@2017-09-05T02:47:02.694Z
Yeah … I didn’t try to compile either of them. Unlike Knuth I have neither proved it correct nor tried it.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T02:47:08.289Z
will have to pick this back up later, though. glad to know this is possible

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-05T02:47:21.033Z
I just got #1 working. Needed to add some type annotation:
```scala
  def expr[T](implicit T: Corecursive.Aux[T, ExprF]): T = ???

  def depth[T, F[_]: Functor](implicit T: Recursive.Aux[T, F]): Coalgebra[EnvT[Int, F, ?], (Int, T)] = {
    case (i, t) => EnvT((i, t.project strengthL (i + 1)))
  }

  val tmp: Nu[EnvT[Int, ExprF, ?]] = (0, expr[Nu[ExprF]]).ana[Nu[EnvT[Int, ExprF, ?]]](depth[Nu[ExprF], ExprF])

```

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T02:48:08.911Z
haha. yeah, not looking for copypasta. i've hit the 40 hour mark on trying to grok recursion schemes, though. glad to know that this simple thing is simply achievabl

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T02:48:11.537Z
achievable*

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T02:49:08.280Z
one question which has remained mysterious - how does EnvT become cofree?

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-05T02:49:57.926Z
to answer that I can recommend @tpolecat's talk from last year

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-05T02:50:36.682Z
https://github.com/tpolecat/cofree

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T02:51:25.338Z
okay! :) thanks @greg, @tscholak , and @edmundnoble for all of your help

                                                                                                                                                      Greg Pfeil @sellout@2017-09-05T02:51:56.794Z
@DanielPorter So, aside from the “explicit” fixed-points, `Fix`, `Mu`, and `Nu`, any structure can have Recursive/Corecursive instances simply by defining the mapping between the recursive type and its pattern functor. For Cofree, it’s https://github.com/slamdata/matryoshka/blob/master/core/shared/src/main/scala/matryoshka/data/cofree.scala#L25

                                                                                                                                                      Greg Pfeil @sellout@2017-09-05T02:52:13.707Z
And yes - @tpolecat’s talk is fantastic.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-05T02:52:26.783Z
It's a 10/10

                                                                                                                                                      Rob Norris @tpolecat@2017-09-05T02:53:26.382Z
:heart: 

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-05T02:53:49.140Z
:clap: 

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T02:55:06.037Z
hm, pattern functor is a new concept for me, but that's clear as far as it goes

                                                                                                                                                      Greg Pfeil @sellout@2017-09-05T02:57:22.817Z
@DanielPorter Yeah, it’s “just” a functor where the normally recursive references in a structure are replaced by an additional type parameter. For `List a = Nil | Cons a (List a)`, the pattern functor is `ListF a r = Nil | Cons a r`, so `List[A] = Fix[ListF[A, ?]]` (to mix some Haskell & Scala).

                                                                                                                                                      Greg Pfeil @sellout@2017-09-05T02:57:41.387Z
So it represents a single step of a recursive structure.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T13:30:47.317Z
Okay, gotcha. So the thing we stick in fix, mu, cofree etc

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T15:11:28.393Z
Ahh, alright. So a question I had was "what would I want to use Ana for", and... parsers came to mind. But as it is "creating" something, you could also frame it as "lifting" (if im allowed to use that word here) a structure into a recursive data type. It could already be a recursive data type that you're lifting into another one, e.g. 

                                                                                                                                                      Greg Pfeil @sellout@2017-09-05T15:12:11.754Z
Yes to both.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T15:13:10.165Z
a simple recursive data type into a pattern functor. Neat.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T15:18:18.768Z
Is that a common usage?

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T15:18:46.921Z
Ahh, gitter keeps sending messages I'm not done with

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-05T15:19:10.836Z
yeah, the mobile version does that sometimes

                                                                                                                                                      Greg Pfeil @sellout@2017-09-05T15:24:13.888Z
@DanielPorter Yeah, I think it’s pretty common – the `Transform` types and `trans` operations are basically some sugar to make that a bit easier.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-05T15:25:47.275Z
Where you can go, say `F[Fix[G]] => G[Fix[G]]` rather than `F[Fix[G]] => Fix[G]`

                                                                                                                                                      Greg Pfeil @sellout@2017-09-05T15:26:59.017Z
Although I guess it tends to be _more_ useful for the unfolds, where, with `Fix[F] => G[Fix[F]]` the first thing you do in the coalgebra is `project` so you get `F[Fix[F]]` to match on.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T15:51:11.452Z
@vil1 hey, if i'm understanding your problem correctly, i think greg and torsten came up with a solution - a working way to allow nodes to see information generated by their ancestors

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T15:57:39.083Z
But there's an important difference

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T15:58:51.361Z
I want to label the nodes of a tree A with the nodes of another tree B

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T15:59:38.210Z
More precisely, with subtrees of B

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T16:01:24.715Z
I want to label the root of A with B, its leftmost child with the subtree of B starting at its leftmost child an so on

                                                                                                                                                      Greg Pfeil @sellout@2017-09-05T16:02:15.773Z
@vil1 Sorry, can you link back to your problem? I missed a ton of stuff this weekend.

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T16:02:30.963Z
That resembles what Runar describes somwhere in the post mentioned above

                                                                                                                                                      Greg Pfeil @sellout@2017-09-05T16:02:34.582Z
(Which is so amazing to me – that there was too much discussion over a couple days for me to keep up with it!)

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T16:03:01.669Z
Ransom of success

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T16:03:38.151Z
I m currently on my phone and commuting, so expect me to be slow

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T16:03:40.786Z
But

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T16:04:28.872Z
I've two carrier functors, SchemaF and DataF

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T16:06:19.880Z
I need to "label" each "node" of DataF with the "subtrees" of the corresponding SchemaF

                                                                                                                                                      Greg Pfeil @sellout@2017-09-05T16:09:43.472Z
Oh, so you want to show which part of the schema each part of the data matches?

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T16:26:06.751Z
That's it

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T16:26:50.762Z
I need that to transform my DataF to an avro GenericContainer

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T16:27:09.825Z
(among other things)

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T16:59:04.042Z
hm. It still seems pretty similar -

```scala
def zipWithSubtrees[something goes here]: Coalgebra[EnvT[SchemaF, F, ?], (SchemaF, T)] = {
    case(schema, data) => EnvT(i, t.project zip (schema.toList))
}
(SchemaF, DataF).cata(zipWithSubtrees)
```



                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T17:01:20.809Z
(incidentally, as i better understand what you're doing - adding schemas to unstructured data, i think - i am getting a much better understanding of why slamdata would want matroyshka for their nosql analytics)

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T17:04:03.704Z
I don't see how a cata could destruct both SchemaF and DataF simultaneously  : /

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T17:04:54.165Z
(nota, I'm now on a train, I might loose service at some point)

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T17:08:15.164Z
I can try to define `type Pair[A] = (SchemaF[A], DataF[A])` with the relevant Functor instance

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T17:10:05.358Z
hm. must be a subtlety i'm not seeing there

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-05T17:10:53.142Z
Label with how many "subtrees"? A list of them?

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T17:11:56.674Z
@DanielPorter eg when there is an empty array of structs in the data

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T17:12:51.402Z
@edmundnoble only the one that describes the schema of the data represented by each node 

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T17:14:42.571Z
I'll try to be more specific

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T17:17:40.391Z
I have (eluding the fixpoint and simplifying schemas by removing metadata and stuff) :
```
val schema = StructF(List( "foos" -> ArrayF(StructF(List("qux" -> ValueF(Types.Int)))), "bar" -> ValueF(Types.String)))
val data = StructDataF(List( "foos" -> ArrayDataF(Nil), "bar" -> StringDataF("I'm a bar!")))
```

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T17:19:11.454Z
and I want to be able to "merge" both trees into a single one

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T17:19:47.335Z


                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T17:22:09.861Z
I ultimately want to use both `schema` and `data` to produce an `org.apache.avro.generic.GenericContainer` 

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T17:22:40.017Z
which looks roughly like this : `case class GenericContainer(datum: GenericContainer, schema: org.apache.avro.Schema)` (the real stuff is much more ugly and involves `java.lang.Object`)

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T17:23:42.273Z
I've already an algebra that allows me to cata a `SchemaF` into an `avro.Schema`

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T17:26:58.335Z
could the empty array of structs issue be solved by representing the array as a data type? 
```scala
ArrayF[A](array: Array[A]) extends DataF[A]
```

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T17:29:12.095Z
but in that case, `A` will be `Nothing` when the array's empty right ?

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T17:29:38.249Z
and empty arrays are just one of many problems

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T17:29:56.901Z
there can also be "unions" in the schema

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T17:30:32.969Z
like "Int or String or Boolean", that I cannot deduce from the data alone

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T17:32:44.378Z
i don't think it will be. I think you can parameterize it - 
```scala
ArrayF[Cofree[SchemaF, DataF]](Nil)
```

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T17:35:50.866Z
i'm not sure how the union would affect things, but I'm imagining it would just be another type of SchemaF, and you'd be able to see as you traverse the tree

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-05T17:38:14.838Z
You're forgetting a type argument for `DataF`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-05T17:39:20.894Z
I think the pattern functor you're looking for here @vil1 is something like this:
```scala
type Pat[A] = (DataF[A], Fix[SchemaF])
```

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-05T17:39:29.522Z
So you're making a `Fix[Pat]`

                                                                                                                                                      Greg Pfeil @sellout@2017-09-05T17:40:03.415Z
@edmundnoble And that looks exactly like `EnvT[Fix[SchemaF], DataF, A]`

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T17:40:08.841Z
hmmm

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-05T17:40:51.481Z
Well yeah, it does ;)

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T17:41:07.288Z
so I'd need to ana that rather than cata it right ? and along the way, peel off layers of that `Fix[SchemaF]` as I go down my `DataF` ?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-05T17:41:33.608Z
That sounds like it would work

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T17:42:53.832Z
lemme digest that while I'm traversing France at 225 km/h

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T17:43:06.424Z
BRB

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T17:44:54.384Z
still convinced it looks isomorphic to the depth annotation, so you could also use cata as in the example that greg gave

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T18:08:06.858Z
re

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T18:24:09.697Z
okay, I'm clearly missing something here

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T18:25:18.670Z
```scala
  type Pat[A] = (DataF[A], Fix[SchemaF])

  def label(schema: Fix[SchemaF]): Coalgebra[Pat, Fix[DataF]] = { 
    case Fix(data) => (data, schema)
  }

```

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T18:56:18.570Z
```scala
def expr[T](implicit T: Corecursive.Aux[T, DataF]): T = ???

def zipTogether[T, F[_]: Functor](implicit T: Recursive.Aux[T, F]): Coalgebra[EnvT[SchemaF, F, ?], (SchemaF, T)] = {
	case (schemaf, dataf) => EnvT((i, t.project zip (schemaf.getchildren))
}

val tmp: Nu[EnvT[SchemaF, DataF, ?]] = (0, expr[Nu[DataF]]).ana[Nu[EnvT[SchemaF, DataF, ?]]](depth[Nu[DataF], DataF])
```

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T18:58:42.499Z
put that together copying torsten's code, as he indicated he got that to compile. swapped out the ExprF for DataF, and the ints for SchemaF. you'll need a function to get the chilldren of the schema F to zip into the thing.

also many or all of those SchemaFs should be Fix[SchemaF], just accidentally omitted them again

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-05T19:00:09.927Z
i feel like a pattern functor's "map" could be implemented in terms of getChildren. i suspect i'm not the only person to make that observation. i noted there was some typeclass that autommatically derives a children and toList, but can't remember which one

                                                                                                                                                      Valentin Kasas @vil1@2017-09-05T19:38:31.184Z
(sorry I'm about to loose internet connection for a while)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T01:06:38.098Z
What's a good haskell library that does the mutual recursion (HFix and friends) stuff?

                                                                                                                                                      Greg Pfeil @sellout@2017-09-08T01:55:00.740Z
@Jacoby6000 compdata, in the Multi module.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-08T01:55:14.708Z
https://github.com/pa-ba/compdata/tree/master/src/Data/Comp/Multi

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-08T02:45:37.409Z
Oh, this is great stuff, thanks for the link! I dug around a bit and found http://dl.acm.org/citation.cfm?doid=2678015.2682539. This seems very relevant to my interests. I'll try to find the PDF.

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-08T02:47:16.833Z
It's here: http://bahr.io/pubs/files/bahr17scp-paper.pdf

                                                                                                                                                      Greg Pfeil @sellout@2017-09-08T02:57:47.414Z
I think another lib … maybe recursion-schemes also has some mutual recursion stuff … or maybe not, maybe I’m just thinking about HFunctor, etc.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-08T02:58:08.166Z
@tscholak Ah, yeah, that paper’s been on my to-read for a while.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-08T03:15:05.413Z
@Jacoby6000 Ah yeah, category-extras … but much less than compdata – https://hackage.haskell.org/package/category-extras-0.53.0/docs/Control-Functor-HigherOrder.html

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T15:35:48.146Z
@sellout Data/Comp/Multi looks like what I need. I'm new to haskell, and googling around for this stuff pointed me at other libs. This one looks the best

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T15:35:52.880Z
thanks!

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-08T16:08:40.934Z
@Jacoby6000 what are you going to do with this? there is still no way of getting mutual recursion to work with scala, is there? it's either dotty or another language. has anyone tried idris or ocaml? what about purescript?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-08T16:53:22.036Z
All you need is higher-kinded GADTs afaik


                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T17:10:33.988Z
@tscholak Yeah, what @edmundnoble said.  Idris is cool if you like dependent typing. Purescript is just haskell -> js IIRC. ETA looks promising for JVM stuff.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-08T17:11:19.103Z
Purescript has no GADTs, but they have leibniz, but they don't have roles
 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T17:12:06.290Z
Right now I'm going to try implementing [lambdapi](https://www.andres-loeh.de/LambdaPi/LambdaPi.pdf) and making an AST first programming language.. I'm going to try to throw in mutual recursion stuff to try to make the AST arbitrarily extensible. We'll see if it works out (it probably wont)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T17:15:40.698Z
I'm mostly doing it to teach myself about how compilers and type systems work

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T17:20:01.133Z
Oh also, dotty seems to work okay with GADTs, breaks with any variance and is actually just hard-coded to fail with variance. https://github.com/lampepfl/dotty/issues/2985 (which is fine by me). Biggest problem is that working with it currently isn't very friendly, and you'll run in to compiler crashes quite a bit.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-08T17:21:06.622Z
So, I _think_ that I could get the mutu branch working if I used type patterns for the algebras instead of “real” patterns.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-08T17:21:51.168Z
@nuttycom Definitely has some hand-written mutual recursion stuff that I _think_ works. Although we just hacked on a bunch of it today, so it probably doesn’t compile any more.

                                                                                                                                                      Rintcius Blok @rintcius@2017-09-08T17:54:15.348Z
@tscholak I have played with https://github.com/slamdata/purescript-matryoshka a bit - works quite nice I think

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-08T17:59:59.883Z
@Jacoby6000 I just had a better look at https://scastie.scala-lang.org/XbNz8MJ5TFycluoKETPl1A. It seems that, in dotty, you need that `Out` type to encode GADTs as described, e.g., in https://en.wikibooks.org/wiki/Haskell/GADT#GADTs. With this technique, are you also able to write and fold over algebras?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T18:32:24.536Z
@sellout I was experimenting in my [scoobie branch](https://github.com/Jacoby6000/scoobie/blob/dotty/plugins/dialects/ansi-sql/src/main/scala/scoobie/doobie/doo/ansi/SqlInterpreter.scala#L86).. I think it's possible, but I kept crashing the compiler, and my internal type-checker isn't good enough to tell if I'm wrong or if the compiler is just not good enough yet. 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T18:37:08.521Z
My syntax is definitely broken in there currently

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T18:37:24.684Z
I mucked about with it until I gave up. left it in disrepair

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T18:39:15.516Z
got the core AST compiling though, with its HFunctor.

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-08T18:44:54.643Z
HFunctor is from here: https://personal.cis.strath.ac.uk/neil.ghani/papers/ghani-popl08.pdf ?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T19:17:21.368Z
@sellout you made me want to poke more.  So far so good as far as writing an algebra

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T19:20:50.302Z
I'll dig in to this over the next few days and see if I can compose algebras for a fold.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-08T19:35:55.815Z
I still want to see kind polymorphism show up, so we can have a functor that is specialized to `F[_]` or `F[_[_], _]`, etc.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-08T19:36:06.368Z
@tscholak Yes.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T19:37:40.486Z
Paramorphism algebras seems to fail, because I can't use this HProject thing I made:

```scala
    object HProject {
      def unapply[X](f: F[ANSIAST, X]): Option[AST[X]] = Some(f.hproject)
    }
```
Those 3 lines crash the compiler.  `F` is `HRecursive` and `ANSIAST` is an `HFunctor`.  
A cata algebra should work fine though.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T19:38:01.360Z
If I can't match on sub-nodes, then para isn't much use without a bunch of clunkiness :/

                                                                                                                                                      Greg Pfeil @sellout@2017-09-08T19:39:26.109Z
@Jacoby6000 I’ve implemented `para` for higher-order recursion schemes. But I haven’t pushed it anywhere …

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T19:39:35.626Z
in dotty?

                                                                                                                                                      Greg Pfeil @sellout@2017-09-08T19:40:05.083Z
In Scala 2.11/12

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T19:40:26.741Z
eh. won't help then. Can't write my algebras in scala :/

                                                                                                                                                      Greg Pfeil @sellout@2017-09-08T19:40:34.148Z
```scala
  def para[A[_]]
    (φ: GAlgebra[Prod[T, ?[_], ?], HBase, A])
    (implicit HF: HFunctor[HBase])
      : T ~> A =
    λ[T ~> A](t =>
      φ(hproject(t).hmap(λ[T ~> (T :*: A)#λ](t => Prod((t, para(φ)(HF)(t)))))))
```

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T19:41:40.906Z
here's that in dotty (roughly)

```scala
    def para[F[_[_], _]: HFunctor, A[_]](
      φ: GAlgebra[[γ[_], α] => (T[F, α], γ[α]), F, A]):
    ([B] => T[F, B]) ~> A =
      new (([B] => T[F, B]) ~> A) {
        def apply[Q](t: T[F, Q]) =
          φ(HFunctor[F].hmap[[B] => T[F, B], [B] => (T[F, B], A[B])](
            new (([B] => T[F, B]) ~> ([B] => (T[F, B], A[B]))) {
              def apply[P](t: T[F, P]) = (t, para(φ).apply(t))
            })(hproject[F, Q](t)))
      }
```

                                                                                                                                                      Greg Pfeil @sellout@2017-09-08T19:41:44.131Z
Oh, `HProject` is an extractor for deep pattern matching on fixed points?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T19:41:50.315Z
@sellout yeah

                                                                                                                                                      Greg Pfeil @sellout@2017-09-08T19:42:06.382Z
I would call that `HEmbed`, actually, because the _apply_ is embed, and the unapply is project.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T19:42:26.793Z
Ah alright. I've hand written most of this, so most of it could be better, for sure.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-08T19:42:35.722Z
And you can specify (at least it Scala) that it returns `Some` not `Option`, so you don’t lose exhaustivity when you use it.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T19:42:38.426Z
I'll change the name, still doesn't fix it though :/ 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T19:45:22.053Z
let me tell you..writing some matryoshka subtitutes in dotty without KP is an amazing exercise, in the worst way.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-08T20:41:26.638Z
Got past the HEmbed thing. Removing the type annotation fixes it.  Now It's failing to compile a recursive call back to it's own algebra :/

                                                                                                                                                      Alex Gryzlov @clayrat@2017-09-10T11:20:37.272Z
@tscholak for Idris there's https://github.com/vmchale/recursion_schemes

                                                                                                                                                      andy scott @andyscott@2017-09-11T15:14:54.287Z
Is there any material available with examples on how to do general recursion with more complicated fixed point trees, where I have contraints on sub forests (that could typically be expressed as a simple type hierarchy for a traditional tree)?

                                                                                                                                                      andy scott @andyscott@2017-09-11T15:29:04.798Z
Mutual recursion. I saw some open/pending issues/PRs. But also I recall seeing a working example somewhere.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-11T15:43:42.796Z
@andyscott Yeah, there’s the PR for that, and I have much more locally to push to that PR. The problem is that scalac currently doesn’t like the way it uses GADTs. There is a workaround, and also an (in-progress) PR against scalac, but not finished. I know @nuttycom has some hand-written stuff to do the same, and someone else (sorry, I forget who) does as well.

                                                                                                                                                      andy scott @andyscott@2017-09-11T15:44:35.130Z
Yeah, there’s the open scalac PR about GADT pattern matching that’s needed, per the PRs to Matryoshka.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-11T15:45:37.744Z
Yeah, and I think that issue only affects defining algebras (which means it’s the test code that breaks in the Matryoshka PR) – you need to use `x: FooF` patterns instead of `FooF(a, b c)` patterns, IIRC.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-11T15:45:44.762Z
That‘s the workaround, I mean.

                                                                                                                                                      andy scott @andyscott@2017-09-11T15:46:05.909Z
Makes sense.

                                                                                                                                                      Valentin Kasas @vil1@2017-09-12T10:57:58.734Z
Hi guys, thank to your advice, I managed to solve my problem

                                                                                                                                                      Valentin Kasas @vil1@2017-09-12T10:58:52.792Z
@DanielPorter 's snipped helped a lot and now I think I understand how to work with `EnvT`, thanks !

                                                                                                                                                      Valentin Kasas @vil1@2017-09-12T10:59:41.238Z
(although it took me quite long to wrap my head around that)

                                                                                                                                                      Simon Hafner @reactormonk@2017-09-13T16:01:52.251Z
I've got a Fix[F], and a Foldable[F], any way to create a List[F] with all the elements?

                                                                                                                                                      Greg Pfeil @sellout@2017-09-13T16:41:20.108Z
@reactormonk What do you want the list to look like? There is a `toTree`. Do you want a list of all subtrees?

                                                                                                                                                      Greg Pfeil @sellout@2017-09-13T16:43:22.386Z
If so, you could do a paramorphism, like
```scala
fa => fa.map(_._1).embed :: fa.foldMap(_._2) :
    GAlgebra[(Fix[F], ?), F, List[Fix[F]]]
```

                                                                                                                                                      Greg Pfeil @sellout@2017-09-13T16:54:59.941Z
@reactormonk Re-reading your question – what are the “elements”?

                                                                                                                                                      Simon Hafner @reactormonk@2017-09-13T17:39:31.437Z
@sellout did a paramorphism in the end, pretty much that way.

                                                                                                                                                      Simon Hafner @reactormonk@2017-09-13T17:39:43.595Z
Except with only one `foldMap` ^^

                                                                                                                                                      andy scott @andyscott@2017-09-14T16:46:27.587Z
I previously had a `Coalgebra[Tree, TreeF]`, but I’ve adjusted my `TreeF` to be a mutually recusive structure. The mutally recursive coalgebra is defined as `A ~> F[A, ?]`, so what’s the proper way to convert my original coalgebra and treat values of Tree as functors `A[_]`? This is based off of the mutual recursion branches open against Matryoshka.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-14T17:56:59.566Z
I feel like I'm doing something wrong with my paramorphism.. I'm essentially requiring it to do the same work twice in this case:

```scala
case Not((ComparisonValueBinOp(HEmbed(_: Null[_, in]), right, Equal), _)) => 
  hRecursive.para[ANSIAST, Const](alg).apply(right) |+| litSql"IS NOT NULL "
```

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-14T17:57:01.552Z
Any ideas?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-14T17:57:55.900Z
I could get rid of this by duplicating the operator for equal, and making a NotEqual, but then I lose out on the composability of my Not node.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-14T19:10:41.928Z
@sellout By the way, I got dotty compiling my algebra for a paramorphism.

Here's the final result: https://github.com/Jacoby6000/scoobie/blob/dotty/plugins/dialects/ansi-sql/src/main/scala/scoobie/doobie/doo/ansi/SqlInterpreter.scala#L82

This is much simpler (aside from some of the match cases) than what I had back whenever I wasn't using GADTs.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-14T19:11:31.296Z
The parts of the code where I set up HFix/HRecursive and all that needs to be cleaned up, and the AST code could be a bit nicer. Overall I'm happy, though.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-14T19:37:55.226Z
Thanks for all your help :)

                                                                                                                                                      Greg Pfeil @sellout@2017-09-14T20:09:29.197Z
@Jacoby6000 💯 That’s awesome.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-14T20:10:11.105Z
re: your para problem … you might want a `histo` instead, which contains all the intermediate results.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-14T20:10:51.408Z
So then you can just `Cofree.head(right)` to get the value you had created when you first processed `right`.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-14T20:37:22.723Z
@sellout that's probably what I want. Having the algebra call back on itself feels dirty :p 

                                                                                                                                                      Greg Pfeil @sellout@2017-09-16T00:09:03.429Z
@Jacoby6000 Having the algebra call back on itself should trigger the `Recursion` wart if you enable it 😄

                                                                                                                                                      Emily Pillmore @emilypi@2017-09-16T17:14:34.480Z
@Jacoby6000 that is one hell of a pattern match

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-16T17:58:23.095Z
@emilypi most of that is because of the special cases for null. I have a feeling it'll get better whenever I change to histo. 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-16T20:49:57.250Z
@Jacoby6000 thinks about doing a dotty branch for matryoshka

                                                                                                                                                      Rintcius Blok @rintcius@2017-09-17T12:23:51.222Z
While updating #53  I encountered constructions like `Recursive[Arithmetic].cata(expr)(pprint)` (see https://github.com/slamdata/matryoshka/pull/91/files#diff-a4cfb0a5e406d01b98912565a0f83fbdR99 ). While I like the conciseness of these, I also found them a bit confusing, since it hides an `ana` (and also because there's another `cata` method that has a `T[F]` as first argument).  I would find something like this easier to understand (pseudo-code alert):  `expr.ana[ArithmeticF].cata(pprint)` or `Something.ana(expr).cata(pprint)`.  Do others share this or should I upgrade my mental model of this in some way?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-17T12:48:55.418Z
Is an ana followed by a cata not hylo?

                                                                                                                                                      Rintcius Blok @rintcius@2017-09-17T13:42:48.183Z
right... using just `hylo` would also unconfuse me

                                                                                                                                                      Rintcius Blok @rintcius@2017-09-17T13:59:08.918Z
so my confusion is about this: https://github.com/slamdata/matryoshka/blob/master/core/shared/src/main/scala/matryoshka/Recursive.scala#L34-L35 being named `cata` (need to forget about the first parameter here to make the name of this method  match up correctly)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-17T14:01:38.894Z
That is a cata, though

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-17T14:02:17.517Z
Cata is a version of hylo with the coalgebra set to project

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-17T14:02:22.665Z
`hylo(t)(f, project)` is `cata(t)(f)` and `hylo(t)(embed, g)`is `ana(t)(g)`

                                                                                                                                                      Rintcius Blok @rintcius@2017-09-17T14:07:33.826Z
hmm.. I find something like this intuitive: `exprF.cata(someAlgebra)` but not the above usage

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-17T14:09:11.405Z
you mean rather than `cata(expr)(someAlgebra)`?

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-17T14:09:50.873Z
where `cata` comes from a `Recursive` instance

                                                                                                                                                      Rintcius Blok @rintcius@2017-09-17T14:09:54.789Z
no I mean  I'd also find this ok: `Recursive[Arithmetic].cata(exprF)(pprint)`

                                                                                                                                                      Rintcius Blok @rintcius@2017-09-17T14:10:05.528Z
but it's an `expr` not an `exprF`

                                                                                                                                                      Rintcius Blok @rintcius@2017-09-17T14:11:42.796Z
(so it does the conversion of `expr` to `exprF` implicitly)

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-17T14:11:57.060Z
not sure I follow

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-17T14:12:01.876Z
what are the types of these?

                                                                                                                                                      Rintcius Blok @rintcius@2017-09-17T14:13:09.176Z
It's the example here: https://github.com/slamdata/matryoshka/pull/53/files#diff-a4cfb0a5e406d01b98912565a0f83fbdR98

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-17T14:14:30.580Z
ah, so you want to unfold `expr` into `exprF` and then fold it using `pprint`?

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-17T14:14:39.162Z
that's a hylo

                                                                                                                                                      Rintcius Blok @rintcius@2017-09-17T14:18:48.366Z
well.. if that method would have been called `hylo` I wouldn't have found it confusing, but it's called `cata`

                                                                                                                                                      Rintcius Blok @rintcius@2017-09-17T14:55:11.958Z
maybe I can better phrase my confusion as being: the conversion `expr` -> `exprF` happens implicitly, but it feels to be too important a conversion to do implicitly, since it hides that it does something like an `ana` 

                                                                                                                                                      Greg Pfeil @sellout@2017-09-17T15:28:54.190Z
@rintcius more later, but it's not hiding an Ana … that is just `expr.cata(pprint)`, but the implicit conversion isn't found in that case, so you have to write it using the `cata` method on the typeclass.

                                                                                                                                                      Rintcius Blok @rintcius@2017-09-17T20:54:04.295Z
Right, it's the fact that it's using a conversion implicitly that I find confusing.
I mean if we were to write `Recursive[Arithmetic].cata(expr)(evalAlgebra)` without implicit magic then it would be written as: `hylo[ArithmeticF, Arithmetic, Double](expr)(evalAlgebra, arithCoalgebra)`. 
The latter uses `hylo`, the function name that I would search for given the type I'm coming from and the type I want to end up with. You also have to explicitly provide all the important components `expr`, plus an algebra and a coalgebra.
However, the first uses the coalgebra implicitly and as a consequence you now have to use `cata` instead.
Similarly (but even more confusing), I could also have chosen to make the algebra implicit and have written: `Corecursive[Double].ana(expr)(arithCoalgebra)`.
All 3 examples give the same result, but the `ana` and `cata` seem to contain too much magic (for me anyway).

                                                                                                                                                      Greg Pfeil @sellout@2017-09-17T20:56:16.540Z
@rintcius Where is the implicit magic in `Recursive[Arithmetic].cata(expr)(evalAlgebra)`?

                                                                                                                                                      Rintcius Blok @rintcius@2017-09-17T20:58:03.933Z
that it uses `arithCoalgebra` to convert from `expr` to `exprF` implicitly

                                                                                                                                                      Greg Pfeil @sellout@2017-09-17T20:59:03.049Z
What is `arithCoalgebra`? It just uses `project`. That is how `cata` is defined.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-17T20:59:33.735Z
Strictly speaking, `cata(alg)` is _not_ `hylo(alg, project)`, though.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-17T21:00:04.388Z
Look at the implementation for `Mu` – `cata` has a definition that can’t be replaced with `hylo`.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-17T21:01:11.769Z
I have been tempted to not give `cata` a default definition, but that just means that making instances for directly-recursive types (like List, Free, Tree, etc.) is harder. Most of the time, the `hylo(…, project)` is what you want.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-17T21:03:59.811Z
`Corecursive[Double].ana(expr)(arithCoalgebra)` can’t give you the same result as `Recursive[Arithmetic].cata(expr)(evalAlgebra)`

                                                                                                                                                      Greg Pfeil @sellout@2017-09-17T21:05:24.745Z
The first can be seen as
```scala
hylo(_)(embed, arithCoalgebra): Double => Arithmetic
```
and the latter is
```scala
hylo(_)(evalAlgebra, project): Arithmetic => Double
```

                                                                                                                                                      Rintcius Blok @rintcius@2017-09-17T21:07:42.906Z
Hmm.. it _does_ give me the same result (by adding an implicit `Birecursive.Aux[Double, ArithmeticF] = Birecursive.algebraIso(evalAlgebra, dontcare)`)

                                                                                                                                                      Greg Pfeil @sellout@2017-09-17T21:08:15.410Z
Oh, yikes – you don’t want to be defining instances like that.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-17T21:08:32.850Z
First, I doubt whatever that is will pass the laws that are required.

                                                                                                                                                      Rintcius Blok @rintcius@2017-09-17T21:08:47.389Z
Yeah, that's true - it's ugly

                                                                                                                                                      Rintcius Blok @rintcius@2017-09-17T21:09:25.040Z
but hiding the other way around is almost as ugly

                                                                                                                                                      Greg Pfeil @sellout@2017-09-17T21:09:35.781Z
There’s no hiding. I don’t know what you mean.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-17T21:11:26.508Z
For that implicit to work, you’re claiming there’s an isomorphism between `Double` and `ArithmeticF[Double]` – which there isn’t.

                                                                                                                                                      Rintcius Blok @rintcius@2017-09-17T21:20:13.686Z
Also true, but I only need half of that "algebraIso", isn't it?

                                                                                                                                                      Greg Pfeil @sellout@2017-09-17T21:24:16.498Z
Well, you need half for `Recursive` operations (the `project` coalgebra), and you need the other half for `Corecursive` operations (the `embed` algebra). And `Birecursive` operations use both.

                                                                                                                                                      Rintcius Blok @rintcius@2017-09-17T21:28:48.556Z
As for that hiding, I mean it's hidden behind an implicit and for me it's hard to match up the use of `cata` together with an `expr` (I would expect it to work with an `exprF` instead) - I can see that `expr -> exprF` is taken care of by the implicit but it's not intuitive to me

                                                                                                                                                      Greg Pfeil @sellout@2017-09-17T21:29:49.667Z
@rintcius But the way you’re using it, there’s no implicit (other than the Functor constraint on ArithmeticF) – that’s what I’m confused about.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-17T21:30:50.870Z
Oh, I guess there is the implicit `Birecursive[Algebra]` that resolves to `Arithmetic.birecursive`. Sorry.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-17T21:32:09.253Z
@rintcius But that’s exactly what `cata` is defined to do – it takes a recursive structure and a function that applies to a single step of that structure and applies it over the entire tree.

                                                                                                                                                      Rintcius Blok @rintcius@2017-09-17T21:33:03.580Z
yes indeed, was just trying out without  that implicit :)

                                                                                                                                                      Greg Pfeil @sellout@2017-09-17T21:33:30.429Z
Well, you can just do `Arithmetic.birecursive.cata(expr)(evalAlgebra)`, and the implicit is gone now.

                                                                                                                                                      Rintcius Blok @rintcius@2017-09-17T21:43:49.286Z
Hmm... right... _something_ is dawning now - in my mind `cata` implied the use of a value like `exprF` as source, but that's wrong it works on directly recursive structures too

                                                                                                                                                      Rintcius Blok @rintcius@2017-09-17T21:48:53.400Z
Thanks for you explanations @sellout, much appreciated!

                                                                                                                                                      Greg Pfeil @sellout@2017-09-17T22:57:54.059Z
No problem! Happy to talk it through … sorry if it seemed disjointed … lots of interruptions on the weekend :D

                                                                                                                                                      andy scott @andyscott@2017-09-17T23:56:53.920Z
When doing mutual recursion, is there any way to constrain the “functor” I had to lift my values to? In my case, I have Scalameta trees that I convert to/from fixed point representations. If I do a hylo, I wind up with a `Id ~> Id` even though the natural transformation is really only valid for `Id[A]` such that `A = Tree`.

                                                                                                                                                      andy scott @andyscott@2017-09-17T23:59:57.838Z
Or related… what’s the appropriate way to define a Coalgebra to handle going from some type `A` to a mutually recusive structure `H[_[_], _]`? I have just defined it as `Coalgebra[Tree, Id]` in my specific case… where `A` is `Tree` and gets plugged into `Id` at some point.

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:01:17.564Z
And also… please excuse my terrible terminology… and by all means corrections are welcomed.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T00:07:05.570Z
@andyscott If you're doing what I think you are, I've had to fudge my algebras. I just do 
```scala
case class Result[A](a: A)
type MutuResult[A] = {
  type x[I] = Result[A]
}
```

And then I make an NT that does something like
```scala
Tree ~> MutuResult[A]#x
```

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:07:41.657Z
Here’s what I’m doing: https://github.com/andyscott/archetype/blob/master/modules/scalameta-fixedpoint/src/test/scala/scala/meta/fixedpoint/TreeChecks.scala#L28

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:08:07.108Z
And yeah… fudging has been required

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:09:22.821Z
I have also looked at redefining everything to allow bounds on the natural transformation. All my type classes would need to be adjusted accordingly, to take into account the world:
```
  class World[⊥, ⊤ >: ⊥] {
    trait BoundFunctionK[F[_ >: ⊥ <: ⊤], G[_ >: ⊥ <: ⊤]] {
      def apply[A >: ⊥ <: ⊤](fa: F[A]): G[A]
    }
    type ~|>[F[_ >: ⊥ <: ⊤], G[_ >: ⊥ <: ⊤]] = BoundFunctionK[F, G]
  }

  val treeWorld = new World[Nothing, Tree]
  import treeWorld._

  val foo: Id ~|> Id = ???

  foo(null: Tree) // compiles
  // foo(null: String) // doesn't

  type TreeId[A <: Tree] = A
  val bar: TreeId ~|> TreeId = ???

  bar(null: Tree) // compiles
  //bar(null: String) // doesn't
```

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:11:02.150Z
@Jacoby6000 In your case above, doesn’t that mean that each value has to be wrapped and unwrapped in the additional `Result` type as you traverse the recursive structure?

                                                                                                                                                      Greg Pfeil @sellout@2017-09-18T00:14:16.231Z
@andyscott `Tree` is of kind `*`?

                                                                                                                                                      Greg Pfeil @sellout@2017-09-18T00:15:16.907Z
Which muturec, you have like a `type HCoalgebra[F[_[_], _], A[_]] = A ~> F[A, ?]`

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:15:49.694Z
Yes

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:16:10.364Z
`Tree` is a `scala.meta.Tree` :)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T00:16:35.863Z
@andyscott yeah. Another way I've done it is by doing
```
type MutuResult[A] = {
  type x[I] = A
}
```

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:16:40.873Z
My algebras/coalgebras are defined as you described

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T00:16:43.396Z
It feels dirty no matter what I do

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:17:08.701Z
Do you use kind projector?

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:17:32.677Z
I was using `λ[a => A]` for a while, or a type `Const` defined like you have above.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T00:18:04.049Z
I used it whenever I could... scalac chokes whenever I try to write algebras, so now I just use dotty which doesn't get KP :( 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T00:18:13.062Z
but yeah, that's the same

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:18:18.180Z
I’ll have to try Dotty

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:18:26.030Z
I have crashed Scalac way too many times to count :)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T00:18:35.566Z
You'll crash dotty more ;)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T00:18:53.963Z
Dotty works when you get it right, usually... but when you get it wrong, you're on your own a lot of the time.

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:19:56.179Z
Heh. Well, it’s good to know that I am not the only one running into a host of issues. Comfort in collective discomfort I suppose.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T00:20:45.644Z
Yeah... It was great whenever I finally figured out how to get the extensibility I wanted in my lib... Not so great whenever I discovered scalac couldn't handle it.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T00:21:35.114Z
What I'm messing mutual recursion for is [this](https://github.com/jacoby6000/scoobie). 

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:22:10.665Z
Yep. I have been tracking your changes ever since @peterneyens pointed me to them.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T00:22:33.041Z
Well, at least maybe some people are getting some use from it then..

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:22:44.461Z
heh

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T00:23:00.277Z
Today i started work on making a basic FP lib, and I'm going to make a watered down version of matryoshka for dotty, so I can pull out the ugly from there.

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:23:51.357Z
you may be able to rip https://github.com/frees-io/iota/blob/master/modules/core/src/main/scala/iota/internal/catryoshka.scala as a base

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T00:24:37.784Z
Ooh nice

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:24:38.072Z
rip out all the cats stuff and use your own TCs for Dotty

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T00:24:39.846Z
I probably will

                                                                                                                                                      Greg Pfeil @sellout@2017-09-18T00:26:25.929Z
@andyscott So, if you want your `A` to be some proper type like `Tree`, you would use `HCoalgebra[F, Const[Tree, ?]]`

                                                                                                                                                      Greg Pfeil @sellout@2017-09-18T00:27:10.676Z
Using `HCoalgebra[F, Id]` would mean that you’re using values of the same type as your index.

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:28:43.159Z
`type Const[F[_[_], _], I] = F[K[Unit, ?], I]` ?

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:29:15.701Z
Tree is `*`, though

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T00:31:42.340Z
Have you successfully written an algebra with mutual recursion in scalac?  For me pattern matches don't work (scala/scala#5744)

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:31:57.172Z
yes

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:32:15.119Z
the first repo I linked to you has it working, albeit with `Id` and a hackey cast

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:33:04.689Z
https://github.com/andyscott/archetype/blob/master/modules/scalameta-fixedpoint/src/main/scala/scala/meta/fixedpoint/algebras.scala

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:34:13.703Z
cheating across the board to get it to work

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T00:38:58.430Z
That implicit def is the most genius piece of sadness I've laid my eyes on.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T00:39:14.903Z
it's so obvious

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T00:39:22.118Z
@Jacoby6000 tries it

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:39:37.557Z
lol

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T00:40:38.964Z
If this works, I'm gonna scream

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:40:58.628Z
I don’t know if obvious is the right word for it… behind that piece of sadness is probably several hours of painful tinkering spread out over a week or so.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-18T00:47:47.769Z
@andyscott No, just regular `type Const[A, B] = A`

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:48:12.165Z
I think I tried that. But I will try again :)

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:53:30.341Z
Aah yea

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:53:32.504Z
That doesn’t work

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:54:56.132Z
In `type Const[A, B] = A`, I need to establish that `B <: A` otherwise I invalidate the invariatns in my ASTs

                                                                                                                                                      Greg Pfeil @sellout@2017-09-18T00:55:20.596Z
But B is the type index …

                                                                                                                                                      Greg Pfeil @sellout@2017-09-18T00:55:41.483Z
Sorry, I’m running in-and-out. I can sit down and look in ~90 minutes.

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:56:03.879Z
err wait

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:56:09.080Z
hold on… again

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:56:15.960Z
I forgot to update one spot

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:57:18.738Z
No worries @sellout.

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:57:30.257Z
```
val lowerTree2 = new (Algebra[TreeF, Const[Tree, ?]]) {
    def apply[A](tree: TreeF[Const[Tree, ?], A]): Const[Tree, A] = tree match {
      case t: SourceF[Const[Tree, ?]]           => Source(t.stats)
      case t: TermF.ApplyInfixF[Const[Tree, ?]] => Term.ApplyInfix(t.lhs, t.op, t.targs, t.args)
      case t: TermF.NameF           => Term.Name(t.value)
      case t: LitF.IntF             => Lit.Int(t.value)
      case t: DefnF.ValF[Const[Tree, ?]]        => Defn.Val(t.mods, t.pats, t.decltpe, t.rhs)
      case t: PatF.VarF[Const[Tree, ?]]         => Pat.Var(t.name)
      case _                        => ???
    }
  }
```
is my updated algebra.

                                                                                                                                                      andy scott @andyscott@2017-09-18T00:58:02.243Z
The problem is that when constructing the result, I get tons of errors along the lines of:
```
[error]  found   : scala.meta.Tree
[error]  required: scala.meta.Term
```
where `scala.meta.Term <:< scala.meta.Tree`

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T01:00:27.777Z
subtyping destroys everything on the index type (assuming that's what that is)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T01:00:39.841Z
even in dotty. 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T01:01:01.268Z
In fact, dotty is hard-coded to just fail if it sees variance on the index.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-18T01:03:21.082Z
@Jacoby6000 oh, that's too bad.

                                                                                                                                                      andy scott @andyscott@2017-09-18T01:04:31.740Z
@andyscott grumbles

                                                                                                                                                      andy scott @andyscott@2017-09-18T01:05:13.928Z
My fixed point structure has leaf nodes that are 1 to 1 with scala meta tree leaf nodes.

                                                                                                                                                      andy scott @andyscott@2017-09-18T01:05:31.002Z
Instead of defining my own indicies, I just used the original scalameta node types as the index markers.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T01:06:01.680Z
You might have to fall back on that and use composition to get something resembling subtyping.

                                                                                                                                                      andy scott @andyscott@2017-09-18T01:06:21.229Z
How so?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T01:06:23.039Z
(maybe... your hacks might make it all work out)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T01:07:06.240Z
`case class TreeTerm[A[_]](tree: A[Tree]) extends TreeF[A, Term]`

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T01:07:09.509Z
stuff like that.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T01:09:01.408Z
Also your trick seems to not work with a paramorphism :/

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T01:09:29.107Z
Assuming I'm doing it right here:
```scala
        implicit def `y u no typecheck?`[I](ast: Query[T, (AST :*: Const)#l, Indicies.Value]): Query[T, (AST :*: Const)#l, I] =
          ast.asInstanceOf[Query[T, (AST :*: Const)#l, I]]
```

                                                                                                                                                      andy scott @andyscott@2017-09-18T01:10:53.884Z
you probably need to rename it from `y u no typecheck?` to `y u no typecheck? PLEASE WORK PLEASE` to get it work for paramorphisms

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T01:11:38.826Z
Good call. I'll let you know if it works out

                                                                                                                                                      andy scott @andyscott@2017-09-18T01:23:02.337Z
I am currently writing things that should not be written in Scala.

                                                                                                                                                      andy scott @andyscott@2017-09-18T01:23:15.288Z
`type X[HH[_[_ >: ⊥ <: ⊤], _ >: ⊥ <: ⊤], FF[_ >: ⊥ <: ⊤]] = { type λ[A >: ⊥ <: ⊤] = HH[FF, A] }`

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T01:24:55.372Z
Well, be comforted knowing you're not alone

                                                                                                                                                      andy scott @andyscott@2017-09-18T01:26:32.153Z
variance on HK type params is rough

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T01:30:26.854Z
I think you can make your `y u no compile` thing a little bit more effective. Instead of making it only work on terms of type `Tree` as it is now, you could move it inside the `apply` definition, and replace `Tree` with the index that gets passed in on the `apply` method.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T01:31:35.876Z
I shouldn't be giving advice though, since I couldn't get it to work :p 

                                                                                                                                                      andy scott @andyscott@2017-09-18T01:31:45.144Z
lol

                                                                                                                                                      andy scott @andyscott@2017-09-18T01:32:06.654Z
You mean drop the type param `A` and instead use the existing param `A` bound by the apply definition?

                                                                                                                                                      andy scott @andyscott@2017-09-18T01:32:33.156Z
Not sure how to say that in a more confusing, or less confusing manner….

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T01:34:01.297Z
```scala
def apply[I](tree: ...) { 
  def y-u-no[X](tree: TreeF[Id, I]): TreeF[Id, X]
```

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T01:34:07.981Z
approximately

                                                                                                                                                      andy scott @andyscott@2017-09-18T01:39:18.699Z
yeah

                                                                                                                                                      andy scott @andyscott@2017-09-18T01:39:47.850Z
I only had it outside to avoid having to put additional brackets around my case statements

                                                                                                                                                      andy scott @andyscott@2017-09-18T01:53:17.498Z
I think I sorted out how to make this work while preserving sufficient type info. I’ll share a PR later, when I get a chance to implement it.

                                                                                                                                                      andy scott @andyscott@2017-09-18T06:08:33.617Z
@sellout @Jacoby6000 If you are curious: https://github.com/andyscott/archetype/pull/2

                                                                                                                                                      andy scott @andyscott@2017-09-18T06:09:33.703Z
```
  val roundTripTree: Id ~> Id = hylo(algebras.lowerTree, algebras.liftTree)

  roundTripTree(null: Tree) // compiles
  roundTripTree(null: String) // compilation error: inferred type arguments [String]
  //  do not conform to method apply's type parameter bounds [A >: scala.meta
  //  .fixedpoint.TreeChecks.roundTripTree.⊥ <: scala.meta.fixedpoint.TreeChecks.roundTripTree.⊤]
```

                                                                                                                                                      andy scott @andyscott@2017-09-18T06:09:52.274Z
which is the behavior I want

                                                                                                                                                      andy scott @andyscott@2017-09-18T06:10:48.791Z
Feel free to comment on the PR if there’s anything interesting to comment on

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T22:32:26.830Z
I still think it's weird to be tied to be using their nodes as index types. :p 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-18T22:32:57.910Z
Looks nice though. I might actually write macros if you manage to make it not-terrible.

                                                                                                                                                      andy scott @andyscott@2017-09-19T00:23:15.520Z
 use my own index type how would I write my lift/lower algebras?

                                                                                                                                                      andy scott @andyscott@2017-09-19T00:23:26.391Z
If I*

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-19T00:33:35.726Z
`Foo ~> Const[?, Tree]` or something 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-19T00:33:58.006Z
where `type Const[I, A] = A`

                                                                                                                                                      Greg Pfeil @sellout@2017-09-19T00:44:40.673Z
@Jacoby6000 the args to Const are reversed, but yes.

                                                                                                                                                      andy scott @andyscott@2017-09-19T01:23:02.492Z
Const is a constant and I need to vary the type with the index type

                                                                                                                                                      andy scott @andyscott@2017-09-19T01:23:56.086Z
I'll have to dig into the code and see if I can rewrite it to make that work

                                                                                                                                                      Greg Pfeil @sellout@2017-09-19T01:23:59.019Z
@andyscott You need to make a type-level function from the Indices to the types you want.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-19T01:24:50.142Z
Foo ~> TreeFrom

                                                                                                                                                      andy scott @andyscott@2017-09-19T01:26:14.073Z
How do I do that?

                                                                                                                                                      Greg Pfeil @sellout@2017-09-19T01:26:57.085Z
I don’t know exactly – I think I’ve seen it done … with type members somehow?

                                                                                                                                                      Greg Pfeil @sellout@2017-09-19T01:27:42.073Z
If you figure it out, that is a very important example for mutu-rec to document somewhere.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-19T01:30:32.698Z
Maybe something like a type class?
```scala
@typeclass TreeFrom[From] { type To }
implicit def meh: TreeFrom.Aux[Int, Bool] = new TreeFrom.Aux[Int, Bool] { }
Foo ~> TreeFrom[?]#To
```
😆

                                                                                                                                                      andy scott @andyscott@2017-09-19T01:30:33.690Z
Hahaha. Okay good. I had this thought earlier about needing type level functions but not knowing how to actually implement one cleanly.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-19T01:30:58.291Z
I mean, `Aux` is the closest I’ve gotten to Haskell type families, so ¯\\\_(ツ)_/¯

                                                                                                                                                      andy scott @andyscott@2017-09-19T01:31:04.663Z
Yeah you could use hackey implicits to compute the type 🤣

                                                                                                                                                      andy scott @andyscott@2017-09-19T01:31:58.121Z
I'd probably need to redefine Nat Trans to support this

                                                                                                                                                      andy scott @andyscott@2017-09-19T01:32:55.757Z
In my repo I had to redefine nat trans to achieve my goal by containing the top and bottom types.

                                                                                                                                                      LukaJCB @LukaJCB@2017-09-19T10:08:18.514Z
Hey guys, is there any ETA on a cats version of Matryoshka? Or anything we can do to help towards that goal? 🙂

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-19T10:29:55.589Z
I wouldn't bet on a cats version at all. The last thing I heard was that there's an idea to submit matryoshka to scalaz 

                                                                                                                                                      LukaJCB @LukaJCB@2017-09-19T10:35:36.887Z
Oh that’s too bad, I didn’t know https://http4s.github.io/fp-ecosystem/ was out of date

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-19T20:46:26.035Z
I'm trying to make sense out of the definition of hyloM. Got a couple of questions -
```scala
  def hyloM[M[_], F[_], A, B]
    (a: A)
    (f: AlgebraM[M, F, B], g: CoalgebraM[M, F, A])
    (implicit M: Monad[M], F: Traverse[F])
      : M[B] =
    hylo[(M ∘ F)#λ, A, M[B]](a)(_ >>= (_.sequence >>= f), g)(M compose F)
```
1. What does the expression `(M ∘ F)#λ` do? I think I've ascertained that the dot is the map operation, but i'm not entirely sure what mapping  over a monad with an instance of traverse means. 
2. What is the >>= operator?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-19T20:46:44.399Z
Dot is compose

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-19T20:46:56.664Z
Circle, rather

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-19T20:47:00.336Z
\>>= is flatMap

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-19T20:47:30.636Z
what's the difference between circle and the compose used farther down the expression?

                                                                                                                                                      Greg Pfeil @sellout@2017-09-19T20:47:45.262Z
@DanielPorter Type vs value level.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-19T20:48:52.144Z
`M compose F` composes the Monad[M] and Traverse[F], giving a Functor[M ∘ F]

                                                                                                                                                      Greg Pfeil @sellout@2017-09-19T20:53:46.026Z
So, you end up creating a hylo that first unfolds `A => M[F[A]]`, then folds `M[F[M[B]]] => M[B]`.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-19T20:54:29.529Z
 in the definition of hylo, circle is being used, but it seems to be operating at the value level.
```scala
  @SuppressWarnings(Array("org.wartremover.warts.Recursion"))
  def hylo[F[_]: Functor, A, B](a: A)(φ: Algebra[F, B], ψ: Coalgebra[F, A]): B =
    φ(ψ(a) ∘ (hylo(_)(φ, ψ)))
```

                                                                                                                                                      Greg Pfeil @sellout@2017-09-19T20:54:53.352Z
@DanielPorter That is the map operator 😄

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-19T20:54:57.451Z
lol

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-19T20:55:52.884Z
still undecided on whether FP is just really intellectual trolling or not. stuff like that tilts the scales towards yes

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-19T20:56:58.982Z
i suspect there must be some deeper relationship between compose and map that makes the circle operator applicable in both cases

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-19T21:01:57.962Z
i'm imagining that porting matroyshka to cats would mostly be a mechanical exercise, yeah?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-19T21:04:18.630Z
> still undecided on whether FP is just really intellectual trolling or not. stuff like that tilts the scales towards yes

Stuff like this only exists because they're commonly used things which have a single correct definition.  We don't go around writing `5 multiply 5`, for example.  Similarly, in the context of general recursion, you'll find yourself writing `compose` a lot, `A => F[A]`, etc;  I can't speak  for the unicode symbols though. I can probably correctly assume they come from mathematics.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-19T21:04:56.828Z
I don't think there is some deeper relationship, may be wrong


                                                                                                                                                      Greg Pfeil @sellout@2017-09-19T21:06:10.620Z
Well, function composition is `Functor[A => ?].map`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-19T21:06:16.673Z
Fair

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-19T21:06:21.707Z
Well

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-19T21:06:23.811Z
Kind of

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-19T21:28:14.227Z
@Jacoby6000 sure. i'm being tongue in cheek. but specifically what i'm being tongue in  cheek about is the (apparent) overloading of symbol meaning.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-19T21:28:28.374Z
This isn't a functional programming thing really

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-19T21:28:31.366Z
This is a matryoshka thing

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-19T21:29:17.168Z
oh. i had assumed those operators were scalaz, not from matroyshka

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-19T21:29:29.136Z
Right yes a scalaz thing

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-19T21:33:27.326Z
Overloading isn't something functional languages have in general, and type operators are mostly not used

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-19T21:39:50.994Z
Oh my bad, I didn't read the whole conversation, and thought you were talking about the whole definition of hylo

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T05:36:23.108Z
any chat for Kmett's recursion schemes or purescript matryoshka?

                                                                                                                                                      Greg Pfeil @sellout@2017-09-20T15:25:43.076Z
@xgrommx I don't know of anything dedicated, but SlamData also wrote the Purescript library and I use Kmett's at work, so this seems like a reasonable enough place.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T16:25:38.738Z
@sellout oh) do u use recursion-schemes from Kmett?

                                                                                                                                                      Greg Pfeil @sellout@2017-09-20T16:31:32.357Z
@xgrommx Yep. But we’re considering switching to compdata – the latter has more in the way of mutual-recursion, which we _might_ need.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-20T16:34:26.649Z
+1 for compdata. worked great for the mutual recursion stuff I did. All the auto derivation is good too

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T16:42:29.163Z
@sellout any interesting examples on haskell?)

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T16:43:41.779Z
do u mean https://hackage.haskell.org/package/compdata ?

                                                                                                                                                      Greg Pfeil @sellout@2017-09-20T16:45:11.873Z
Yep, that’s the one. I don’t have anything public in Haskell, and actually I’m _removing_ some uses, because apparently someone got really excited about recursion schemes (who wouldn’t be?!) and represented a lot of simple data types into complicated recursive ones.

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-20T16:47:42.492Z
lol

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-20T16:48:40.468Z
@tscholak I have a really simple example of using comp-data here. https://github.com/jacoby6000/extensible-ast-poc  
I write the AST for lambda calculus, and then extend it with primitive ints.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-20T16:48:48.468Z
er.. I meant @xgrommx 

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T16:49:04.961Z
https://hackage.haskell.org/package/recursion-schemes-ext-0.1.0.1/docs/Data-Foldable-Functor-Extensions.html

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-20T16:49:45.775Z
@Jacoby6000 I didn't ask for the example, @xgrommx did. I take it nonetheless.

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-20T16:50:14.095Z
I'm reading the compdata paper these days, and I'll be using it soon. Thanks!

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-20T16:51:01.950Z
My example is extremely basic.. I made it mostly to understand how to use compdata, and I'm still learning haskell.
All my algebra does is convert the ASTs to strings

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-20T16:51:40.436Z
my compdata project will be my first haskell project ;)

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-20T16:52:29.470Z
Theoretically you could break it down where primitives have operations that only work on certain types of primitives, and then actually evaluate those things in an alg. 

Once I understand typed lambda calculus better, and then lambdapi calculus, I hope to make a language in lambdapi with an arbitrarily extensible ast using these ideas.

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-20T16:52:57.638Z
@tscholak oh nice. It was my first haskell project too :p 

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-20T16:53:14.786Z
The `Eval.hs` file gets a little hairy. feel free to ask questions.

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-20T16:54:05.791Z
cool, thank you

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T16:54:16.142Z
@Jacoby6000 this is phantom and I think it will be `Const` https://github.com/Jacoby6000/extensible-ast-poc/blob/master/src/AST/Alg/Eval.hs#L15

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-20T16:54:53.095Z
@xgrommx yeah, I figured as much. I couldn't get const to work the way i wanted to IIRC. I should try again now that I know more.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T16:56:10.337Z
I never use compdata. I only experimented with recursion-schemes

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-20T16:57:54.493Z
Oh something else to note, is I'm deriving a ton of stuff for my ASTs. All I need in these examples is an HFunctor

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T16:59:05.772Z
@Jacoby6000 from free-functor?

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-20T16:59:14.913Z
From CompData

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-20T16:59:39.138Z
https://hackage.haskell.org/package/compdata-0.11/docs/Data-Comp-Multi-HFunctor.html

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T16:59:49.148Z
@Jacoby6000 I mean this https://github.com/sjoerdvisscher/free-functors

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-20T17:02:43.342Z
Huh that's interesting. I've never seen that before, but it looks like it'd sit along side the mutual recursion stuff really well

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T17:04:36.016Z
also https://github.com/sjoerdvisscher/algebraic-classes

                                                                                                                                                      Jacob Barber @Jacoby6000@2017-09-20T17:05:54.566Z
I think compdata provides anything with algebras that you might need

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T17:06:51.570Z
about mutumorphism I wrote it
```hs
mutu :: Recursive t => (Base t (a, a) -> a) -> (Base t (a, a) -> a) -> t -> a
mutu = go where go f g = g . fmap (go g f &&& go f g) . project

evenOdd :: Nat -> Bool
evenOdd = mutu f g where
  f ZeroF = False
  f (SuccF (b, _)) = b
  g ZeroF = True
  g (SuccF(b, _)) = b
```

                                                                                                                                                      Greg Pfeil @sellout@2017-09-20T17:09:15.519Z
@xgrommx That’s not general enough to be mutu – should be https://github.com/slamdata/matryoshka/blob/master/core/shared/src/main/scala/matryoshka/Recursive.scala#L143

                                                                                                                                                      Greg Pfeil @sellout@2017-09-20T17:09:51.583Z
I.e. `F (A, B) -> B` and `F (B, A) -> A`

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T17:10:54.969Z
@sellout why?

                                                                                                                                                      Greg Pfeil @sellout@2017-09-20T17:11:34.123Z
I mean, it’s basically the same, right? You just need to generalize the types a bit.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-20T17:12:41.803Z
Should still work. Nothing other than the type signature is constraining your tuples.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-20T17:21:58.184Z
As for the “reason” … `zygo` is a special case of `mutu` where the “helper” algebra never refers to the result of the “primary” algebra. But that’s only true with the `(a, b)` tuple. Unfortunately, the comonadic model of recursion schemes can only encapsulate `zygo`, so `mutu` ends up being a bit hacky. Hence #46 which would bring `mutu` into the fold (pun intended).

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T17:32:59.217Z
zygo is dualism for apo?

                                                                                                                                                      Greg Pfeil @sellout@2017-09-20T17:33:29.738Z
Well, for a “generalized” apo – apo is dual to para (which is a further specialization of zygo).

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T17:33:47.976Z
oh

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T17:33:58.162Z
gapo

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T17:34:02.213Z
I forgot

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T17:34:35.003Z
maybe somebody know how will be `zygoM` on haskell?

                                                                                                                                                      Greg Pfeil @sellout@2017-09-20T17:34:51.471Z
If it weren’t for terrible type inference, I’d recommend just using `gcata` all the time, and passing in the distributive law you want.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-20T17:35:11.958Z
Oh, but in Haskell that would be fine :D

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T17:35:48.236Z
I cannot to write `zygoM` in haskell

                                                                                                                                                      Greg Pfeil @sellout@2017-09-20T17:35:55.611Z
I feel like the `zygo`/`apo`/etc. names are generally only useful to tie them to work from before there was a generalized model.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-20T17:36:08.682Z
@xgrommx Do you have a `gcataM`?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T17:37:32.645Z
looks like yes
```hs
gcataM :: (Recursive a1, Traversable w, Traversable (Base a1), Comonad w, Monad m) => (Base a1 (w (w a)) -> w (m b)) -> (m b -> m a) -> a1 -> m a
gcataM k g t = g $ extract =<< loop t where
  loop t = k <$> traverse (fmap duplicate . traverse g <=< loop) (project t)
```

                                                                                                                                                      Greg Pfeil @sellout@2017-09-20T17:38:58.307Z
@xgrommx That doesn’t look like the `gcataM` I know.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-20T17:40:08.152Z
You should have a signature like https://github.com/ekmett/recursion-schemes/blob/master/Data/Functor/Foldable.hs#L402 but just with `-> a` converted to `-> m a`

                                                                                                                                                      Greg Pfeil @sellout@2017-09-20T17:41:38.836Z
(and a couple new constraints – `Monad m` and `Traversable (Base t)`)

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T17:42:25.874Z
@sellout https://github.com/slamdata/purescript-matryoshka/blob/master/src/Matryoshka/Fold.purs#L80-L82

                                                                                                                                                      Greg Pfeil @sellout@2017-09-20T17:44:48.239Z
@xgrommx That one has an unnecessary `Traversable w` (I think), but otherwise looks like the one in Kmett’s. Yours looks different.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-20T17:45:23.765Z
Like, what is `m b -> m a`?

                                                                                                                                                      Greg Pfeil @sellout@2017-09-20T17:46:01.774Z
And the algebra should look like `Base a1 (w a) -> m a`, but you have an extra `w` on both sides.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T17:46:44.199Z
also `mutu :: Recursive t => (Base t (a, b) -> b) -> (Base t (b, a) -> a) -> t -> a` doesn't work

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T17:47:03.352Z
```
    • Couldn't match type ‘b’ with ‘a’
      ‘b’ is a rigid type variable bound by
        the type signature for:
          mutu :: forall t a b.
                  Recursive t =>
                  (Base t (a, b) -> b) -> (Base t (b, a) -> a) -> t -> a
        at src/Nat.hs:79:9
      ‘a’ is a rigid type variable bound by
        the type signature for:
          mutu :: forall t a b.
                  Recursive t =>
                  (Base t (a, b) -> b) -> (Base t (b, a) -> a) -> t -> a
        at src/Nat.hs:79:9
      Expected type: (Base t (a, b) -> b)
                     -> (Base t (b, a) -> a) -> t -> a
        Actual type: (Base t (a, a) -> a)
                     -> (Base t (a, a) -> a) -> t -> a
    • In the expression: go
      In an equation for ‘mutu’:
          mutu
            = go
            where
                go f g = g . fmap (go g f &&& go f g) . project
    • Relevant bindings include
        mutu :: (Base t (a, b) -> b) -> (Base t (b, a) -> a) -> t -> a
          (bound at src/Nat.hs:80:1)
```

                                                                                                                                                      Greg Pfeil @sellout@2017-09-20T17:48:41.126Z
@xgrommx Do you need to add `NoMonomorphismRestriction`?

                                                                                                                                                      Greg Pfeil @sellout@2017-09-20T17:49:13.410Z
Or, an explicit polymorphic type on `go`?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T19:05:42.661Z
yes, I have ScopedTypeVariables and NoMonomorphismRestriction

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-09-20T19:58:36.122Z
@sellout looks like commented type doesn't work with my `mutu`
```hs
mutu :: Recursive t => (Base t (a, a) -> a) -> (Base t (a, a) -> a) -> t -> a
-- mutu :: Recursive t => (Base t (a, b) -> b) -> (Base t (b, a) -> a) -> t -> a
mutu = go where go f g = g . fmap (go g f &&& go f g) . project
```

                                                                                                                                                      artjomg @artjomg@2017-09-25T19:52:25.782Z
Hi where is the repo https://github.com/slamdata/slamdata.git ? How can I install and use the open source version?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-26T01:16:10.713Z
@artjomg See my answer in slamdata/slamdata.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-26T03:51:39.574Z
so i'm assuming the answer to this question is yes, but worth asking - has anyone investigated using macros to create pattern functors from an AST? I'm looking at the intellij macro code and if I squint a little I think I see how you could define the pattern functor on a companion object with your macro and then let intellij know about it.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-26T03:54:17.839Z
@DanielPorter Haskell does it (https://github.com/ekmett/recursion-schemes/blob/master/Data/Functor/Foldable/TH.hs#L68), but I don’t think anyone has tried with Matryoshka.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-26T04:27:12.570Z
oh, neat.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-26T04:30:20.309Z
also - i'm back on this depth thing. started trying to implement typechecking on arangodb's language, AQL, want to do arbitrary annotations.

I got the example we worked out to compile with the prestwood AST:
```scala
  def tmp(ast: FAST): Nu[EnvT[Int, PrestwoodAST, ?]] = (0, ast).ana[Nu[EnvT[Int, PrestwoodAST, ?]]](depth[Fix[PrestwoodAST], PrestwoodAST])
```
but with this other SchemaF, it doesn't compile:
```scala
  def tmp(ast: Fix[SchemaF]): Fix[EnvT[Int, SchemaF, ?]] = (0, ast).ana[Fix[EnvT[Int, SchemaF, ?]]](depth[Fix[SchemaF], SchemaF])
```
I get a couple of type mismatch errors, and then a "implicit evidence not found" error, which I suspect is key -
`Error:(118, 100) could not find implicit value for evidence parameter of type scalaz.Functor[F]
  def tmp(ast: Fix[SchemaF]): Fix[EnvT[Int, SchemaF, ?]] = (0, ast).ana[Fix[EnvT[Int, SchemaF, ?]]](depth[Fix[SchemaF], SchemaF])`

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-26T04:31:47.444Z
If i didn't know any better, i'd think i didn't have a functor instance defined for SchemaF.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-26T04:33:07.169Z
figure there's some incantation i'm not doing, but not sure which one. the compiler gods are unappeased

                                                                                                                                                      Greg Pfeil @sellout@2017-09-26T04:39:11.783Z
@DanielPorter My guess, without looking at the code, is that `EnvT` is missing a `Functor` instance.

                                                                                                                                                      Greg Pfeil @sellout@2017-09-26T04:39:41.898Z
I bet if you defined `Traverse[SchemaF]` instead of `Functor[SchemaF]`, it’d work.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-26T04:44:57.255Z
hm. actually have both of those defined

                                                                                                                                                      Greg Pfeil @sellout@2017-09-26T04:46:53.953Z
@DanielPorter Is one lower priority than the other? Also, there’s no need to also have a Functor instance for it, is there? You can always override `map` in the Traverse instance.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-26T04:47:58.265Z
no, there's no need for functor

                                                                                                                                                      Julien Truffaut @julien-truffaut@2017-09-27T09:54:01.040Z
does matryoshka has an implementation of loeb / moeb? (still trying to put my head around the haskell definition)

                                                                                                                                                      Greg Pfeil @sellout@2017-09-27T14:47:49.379Z
@julien-truffaut Damn you, sniper.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-27T14:51:31.624Z
Lmao

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-27T14:51:37.930Z
I think you need laziness for that to make sense

                                                                                                                                                      Greg Pfeil @sellout@2017-09-27T14:52:14.374Z
Definitely.

                                                                                                                                                      Julien Truffaut @julien-truffaut@2017-09-27T14:56:08.601Z
you mean lazy data structures like list in haskell?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-27T17:22:17.063Z
Like, pervasive laziness

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-27T17:22:19.163Z
Everything is lazy

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-27T17:22:54.578Z
Your functions aren't ever applied eagerly

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-27T17:23:20.211Z
As in, programs just construct graphs and drive their evaluation via case statements

                                                                                                                                                      Greg Pfeil @sellout@2017-09-27T17:32:09.674Z
@edmundnoble I’m thinking you could achieve that with `Partial` somehow, though. But I can’t afford to think about it today 😆

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-27T17:32:20.095Z
Maybe you can do it with a lazy comonad? Not sure

                                                                                                                                                      Valentin Kasas @vil1@2017-09-28T15:02:20.475Z
Hi there. I'm currently working on a scala meta annotation that generates a pattern-functor from a simple recursive ADT, along with a `Birecursive` instance and a `Traverse` one (when possible, that's WIP and looks bit tricky)

                                                                                                                                                      Valentin Kasas @vil1@2017-09-28T15:04:02.176Z
given 
```scala
@pattern
sealed trait Tree
object Tree {
  final case class Node(label: String, children: List[Tree]) extends Tree
  final case class Leaf(label: String)                       extends Tree
  case object EmptyTree                                      extends Tree
}
```
it expands to 
```scala
  sealed trait Tree
  object Tree {
    final case class Node(label: String, children: List[Tree]) extends Tree()
    final case class Leaf(label: String) extends Tree()
    case object EmptyTree extends Tree()
    sealed trait TreeF[A]
    final case class NodeF[A](label: String, children: List[A]) extends TreeF[A]
    final case class LeafF[A](label: String) extends TreeF[A]
    final case class EmptyTreeF[A]() extends TreeF[A]
    implicit val TreeTraverse: _root_.scalaz.Traverse[TreeF] = new _root_.scalaz.Traverse[TreeF] {
      import scala.language.higherKinds
      def traverseImpl[G[_], A, B](fa: TreeF[A])(f: A => G[B])(implicit ev: _root_.scalaz.Applicative[G]): G[TreeF[B]] = fa match {
        case NodeF(label, children) => ???
        case LeafF(label) => ???
        case EmptyTreeF() => ???
      }
    }
    implicit val TreeBirecursive: _root_.matryoshka.Birecursive[Tree] = new _root_.matryoshka.Birecursive[Tree] {
      type Base[A] = TreeF[A]
      def project(t: Tree)(implicit BF: _root_.scalaz.Functor[TreeF]): TreeF[Tree] = t match {
        case Node(label, children) =>
          NodeF(label, children)
        case Leaf(label) =>
          LeafF(label)
        case EmptyTree =>
          EmptyTreeF[Tree]()
      }
      def embed(t: TreeF[Tree])(implicit BF: _root_.scalaz.Functor[TreeF]): Tree = t match {
        case NodeF(label, children) =>
          Node(label, children)
        case LeafF(label) =>
          Leaf(label)
        case EmptyTreeF() =>
          EmptyTree
      }
    }
  }
```

                                                                                                                                                      Valentin Kasas @vil1@2017-09-28T15:06:41.778Z
I took that mainly as a way to get my hands dirty a learn a little scala.meta, but I wonder if wouldn't end up being something useful

                                                                                                                                                      Valentin Kasas @vil1@2017-09-28T15:06:47.445Z
what do you think?

                                                                                                                                                      Greg Pfeil @sellout@2017-09-28T15:09:16.654Z
@vil1 Wow, I was just talking to @Voltir about this yesterday. You’re magic. I think it would be great. Kmett’s recursion-schemes has something like this.

                                                                                                                                                      Valentin Kasas @vil1@2017-09-28T15:09:42.123Z
kewl

                                                                                                                                                      Valentin Kasas @vil1@2017-09-28T15:15:01.981Z
The traverse bit looks rather tricky to work out at the purely syntactic level (in the scala.meta world), but a limited version seems doable 

                                                                                                                                                      Valentin Kasas @vil1@2017-09-28T15:16:11.098Z
also I'm not a big fan of the subclasses of `Tree` defined in the companion object , but it seems to be the only way to see them during the annotation expansion

                                                                                                                                                      Valentin Kasas @vil1@2017-09-28T15:27:28.165Z
I've another question. There is a tut documentation module, but it is not published on `ghpages`, is that on purpose?

                                                                                                                                                      Greg Pfeil @sellout@2017-09-28T15:29:08.275Z
Not on purpose. Until like a week ago, it didn’t even have actual Matryoshka docs (@tpolecat had supplied the boilerplate), so having it published wasn’t a priority. Someone with access should publish it, I guess. (@edmundnoble?)

                                                                                                                                                      Valentin Kasas @vil1@2017-09-28T15:30:27.647Z
ok

                                                                                                                                                      Valentin Kasas @vil1@2017-09-28T15:30:57.013Z
I might PR some stuff there in a relatively near future

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-28T15:34:15.601Z
I can try, sure

                                                                                                                                                      Nick Childers @Voltir@2017-09-28T16:31:31.317Z
@vil1 If the limited semantic capabilities of scala.meta turn out to be to problematic, I think something similar could be done using the macro paradise plugin and whitebox macros - with the added advantage of having all the semantics of the context and types also available. 

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-28T22:08:52.665Z
Scala meta macros will not be the official macro API and in fact have already been removed from master

                                                                                                                                                      ritschwumm @ritschwumm@2017-09-28T23:18:30.817Z
eh, what will be the official macro api then?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-28T23:31:52.022Z
It's not announced yet

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-28T23:31:56.205Z
Olaf is working on a roadmap

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-28T23:32:07.346Z
It's going to be similar to scala.meta but scala.meta is going to be for tooling and that's it

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-28T23:33:17.212Z
that's... unexpected

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-29T00:28:09.622Z
I was bringing this up in the scala/scala channel yesterday

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-29T00:28:19.873Z
Along with the fact that there's a distinct possibility that dotty will not be the new scalac

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-29T00:28:26.668Z
As things which apparently nobody knows

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-29T00:31:55.339Z
you are the vanguard of knowledge

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-29T00:49:04.908Z
I'm only passing on things I keep hearing from people, honestly some people need to start talking more

                                                                                                                                                      Valentin Kasas @vil1@2017-09-29T08:52:03.771Z
hmm that's unfortunate. I'm already quite deep down that rabbit's hole

                                                                                                                                                      Valentin Kasas @vil1@2017-09-29T08:53:22.214Z
so deep I'm dreaming of a "patternized" version of scala(meta/macro) ASTs I would be able to `cata` and stuff

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-29T14:06:48.250Z
i think we will have reached critical recursion when you can implement macros with recursion schemes using macros written with recursion schemes.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-09-29T14:07:22.839Z
i'm rooting for you, valentin :)

                                                                                                                                                      Valentin Kasas @vil1@2017-09-29T14:11:59.013Z
Dependency graphs of scala.macros and matryoshka becoming mutualy recursive 😁

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-29T14:36:35.324Z
@vil1 Andy Scott seems to be working on that

                                                                                                                                                      Valentin Kasas @vil1@2017-09-29T14:40:54.561Z
Holly Molly! Do you know where/how I can get involved?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-29T14:41:45.862Z
I'd look at his GitHub, @andyscott 

                                                                                                                                                      Valentin Kasas @vil1@2017-09-29T14:42:40.306Z
fair enough ;)

                                                                                                                                                      andy scott @andyscott@2017-09-29T15:29:06.745Z
Slowly working on it

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-29T15:29:47.011Z
seems to support mutual recursion :)

                                                                                                                                                      andy scott @andyscott@2017-09-29T15:30:40.479Z
My code or somewhere else?

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-29T15:30:57.698Z
yours, no? I see HFunctor, HFix, etc.

                                                                                                                                                      andy scott @andyscott@2017-09-29T15:32:49.243Z
I was hoping you saw more somewhere else, so I'd have more reference material

                                                                                                                                                      andy scott @andyscott@2017-09-29T15:33:18.851Z
But yeah-- I have hacked up mutual recursion working 

                                                                                                                                                      Valentin Kasas @vil1@2017-09-29T15:34:00.656Z
there are plenty of HThings in there https://github.com/nuttycom/xenomorph

                                                                                                                                                      Torsten Scholak @tscholak@2017-09-29T15:34:12.449Z
was just going to post that

                                                                                                                                                      Valentin Kasas @vil1@2017-09-29T15:34:20.257Z
hehe

                                                                                                                                                      andy scott @andyscott@2017-09-29T15:35:09.842Z
Awesome, thanks!

                                                                                                                                                      Valentin Kasas @vil1@2017-09-29T15:41:23.407Z
there's also https://github.com/nuttycom/scala_world-2017

                                                                                                                                                      Valentin Kasas @vil1@2017-09-29T15:42:01.952Z
which I'm yet to completely understand, but I'm usually rather slow XD

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-29T16:28:28.747Z
It's a DDL

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-29T16:28:52.077Z
Not sure if you were at scala world, I got to see that talk but I was really, really tired

                                                                                                                                                      Edmund Noble @edmundnoble@2017-09-29T16:29:10.594Z
It's mostly for codec generation from what I saw

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-02T22:41:39.671Z
can someone help me?) https://stackoverflow.com/questions/46525571/an-example-for-chronomorphism

                                                                                                                                                      Greg Pfeil @sellout@2017-10-03T01:17:17.684Z
@xgrommx Is there something in particular on that page?

                                                                                                                                                      Greg Pfeil @sellout@2017-10-03T01:18:10.837Z
Oh weird … I clicked your link, but it took me to a different question …

                                                                                                                                                      Greg Pfeil @sellout@2017-10-03T01:57:18.946Z
@xgrommx I commented on ekmett/recursion-schemes#42 – I don’t think I have a StackOverflow account.

                                                                                                                                                      Torsten Scholak @tscholak@2017-10-03T02:30:19.983Z
That was a good question though. I learned something :)

                                                                                                                                                      Greg Pfeil @sellout@2017-10-03T02:31:12.063Z
Yeah, I don’t mean to criticize the question at all! Definitely don’t feel like it was a duplicate of that other one (which SO confusingly auto-redirected me to).

                                                                                                                                                      Greg Pfeil @sellout@2017-10-03T02:32:53.554Z
@xgrommx And I elided a lot of stuff in that comment – so please follow-up if it’s not clear what I mean (and I wouldn’t be surprised if Kmett or someone shows up and smacks me down, either 😄).

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-03T03:06:24.168Z
Kmett agrees about just using distributive laws

                                                                                                                                                      Greg Pfeil @sellout@2017-10-03T03:06:36.757Z
Noice!

                                                                                                                                                      Greg Pfeil @sellout@2017-10-03T03:06:56.418Z
But in Scala this all goes out the window, because then you need to provide a dozen type annotations.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-03T03:07:08.814Z
Yep :P

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-03T08:19:58.303Z
@sellout I answered you in github issue =)

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-03T08:21:57.612Z
Also I know about time traveling morhisms like a `futu` and `histo` but I don't know how can I create example with `chrono` :smile: 

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-03T08:48:30.946Z
and looks like `chrono` should be like a Tardis monad) (but this is only my opinion)

                                                                                                                                                      Daniel Porter @DanielPorter@2017-10-03T20:27:50.640Z
Hi, back once again on this depth-annotation-won't-compile thing - I've put together a  minimum example

                                                                                                                                                      Daniel Porter @DanielPorter@2017-10-03T20:27:51.060Z
https://gist.github.com/DanielPorter/b8adca7a35e8d1d50e2a3fccdd4e9cc3

                                                                                                                                                      Daniel Porter @DanielPorter@2017-10-03T20:33:32.864Z
it seems like it's failing to generate a corecursive instance for Fix[EnvT[etc]], EnvT

                                                                                                                                                      Daniel Porter @DanielPorter@2017-10-03T20:38:36.331Z
```scala
Error:(100, 95) could not find implicit value for parameter T: matryoshka.Corecursive.Aux[matryoshka.data.Fix[[γ$1$]matryoshka.patterns.EnvT[Int,rasit.migrateit.MoveITF,γ$1$]],[γ$2$]matryoshka.patterns.EnvT[Int,rasit.migrateit.MoveITF,γ$2$]]
  def tmp(ast: Fix[MoveITF]) = (0, ast).ana[Fix[EnvT[Int, MoveITF, ?]]][EnvT[Int, MoveITF, ?]](appld)
Error:(100, 95) not enough arguments for method apply: (implicit evidence$19: scalaz.Functor[[γ$2$]matryoshka.patterns.EnvT[Int,rasit.migrateit.MoveITF,γ$2$]], implicit T: matryoshka.Corecursive.Aux[matryoshka.data.Fix[[γ$1$]matryoshka.patterns.EnvT[Int,rasit.migrateit.MoveITF,γ$1$]],[γ$2$]matryoshka.patterns.EnvT[Int,rasit.migrateit.MoveITF,γ$2$]])matryoshka.data.Fix[[γ$1$]matryoshka.patterns.EnvT[Int,rasit.migrateit.MoveITF,γ$1$]] in class PartiallyApplied.
Unspecified value parameter T.
  def tmp(ast: Fix[MoveITF]) = (0, ast).ana[Fix[EnvT[Int, MoveITF, ?]]][EnvT[Int, MoveITF, ?]](appld)
```

                                                                                                                                                      Daniel Porter @DanielPorter@2017-10-03T21:13:20.815Z
Ohhhhhh. Doh. Swap that fix envt type parameter on Ana to a cofree and it works

                                                                                                                                                      Greg Pfeil @sellout@2017-10-04T00:09:13.274Z
@xgrommx Re: the `mutu` problem you had a while back, I found that if you don’t use `go`, the more general type works:

                                                                                                                                                      Greg Pfeil @sellout@2017-10-04T00:10:18.621Z
```scala
mutu
  :: (Recursive t f, Functor f)
  => GAlgebra ((,) a) f b
  -> GAlgebra ((,) b) f a
  -> t
  -> a
mutu φ' φ = φ . fmap (mutu φ φ' &&& mutu φ' φ) . project
```
(where `GAlgebra w f a = f w a -> a`)

                                                                                                                                                      Greg Pfeil @sellout@2017-10-04T00:11:32.296Z
@DanielPorter You’re saying that `.ana[Cofree[MoveITF, Int]]` works, but `.ana[Fix[EnvT[Int, MoveITF, ?]]]` doesn’t?

                                                                                                                                                      Greg Pfeil @sellout@2017-10-04T00:12:48.959Z
@DanielPorter What are your imports?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-04T07:50:33.551Z
@sellout wow! https://github.com/sellout/yaya I can add monadic versions =)

                                                                                                                                                      Greg Pfeil @sellout@2017-10-04T13:45:51.817Z
@xgrommx Cool. I have cataM and gcataM locally, but not the others yet.

                                                                                                                                                      Daniel Porter @DanielPorter@2017-10-04T15:41:38.541Z
@sellout i'm using the imports in the gist just up the page

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-04T16:48:08.034Z
@sellout I cannot port zygoM from matryoshka =(

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-04T17:12:51.339Z
@sellout if u interested in some examples, several of them I had provide here https://github.com/vmchale/recursion_schemes/issues/5#issue-248280570 (also I have too much interesting experiments, but never publish it)

                                                                                                                                                      Greg Pfeil @sellout@2017-10-04T18:11:20.507Z
@xgrommx Don't bother porting zygoM, just use `zygoM = gcataM . distZygo`

                                                                                                                                                      Greg Pfeil @sellout@2017-10-04T18:12:35.286Z
Oh, I guess it's more complicated. Sorry, on my phone.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-04T18:40:43.239Z
oh) just `zygoM = gcataM . distZygo`? @sellout 

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-04T19:47:01.115Z
what is gcataM? do u have this implementation?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-04T20:08:56.218Z
why this code doesn't work? https://gist.github.com/danidiaz/e5debcaf531838eb6e2afd3ef3b34d60

                                                                                                                                                      Greg Pfeil @sellout@2017-10-05T01:20:57.409Z
@xgrommx Sorry, I hadn’t pushed it before: https://github.com/sellout/yaya/blob/master/src/Yaya/Control.hs#L36

                                                                                                                                                      Greg Pfeil @sellout@2017-10-05T01:33:25.801Z
@xgrommx But `zygoM` _is_ more complicated than that. I’ll try to get that pushed tonight.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-05T15:06:12.623Z
@xgrommx Ok, I confused myself. So, in Idris I wouldn’t _necessarily_ implement things like `paraM`. `paraM = gcataM $ distZygo embed`. If using `gcataM` infers properly, just use that directly. Also, `apoM = ganaM $ distGApo id`, `anaM = ganaM $ distAna`, `futuM = ganaM $ distGFutu id`, etc.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-05T15:06:39.137Z
Use `%default total` – I think a lot of your definitions (like `paraM`) won’t pass.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-05T15:07:56.739Z
Oh, and `zygoM` is a bit confusing. If you look at the pattern everywhere else `zygoM φ = gcataM $ distZygo φ` … but that doesn’t give you a monadic “helper” algebra.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-05T15:09:27.396Z
But, because of the pattern, I’d say that’s the correct definition for `zygoM`. You definitely _can_ implement a flavor of `zygoM` that does have a monadic helper, but I think it needs to be done without relying on `gcataM`.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-05T15:55:59.631Z
In matryoshka zygoM without gCataM or something

                                                                                                                                                      Greg Pfeil @sellout@2017-10-05T15:59:43.613Z
Right … Matryoshka gives you the richer definition – where the helper is also monadic.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-05T16:00:46.039Z
Well, it still uses gcataM, but it’s more complicated than just passing the right distributive law.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-05T16:05:01.207Z
I tried to port it to haskell, but... Maybe I don't understand scala)

                                                                                                                                                      Greg Pfeil @sellout@2017-10-05T16:14:42.846Z
@xgrommx https://github.com/sellout/yaya/blob/master/core/src/Yaya/Control.hs#L45

                                                                                                                                                      Greg Pfeil @sellout@2017-10-05T16:14:49.024Z
(just pushed it)

                                                                                                                                                      Greg Pfeil @sellout@2017-10-05T16:15:09.510Z
The Scala is definitely confusing to follow.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-05T16:28:05.969Z
@sellout nice! maybe some example with it?)

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-05T16:31:42.648Z
```hs
type ParaAlgebraM m t a = Base t (t, a) -> m a

paraM
  :: (Monad m, Traversable (Base t), Recursive t)
  => ParaAlgebraM m t a -> t -> m a
paraM alg = go where go t = alg =<< traverse (fmap (t,) . go) (project t)

anaM
  :: (Monad m, Traversable (Base t), Corecursive t)
  => (a -> m (Base t a)) -> a -> m t
anaM f = fmap embed . traverse (anaM f) <=< f
-- anaM coalg = a where
--   a = (return . embed) <=< traverse a <=< coalg

futuM :: (Corecursive t, Traversable (Base t), Monad m)
      => (a -> m (Base t (Free (Base t) a)))
      -> a
      -> m t
futuM coalg = anaM go . Pure
  where
    go (Pure a)  = coalg a
    go (Free fa) = return fa

apoM
  :: (Monad m, Traversable (Base t), Corecursive t)
  => (a -> m (Base t (Either t a))) -> a -> m t
apoM coalg = a where
  a = (return . embed) <=< traverse f <=< coalg
  f = either return a

hyloM
  :: (Monad m, Traversable t)
  => (t b -> m b) -> (a -> m (t a)) -> a -> m b
hyloM alg coalg = h
  where h = alg <=< traverse h <=< coalg
```

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-05T16:34:52.491Z
```hs
dyna' :: Functor f => (f (Cofree f b) -> b) -> (a -> f a) -> a -> b
dyna' a c = extract . hylo (\b -> a b :< b) c
```

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-05T16:35:26.877Z
or
```hs
dyna :: Functor f => (f (Cofree f a) -> a) -> (c -> f c) -> c -> a
dyna a c = extract . h
  where h = uncurry (:<) . (a &&& id) . fmap h . c
```

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-05T16:37:04.835Z
composition for algebras
```hs
infixr 9 <><

f <>< g = f . project . g
```

and we can `cata(alg1 <>< alg2 <>< alg3)`

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-05T16:40:01.089Z
maybe do u know how second function will be rewritten with recursion schemes?
```hs
polyPlus''' :: Num a => [a] -> [a] -> [a]
polyPlus''' =
  curry $ apo coalg where
    coalg :: Num a => ([a], [a]) -> ListF a (Either [a] ([a], [a]))
    coalg = \case
      ([], []) -> Nil
      ([], x:xs) -> Cons x $ Left xs
      (x:xs, []) -> Cons x $ Left xs
      (a:as, b:bs) -> Cons (a + b) $ Right (as, bs)

polyMult' (f:fs) gss@(g:gs) = f*g : polyPlus''' (polyMult' [f] gs) (polyMult' fs gss)
polyMult' _ _ = []
```

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-05T16:40:17.930Z
I talk about `polyMult'`

                                                                                                                                                      Olivier Mélois @Baccata@2017-10-14T22:22:18.369Z
Hey guys, I have no idea whether it'd be useful or not, and I suppose somebody already emitted the idea anyway, but I wanted to take a shot at implementing a stack safe `hylo`. Managed to do it using cats's`Eval` and increasing the requirement for `F[_]` from `Functor` to `Traverse`. [here's the code](https://gist.github.com/Baccata/5fb6e9784992b2a467aa1c846d4585c2). 

                                                                                                                                                      Olivier Mélois @Baccata@2017-10-14T22:25:20.168Z
Dumb benchmarks show the performance of that version isn't too bad 

                                                                                                                                                      Greg Pfeil @sellout@2017-10-14T23:15:09.622Z
@Baccata I think this is really useful. There’s been a _little_ discussion about how to handle stack-safety in general, and I don’t think we have a good solution. There is already `hyloM`, which (as with yours) requires `Traverse`. And `hyloM[Eval]` (or `Free.Trampoline`) should be stack-safe. However, it uses `A => M[F[A]]` (and `F[A] => M[A]`). I wonder if you could define a version like yours (without the `M` in the algebras) on top of `hyloM[Eval]`.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-14T23:19:51.396Z
@xgrommx Sorry, I’ve been away from Gitter for a while … looking at your stuff from a couple weeks ago now.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-14T23:20:15.027Z
hyloM with eval is not stack-safe

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-14T23:20:28.841Z
It can't be, because you need to guard the recursive call

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-14T23:20:35.557Z
`Monad` has no idea how to do that

                                                                                                                                                      Greg Pfeil @sellout@2017-10-14T23:22:09.444Z
@edmundnoble Hrmm, well stuff that overflows with `hylo` definitely doesn’t with `hyloM`. Doesn’t the fact that the result of the coalgebra is delayed handle that?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-14T23:25:37.768Z
It doesn't?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-14T23:25:44.368Z
It does with `cataM`

                                                                                                                                                      Greg Pfeil @sellout@2017-10-14T23:26:01.948Z
Wait, what? `cataM[Eval]` is definitely not stack-safe.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-14T23:26:12.778Z
It does *overflow* *

                                                                                                                                                      Greg Pfeil @sellout@2017-10-14T23:27:00.725Z
Ah – yeah, `cataM[Eval]` isn’t stack-safe, because it uses `M.pure`, which is not `delay`.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-14T23:27:49.527Z
But if the `A => Eval[F[A]]` coalgebra uses `delay`, then `hyloM` should be stack-safe.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-14T23:28:39.990Z
Right, true, that's the user's choice

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-14T23:28:56.897Z
This version uses `Eval.defer`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-14T23:29:20.421Z
I think actually letting the user decide may be better, that sounds like it means the user can control the stack bouncing

                                                                                                                                                      Olivier Mélois @Baccata@2017-10-14T23:32:18.193Z
I had misread the definition of `hyloM`. Hadn't notice it could provide type safety provided the coalgebra handles it  ! yay for learning things  :smile: 

                                                                                                                                                      Greg Pfeil @sellout@2017-10-14T23:32:44.856Z
Yeah, and that’s great for `hyloM`, but you can’t get a user-controlled stack-safe `cataM`. You need like an explicit `cataEval` that knows to `defer`. The problem is that because of inference issues, you can’t just have `gcataEval` and let users pass the `DistributiveLaw` they want, you need to provide `zygoEval`, `paraEval`, `histoEval`, etc. I mean, it’s just a bunch of annoying definitions over `gcataEval`, but still. Meh.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-14T23:33:29.807Z
I actually am not sure `hyloM` can do this.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-14T23:33:47.155Z
I guess `anaM[Eval]` is stack-safe? So it’s only the cata side of things that’s a problem.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-14T23:34:22.528Z
I really don't think either can be.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-14T23:34:41.963Z
These functions are `A => F[A]` not `(=> A) => F[A]`

                                                                                                                                                      Greg Pfeil @sellout@2017-10-14T23:34:46.277Z
@edmundnoble You mean, you’re not sure if @Baccata’s `hylo` can be defined in terms of `hyloM`? I think you may be right. But I was hoping someone thinking about it longer would solve it :D

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-14T23:35:35.977Z
I think up there I've found the reason. Even with a lazy monad, the ~~result~~ parameter has already been evaluated.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-14T23:38:10.101Z
But with `Eval.defer <<< ψ`, we’ve calculated `F[A]`, but then it should still defer the recursive call … no?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-14T23:38:24.698Z
We have an `F[A]` to pass to that, though

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-14T23:38:32.078Z
Not an `=> F[A]`

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-14T23:38:54.415Z
Or rather an `A` and not an `=> A`, sorry, still not clear on the phi vs psi distinction ;)

                                                                                                                                                      Greg Pfeil @sellout@2017-10-14T23:39:33.552Z
ψ : A => F[A]

                                                                                                                                                      Greg Pfeil @sellout@2017-10-14T23:40:01.147Z
I see it as ψ opens it up, and φ folds it down … a visual mnemonic.

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-14T23:40:07.164Z
Ah that helps!

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-14T23:40:19.068Z
Right yeah, the trouble is that the signature of that (`Eval.defer <<< up`) is still going to be adapted to `A => F[A]` which means the `A` is evaluated before calling

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-14T23:42:43.715Z
The caller has no knowledge that the function call could be lazy

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-15T02:26:31.253Z
@sellout oh)

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T03:38:35.307Z
@sellout Hello. I try to create monadic histomorphism but I don't know how...
```hs
histoM :: (Traversable f, Monad m) => (m (f (Cofree f a)) -> a) -> Fix f -> m a
histoM coalg = fmap extract . cataM (\x -> Cofree(Fix (CoBindF (coalg x) (fmap uncofree x))))
```

I create `histo` via `cata`
```hs
histo :: Functor f => (f (Cofree f a) -> a) -> Fix f -> a
histo f = extract . cata (\x -> Cofree(Fix (CoBindF (f x) (fmap uncofree x))))
```

could u please help my with `histoM`?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T04:01:32.958Z
@sellout Okay, looks like type is correct, but how about implementation?
```
histoM :: (Traversable f, Monad m) => (m (f (Cofree f a)) -> a) -> Fix f -> m a
histoM f = fmap extract . cataM (\x -> return(Cofree(Fix(CoBindF (f $ return x) (fmap uncofree x)))))
``` 

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T17:13:40.112Z
anybody can help me?
https://gist.github.com/xgrommx/8da8b1b1c5f55081656ede665e80ab40#file-fix-hs-L45-L46

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T18:21:31.013Z
@xgrommx Because Haskell is lazy, Fix ~ Nu (`Nu` makes the laziness explicit. In Scala, Fix ~ Mu), and both Free and Cofree should use Nu (in Haskell).

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T18:23:27.662Z
@xgrommx You might want to look at sellout/yaya – you can start with something like `anaM = ganaM distAna`, then manually expand the definition step by step.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T18:24:09.247Z
Oh, or start with `anaM = hyloM $ pure . embed`, and expand.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T18:24:38.189Z
That probably makes more sense, as `ganaM` is defined in terms of `anaM` 😆

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T18:26:08.702Z
but now is problem with `histoM`)

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T18:26:17.428Z
could you help me?)

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T18:27:06.389Z
also histo via cata
```hs
histo :: Functor f => (f (Cofree f c) -> c) -> Fix f -> c
histo f = extract . cata (\x -> Cofree(Fix (CoBindF (f x) (fmap uncofree x))))

histoM :: (Traversable f, Monad m) => (m (f (Cofree f a)) -> a) -> Fix f -> m a
histoM f = fmap extract . cataM (\x -> ...)
```

I think we can create `histoM` via `cataM`

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T18:27:54.118Z
@sellout what do u think?)

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T18:58:24.839Z
@xgrommx Yeah, start from `gcataM (disGHisto id)` and expand it out.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T19:16:40.147Z
hm

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T19:17:00.345Z
`gcataM (distGHisto id)` is `histoM`? @sellout

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T19:27:06.530Z
@sellout looks like no

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T19:30:12.474Z
@sellout maybe you could help me?)

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T19:32:24.700Z
@xgrommx it _should_ be. I think your type for HistoM is wrong … sorry, on my phone.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T19:33:16.129Z
I just revert functional arrow from `futuM`

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T19:34:14.592Z
`m (f (Cofree f a)) -> a` isn't generally implementable.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T19:34:55.715Z
histoM uses `f (Cofree f a) -> m a`.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T19:35:23.107Z
And you're right, that's not the dual of futuM.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T19:35:49.432Z
`futuM :: (Traversable f, Monad m) => (a -> m (f (Free f a))) -> a -> m (Fix f)` hm I think it should dual for `histoM`

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T19:36:17.210Z
To take the dual, you would have to flip _all_ the arrows, which means your Monad would become a Comonad as well.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T19:36:59.760Z
maybe you could help me later... thanks

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T19:37:53.689Z
As I understand `chronoM f g = histoM f <=< futuM g`

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T19:40:16.363Z
but why in `anaM` and `cataM` used `Monad m`?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T19:42:59.842Z
here also `Monad` but I don't understand how can I port it https://github.com/pa-ba/compdata-param/blob/079c5f34a2b433607a14b467c2e17af0d5df6ceb/src/Data/Comp/Param/Algebra.hs#L571-L578

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T19:59:10.547Z
Maybe I'm wrong but
```hs
chronoM :: (Traversable f, Monad m) => (m (f (Cofree f b)) -> b) -> (a -> m (f (Free f a))) -> a -> m b
chronoM f g = _x f <=< futuM g
```
`Found hole: _x :: (m (f (Cofree f b)) -> b) -> Fix f -> m b` and it should be type signature for `histoM`

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T20:34:20.974Z
@xgrommx It’s not possible to implement, that, though. Andi it’s only telling you that’s the signature because that’s what you gave it. Try

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T20:35:07.548Z
```haskell
chronoM :: (Traversable f, Monad m) => (f (Cofree f b) -> m b) -> (a -> m (f (Free f a))) -> a -> m b
chronoM f g = _x f <=< futuM g
```
and see what it tells you.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T20:36:42.963Z
With your type for `f`, you need a way to eliminate an arbitrary `Monad`, which isn’t a thing.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T20:43:55.961Z
@sellout what do u mean?

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T20:45:11.992Z
`m (f (Cofree f b)) -> b` has `m` in the parameter, but not in the result – how do you do that?

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T20:45:28.197Z
You can’t implement any `f`.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T20:46:00.985Z
ok, now I got this one `Found hole: _x :: (f (Cofree f b) -> m b) -> Fix f -> m b`

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T20:47:14.931Z
Yeah, that’s what you want. So, you can write the type for `histoM` and use that in place of _x.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T20:48:49.202Z
```hs
histoM :: (Traversable f, Monad m) => (f (Cofree f a) -> m a) -> Fix f -> m a
histoM = undefined

chronoM :: (Traversable f, Monad m) => (f (Cofree f b) -> m b) -> (a -> m (f (Free f a))) -> a -> m b
chronoM f g = histoM f <=< futuM g
```

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T20:48:52.656Z
okay

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T20:49:14.960Z
but I cannot realize how should be implemented `histoM`

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T20:51:11.982Z
Right … so the way _I_ implement it is via `gcataM`, because that works for any[†] Comonad, not just Cofree. ([†]: presuming you have a distributive law `f (w a) -> w (f a)` … which is what `distGHisto` is.)

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T20:51:18.431Z
```hs
histoM :: (Traversable f, Monad m) => (f (Cofree f a) -> m a) -> Fix f -> m a
histoM f = fmap extract . cataM (\x -> ?)
```

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T20:51:40.683Z
Yep!

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T20:52:01.405Z
but what is body in `cataM`?

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T20:52:08.024Z
So, `(traverse f . w . fmap duplicate)` is the argument to `cataM`.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T20:52:24.268Z
Now you just need to define `w`.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T20:52:35.172Z
Which, use `_w` to see what it needs to be.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T20:52:38.069Z
oh... help me =(

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T20:53:13.431Z
Sure. I’m definitely not doing any thinking at the moment, just pasting, so … lemme think.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T20:53:56.318Z
`cataM` is expecting some `g b -> m b` … but we don’t know what `g` and `b` are yet.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T20:54:55.928Z
`fmap extract` tells us that the result of `cataM` is `m (Cofree f a)`.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T20:56:04.686Z
Because `histoM` needs to return `m a`, and so we’re `fmap`ping over the `m` and using `extract` to get rid of _some_ Comonad … and the Comonad we have is `Cofree f`.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T20:59:10.276Z
okay, do u think it will be implemented via `cataM`?

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T21:06:30.184Z
Yes, definitely.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T21:07:05.283Z
So, `b` is `Cofree f a`.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T21:07:59.224Z
Ok, sorry on my phone again … back later :)

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T21:12:59.510Z
okay)

                                                                                                                                                      Greg Pfeil @sellout@2017-10-21T21:36:52.624Z
The short answer is that `w` should be replaced by `distGHisto id`. But figuring out what that means is the hard part.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T21:57:54.725Z
could u help me with Comonadic instance for Cofree? (my Cofree which I provided above)
```hs
instance Functor f => Comonad (Cofree f) where
    duplicate :: Cofree f a -> Cofree f (Cofree f a)
    duplicate w = Cofree(Fix(CoBindF w (fmap duplicate w)))
    extract (Cofree(Fix(CoBindF a _))) = a
```

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-21T21:58:19.616Z
Looks like some problem in `fmap duplicate w`

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T01:13:23.756Z
@xgrommx Are you saying that that doesn’t compile?

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T01:16:22.069Z
I’m guessing it’s because `duplicate` in `fmap duplicate w` is being applied to `Fix CofreeF`, not to `Cofree`. Maybe `fmap duplicate (Cofree w)`?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T05:52:35.086Z
@sellout no, now I got
```
/Users/dstoyano/work/app10/src/Free.hs:295:30: error:
    • Couldn't match kind ‘* -> *’ with ‘*’
      When matching the kind of ‘Fix’
      Expected type: CofreeF
                       (Cofree f0) (Cofree f a) (Fix (CofreeF (Cofree f0) (Cofree f a)))
        Actual type: CofreeF
                       (Cofree f0) (Cofree f a) (Fix (Fix (Cofree f a)))
    • In the first argument of ‘Fix’, namely
        ‘(CoBindF w (fmap duplicate (Cofree w)))’
      In the first argument of ‘Cofree’, namely
        ‘(Fix (CoBindF w (fmap duplicate (Cofree w))))’
      In the expression:
        Cofree (Fix (CoBindF w (fmap duplicate (Cofree w))))

/Users/dstoyano/work/app10/src/Free.hs:295:64: error:
    • Couldn't match expected type ‘Fix
                                      (CofreeF f0 (Fix (Cofree f a)))’
                  with actual type ‘Cofree f a’
    • In the first argument of ‘Cofree’, namely ‘w’
      In the second argument of ‘fmap’, namely ‘(Cofree w)’
      In the second argument of ‘CoBindF’, namely
        ‘(fmap duplicate (Cofree w))’
    • Relevant bindings include
        w :: Cofree f a
          (bound at /Users/dstoyano/work/app10/src/Free.hs:295:15)
        duplicate :: Cofree f a -> Cofree f (Cofree f a)
          (bound at /Users/dstoyano/work/app10/src/Free.hs:295:5)
Failed, modules loaded: none.
```

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T05:52:47.458Z
```hs
instance Functor f => Comonad (Cofree f) where
    duplicate :: Cofree f a -> Cofree f (Cofree f a)
    duplicate w = Cofree(Fix(CoBindF w (fmap duplicate (Cofree w))))
    extract (Cofree(Fix(CoBindF a _))) = a
```

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T06:00:59.390Z
@xgrommx Oh, whoops – you want to do `(fmap (duplicate . Cofree) (unwrap w))` (or something similar), where `unwrap (Cofree (Fix (CoBindF _ fr))) = fr`

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T06:16:29.703Z
@sellout do u mean `duplicate w = Cofree(Fix(CoBindF w (fmap (duplicate . Cofree) (_unwrap w))))`?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T06:16:52.037Z
```hs
_unwrap :: Cofree a b -> a (Fix (CofreeF a b))
_unwrap (Cofree(Fix(CoBindF _ as))) = as
```

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T06:23:25.408Z
Yep.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T06:26:02.097Z
I got new error. (I hate newtype :)) 
```
/Users/dstoyano/work/app10/src/Free.hs:300:30: error:
    • Couldn't match type ‘Cofree f (Cofree f a)’
                     with ‘Fix (CofreeF f (Cofree f a))’
      Expected type: CofreeF
                       f (Cofree f a) (Fix (CofreeF f (Cofree f a)))
        Actual type: CofreeF f (Cofree f a) (Cofree f (Cofree f a))
    • In the first argument of ‘Fix’, namely
        ‘(CoBindF w (fmap (duplicate . Cofree) (_unwrap w)))’
      In the first argument of ‘Cofree’, namely
        ‘(Fix (CoBindF w (fmap (duplicate . Cofree) (_unwrap w))))’
      In the expression:
        Cofree (Fix (CoBindF w (fmap (duplicate . Cofree) (_unwrap w))))
    • Relevant bindings include
        w :: Cofree f a
          (bound at /Users/dstoyano/work/app10/src/Free.hs:300:15)
        duplicate :: Cofree f a -> Cofree f (Cofree f a)
          (bound at /Users/dstoyano/work/app10/src/Free.hs:300:5)
Failed, modules loaded: none.
```

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T06:30:16.969Z
Ok, so I _think_ `(duplicate . Cofree)` has to be `(uncofree . duplicate . Cofree)`.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T06:31:51.395Z
wow!

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T06:33:20.332Z
another problem) I see u create `mutuM` via `cataM` I tried the same for `paraM` but got some errors
```hs
para :: Functor f => (f (Fix f, c) -> c) -> Fix f -> c
para psi = snd . cata ((Fix . fmap fst) &&& psi)

paraM :: (Traversable t, Monad m) => (t (Fix t, b) -> m b) -> Fix t -> m b
paraM f = fmap snd . cataM (bisequence . (Fix fmap fst &&& f))
```
in `Fix fmap fst `
```
/Users/dstoyano/work/app10/src/Free.hs:123:43: error:
    • Couldn't match expected type ‘((a0, b0) -> a0)
                                    -> t (Fix t, b) -> m (Fix t)’
                  with actual type ‘Fix ((->) (a1 -> b1))’
    • The function ‘Fix’ is applied to two arguments,
      but its type ‘((a1 -> b1) -> Fix ((->) (a1 -> b1)))
                    -> Fix ((->) (a1 -> b1))’
      has only one
      In the first argument of ‘(&&&)’, namely ‘Fix fmap fst’
      In the second argument of ‘(.)’, namely ‘(Fix fmap fst &&& f)’
    • Relevant bindings include
        f :: t (Fix t, b) -> m b
          (bound at /Users/dstoyano/work/app10/src/Free.hs:123:7)
        paraM :: (t (Fix t, b) -> m b) -> Fix t -> m b
          (bound at /Users/dstoyano/work/app10/src/Free.hs:123:1)

/Users/dstoyano/work/app10/src/Free.hs:123:47: error:
    • Couldn't match type ‘f0 a1 -> f0 b1’ with ‘Fix ((->) (a1 -> b1))’
      Expected type: (a1 -> b1) -> Fix ((->) (a1 -> b1))
        Actual type: (a1 -> b1) -> f0 a1 -> f0 b1
    • In the first argument of ‘Fix’, namely ‘fmap’
      In the first argument of ‘(&&&)’, namely ‘Fix fmap fst’
      In the second argument of ‘(.)’, namely ‘(Fix fmap fst &&& f)’
Failed, modules loaded: none.
```

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T06:34:13.529Z
Hah! I _just_ pushed that `mutuM` like an hour ago :D

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T06:35:43.618Z
yes) I like idea with `cataM`

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T06:35:49.647Z
Did you forget the `.` between `Fix` and `fmap`?

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T06:36:23.582Z
Also, you should only need `sequenceA`, not `bisequence` there.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T06:36:26.655Z
yep

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T06:36:46.276Z
wow!

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T06:37:17.720Z
and how about our discussion about `histoM`?)

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T06:37:53.698Z
Ahahaha – where did we leave it? I figured that’s why you were working on the Comonad Cofree instance.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T06:38:17.674Z
yes, Comonad is implemented

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T06:38:46.770Z
```hs
histoM :: (Traversable f, Monad m) => (f (Cofree f a) -> m a) -> Fix f -> m a
histoM f = fmap _extract . cataM (\x -> undefined)

chronoM :: (Traversable f, Monad m) => (f (Cofree f b) -> m b) -> (a -> m (f (Free f a))) -> a -> m b
chronoM f g = histoM f <=< futuM g
```

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T06:40:31.710Z
So
```haskell
histoM f = fmap extract . cataM (traverse f . distGHisto id . fmap duplicate)
```

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T06:41:04.723Z
Unexplained, because I really need to go to bed soon :D

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T06:41:46.363Z
But, `distGHisto id` is the thing to figure out – it’s `f (Cofree f a) -> Cofree f (f a)`

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T06:44:07.575Z
@sellout good night =)

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T06:44:19.452Z
and thanks again =)

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T06:44:39.843Z
I need go deeper to recursion schemes

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T06:44:50.963Z
No problem. It’s always fun to work through this stuff (for me, at least).

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T06:46:18.843Z
Kmett's version is ok for 
```hs
histoM :: (Traversable f, Comonad m, Monad m) => (f (Cofree f a) -> m a) -> Fix f -> m a
histoM f = fmap extract . cataM (traverse f . distGHisto id . fmap duplicate)

chronoM :: (Traversable f, Comonad m, Monad m) => (f (Cofree f b) -> m b) -> (a -> m (f (Free f a))) -> a -> m b
chronoM f g = histoM f <=< futuM g
```
Now I need create it for my Cofree via Fix

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T06:58:24.525Z
strange result for your new version of `mutu`
Old
```hs
mutu':: Recursive t => (Base t (a, b) -> b) -> (Base t (b, a) -> a) -> t -> a
mutu' φ' φ = φ . fmap (mutu' φ φ' &&& mutu' φ' φ) . project

evenOdd :: Nat -> Bool
evenOdd = mutu' f g where
  f ZeroF = False
  f (SuccF (b, _)) = b
  g ZeroF = True
  g (SuccF(b, _)) = b

evenOdd 10 -- True
```

New
```hs
mutu :: Recursive t => (Base t (b, a) -> b) -> (Base t (b, a) -> a) -> t -> a
mutu f g = snd . cata (f &&& g)

evenOdd' :: Nat -> Bool
evenOdd' = mutu f g where
  f ZeroF = False
  f (SuccF (b, _)) = b
  g ZeroF = True
  g (SuccF(b, _)) = b

evenOdd' 10 -- False
```

Looks like for new it isn't correct result

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T06:59:09.189Z
Because `even 10` should be `True`

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T06:59:43.595Z
@xgrommx Yeah … the new one has a different type for `f :: Base t (b, a) -> b`.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T07:00:54.106Z
That’s actually the way it’s defined in the literature, but I’m not sure if I like it. To get the old signature back, you could do
```haskell
mutu':: Recursive t => (Base t (a, b) -> b) -> (Base t (b, a) -> a) -> t -> a
mutu' f g = snd . cata (f . fmap swap &&& g)
```

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T07:01:05.412Z
(`fmap swap` being the difference)

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T07:02:48.053Z
I like that with my previous def, both parameters were `GAlgebra`s. The new way matches the papers and avoids the `fmap swap`.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T07:03:30.335Z
but why old version isn't correct?
```
*Nat> even 10
True
*Nat> evenOdd 10
True
*Nat> evenOdd' 10
False
*Nat>
```

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T07:03:49.375Z
To fix your `evenOdd'`, I think just change `f (SuccF (b, _)) = b` to `f (SuccF (_, b)) = b`

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T07:04:03.799Z
flipped arguments?)

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T07:04:08.840Z
Yep.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T07:04:48.718Z
I’m inclined to change it back … gotta sleep on it :D

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T07:04:53.786Z
hm, looks good
```
*Nat> even 10
True
*Nat> evenOdd 10
True
*Nat> evenOdd' 10
True
*Nat> evenOdd 3
False
*Nat> evenOdd' 3
True
```

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T07:05:10.138Z
That last one daesn’t look good …

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T07:05:29.076Z
oh sure

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T07:05:40.750Z
now, it always True

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T07:05:52.159Z
Did you change the argument order to `g` as well?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T07:06:24.630Z
I did it in both...

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T07:06:35.262Z
now I change only in first function

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T07:06:36.280Z
Only `f` needed it.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T07:06:41.625Z
```hs
evenOdd' :: Nat -> Bool
evenOdd' = mutu' f g where
  f ZeroF = False
  f (SuccF (_, b)) = b
  g ZeroF = True
  g (SuccF(b, _)) = b
```

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T07:06:44.254Z
👍🏼

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T07:07:05.725Z
But tomorrow I might switch it back and break your code again 😆

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T07:07:12.906Z
why we have 2 versions of `mutu`?)

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T07:07:48.696Z
There should only be the one. I thought I deleted the old one. Maybe I didn’t commit that …

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T07:08:10.121Z
Hrmm, I did. Should be good.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T07:13:46.302Z
So, a practical reason I liked the old one is that with your function, `mutu f g` returns `True` when even and `False` when odd, but `mutu g f` would return `False` when even and `True` when odd. With the new version, I don’t think you can do that.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T07:14:41.407Z
It might do something reasonable in this case, but when `a` and `b` are different types, it can’t do anything good to switch the parameter order.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-22T07:15:14.843Z
Pretty sure I’m going to switch it back tomorrow – sorry for breaking your code :D

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T07:16:47.768Z
@sellout don't worry) This is only my experiments, I don't know what is version of `mutu` will be correct

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-22T07:18:15.943Z
I use this classic version of mutual recursion
```hs
even :: Int -> Bool
even 0 = True
even n = odd (n - 1)

odd :: Int -> Bool
odd 0 = False
odd n = even (n - 1)
```

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T06:58:15.325Z
@sellout Hello) How can I solve this problem?)
```hs
chronoM :: (Corecursive a1, Recursive a1, Traversable (Base a1), Monad m) => (Base a1 (Cofree (Base a1) c) -> m c) -> (a -> m (Base a1 (Free (Base a1) a))) -> a -> m c
chronoM f g = histoM f <=< futuM g 
```

```
/Users/dstoyano/work/app10/src/Experiments2.hs:1670:22: error:
    • Couldn't match type ‘Base a10’ with ‘Base a1’
      Expected type: Base a10 (Cofree (Base a10) c) -> m c
        Actual type: Base a1 (Cofree (Base a1) c) -> m c
      NB: ‘Base’ is a type function, and may not be injective
      The type variable ‘a10’ is ambiguous
    • In the first argument of ‘histoM’, namely ‘f’
      In the first argument of ‘(<=<)’, namely ‘histoM f’
      In the expression: histoM f <=< futuM g
    • Relevant bindings include
        g :: a -> m (Base a1 (Free (Base a1) a))
          (bound at /Users/dstoyano/work/app10/src/Experiments2.hs:1670:11)
        f :: Base a1 (Cofree (Base a1) c) -> m c
          (bound at /Users/dstoyano/work/app10/src/Experiments2.hs:1670:9)
        chronoM :: (Base a1 (Cofree (Base a1) c) -> m c)
                   -> (a -> m (Base a1 (Free (Base a1) a))) -> a -> m c
          (bound at /Users/dstoyano/work/app10/src/Experiments2.hs:1670:1)
Failed, modules loaded: none.
```

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T14:47:48.735Z
@xgrommx Because there’s nothing that determines what `a1` is in that definition. Two of your options are to `AllowAmbiguousTypes` and have some caller use `TypeApplications` to specify which `a1` they want, or to just add an annotation here, like `:: a -> Fix f`, and replace all the mentions of `Base a1` with `f`.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T17:02:54.570Z
@sellout Sorry, could you please explain it?

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T17:14:10.537Z
@xgrommx I’ll give it a go … `futuM g` returns `a1`, `histoM f` consumes `a1`, but there is no `a1` either being passed to or returned from `chronoM`. So GHC has to infer the type. But there can be multiple types that satisfy `Corecursive a1, Recursive a1` with a `Base`. So GHC can’t infer one.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T17:15:13.897Z
E.g., `Fix f` and `Nu f` are two things that satisfy that regardless of what `Base a1` is.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T17:18:23.638Z
When I'll be home, I'll try it and notify you about result. Thanks

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T19:47:34.673Z
@sellout and what is should be my signature?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T19:48:24.340Z
```hs
futuM :: (Corecursive t, Traversable (Base t), Monad m) => (a -> m (Base t (Free (Base t) a))) -> a -> m t
futuM coalg = anaM go . Pure where
  go (Pure a)  = coalg a
  go (Free fa) = return fa

histoM :: (Traversable (Base a1), Recursive a1, Monad f) => (Base a1 (Cofree (Base a1) a) -> f a) -> a1 -> f a
histoM f = fmap extract . cataM (traverse f . distGHisto id . fmap duplicate)

chronoM :: (Corecursive a1, Recursive a1, Traversable (Base a1), Comonad m, Monad m) => (Base a1 (Cofree (Base a1) c) -> m c) -> (a -> m (Base a1 (Free (Base a1) a))) -> a -> m c
chronoM f g = histoM f <=< futuM g
```

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T19:48:47.152Z
 @xgrommx `chronoM :: (Traversable f, Monad m) => (f (Cofree f c) -> m c) -> (a -> m (f (Free f a))) -> a -> m c`

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:06:56.035Z
how about `zygoM` via `cataM`?
```hs
zygoM :: (Monad (Base a1), Traversable (Base a1), Recursive a1) => (Base a1 b -> Base a1 b) -> (Base a1 (b, a) -> Base a1 a) -> a1 -> Base a1 a
zygoM φ' φ =
  gcataM (distZygo (φ' <=< sequenceA))
                   (φ <=< traverse (fmap swap . sequenceA . swap)) 
                         
zygoM' :: (Recursive a, Traversable (Base a), Monad f) => (Base a b1 -> f b1) -> (Base a (b1, b) -> f b) -> a -> f b
zygoM' g f = fmap snd . cataM(bisequence . (g . fmap fst &&& f))  
```

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:09:14.639Z
@sellout I got it
```
/Users/dstoyano/work/app10/src/Experiments2.hs:1668:34: error:
    • Couldn't match type ‘f’ with ‘Base a10’
      ‘f’ is a rigid type variable bound by
        the type signature for:
          chronoM :: forall (f :: * -> *) (m :: * -> *) c a.
                     (Traversable f, Monad m) =>
                     (f (Cofree f c) -> m c) -> (a -> m (f (Free f a))) -> a -> m c
        at /Users/dstoyano/work/app10/src/Experiments2.hs:1667:12
      Expected type: a -> m (Base a10 (Free (Base a10) a))
        Actual type: a -> m (f (Free f a))
    • In the first argument of ‘futuM’, namely ‘g’
      In the second argument of ‘(<=<)’, namely ‘futuM g’
      In the expression: histoM f <=< futuM g
    • Relevant bindings include
        g :: a -> m (f (Free f a))
          (bound at /Users/dstoyano/work/app10/src/Experiments2.hs:1668:11)
        f :: f (Cofree f c) -> m c
          (bound at /Users/dstoyano/work/app10/src/Experiments2.hs:1668:9)
        chronoM :: (f (Cofree f c) -> m c)
                   -> (a -> m (f (Free f a))) -> a -> m c
          (bound at /Users/dstoyano/work/app10/src/Experiments2.hs:1668:1)
Failed, modules loaded: none.
```

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:24:09.855Z
Also another question. How will be implemented `anaM`  via `ana` for example `cataM` => `cataM alg = (>>= alg) . cata (traverse (>>= alg))`

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:31:51.308Z
and about `dynaM` this is correct?
```hs
dyna :: Functor f => (f (Cofree f b) -> b) -> (a -> f a) -> a -> b
dyna f g = chrono f (fmap return . g)

dynaM :: (Monad m, Comonad m, Traversable f) => (f (Cofree f b) -> m b) -> (a -> m (f (Free f a))) -> a -> m b
dynaM f g = chronoM f (traverse return <=< g)
```

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:32:17.607Z
I have some doubt about `(a -> m (f (Free f a)))`

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T21:36:17.363Z
There shouldn’t be a Free  … why use `chrono` for  `dyna`? `dyna f g = histo f . ana g` (plus the type annotation like you added for `chrono`)

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T21:38:58.639Z
`anaM`, unfortunately, isn’t implementable that way, I think (or, if it is, I haven’t figured it out): https://github.com/sellout/yaya/blob/master/unsafe/src/Yaya/Unsafe/Control.hs#L16

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T21:39:52.840Z
@xgrommx And what’s the context of that error you pasted?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:40:02.974Z
:point_up: [October 24, 2017 12:06 AM](https://gitter.im/slamdata/matryoshka?at=59ee59f0614889d475ef9411) how about this error?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:40:19.744Z
context?

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T21:41:20.007Z
Yeah, there’s an error from like 30 minutes ago, and I don’t know what it relates to.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:42:03.115Z
It regarding with your signature `chronoM :: (Traversable f, Monad m) => (f (Cofree f c) -> m c) -> (a -> m (f (Free f a))) -> a -> m c`

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:42:31.221Z
Also I understand about `anaM` via `futuM`
```hs
anaM' :: (Monad m, Traversable f) => (a -> m (f a)) -> a -> m (Fix f)
anaM' f = futuM(fmap (\x -> fmap (\y -> Free(Fix(ReturnF y))) x) . f)
```

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T21:43:23.626Z
@xgrommx So, what’s the code that got you that error?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:44:18.135Z
```hs
futuM :: (Corecursive t, Traversable (Base t), Monad m) => (a -> m (Base t (Free (Base t) a))) -> a -> m t
futuM coalg = anaM go . Pure where
  go (Pure a)  = coalg a
  go (Free fa) = return fa

histoM :: (Traversable (Base a1), Recursive a1, Monad f) => (Base a1 (Cofree (Base a1) a) -> f a) -> a1 -> f a
histoM f = fmap extract . cataM (traverse f . distGHisto id . fmap duplicate)

chronoM :: (Traversable f, Monad m) => (f (Cofree f c) -> m c) -> (a -> m (f (Free f a))) -> a -> m c
chronoM f g = histoM f <=< futuM g 
```

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T21:45:37.205Z
Right, so as I mentioned earlier, you need a type annotation in `chronoM` – like `histoM f <=< (futuM g :: a -> m (Fix f))`

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T21:46:07.446Z
You probably also need `forall f m a c.`, too.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:47:03.693Z
hm

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:47:17.570Z
In Kmett's version used `Base` not `Fix`

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T21:47:39.682Z
?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:48:18.569Z
histoM, futuM used `Base t`
```hs
futuM :: (Corecursive t, Traversable (Base t), Monad m) => (a -> m (Base t (Free (Base t) a))) -> a -> m t
futuM coalg = anaM go . Pure where
  go (Pure a)  = coalg a
  go (Free fa) = return fa

histoM :: (Traversable (Base a1), Recursive a1, Monad f) => (Base a1 (Cofree (Base a1) a) -> f a) -> a1 -> f a
histoM f = fmap extract . cataM (traverse f . distGHisto id . fmap duplicate)
```

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T21:48:42.774Z
Yeah, those should. We’re talking about `chronoM`.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:48:58.994Z
but why here `Fix`? `futuM g :: a -> m (Fix f))`

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T21:49:22.046Z
Because you have to choose _some_ specific type for the result of `futuM`.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:50:27.007Z
ohh... type families isn't helpful sometime, I talk about restriction `Base`

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T21:51:05.805Z
restriction?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:51:19.736Z
`(Base t) => ...`

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T21:51:36.529Z
I’m still not sure what you’re saying.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:51:47.561Z
ok, no problem)

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T21:51:49.590Z
`Base t` isn’t a constraint.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:52:21.101Z
yes) I know, maybe I use wrong word for it

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:52:23.951Z
and about `zygoM` looks like this is correct deriving via `cataM`?)

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T21:54:15.182Z
You have `Traversable (Base t)` when you need to extract the `Base` from a known fixed-point type, but the problem with `chronoM` (or any hylomorphism) is that there’s no way for the compiler to guess which fixed-point type you want to use for the intermediate step (and those functions are usually defined in a way that avoids the problem, e.g., `hylo f g = f . fmap (hylo f g) . g` rather than `hylo f g = cata f . ana g`)

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:56:02.760Z
yes, I know, because if we unpack `cata, ana` we can eliminate some part of it `fmap unfix . fmap Fix` => `fmap (unfix . Fix)` => `fmap id` => `id`

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T21:56:14.316Z
Your `zygoM` looks a lot like `mutuM` – so you could define it as `zygoM g f = mutuM(g . fmap snd, f)`

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:56:52.176Z
@sellout my version with `cataM` is wrong?

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T21:57:42.442Z
No, it looks right … but you have a lot of duplicated code between all of your schemes, so I was trying to simplify it.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T21:58:28.715Z
I just make my old version of `zygo` - monadic
```hs
zygo :: Functor f => (f a -> a) -> (f (a, b) -> b) -> Fix f -> b
zygo g f = snd . cata (\x -> (g $ fmap fst x, f x))

zygoM :: (Monad f, Traversable t) => (t a -> f a) -> (t (a, b) -> f b) -> Fix t -> f b
zygoM g f = fmap snd . cataM(bisequence . (g . fmap fst &&& f))
```

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T21:59:24.525Z
So, we’ve been going over this stuff for a while – I’m curious what your goal is. Just a deeper understanding of these tools?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T22:00:53.346Z
And I have maybe another version of `mutu` unlike your version
```hs
mutu :: Functor f => (f (a, b) -> b) -> (f (b, a) -> a) -> Fix f -> a
mutu f g = snd . cata (f . fmap swap &&& g)
-- mutu φ' φ t = φ (fmap (\x -> (mutu φ φ' x, mutu φ' φ x)) (unfix t))

mutuM :: (Monad f, Traversable t) => (t (a, b) -> f a) -> (t (a, b) -> f b) -> Fix t -> f b
mutuM f g = fmap snd . cataM (bisequence . (f &&& g))
```

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T22:01:18.223Z
That is exactly my version of mutu.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T22:01:59.432Z
@sellout yes! I love recursion schemes. And I want replace all my recursion on a specific recursion schemes

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T22:02:28.627Z
@sellout and `mutuM`?

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T22:03:12.569Z
Yeah … other than that I do `f . fmap swap` in both – mixing those seems like a bad idea.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T22:03:32.399Z
I mean in both `mutu` and `mutuM`

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T22:05:32.830Z
@sellout what is wrong here? `zygoM g f = mutuM(g . fmap snd, f)` should be tuple?

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T22:07:33.591Z
If you’re using your definition of `mutuM`, then you want `zygoM g f = mutuM(g . fmap fst, f)`, but if you change your `mutuM` to match your `mutu`, then you should keep `snd`.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T22:07:57.728Z
oh

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T22:08:20.295Z
```hs
mutuM f g = fmap snd . cataM (bisequence . ((f . fmap swap) &&& g))
```
how it will be correct regarding with my `mutu` version

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T22:08:31.637Z
Yep.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T22:08:53.879Z
this `mutuM` doesn't compile

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T22:09:03.815Z
Did you fix the type?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T22:10:00.741Z
should be?
```hs
mutuM :: (Monad f, Traversable t) => (t (a, b) -> f b) -> (t (b, a) -> f a) -> Fix t -> f a
mutuM f g = fmap snd . cataM (bisequence . ((f . fmap swap) &&& g))
```

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T22:10:37.418Z
but I got error
```
src/Free.hs:144:18: error:
    • Couldn't match expected type ‘t (a, b) -> f b’
                  with actual type ‘(f1 (a0, b1) -> c, t1)’
    • In the first argument of ‘mutuM’, namely ‘(g . fmap snd, f)’
      In the expression: mutuM (g . fmap snd, f)
      In an equation for ‘zygoM’: zygoM g f = mutuM (g . fmap snd, f)
    • Relevant bindings include
        f :: t1 (bound at src/Free.hs:144:9)
        g :: f1 b1 -> c (bound at src/Free.hs:144:7)
        zygoM :: (f1 b1 -> c) -> t1 -> (t (b, a) -> f a) -> Fix t -> f a
          (bound at src/Free.hs:144:1)
Failed, modules loaded: none.
```

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T22:11:47.058Z
You mean _zygoM_ doesn’t compile.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T22:12:10.562Z
oh

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T22:13:01.369Z
this isn't what should be)
```hs
zygoM :: (Traversable t, Monoid c) => (t a -> c) -> (t (a, b) -> b) -> (t (b, a) -> (c, a)) -> Fix t -> (c, a)
zygoM g f = mutuM(g . fmap fst &&& f)
```

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T22:13:19.266Z
Looks like `zygoM` should be `zygoM :: (Monad f, Traversable t) => (t a -> f a) -> (t (a, b) -> f b) -> Fix t -> f b`

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T22:13:20.515Z
That type signature is wrong …

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T22:13:29.504Z
Yeah, that’s right.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T22:14:09.017Z
some problem here `g . fmap fst &&& f`

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T22:14:24.471Z
```hs
src/Free.hs:145:13: error:
    • Couldn't match type ‘Fix t’ with ‘t (f b, a) -> (f a, a)’
      Expected type: Fix t -> f b
        Actual type: (t (f b, a) -> (f a, a)) -> Fix t -> (f a, a)
    • Possible cause: ‘mutuM’ is applied to too many arguments
      In the expression: mutuM (g . fmap fst &&& f)
      In an equation for ‘zygoM’: zygoM g f = mutuM (g . fmap fst &&& f)
    • Relevant bindings include
        f :: t (a, b) -> f b (bound at src/Free.hs:145:9)
        g :: t a -> f a (bound at src/Free.hs:145:7)
        zygoM :: (t a -> f a) -> (t (a, b) -> f b) -> Fix t -> f b
          (bound at src/Free.hs:145:1)
Failed, modules loaded: none.
```

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T22:15:13.195Z
Oh, now I understand your “should be tuple?” question.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T22:15:28.079Z
No – `zygoM g f = mutuM (g . fmap snd) f`

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T22:17:51.226Z
oh!!! thaaaanks!

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T22:18:32.719Z
Maybe I need sleep. I a little bit tired today, and cannot normal think.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T22:19:53.156Z
I love it!)
```hs
zygo :: Functor f => (f a -> a) -> (f (a, b) -> b) -> Fix f -> b
zygo g f = mutu(g . fmap snd) f
```

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T22:21:52.560Z
@sellout what is your main reason why you avoid type families in `yaya`?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T22:29:13.875Z
Also can we derive `paraM` via `para`?

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T22:37:04.507Z
So, if you start doing a bunch of polymorphic folds (and most in my experience are), you do a _lot_ of `Recursive t, Base t ~ Maybe` constraints. So I prefer writing `Recursive t Maybe`.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T22:39:27.584Z
Re: para/paraM – I would define them in terms of zygo/zygoM – `para f = zygo embed f`

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T22:42:58.582Z
This is why all these operations are in a `Zoo` module in `Yaya` – they’ve been given names by various papers over the years, but it turns out they’re all ultimately the same thing. So rather than define every single variation, only have `gcata` and `gcataM` (need both, because `gcataM` is more constrained). And those are defined in terms of `cata`, because `cata` is the easiest to define for `Recursive` instances.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T22:55:09.434Z
@sellout I ask you about `paraM` via `para` because I see in your `Yaya` exists `cataM` version via `cata`

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T22:57:07.318Z
And what is a version of `paraM` via `zygoM`?
```hs
para' :: Functor f => (f (Fix f, c) -> c) -> Fix f -> c
para' f = zygo Fix f

paraM' :: (Traversable t, Monad m) => (t (Fix t, b) -> m b) -> Fix t -> m b
paraM' f = zygoM Fix f
```

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T22:58:54.811Z
Well, your `zygoM` helper is `f a -> m a`, right? But `Fix :: f (Fix f) -> Fix f`, so you gotta add `pure`.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T23:01:16.942Z
And I guess you could do something like `paraM f = para (f <=< traverse sequenceA)`?

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T23:01:33.717Z
Not _certain_ that’s right. It seems to easy.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T23:01:51.001Z
@sellout where `pure`?

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T23:02:21.134Z
@xgrommx On `Applicative` – it’s the less-constrained name for `return`.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T23:02:41.588Z
Oh, you mean where to _use_ it?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T23:02:43.780Z
`zygo Fix f . pure`? looks like it is wrong

                                                                                                                                                      Greg Pfeil @sellout@2017-10-23T23:02:57.571Z
`zygo (pure . Fix) f`

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T23:03:11.186Z
oh

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T23:03:26.034Z
I try `zygo (Fix . pure) f`

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-23T23:04:02.230Z
By the way) this is version will be compiled
```hs
paraM' :: (Traversable t, Monad m) => (t (Fix t, b) -> m b) -> Fix t -> m b
paraM' f = para (f <=< traverse sequenceA)
```

                                                                                                                                                      Edmund Noble @edmundnoble@2017-10-25T23:06:01.212Z
@sellout I just implemented `transHyloM`, will get into matryoshka probably fairly soon

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:22:14.595Z
anyone have any resources on matryoshka and how it relates to monads like Task?

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:22:46.907Z
@wemrysi how you doing by the way

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:31:04.416Z
another thing i'm interested in is taking a recursive structure like `case class Foo(a: Bar, bars: List[Bar], irrelevant: Baz)` and being able to define a function that can return a List[Bar]

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:31:21.485Z
i.e. filtering all the `Bar` out of the structure

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:31:47.879Z
I'm guessing that's possible with matryoshka

                                                                                                                                                      Greg Pfeil @sellout@2017-10-28T04:33:44.947Z
@hderms I don’t see how that case class is recursive (other than it containing a List, which is recursive).

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:33:51.350Z
@sellout i got lazy

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:33:58.200Z
but in reality some of it would be recursive

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:34:26.621Z
with respect to how matryoshka relates to Task or Future, I'm interested in whether matryoshka would enable me to take a nested ADT that has some Task as members and be able to define traverse for it 

                                                                                                                                                      Greg Pfeil @sellout@2017-10-28T04:35:12.451Z
So, you’re saying that there’d be a parameter of type `Foo`, and you’d want to concat the nested `bars` with the outer `bars`?

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:35:24.943Z
yeah

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:35:38.330Z
basically recurse through the structure pulling out anything of type Bar

                                                                                                                                                      Greg Pfeil @sellout@2017-10-28T04:39:47.450Z
Well, it’d have to be specific to the structure. Maybe _have to_ is a strong word, but otherwise you need to get into Generics / HList … or, you could parameterize over `Bar`, like `Foo[A](a: A, bars: List[A], recursive: Foo[A])`, in which case having `Traverse[Foo]` would let you use Matryoshka on the pattern functor (which would be like `FooF[A, B]` to collect all the Bars, with only `Bitraverse[F]`, rather than specifically on `FooF`.

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:40:09.072Z
yeah i was thinking shapeless might be involved

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:40:44.787Z
whats FooF ? Fix[Foo] ?

                                                                                                                                                      Greg Pfeil @sellout@2017-10-28T04:41:00.190Z
I’d have to see an example of what you mean re: `Task`. Let’s not talk about `Future`, though. It doesn’t mix so well with this sort of thing.

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:41:14.375Z
yeah i was thinking task would be more appropriate

                                                                                                                                                      Greg Pfeil @sellout@2017-10-28T04:41:34.498Z
`FooF` is a functor such that `Foo ≅ Fix[FooF]`

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:42:05.940Z
@sellout basically its the same question as the previous one but it would be like a sealed trait where some of the nodes have a Task[Foo] as a member

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:43:03.757Z
basically want to be able to traverse it returning Task[Foo] replacing the things that had been Task[Foo] with Foo

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:43:14.411Z
might be a pipe dream

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:43:50.234Z
the questions are related as far as i can see but im trying to solve different problems

                                                                                                                                                      Greg Pfeil @sellout@2017-10-28T04:44:07.065Z
Yeah, I think doing specifically that might not be feasible, but that stepping back a bit and taking a different approach might avoid having `Task[Foo]` members at all.

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:44:28.220Z
@sellout its basically an ADT that describes steps in a web form wizard

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:44:39.493Z
some of the steps aren't known without making asynchronous requests

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:45:02.151Z
and im trying to build up a tree structure thats concrete and has no async parts

                                                                                                                                                      Greg Pfeil @sellout@2017-10-28T04:45:21.799Z
Yeah, so you might just want some sort of `anaM[Task]` to do that.

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:45:32.689Z
cool i'll look into that

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:45:40.080Z
the non-task related question is that i'm trying to take a data model that's defined through a JSON schema

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:45:51.315Z
use argus to produce a bunch of case classes automatically

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:46:20.607Z
and then be able to take this big nested JSON structure and pull out all the individual case classes that appear separately

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:46:34.006Z
so that i can use Slick or something to build a big SQL transaction

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:46:39.874Z
saving them all in one go into separate tables

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:47:08.097Z
another possible pipe dream but i'm trying to think outside the box to solve this problem elegantly so i can evangelize scala at my workplace

                                                                                                                                                      Dermot Haughey @hderms@2017-10-28T04:49:18.342Z
which i was thinking is superficially similar to JSON encoding or other stuff i could use shapeless to do

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-30T00:20:46.127Z
@sellout hello =) I have this code with `apo`
```hs
zapWith :: (a -> a -> a) -> [a] -> [a] -> [a]
zapWith f =
  curry $ apo coalg where
    coalg = \case
      ([], []) -> Nil
      ([], x:xs) -> Cons x $ Left xs
      (x:xs, []) -> Cons x $ Left xs
      (a:as, b:bs) -> Cons (f a b) $ Right (as, bs)
```

But how the same code will be with para?
```hs
zapWith' :: (a -> b -> c) -> [a] -> [b] -> [c]
zapWith' f =
  curry $ para alg where
    alg = \case
      ? -> ?
```

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-30T00:47:30.066Z
looks like need `Recursive` instance for `([a], [b])` but how can I implement type instance? `type instance Base ([a], [b]) = ?`

                                                                                                                                                      Greg Pfeil @sellout@2017-10-30T03:02:57.543Z
@xgrommx I’m pretty sure you can’t write that with para.

                                                                                                                                                      Greg Pfeil @sellout@2017-10-30T03:08:41.372Z
@xgrommx What is your goal with the `para` version – since you separated the types, it seems you want to truncate the longer list, but you do want them aligned from the head? (if so, just use `ana`) or the tail? (you could do something hylo-y, I think)

                                                                                                                                                      Greg Pfeil @sellout@2017-10-30T03:20:13.577Z
Like, `anaM` with `State`, where you zip, then throw the tail of the longer list into the `State`, followed by `cataM`, where you `ConsF h t -> s -> (f (fst h) (last s) : t, snd h : init s)` (in the case where the 2nd list was longer).

                                                                                                                                                      Greg Pfeil @sellout@2017-10-30T05:48:52.089Z
@xgrommx I guess you could make something like `data TwoListF a b c = TwoConsF a b c | LeftConsF a c | RightConsF b c | NoneConsF` … but that’s not quite right, because there are constructions of that which aren’t isomorphic with `([a], [b])`, like `LeftConsF 0 (RightConsF 'a' NoneConsF)` -> `([0], ['a'])` -> `TwoConsF 0 'a' NoneConsF`.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-10-30T10:12:43.755Z
ok

                                                                                                                                                      Julien Truffaut @julien-truffaut@2017-11-06T15:04:34.458Z
Hi all,  I am having an issue at work where it seems I am missing the right recursion abstraction.  I hope you don't mind if I try to describe the problem quickly, maybe you would have have some pointers to give me!

                                                                                                                                                      Greg Pfeil @sellout@2017-11-06T15:05:01.285Z
@julien-truffaut Absolutely!

                                                                                                                                                      Julien Truffaut @julien-truffaut@2017-11-06T15:09:13.874Z
```
val as: Stream[A] = Stream(a1,a2,a3, ...)
lazy val bs: Stream[B] = (as |@| (hardCodedC ##:: cs)).map(f)
lazy val cs: Stream[C] = bs.map(g)
```

So we have two "Stream" (doesn't have to be std stream) that depend on each other but it is ok because we "shift" `cs` in `bs`

                                                                                                                                                      Julien Truffaut @julien-truffaut@2017-11-06T15:10:32.734Z
now we are trying to replicate the same behaviour but inside of a Monad `F`, e.g.:
```
val as: F[Stream[A]] = ???
lazy val bs: F[Stream[B]] = ???
lazy val cs: F[Stream[C]] = ???
```

                                                                                                                                                      Julien Truffaut @julien-truffaut@2017-11-06T15:11:30.353Z
what I don't know is what properties `F` needs in order to maintain the lazyness of the original stream encoding

                                                                                                                                                      Greg Pfeil @sellout@2017-11-06T15:36:43.329Z
@julien-truffaut I have to run … but does it need anything beyond `Applicative?`
```scala
val as: F[Stream[A]] = ???
lazy val bs: F[Stream[B]] = (as |@| cs).map((as, cs) => (as |@| (hardCodedC ##:: cs)).map(f))
lazy val cs: F[Stream[C]] = bs.map(_.map(g))
```

                                                                                                                                                      Julien Truffaut @julien-truffaut@2017-11-06T15:53:00.690Z
np

                                                                                                                                                      Julien Truffaut @julien-truffaut@2017-11-06T15:56:08.303Z
I am not sure how to accurately describe it but I think the issue is that `F[Stream[B]]` is not lazy. I have `B_n` depend on `C_n-1` and `C_n` depends on `B_n` and `C_0` is hardcoded

                                                                                                                                                      Greg Pfeil @sellout@2017-11-06T17:13:28.793Z
@julien-truffaut I think I’d have to experiment with it – it _seems_ to me that you don’t need `F` to be lazy, but I’m not surprised that I’m wrong about that.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-10T13:10:18.987Z
@sellout  I see u create https://github.com/sellout/Iaia and also I know about https://github.com/vmchale/recursion_schemes

                                                                                                                                                      Greg Pfeil @sellout@2017-11-10T16:50:35.894Z
@xgrommx Heh, you’re the second person to mention that today 😆 Yeah, I know Vanessa and we talk about recursion schemes. Iaia makes some different decisions than the existing libraries (somewhat summarized in https://github.com/sellout/yaya#differences-from-recursion-schemes), and I created Yaya & Iaia (I promise they’re pronounced differently) to illustrate those, to simplify discussions with Vanessa, Kmett, and others. I’m hoping we can come to some agreement on the approaches, and re-unify the libs.

                                                                                                                                                      Greg Pfeil @sellout@2017-11-10T17:01:41.993Z
(Actually, you were probably the first … I just saw it second)

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-10T17:51:46.795Z
interesting idea with Stepper

                                                                                                                                                      Greg Pfeil @sellout@2017-11-10T18:00:26.413Z
@xgrommx Well, my hand was kind of forced by totality :D

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-10T18:10:20.036Z
@sellout looks like Stepper + Recursive is Recursive from Kmett's recursion schemes

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-10T18:10:58.608Z
and why u don't use `Control.Arrow`? https://github.com/sellout/Iaia/blob/master/src/Iaia/Control.idr#L78-L92

                                                                                                                                                      Greg Pfeil @sellout@2017-11-10T18:29:45.590Z
@xgrommx Ah! That is because you can’t define instances on `->`!

                                                                                                                                                      Greg Pfeil @sellout@2017-11-10T18:31:24.626Z
But, I wondered if you could add those definitions to Control.Arrow under a namespace and hope that Idris would successfully disambiguate them. So a friend said he’s going to try that. At least then it’ll often _look_ like you have `Arrow (->)`, but it still wouldn’t work anywhere you had an `Arrow` constraint.

                                                                                                                                                      Greg Pfeil @sellout@2017-11-13T10:42:38.147Z
**\[Jean-Remi Desjardins, SlamData Inc.\]** What does “irrufutable” mean here?: [https://github.com/slamdata/matryoshka/blob/master/core/shared/src/main/scala/matryoshka/Embed.scala#L27](https://github.com/slamdata/matryoshka/blob/master/core/shared/src/main/scala/matryoshka/Embed.scala#L27)

                                                                                                                                                      Greg Pfeil @sellout@2017-11-13T10:42:58.216Z
**\[Jean-Remi Desjardins, SlamData Inc.\]** Google tells me it’s a typo, but I’m wondering if that’s actually the case

                                                                                                                                                      Greg Pfeil @sellout@2017-11-13T10:43:33.035Z
**\[Jean-Remi Desjardins, SlamData Inc.\]** But if someone knows, I might add a reference because it’s not easy to find what that word means

                                                                                                                                                      Greg Pfeil @sellout@2017-11-13T12:25:23.370Z
**\[Rintcius Blok, SlamData Inc.\]** @jr yeah, that's a typo - it should be irrefutable

                                                                                                                                                      Greg Pfeil @sellout@2017-11-13T17:38:49.573Z
**\[Jean-Remi Desjardins, SlamData Inc.\]** @rintcius What does an irrefutable extractor mean?

                                                                                                                                                      Jean-Rémi Desjardins @jedesah@2017-11-13T18:05:42.152Z
Haha, didn't realize @sellout was being the messenger here! :smile: We might want to fix that one of these days

                                                                                                                                                      Greg Pfeil @sellout@2017-11-14T23:06:42.163Z
@jedesah It means it always returns `Some`, so it doesn’t break exhaustivity when you use it.

                                                                                                                                                      andy scott @andyscott@2017-11-20T00:26:53.318Z
Is there a reasonable way to implement a stack safe hylo for regular Algebra/Coalgebras?

                                                                                                                                                      Edmund Noble @edmundnoble@2017-11-20T01:56:19.841Z
Yes

                                                                                                                                                      Edmund Noble @edmundnoble@2017-11-20T01:56:26.729Z
Not regular

                                                                                                                                                      Edmund Noble @edmundnoble@2017-11-20T01:56:33.441Z
You need to have a `Traverse` constraint

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T14:42:57.061Z
@sellout Hello!)
I have some question about `distGMutu` also `gmutu` and `comutu` =)
```hs
-- distGMutu ?
-- gmutu ?
comutu :: Functor f => (b -> f(Either a b)) -> (a -> f(Either b a)) -> a -> Fix f
comutu f g = Fix . fmap (either (comutu g f) (comutu f g)) . g -- I'm not sure here

cozygo :: Functor f => (a -> f a) -> (b -> f (Either a b)) -> b -> Fix f
cozygo f psi = ana (either (fmap Left . f) psi) . Right
```

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T14:51:41.648Z
@sellout and also
```hs
cozygo :: Functor f => (a -> f a) -> (b -> f (Either a b)) -> b -> Fix f
cozygo f psi = comutu (f . ?) psi
```

                                                                                                                                                      andy scott @andyscott@2017-11-20T16:17:44.682Z
@edmundnoble Awesome. I had implemented one myself with a traverse constraint but wasn’t sure if there was a better way!

                                                                                                                                                      andy scott @andyscott@2017-11-20T16:18:08.000Z
Thanks :)

                                                                                                                                                      Edmund Noble @edmundnoble@2017-11-20T16:50:54.859Z
Welcome :) you can probably do it in a nicer way than using `Trampoline` or `Eval` but I haven't cracked it yet.

                                                                                                                                                      Greg Pfeil @sellout@2017-11-20T18:59:13.774Z
@xgrommx cozygo is better known as gapo.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T19:09:18.091Z
@sellout I know)

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T19:09:36.493Z
@sellout how about `distGMutu`, `gmutu`?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T19:14:17.503Z
also I realize it
```hs
gapo :: Functor f => (a -> f a) -> (b -> f (Either a b)) -> b -> Fix f
gapo f psi = comutu (fmap Right . f) psi
```

                                                                                                                                                      Greg Pfeil @sellout@2017-11-20T21:10:18.291Z
@xgrommx So, what do you expect `gmutu` to look like? I.e., how does it generalize `mutu`?

                                                                                                                                                      Greg Pfeil @sellout@2017-11-20T21:12:18.929Z
@xgrommx And `distGMutu` seems unlikely to me – at least, I don’t think that even a `distMutu` is possible with comonadic folds. You need a distributive law over adjunctions (as in http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/urs.pdf), rather than one over comonads.

                                                                                                                                                      Greg Pfeil @sellout@2017-11-20T21:12:50.627Z
@xgrommx `comutu` looks interesting, though – would be cool to see a use case for it.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T22:00:22.170Z
```hs
comutuM :: (Traversable f, Monad m) => (b -> m (f (Either a b))) -> (a -> m (f (Either b a))) -> a -> m (Fix f)
comutuM f g = fmap Fix . traverse(either (comutuM g f) (comutuM f g)) <=< g
```

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T22:30:12.523Z
oh...
```hs
ana :: Functor f => (a -> f a) -> a -> Fix f
ana phi = comutu (fmap Right . unfix) (fmap Right . phi)
```

                                                                                                                                                      Greg Pfeil @sellout@2017-11-20T22:34:21.890Z
Yeah, there is a line of generalization `ana` → `apo` → `gapo` → `comutu`. All of those except `comutu` are part of the family of generalized monadic unfolds (`gana`).

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T22:43:46.437Z
sure) but I think should exists `gmutu/gcomutu`?

                                                                                                                                                      Greg Pfeil @sellout@2017-11-20T22:44:31.908Z
What do you think `gmutu` would look like?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T22:45:00.546Z
like `mutu` but with `DistributiveLaw`

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T22:47:53.257Z
smth like here https://github.com/ekmett/recursion-schemes/blob/master/Data/Functor/Foldable.hs#L610-L625

                                                                                                                                                      Greg Pfeil @sellout@2017-11-20T22:49:31.903Z
So, I think you’re working your way toward adjoint folds. The problem is that most useful adjunctions (including `∆ ⊣ (×)` for `mutu`) require non-endo `Functors`.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T22:51:28.898Z
@sellout sorry?)

                                                                                                                                                      Greg Pfeil @sellout@2017-11-20T22:54:09.348Z
Oh, wait … I might be misinterpreting … you’re saying you want something like `gmutu :: (Recursive t f, Functor f, Comonad w) => DistributiveLaw f w -> GAlgebra (Compose ((,) a) w) f b -> GAlgebra (Compose ((,) b) w) f a -> t -> a`?

                                                                                                                                                      Greg Pfeil @sellout@2017-11-20T22:54:41.736Z
And then you can treat `gmutu` as a generalization over `gcata`?

                                                                                                                                                      Greg Pfeil @sellout@2017-11-20T22:56:39.602Z
Oh, and I guess using `EnvT` instead of `Compose` is a good way to go, like `gzygo` does.

                                                                                                                                                      Greg Pfeil @sellout@2017-11-20T22:57:29.993Z
`gmutu :: (Recursive t f, Functor f, Comonad w) => DistributiveLaw f w -> GAlgebra (EnvT a w) f b -> GAlgebra (EnvT b w) f a -> t -> a`

                                                                                                                                                      Greg Pfeil @sellout@2017-11-20T22:59:38.845Z
(Yeah, I think you could do that)

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T23:09:30.954Z
looks like

                                                                                                                                                      Greg Pfeil @sellout@2017-11-20T23:10:18.295Z
👍🏼 I like it

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T23:11:35.271Z
and `gcomutu` will be generalized version of `gana` (as I understand `gana` correctly)

                                                                                                                                                      Greg Pfeil @sellout@2017-11-20T23:12:00.273Z
`gcomutu`, yeah, totally.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T23:12:17.714Z
yes)

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T23:12:21.474Z
some mistake

                                                                                                                                                      Greg Pfeil @sellout@2017-11-20T23:12:28.698Z
I think it needs a better name than `comutu`, though :D

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T23:13:00.408Z
what is signature for `gcomutu`?)

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T23:13:34.682Z
`gmutu :: (Recursive t f, Functor f, Comonad w) => DistributiveLaw f w -> GAlgebra (EnvT a w) f b -> GAlgebra (EnvT b w) f a -> t -> a` oh... Can we use `mutu` for it?)

                                                                                                                                                      Greg Pfeil @sellout@2017-11-20T23:16:26.469Z
So … `GCoalgebra (ExceptT a m) f b` … but I think that stack might be in the wrong order, so you might need to try `GCoalgebra (Compose (Either a) m) f b`?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T23:20:39.699Z
I try it
```hs
gmutu :: (Functor f, Comonad w) => DistributiveLaw f w -> GAlgebra (EnvT a w) f b -> GAlgebra (EnvT b w) f a -> Fix f -> a
gmutu = undefined
```

And got
```
    • Cannot instantiate unification variable ‘a0’
      with a type involving foralls:
        DistributiveLaw f w
        -> GAlgebra (EnvT a w) f b -> GAlgebra (EnvT b w) f a -> Fix f -> a
        GHC doesn't yet support impredicative polymorphism
    • In the expression: undefined
      In an equation for ‘gmutu’: gmutu = undefined
    • Relevant bindings include
        gmutu :: DistributiveLaw f w
                 -> GAlgebra (EnvT a w) f b -> GAlgebra (EnvT b w) f a -> Fix f -> a
          (bound at src/Free.hs:503:1)
Failed, modules loaded: none.
```

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T23:21:30.931Z
pragma `ImpredicativeTypes`...

                                                                                                                                                      Greg Pfeil @sellout@2017-11-20T23:22:39.196Z
That error seems to be about the expression, not the type, right?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T23:25:15.816Z
`ImpredicativeTypes` fix it

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T23:26:09.454Z
```hs
gmutu :: (Functor f, Comonad w) => DistributiveLaw f w -> GAlgebra (EnvT a w) f b -> GAlgebra (EnvT b w) f a -> Fix f -> a
gmutu n f g = undefined
```

body for `gmutu` is complicated for me(

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T23:26:35.940Z
looks like we need use `gana`?

                                                                                                                                                      Greg Pfeil @sellout@2017-11-20T23:27:21.161Z
But once you implement it, you should be able to remove ImpredicativeTypes, I believe.

                                                                                                                                                      Greg Pfeil @sellout@2017-11-20T23:27:39.391Z
Also, I’m trying to avoid implementing it, so I can get some work done 😆

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-20T23:28:02.426Z
nice)

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-21T23:59:41.823Z
@sellout some results?) hello

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-24T15:58:17.714Z
@sellout hello!) are u here?

                                                                                                                                                      Greg Pfeil @sellout@2017-11-24T16:28:35.563Z
@xgrommx Not really – but I might be around some either tomorrow or Sunday.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-24T16:37:47.059Z
@sellout I have some question
```hs
import Data.Functor.Foldable

type List a = Mu(ListF a)

unMu (Mu m) = m

nil :: Mu(ListF a)
nil = Mu $ \f -> f Nil
    
cons :: forall a. a -> Mu (ListF a) -> Mu (ListF a)
cons a b = Mu $ \f -> f ?
```

what is should be `cons`?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-24T16:38:42.327Z
`Mu` from here https://github.com/ekmett/recursion-schemes/blob/master/Data/Functor/Foldable.hs#L539

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-24T16:45:42.552Z
```hs
cons :: forall a. a -> Mu (ListF a) -> Mu (ListF a)
cons a b = Mu $ \f -> f $ Cons a _y
```
ok... but `_y` is?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-24T17:46:39.453Z
@sellout solve it! thx)
```hs
nil :: Mu(ListF a)
nil = Mu $ \f -> f Nil
    
cons :: forall a. a -> Mu (ListF a) -> Mu (ListF a)
cons a (Mu b) = Mu $ \f -> f $ Cons a (b f)
```

                                                                                                                                                      Greg Pfeil @sellout@2017-11-24T18:58:40.411Z
@xgrommx Indeed, it’s `embed $ Cons a b`, given `embed m = Mu (\f -> f (fmap (fold f) m))` (also from `Data.Functor.Foldable`).

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-24T19:13:02.995Z
`fold` - `cata`?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-24T19:13:09.918Z
or Data.Foldable?

                                                                                                                                                      Greg Pfeil @sellout@2017-11-24T19:13:20.592Z
Yeah, `cata`.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-24T19:13:38.555Z
how about gmutu/gcomutu?)

                                                                                                                                                      Greg Pfeil @sellout@2017-11-24T19:13:59.433Z
I haven’t had a chance to think about them :D

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-24T19:14:37.922Z
also https://github.com/xgrommx/awesome-functional-programming/blob/master/rsfa.md

                                                                                                                                                      Greg Pfeil @sellout@2017-11-24T19:14:45.896Z
But I want to call `comutu` something like a `divmorphism` or something (for “diverging”), but that’s still not a nice name.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-24T19:16:22.462Z
will be nice)

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-24T19:16:25.385Z
https://hackage.haskell.org/package/recursion-schemes-ext-1.0.0.0/docs/Data-Functor-Foldable-Exotic.html

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-11-24T19:16:35.478Z
several strange operators)

                                                                                                                                                      LukaJCB @LukaJCB@2017-12-09T16:34:54.861Z
Might be a stupid question, but are `ana` and `catamorphisms` guaranteed to be total? 🤔 

                                                                                                                                                      Greg Pfeil @sellout@2017-12-09T17:48:12.280Z
@LukaJCB Great question! They are not.

                                                                                                                                                      Greg Pfeil @sellout@2017-12-09T17:48:45.621Z
But I’m working on libraries where you can expect them to be – e.g. sellout/yaya

                                                                                                                                                      LukaJCB @LukaJCB@2017-12-09T17:49:38.812Z
Nice!

                                                                                                                                                      Greg Pfeil @sellout@2017-12-09T17:50:06.392Z
If you were to define cata on a Stream, it may never terminate, for example. But ana on a Stream is total.

                                                                                                                                                      LukaJCB @LukaJCB@2017-12-09T17:50:17.574Z
Makes sense

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-12-09T18:01:18.367Z
Also u can take a look on recursion schemes which written on idris

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-12-09T18:03:06.524Z
cc @sellout and https://github.com/vmchale/recursion_schemes

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-12-09T18:04:38.729Z
https://github.com/sellout/Iaia

                                                                                                                                                      Torsten Scholak @tscholak@2017-12-09T18:40:24.427Z
@sellout I’m looking closely into Idris these days and I noticed that you started implementing a recursion schemes library, iaia. Would you say that this channel is a good place to discuss it?

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-12-09T18:41:13.477Z
How about gcomutu and other friends?)

                                                                                                                                                      Greg Pfeil @sellout@2017-12-09T20:06:41.907Z
@tscholak Fine by me – already been discussing the Haskell one here.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-12-09T20:08:41.848Z
@sellout ?

                                                                                                                                                      Greg Pfeil @sellout@2017-12-09T21:53:44.864Z
@xgrommx I just tried for a bit, and got this:

                                                                                                                                                      Greg Pfeil @sellout@2017-12-09T21:54:25.230Z
```haskell
gmutu
  :: ( Comonad w
     , Recursive t f
     , Functor f)
  => DistributiveLaw f w
  -> GAlgebra (EnvT a w) f b
  -> GAlgebra (EnvT b w) f a
  -> t
  -> a
gmutu w φ' φ = extract . mutu (lowerEnv φ') (lowerEnv φ)
  where
    -- lowerEnv :: GAlgebra (EnvT c w) f d -> GAlgebra ((,) (w c)) f (w d)
    lowerEnv φ'' =
      lower . fmap φ'' . distZygoT _f w . fmap (duplicate . uncurry EnvT . first extract)
```

                                                                                                                                                      Greg Pfeil @sellout@2017-12-09T21:54:53.955Z
It’s not quite right … that `_f` I haven’t figured out.

                                                                                                                                                      Greg Pfeil @sellout@2017-12-10T16:08:23.917Z
@xgrommx Got it!
```haskell
gmutu
  :: (Comonad w, Comonad v, Recursive t f, Functor f)
  => DistributiveLaw f w
  -> DistributiveLaw f v
  -> GAlgebra (EnvT a w) f b
  -> GAlgebra (EnvT b v) f a
  -> t
  -> a
gmutu w v φ' φ = extract . mutu (lowerEnv w φ') (lowerEnv v φ)
  where
    lowerEnv x φ'' =
      fmap φ''
      . x
      . fmap (fmap (uncurry EnvT) . distProd . fmap duplicate . first extract)
    distProd p =
      let a = fst p
      in fmap (\b -> (a , b)) (snd p)
```
It even allows you to use a different comonad for each algebra.

                                                                                                                                                      Greg Pfeil @sellout@2017-12-10T16:23:14.748Z
Minor simplification: `fmap duplicate . first extract` → `(extract *** duplicate)`

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-12-10T21:38:56.219Z
@sellout wow! nice

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-12-10T21:39:47.461Z
@sellout this is should be `gmutu` or `gcomutu`?

                                                                                                                                                      Greg Pfeil @sellout@2017-12-10T21:41:20.092Z
gmutu … but it can be mechanically converted to gcomutu.

                                                                                                                                                      Greg Pfeil @sellout@2017-12-10T21:41:53.294Z
I started to do it, but then I decided it’d be better to teach GHC to do it.

                                                                                                                                                      Greg Pfeil @sellout@2017-12-10T21:42:16.099Z
I.e., `makeDualValue 'gmutu 'gcomutu`.

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-12-10T21:46:38.652Z
@sellout nice idea, about `makeDualValue`

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-12-10T23:07:23.518Z
@sellout my small experiments for recursion schemes with gadts! https://gist.github.com/xgrommx/4c72ae9d407214deab55fe9aebc08b45 (PHOAS, HOAS,...)

                                                                                                                                                      Greg Pfeil @sellout@2017-12-11T16:33:13.757Z
@xgrommx 👍🏼

                                                                                                                                                      Valentin Kasas @vil1@2017-12-15T08:57:45.420Z
Hi there, long time no see

                                                                                                                                                      Valentin Kasas @vil1@2017-12-15T08:58:14.576Z
Seems like this as turned to an Haskell channel :)

                                                                                                                                                      Valentin Kasas @vil1@2017-12-15T09:03:58.266Z
I'm back with yet another not so smart question: I have two pattern functors `D` and `V` and I use an hylo to build an `EnvT[E, V, A]` out of a pair `(E, D)` (pretty standard so far) 

                                                                                                                                                      Valentin Kasas @vil1@2017-12-15T09:06:37.562Z
My problem is that `D` and `V` are (or should not be) isomorphic: some cases of `D` do not exist in `V`so in my coalgebra, I find myself wanting to consume multiple layers of `D` at once

                                                                                                                                                      Valentin Kasas @vil1@2017-12-15T09:07:44.467Z
but I don't know how to do that, so for now, I've just created "useless" cases in `V` so that it matches `D`'s structure and I simply ignore these cases in my algebra

                                                                                                                                                      Valentin Kasas @vil1@2017-12-15T09:08:42.563Z
I suspect there is a cleaner way to do that

                                                                                                                                                      Matija Folnovic @mfolnovic@2017-12-29T13:11:59.806Z
what would you recommend me to read / watch if I understand Fix and `cata` (and barely `ana`), but don't understand anything else?

                                                                                                                                                      Matija Folnovic @mfolnovic@2017-12-29T13:12:06.453Z
any Scala examples would be :ok_hand: 

                                                                                                                                                      Holothuroid @Holothuroid@2017-12-29T13:39:56.846Z
Hi everyone. I heard from several sources that recursion schemes combine in such a way that they can safe traversals. I'm interested how that works.

                                                                                                                                                      Matija Folnovic @mfolnovic@2017-12-29T13:53:25.679Z
@Holothuroid you might want to look at (6:44 - 8:54): https://youtu.be/IlvJnkWH6CA?t=404

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-12-29T14:01:26.435Z
@mfolnovic my big list about RS https://github.com/xgrommx/awesome-functional-programming/blob/master/rsfa.md

                                                                                                                                                      Matija Folnovic @mfolnovic@2017-12-29T14:03:54.442Z
@xgrommx my google-fu was weak, tnx! :blush:

                                                                                                                                                      Greg Pfeil @sellout@2017-12-29T14:13:11.631Z
@Holothuroid RS definitely provide safer tree traversals than doing direct recursion – it handles the recursion automatically, so you can’t accidentally miss cases, and you only have to reason about one node at a time. However, it’s still hard to ensure that RS are total (e.g., not letting you fold an infinite stream). I now have a total implementation in Idris to help guide my hand a bit, but it’s not a perfect mapping (especially with Haskell, because laziness).

                                                                                                                                                      Holothuroid @Holothuroid@2017-12-29T14:31:20.079Z
@mfolnovic That very talk brought me here. At the end (42:00) Pawel says that recursion scheme are composable, so they are faster than traversing the AST every time. - How? What's the limitations? 

Say I have: `as.zip(bs).reduce(...).reduce(...)`

Will Matryoshka automatically combine the last two Catamorphisms, when I call `.cata{...}.cata{...}`? Do I have to call that optimisation explicitely? Is such optimisation possible with other *morphisms? Between different types`?

                                                                                                                                                      Greg Pfeil @sellout@2017-12-29T14:34:04.044Z
@Holothuroid Currently you don’t get that kind of fusion automatically from Matryoshka, but can do it manually like `.cata(f).cata(g)` -> `.cata(f >>> project >>> g)` (although you’ll probably have to annotate types or do `.cata(x => g(f(x).project))` or something).

                                                                                                                                                      Greg Pfeil @sellout@2017-12-29T14:35:43.464Z
And yes, you can apply that in many cases. The most well known cases first unfold then fold – `.ana(f).cata(g)` -> `.hylo(g, f)`, and yes, that works with other morphisms like `histo`, `zygo`, whatever.

                                                                                                                                                      Greg Pfeil @sellout@2017-12-29T14:37:15.190Z
`cata` (and `ana`) is fully general – if you look at the code, you’ll see that things like `histo` are implemented in terms of `gcata`, and `gcata` is implemented in terms of `cata`. So, not that you’d want to do it manually, but any fold can be written using only `cata` for recursion.

                                                                                                                                                      Greg Pfeil @sellout@2017-12-29T14:40:49.506Z
@Holothuroid I would love to see some macros that handle those rewrites, even just a tiny subset of them, automatically.

                                                                                                                                                      Holothuroid @Holothuroid@2017-12-29T14:44:11.021Z
Thank you. That helps. What type does `.project`belong to?

                                                                                                                                                      Greg Pfeil @sellout@2017-12-29T14:44:27.650Z
It’s a method on the `Recursive` type class.

                                                                                                                                                      Greg Pfeil @sellout@2017-12-29T14:44:45.730Z
Roughly `Fix[F] => F[Fix[F]]`.

                                                                                                                                                      Holothuroid @Holothuroid@2017-12-29T14:45:43.136Z
Cool. Thanks.

                                                                                                                                                      Greg Pfeil @sellout@2017-12-29T14:47:48.598Z
I find that I often write natural transformations, `F ~> G`, and then it’s really easy to compose them, as they can be used in both folds and unfolds. So whenever you have a 1:1 mapping, `~>` is the way to go. `.cata(natTrans >>> embed).cata(alg)`, and since `embed` is the dual of `project` that becomes `.cata(natTrans >>> alg)`

                                                                                                                                                      Denis Stoyanov @xgrommx@2017-12-29T14:59:02.675Z
https://twitter.com/xgrommx/status/861913282541740036

                                                                                                                                                      Matija Folnovic @mfolnovic@2017-12-30T16:16:56.302Z
> The .embed calls in someExpr wrap the nodes in the fixed point type. embed is generic, and we abstract someExpr over the fixed point type (only requiring that it has an instance of Corecursive), so **we can postpone the choice of the fixed point as long as possible**.

bolded part, why?

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-01T12:01:08.573Z
Hi everyone, I've just started playing around with matryoshka and I think I might need a hand from someone with a bit more knowledge than me :)

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-01T12:01:54.262Z
I'm trying to parse a hierarchy of case classes from json, but I'd like to have the resulting tree annotated 

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-01T12:01:59.724Z
Basically like a merkle tree

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-01T12:02:49.805Z
I was thinking I could just use argonauts optionDecoder which seems to work fine with something like an anaM

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-01T12:03:19.996Z
I then want to use a histo to annotate the nodes with the hash of the children

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-01T12:04:01.766Z
The problem seems to be when I want to combine these two, I think I need something like dynaM, but there's only a dyna

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-01T12:04:12.065Z
Maybe there's an easier way to do this?

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T12:10:00.709Z
@freskog whenever someone talks about annotating a structure, I tend to think about https://github.com/slamdata/matryoshka/blob/master/core/shared/src/main/scala/matryoshka/patterns/EnvT.scala

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T12:17:31.234Z
let say you have a pattern functor `JsonF`, and a `Hash` type, you can build an `T[EnvT[Hash, JsonF, ?]]` from a `T[JsonF]` quite easily (`T` being your fix point of choice)

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T12:21:44.995Z
which leads to @mfolnovic's question: postponing choices is always a good practice in FP. When you abstract over the fix-point type, and defer the choice, it allows you to, for example, use `Fix` for tests and debugging (`Fix` is easy to print but not stack-safe) and to use `Mu` or `Nu`for production code 

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T12:44:35.689Z
(back to @freskog's problem), the cool thing is that given a `T` with the proper `Corecursive` instance, you can write an `AlgebraM[Option, JsonF, T[EnvT[Hash, JsonF, ?]]]` so you can use `hyloM` with `optionDecoder` and this algebraM and obtain your simili-merkle tree

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-01T13:18:26.273Z
Ah, interesting!

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-01T15:09:11.484Z
Out of curiosity, it seems like using EnvT is solving the same problem as histo

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-01T15:09:14.081Z
is that correct?

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T15:56:27.011Z
I might not be the best person to ask that (I'm still a n00b here), but I think histo solves a more general problem

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T15:59:26.657Z
In other words, you could rewrite any fold+EnvT into an histo, but not the other way around

                                                                                                                                                      Greg Pfeil @sellout@2018-01-01T16:05:19.778Z
@freskog histo doesn’t give you an annotated tree, but rather uses annotations _while folding_ to give you access to intermediate results of the fold. @vil1’s suggestion is the right path to pursue.

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T16:06:53.414Z
G

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T16:07:29.058Z
(damned phone)

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T16:09:30.375Z
FWIW I've been fiddling with Matryoshka for roughly a year now and I am yet to find a problem that needs more than a cata/ana/hylo

                                                                                                                                                      Greg Pfeil @sellout@2018-01-01T16:17:14.916Z
Yeah, on my phone here, too.

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T16:21:58.778Z
BTW @sellout, how do I consume multiple layers of a structure at once during a fold ?

                                                                                                                                                      Greg Pfeil @sellout@2018-01-01T16:22:49.328Z
@vil1 Technically nothing requires more than those three 😎 but I get your point

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T16:23:13.405Z
I refold a functor `D`into another functor `E` (both ADTs) but some cases of `D` do not exist in `E`

                                                                                                                                                      Daniel Porter @DanielPorter@2018-01-01T16:24:18.083Z
@freskog i have a gist that shows doing some nonsense annotations using cata and ana.  https://gist.github.com/DanielPorter/460ff5e4c5246ef680e053d95bd5a010

                                                                                                                                                      Daniel Porter @DanielPorter@2018-01-01T16:24:26.744Z
lines 170-184

                                                                                                                                                      Daniel Porter @DanielPorter@2018-01-01T16:24:29.127Z
the naming is awful, but it does compile :)

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T16:24:49.773Z
`map[_, B]`?

                                                                                                                                                      Greg Pfeil @sellout@2018-01-01T16:24:54.194Z
@vil1 I think I need my laptop, but probably histo with Maybe in the carrier (not histoM)

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T16:25:04.651Z
currently I just add "useless" cases in `E` so that it matches `D`'s structure and ignores these cases when I fold `E` but that looks bad 

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T16:25:26.610Z
@sellout I'd probably add `Fix[D] Either ?` to the carrier instead

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T16:27:59.486Z
(@freskog, @DanielPorter I have some too : https://github.com/ScalaIO/pear/blob/master/core/src/main/scala/pear/form/package.scala, and it is also the problem I have with my `D`s and `E`s)

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T16:28:25.194Z
@sellout, @edmundnoble : I'll dig that, thx

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T16:29:43.590Z
I would also probably not use `State` to accumulate errors

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T16:29:54.905Z
Because by definition you *must* lose type-safety

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T16:30:34.343Z
I don't follow you there

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T16:31:14.333Z
If you use `State` to accumulate errors that means you can keep processing even after you've reached an error

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T16:31:34.587Z
And if you've reached an error and you needed the result that instead gave you an error to proceed

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T16:31:52.905Z
You have to return some *fake* result for upstream to deal with

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T16:32:23.904Z
that's right, I usually return `ValueNull` upon error

                                                                                                                                                      Greg Pfeil @sellout@2018-01-01T16:32:28.217Z
@edmundnoble Yeah, I just meant “some failure”.

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T16:32:41.030Z
Right, I consider that to be a hack

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T16:32:59.682Z
You're including the effects of your traversal *inside the output AST itself*

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T16:33:06.193Z
which is fine IMO, at the end I return a well formed result or all the errors I envountered

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T16:33:26.959Z
If you want sane error accumulation that isn't actually inside the output AST you should just use `Either`

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T16:33:41.050Z
OK I see your point now

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T16:35:03.660Z
but I use `Either` (or `\/`) as my carrier monad, I'll fail on the first error

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T16:35:26.239Z
and I want to simulate a `Validation`, hence collect all possible errors

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T16:36:34.223Z
Right, this is a good point, you can overcome it though

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T16:36:42.857Z
One possibility is not to use `hyloM` or `cataM`

                                                                                                                                                      Greg Pfeil @sellout@2018-01-01T16:36:57.739Z
Yeah, don’t use hyloM – include `Either` in the carrier itself.

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T16:36:58.377Z
You can do the `toValidation` followed by the `Applicative` calls yourself then, and you're in the clear

                                                                                                                                                      Greg Pfeil @sellout@2018-01-01T16:37:53.827Z
`Algebra D Either[Fix[D], Fix[E]]`

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T16:38:06.203Z
hmm

                                                                                                                                                      Greg Pfeil @sellout@2018-01-01T16:38:24.085Z
Well … GAlgebra, with the Cofree in there.

                                                                                                                                                      Greg Pfeil @sellout@2018-01-01T16:39:02.683Z
Or use Validation directly instead, that’s fine. The thing is, if you’re passing over some intermediate results, those Lefts might never actually be in the result.

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T16:39:29.099Z
Oh, are the only errors values of type `Fix[D]` that couldn't be translated to `E`?

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T16:40:01.284Z
nope, that's something else

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T16:42:40.953Z
Right yeah, `Either[NonEmptyList[Error], ?]` wrapped around your algebra's `A` should suffice

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T16:43:06.761Z
anyway, you both provided me with good leads (as usual ^^), I need to tinker a little bit on that

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T16:45:10.272Z
having to pattern match on a Either at each case of my algebra might fell a little bit clumsy, but it'll help simplify my ADTs so the end result might indeed be clearer

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T16:45:20.789Z
Oh you don't need to do that

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T16:45:38.231Z
You make a `flatMap` or `Applicative.mapN` followed by `.toValidation` call

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T16:47:44.032Z
hmm right, `Applicative.mapN` it is then (to be able to accumulate errors)

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T16:48:05.415Z
Exactly

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T16:49:01.416Z
so, lets get to work!

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-01T16:49:30.251Z
Thanks for you help, I have my "merkle" tree now

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-01T16:49:44.049Z
I just need to figure out how to write an efficient merge :)

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-01T16:50:17.890Z
I'm looking at paraMerga but I can't say I understand it

                                                                                                                                                      Valentin Kasas @vil1@2018-01-01T16:51:06.419Z
^^ welcome to the club buddy

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-01T16:51:34.785Z
I suspect that's there's probably another way of doing it that makes more sense

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T16:52:56.399Z
@freskog I might suggest doing it in the simplest way you can think of first, potentially without even using recursion schemes, then factoring it down

                                                                                                                                                      Greg Pfeil @sellout@2018-01-01T17:05:06.322Z
@freskog paraMerga is definitely one of the weakest points of the library 😝

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-01T20:04:05.031Z
I have (simplified):
```scala
trait Root[E, M]
case class Expr[E, M](metadata: M, next: Option[E])
case class Loop[E, M](metadata: M, next: Option[E])
```

and I have defined a `scalaz.Functor[Root[?, M]]` for this, but I get `value cata is not a member of Root`

from my debugging, I realized `toRecursiveOps[Fix[Root[?, M]], Root[?, M]](x)` doesn't work because:
`could not find implicit value for parameter tc: matryoshka.Recursive.Aux[matryoshka.data.Fix[[α$30$]Root[α$30$,M]],[α$31$]Root[α$31$,M]]`

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-01T20:04:13.729Z
how can I make this to compile? :(

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T20:04:32.694Z
You'll have to reverse the type parameters.

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T20:04:40.196Z
Are you familiar with SI-2712, or partial unification?

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-01T20:04:54.278Z
only heard of it, but didn't understand what's going on there...

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T20:05:04.455Z
Right, SI-2712 is what lets you have a functor for `Either[E, ?]`.

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T20:05:14.317Z
It can't possibly let you have a functor for `Either[?, E]`.

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-01T20:05:31.164Z
oh, never realized order is important

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-01T20:05:36.056Z
thanks, I'll try that!

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T20:05:38.767Z
Welcome :)

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-01T20:13:27.155Z
yep, it works, thanks again :)

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-01T20:13:34.984Z
Good to hear :)

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-01T20:13:53.818Z
well, at least it compiles, can't run it yet :joy: 

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T12:37:01.410Z
hello! could someone explain to me pros & cons for having both `TreeF[_]` and `Tree` and what `Birecursive` is? :angel:

                                                                                                                                                      Valentin Kasas @vil1@2018-01-02T12:47:26.361Z
Tree is easy to build manually. And if you have a Birecursive it means that you can use/return a Tree wherever a TreeF is needed

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T12:48:56.627Z
hmm, would it also work if I returned `Tree` in my algebra (instead of `Fix[TreeF]`) ?

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T12:49:26.666Z
or better, do you know of any example showing this?

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T12:49:45.416Z
my google-fu isn't working on matryoshka :sweat_smile: 

                                                                                                                                                      Valentin Kasas @vil1@2018-01-02T13:00:38.897Z
I think so

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T13:04:57.558Z
thanks! :blush: 

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T13:05:08.435Z
aaand about example, do you know of any? :blush:

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T13:05:26.203Z
not sure if impatient or missed my other question

                                                                                                                                                      Valentin Kasas @vil1@2018-01-02T13:07:58.478Z
I think I missed it 😓

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T13:08:23.852Z
:angel:

                                                                                                                                                      Valentin Kasas @vil1@2018-01-02T13:08:52.884Z
I'm afk right now but I 'lol be back soon

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T13:09:04.888Z
okay, thanks :)

                                                                                                                                                      Valentin Kasas @vil1@2018-01-02T13:13:16.171Z
Meanwhile you can look the signatures in `IdOps`

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T13:16:02.707Z
:thumbsup: 

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T14:39:17.531Z
for some reason, I need to explicitly forward a `Functor` instance, e.g.

```scala
val tree: Fix[NodeF[Int, Int, ?]] = ...

implicit def functor[A, B] = new Functor[NodeF[A, B, ?]] {
  ...
}

tree.cata(algebra) // doesn't work

tree.cata(algebra)(functor) // works
```

                                                                                                                                                      Greg Pfeil @sellout@2018-01-02T14:40:07.282Z
@mfolnovic What’s your algebra?

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T14:41:14.177Z
`val algebra: Algebra[NodeF[Expr, Nothing, ?], Fix[NodeF[Expr, Nothing]]] = ...`

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T14:41:42.104Z
but I don't think it's connected to algebra, this also happens with `embed` / `project`, e.g.: `tree.project(functor).embed(functor)`

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T14:42:09.665Z
(I'm trying to experiment with my instance of `Birecursive` for `NodeF` / `Node`)

                                                                                                                                                      Greg Pfeil @sellout@2018-01-02T14:42:15.990Z
What error do you get?

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T14:43:02.506Z
`could not find implicit value for parameter BF: scalaz.Functor[[Node]NodeF[Int,Int,Node]]`

                                                                                                                                                      Greg Pfeil @sellout@2018-01-02T14:43:20.138Z
So … you might have _multiple_ `Functor` instances for `NodeF`?

                                                                                                                                                      Greg Pfeil @sellout@2018-01-02T14:43:34.415Z
(sometimes scalac gets confused and thinks ambiguous instances are no instances)

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T14:43:51.055Z
hmmm, is there a way I could debug that in IDEA ?

                                                                                                                                                      Greg Pfeil @sellout@2018-01-02T14:44:15.762Z
I haven’t used it, so I dunno.

                                                                                                                                                      Greg Pfeil @sellout@2018-01-02T14:44:27.280Z
But try commenting out the one instance you can see.

                                                                                                                                                      Greg Pfeil @sellout@2018-01-02T14:45:13.501Z
I’ve also had cases where an instance has been hidden by another value with the same name, perhaps from another import, and that is _hella_ confusing.

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T14:46:16.370Z
commenting out doesn't help, I name all functors the same, so let me try to rename it

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T14:48:40.472Z
hmm that also doesn't help... :(

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T14:49:23.878Z
is it possible it can't handle `implicit def functor[A, B]`, where it would need to infer `A =:= Int` and `B =:= Int` (in my first example)?

                                                                                                                                                      Greg Pfeil @sellout@2018-01-02T14:51:13.897Z
I dunno – I’ve had functors at least that complicated before. You are compiling with `-Ypartial-unification`, right?

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T14:51:34.862Z
I tried:
`implicit val fc = functor[Int, Int]`
before calling `cata` and it works without passing a `Functor`

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T14:51:48.285Z
yep, I am

                                                                                                                                                      Greg Pfeil @sellout@2018-01-02T14:53:51.130Z
@mfolnovic You might fare better in a Scalaz channel or #typelevel/general, or something.

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T14:53:52.286Z
at least I know it should work, I'll figure it out, tnx! :)

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T14:54:02.359Z
true, tnx!

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T15:51:33.803Z
another question, I've defined `Birecursive` for my `NodeF[_]` / `Node`. how would I go from converting `Fix[NodeF]` to `Node` ?

                                                                                                                                                      Valentin Kasas @vil1@2018-01-02T17:01:57.506Z
Things have a little diverged and I am still afk. tek/slain 

                                                                                                                                                      Valentin Kasas @vil1@2018-01-02T17:02:06.131Z
Arrrr

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T17:02:46.081Z
hah, it's fine :)

                                                                                                                                                      Valentin Kasas @vil1@2018-01-02T17:02:58.203Z
github.com/tek/splain might help debugging implicit resolution

                                                                                                                                                      Greg Pfeil @sellout@2018-01-02T17:04:33.334Z
@mfolnovic `tree.convertTo[Node]` – which is just a nice name for `tree.cata[Node](_.embed)`

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T17:08:06.193Z
oh, nice, tnx!

                                                                                                                                                      Greg Pfeil @sellout@2018-01-02T17:08:38.498Z
But … you should be able to just generate Node directly anywhere you generate Fix[NodeF].

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T17:09:06.062Z
what do you mean?

                                                                                                                                                      Greg Pfeil @sellout@2018-01-02T17:10:04.264Z
if you’re doing something like `x.ana[Fix[NodeF]](coalg)`, you should be able to just do `x.ana[Node](coalg)` and have it work.

                                                                                                                                                      Greg Pfeil @sellout@2018-01-02T17:10:10.430Z
Or any other operation.

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T17:11:23.364Z
wait, and `x` can be of type `Node` ?

                                                                                                                                                      Greg Pfeil @sellout@2018-01-02T17:11:37.827Z
No.

                                                                                                                                                      Greg Pfeil @sellout@2018-01-02T17:11:49.441Z
Show me where you use `Fix[NodeF]`.

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T17:16:28.361Z
I'm not exactly sure what you mean... but since I get type mismatch when I inject my `Birecursive` directly, I've probably defined it wrong so I'm debugging that

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-02T17:16:54.712Z
What actually is `Node`? 

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T17:17:01.154Z
but just out of curiosity, when I generate my instance from input, should I generate `Fix[NodeF]` or `Node` ?

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T17:18:22.704Z
simplified, something like:
```
sealed trait Node[Expr, +Info]
case class ExprNode[Expr, +Info](expr: Expr, info: Info) extends Node
case class WhileLoopNode[Expr, +Info](condition: Expr, body: Node, info: Info) extends Node
etc.
```

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-02T17:19:57.877Z
Why does `Node` exist when you have `Fix[NodeF]`?

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T17:21:07.400Z
and my `Birecursive` is:

```scala
  implicit def birecursive[Expr, Info]: Birecursive[Node[Expr, Info]] =
    new Birecursive[Node[Expr, Info]] {
      private type N = Node[Expr, Info]

      override type Base[A] = NodeF[Expr, Info, A]

      override def project(t: N)(implicit BF: Functor[Base[?]]): Base[N] = t match {
        case ExprNode(expr, info) => ExprNodeF(expr, info)
      }

      override def embed(t: Base[N])(implicit BF: Functor[Base[?]]): N = t match {
        case ExprNodeF(expr, info) => ExprNode(expr, info)
      }
    }
```

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T17:22:31.880Z
well, atm I'm just experimenting with this, seeing if it'll help my issue with pattern matching and building DSL

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-02T17:25:01.120Z
What version of Scala are you running?

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T17:25:15.674Z
oook, it works with:
```scala
  implicit def birecursive[Expr, Info] =
    Birecursive.algebraIso[Node[Expr, Info], NodeF[Expr, Info, ?]](
      {
        case ExprNodeF(expr, next, info) => ExprNode(expr, next, info)
      }, {
        case ExprNode(expr, next, info) => ExprNodeF(expr, next, info)
      }
    )
```

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T17:25:20.827Z
2.12.4

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-02T17:25:49.341Z
Do you have  `-Ypartial-unification` in your compiler options?

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T17:26:13.634Z
I've defined it both in SBT and IDEA, so I hope so :(

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-02T17:26:29.088Z
Right, here's your issue

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-02T17:26:45.669Z
Look at the difference between the two of those

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-02T17:27:07.719Z
`def birecursive[Expr, Info] = ...` and `def birecursive[Expr, Info]: Birecursive[Node[Expr, Info]] = ...`

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-02T17:27:23.465Z
Your type annotation here is *forgetting the value of `Base`*

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T17:27:50.993Z
ooooh :facepalm:

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-02T17:27:55.357Z
tnx!

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-02T17:28:04.726Z
You're welcome, so the solution here is to use `Birecursive.Aux`

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T13:11:21.937Z
continuing from yesterday, I'm trying to define `def transform[T, F[_]](x: T)(f: T => T)(implicit BC: Birecursive[T, F], F: Functor[F]): T): T`  that would be basically `cata` but for `Node => Node` instead of `Fix[NodeF] => Fix[NodeF]`

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T13:11:49.074Z
this is my first attempt, but isn't even close to compiling... I'm quite confused about `Birecursive` here...:

```scala
    implicit class AnyOps[T, F[_]](x: T) {
      def transform(f: PartialFunction[T, T])(
          implicit
          BC: Birecursive.Aux[T, F],
          F: scalaz.Functor[F],
      ): T = {
        val transformed =
          BC.cata[Fix[F]](x) {
            case x: F[Fix[F]] =>
              val embedded = BC.embed(x)
              val value = f.lift(embedded).getOrElse(embedded)
              val projected = BC.project(value)
              Fix(projected)
          }

        BC.embed(transformed.unFix)
      }
    }
```

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T13:15:23.287Z
hmm this compiles, though haven't tested if it works yet:
```scala
BC.cata[T](x) { x =>
  val embedded = BC.embed(x)
  f.lift(embedded).getOrElse(embedded)
}
```

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T14:07:13.850Z
@mfolnovic Look for `transCataT` … I think that still exists.

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T14:08:14.841Z
wow, tnx!

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T15:07:31.598Z
another question :angel: 

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T15:08:06.340Z
cata, but with state from previous element?

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T15:08:12.256Z
and of course, initial state...

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T15:09:02.807Z
e.g. `Cons(5, Cons(9, Nil))`, and let's say I want to increment first by 1, second by 2 etc.

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T15:09:57.153Z
and another, I assume trickier requirement... I would need to do that from both sides, so the other side would be: increment last by 1, second from last by 2 etc.

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T15:14:30.034Z
Well, the second one is easier … that’s just `cataM`. You might be able to avoid a hylo with something like `incrAlg :: AlgebraM[State[Int, ?], ListF[Int, ?], Int -> Int]`, then do `list.cataM(incrAlg).eval(1)(1)`.

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T15:16:32.988Z
hmm, it says:
`type AlgebraM[M[_], F[_], A] = F[A] => M[A]`

which looks like I wouldn't receive the state in my algebra? or I'm misunderstanding something? :(

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T15:17:39.827Z
To unpack that a bit … `State` is for the tail->head state, and `Int ->` is for the head->tail state (that is a bit of an attribute grammar trick for passing state up toward the leaves, even though you’re folding down toward the root). Then `cataM(incrAlg)` returns `State[Int, Int -> Int]`, so `.eval(1)` passes the tail->head initial state, and the second `(1)` applies the final `Int -> Int` function .

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T15:18:10.461Z
@mfolnovic Are you familiar with the State monad?

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T15:20:01.486Z
just in case, either I'm totally misreading what you are saying or you misunderstood me :) what I'd like to do is, receive a List, and based on some logic, choose if I'm going to increment it from last element or from first one, so something like:

`def increment(list: Fix[ListF], direction: Direction): Fix[ListF] = ???`

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T15:20:27.691Z
@mfolnovic What it effectively does is delay the processing, returning a function where you pass the initial state, and it applies that through all the nested state values. So `State[A, B]` is really `A -> (A, B)`, “given some initial state value, return a new state value and the result that required that state”.

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T15:20:30.299Z
hmm, I'm familiar and I guess I understand it, though haven't used it yet

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T15:21:30.475Z
ooh, I think I understand

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T15:22:06.124Z
I should have made this example with different types, it's kinda hard to differentiate `Int` between a value from list and state

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T15:23:18.600Z
Yeah, you should be able to do that `increment` approach with that type – What you’ll effectively return from the algebra is `Int -> Int -> Int`, where the first arg is the tail->head state, and the second is the head-to-tail state … actually, slight change …

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T15:23:49.170Z
Try `AlgebraM[State[Int, ?], ListF[Int, ?], State[Int, Int]]`.

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T15:24:48.251Z
ok, let me try to write all this on List example :)

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T15:25:45.929Z
Then you effectively return `Int -> (Int, Int -> (Int, Int)` … that’s a lot of `Int`s, but the first `Int -> (Int,` is the incoming and outgoing tail->head state and the second `Int -> (Int,` is the incoming and outgoing head->tail state, and the final `Int)` is the result.

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T15:26:14.419Z
But you don’t want the result to be Int … you want `List[Int]` … so `AlgebraM[State[Int, ?], ListF[Int, ?], State[Int, List[Int]]]`

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T15:26:18.834Z
*phew*

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T15:26:41.527Z
I haven’t done anything like that before, but I think it should work.

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T15:27:55.727Z
And to be clear, `Int -> (Int, List[Int])` isn’t literally what you have, but `State[Int, List[Int]]` is equivalent to that structure.

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T15:28:08.607Z
hah, I'm still kinda understanding this :)

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T15:30:54.373Z
@mfolnovic Then you’re doing better than me 😆

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T15:31:16.563Z
it doesn't look like that :P

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T15:41:10.029Z
`But you don’t want the result to be Int … you want List[Int] … ` didn't understand this? :(

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T15:57:07.371Z
@sellout I tried this, trying not do dig into State monad in Scalaz just yet, so:

```scala
  type Result = State[Int, Fix[ListF]]
  val incrementByState: AlgebraM[State[Int, ?], ListF[?], Result] = {
    case NilF() =>
      State[Int, Result] { incoming =>
        val result = State[Int, Fix[ListF]] { outgoing =>
          (outgoing + 1, Fix(NilF()))
        }

        (incoming + 1, result)
      }
    case ConsF(x, xs) =>
      State[Int, Result] { incoming =>
        val result = State[Int, Fix[ListF]] { outgoing =>
          (outgoing + 1, Fix(ConsF(x + incoming, ???)))
        }

        (incoming + 1, result)
      }
  }

  val result: State[Int, State[Int, Fix[ListF]]] = list.cataM(incrementByState)
  val (_, phase1)                                = result.apply(0)
  val (_, phase2)                                = phase1.apply(0)

  println(phase2)
```

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T15:57:24.088Z
but don't really know what I should put in `???`, since xs is of type `State[Int, Fix[ListF]]`

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T16:01:40.728Z
putting `xs.eval(outgoing)` there makes it work, `List(5, 9, 14) -> List(8, 11, 15)`

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T16:02:41.685Z
now just to figure out how to have `List(5, 9, 14) -> List(6, 11, 17)` ;)

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T16:03:07.818Z
You might want to start with different initial states (like `0` and `100` to make it clear you’re using the right one)

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T16:03:32.729Z
good point, tnx!

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T16:04:46.309Z
also changed:
```scala
  val (phase1State, phase1)                      = result.apply(0)
  val (phase2State, phase2)                      = phase1.apply(phase1State)
```

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T16:08:40.014Z
for some reason, `State[Int, Fix[ListF]] { outgoing =>` here, `outgoing` is always equal to what I give in `phase1.apply(...)`

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T16:08:49.196Z
Here’s something
```scala
val incrementByState: AlgebraM[State[Int, ?], ListF[?], State[Int, List[Int]]] = {
  case NilF() =>
    State(bottomUp => (bottomUp + 1, State(topDown => (topDown + 1, Nil))))
  case ConsF(x, xs) =>
    State(bottomUp =>
      (bottomUp + 1,
       State(topDown =>
         (topDown + 1,
          chooseDirection match {
            case BottomUp => (x + bottomUp) :: xs
            case TopDown => (x + topDown) :: xs
          }))))
}
```

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T16:09:12.709Z
So, `chooseDirection` returns which state you want to apply to that index.

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T16:11:19.591Z
`xs` is a `State[Int, List[Int]]`, so I guess you want to `eval` on that?

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T16:13:55.333Z
yeah, blindly changing yours to:
```scala
               case BottomUp => (x + bottomUp) :: xs.eval(bottomUp)
               case TopDown  => (x + topDown) :: xs.eval(topDown)
```

makes it behave same as mine, so I'm misunderstanding something here :(

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T16:26:21.926Z
Oh, whoops … 

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T16:26:27.523Z
You don’t want to eval.

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T16:30:12.236Z
@mfolnovic
```scala
val incrementByState: AlgebraM[State[Int, ?], ListF[?], State[Int, List[Int]]] = {
  case NilF() =>
    State(bottomUp => (bottomUp + 1, State(topDown => (topDown + 1, Nil))))
  case ConsF(x, tdState) =>
    State(bottomUp =>
      (bottomUp + 1,
       tdState >>= (\xs =>
         State(topDown =>
           (topDown + 1,
            chooseDirection match {
              case BottomUp => (x + bottomUp) :: xs
              case TopDown => (x + topDown) :: xs
            })))))
}
```
So, the change there is that you have to use `>>=` (`flatMap`) to “combine” the state.

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T16:35:03.703Z
hm, with eval, I actually got it working with:
```scala
               case TopDown =>
                 (x + topDown) :: xs.eval(topDown + 1)
```

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T16:35:21.083Z
for some reason, I get same result with either `BottomUp` or `TopDown` with your code :|

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T16:35:43.256Z
what should initial states be?

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T16:36:19.138Z
Same as with your version … I’m sure I just did something silly. Sorry, trying to focus on both this and work, and failing :D

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T16:36:57.214Z
oh, sorry :(

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T16:37:18.813Z
and I actually changed both initial states to zero

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T16:39:24.194Z
```
input == List(5, 9, 6)

both initial states == 0:
TopDown: List(8, 11, 7)
BottomUp: List(8, 11, 7)

second initial state == first final state
TopDown: List(8, 11, 7)
BottomUp: List(12, 15, 11)
```

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T16:40:46.745Z
`12 == 5 + 3 + 4`, `15 == 9 + 2 + 4`, `11 = 6 + 1 + 4`

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T16:53:56.833Z
I understand why `eval` variant works, though it's also (hopefully unnecessarily) slow, but can't figure out how to make your variant work :/

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T17:03:20.625Z
I think it might be time to switch back to a Scalaz or Typelevel channel again :D Glad you have something that works now, though.

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T17:06:06.631Z
not sure if someone who doesn't understand `cataM` would figure out how this works :(

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T17:06:15.775Z
but thanks for all the help :)

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T17:09:37.679Z
True … I might get time to look at it more later. But I haven’t been trying to compile any of this or anything, so it’s very hand-wavy. Now that I’m not working in Scala, sbt and everything seem very out of reach :D

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T17:10:04.782Z
still amazing you came up with this without compiling :D

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-03T17:10:32.331Z
in the meantime, i'll try to write this same thing with normal recursion and without Fix and ask in Scalaz :)

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-03T19:12:18.594Z
Hi again, I've been trying to use the operation generalizeM from the AlgebraOps trait, but it doesn't seem to work the way I thought it does

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-03T19:13:09.438Z
I was expecting to be able to call it like (myAlgebra:Algebra[MyF,MyA]).generalizeM[Option]

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-03T19:13:43.829Z
but the above doesn't compile, I have the standard imports in scope, matryoshka._, matryoshka.implicits._ etc...

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-03T19:14:02.489Z
Is that expected?

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-03T19:14:11.740Z
or should it work as I thought?

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T19:14:33.926Z
@freskog Hrmm … that’s how I would expect it to work, too. What’s the error?

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-03T19:15:58.651Z
value generalizeM is not a member of matryoshka.Algebra[experiments.EntityF,scalaz.Cofree[experiments.EntityF,experiments.EntityF.Hash]]
[error]     optionDecoder[Cofree[EntityF,Hash]]( _.hyloM(merkleAlgebra.generalizeM[Option], entityDecoderCoalgebraM), "EntityF")


                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-03T19:18:27.446Z
when trying to compile 
optionDecoder[Cofree[EntityF,Hash]]( _.hyloM(merkleAlgebra.generalizeM[Option], entityDecoderCoalgebraM), "EntityF")

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-03T19:18:44.977Z
```optionDecoder[Cofree[EntityF,Hash]]( _.hyloM(merkleAlgebra.generalizeM[Option], entityDecoderCoalgebraM), "EntityF")```

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-03T19:19:31.126Z
if I change it to 
```optionDecoder[Cofree[EntityF,Hash]]( _.hyloM(merkleAlgebra andThen (Option(_)), entityDecoderCoalgebraM), "EntityF")```

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-03T19:19:34.641Z
it compiles 

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T19:21:11.947Z
Yeah … the whole point of `generalizeM` was to fix inference issues … I would prefer to write `merkleAlgebra >>> pure` anyway (or `andThen` if you like). So, if it’s not converting/inferring properly, then I would do what you’re doing.

                                                                                                                                                      Greg Pfeil @sellout@2018-01-03T19:21:16.772Z
Sorry about that :/

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-03T19:21:45.796Z
No worries, it's not a problem 

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-04T10:03:36.375Z
me again :joy: I defined my structure as (simplified):

```scala
case class Container(node: Node, info: Info)

sealed trait Node
case class ExprNode(expr: Expr) extends Node
case class WhileLoopNode(condition: Expr, body: Container) extends Node
```

which looks natural to me (?)

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-04T10:04:18.111Z
so I also tried to define:

```scala
case class ContainerF[T](node: T, info: Info)

sealed trait NodeF[T]
case class ExprNodeF[T](expr: Expr) extends NodeF[T]
case class WhileLoopNodeF[T](condition: Expr, body: T) extends NodeF[T]
```

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-04T10:04:51.040Z
which isn't really right I guess, because I can't enforce that `body` is always a `Container`, which makes sense to me?

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-04T10:05:28.005Z
so then I tried to define it as:

```scala
case class ContainerF[T](node: T, info: Info)

sealed trait NodeF[T]
case class ExprNodeF[T](expr: Expr) extends NodeF[T]
case class WhileLoopNodeF[T](condition: Expr, body: ContainerF[T]) extends NodeF[T]
```

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-04T10:08:07.818Z
but I'm having issues defining `Birecursive` ...

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-04T10:08:37.212Z
this is my attempt:

```scala
  implicit def containerBirecursive =
    Birecursive.algebraIso[Container, ContainerF[?]](
      {
        case ContainerF(node, info) => Container(node, info)
      }, {
        case Container(node, info)  => ContainerF(node, info)
      }
    )

  implicit def nodeBirecursive =
    Birecursive.algebraIso[Node, NodeF[?]](
      {
        case ExprNodeF(expr)                 => ExprNode(expr)
        case WhileLoopNodeF(condition, body) => WhileLoopNode(condition, body)
      }, {
        case ExprNode(expr)                 => ExprNodeF(expr)
        case WhileLoopNode(condition, body) => WhileLoopNodeF(condition, body)
      }
    )
```

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-04T10:10:56.281Z
errors:

```
[error] /home/mfolnovic/dev/projects/playground/src/Playground.scala:72: type mismatch;
[error]  found   : Playground.Container
[error]  required: Playground.Node
[error]                                                  ^
[error] /home/mfolnovic/dev/projects/playground/src/Playground.scala:74: type mismatch;
[error]  found   : Playground.Node
[error]  required: Playground.Container
[error]                                                  ^
[error] /home/mfolnovic/dev/projects/playground/src/Playground.scala:82: type mismatch;
[error]  found   : Playground.Node
[error]  required: Playground.Container
[error]                                                                          ^
[error] /home/mfolnovic/dev/projects/playground/src/Playground.scala:85: type mismatch;
[error]  found   : Playground.Container
[error]  required: Playground.Node
[error]                                                                          ^
```

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-04T10:28:36.922Z
I also tried doing something like: https://gist.github.com/mfolnovic/a66dba4fb7bdf1ab75b48f689109d81a

                                                                                                                                                      Greg Pfeil @sellout@2018-01-04T15:12:48.433Z
@mfolnovic Ok, yeah, you are entering dangerous waters … but I think there’s a way out for you.

                                                                                                                                                      Greg Pfeil @sellout@2018-01-04T15:14:09.456Z
“Mutual recursion” is when you have two structures that refer to each other, and you have to use something more akin to an HList to manage it – where at each recursive point, you have to indicate _which_ structure belongs there. It’s totally feasible, but hasn’t been integrated into Matryoshka (there is a PR, though).

                                                                                                                                                      Greg Pfeil @sellout@2018-01-04T15:14:56.911Z
However … in your case, it seems like you strictly alternate between the two types, which is good - it means the mutual part can be eliminated.

                                                                                                                                                      Greg Pfeil @sellout@2018-01-04T15:15:08.677Z
In two different ways, in your particular case.

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-04T15:15:44.752Z
in what two ways? :)

                                                                                                                                                      Greg Pfeil @sellout@2018-01-04T15:16:39.501Z
1. flatten the structure, something like `WhileLoopNodeF[T](condition: Expr, body: T, info: Info)`, eliminating Container

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-04T15:17:03.009Z
1. I actually had that, and I refactored it to this :joy: 

                                                                                                                                                      Greg Pfeil @sellout@2018-01-04T15:17:17.709Z
2. just eliminate the Birecursive instance for Container, and handle modifying the Container within the Node instance.

                                                                                                                                                      Greg Pfeil @sellout@2018-01-04T15:17:29.684Z
Ugh, Gitter doesn’t like me numbering things.

                                                                                                                                                      Greg Pfeil @sellout@2018-01-04T15:17:42.380Z
There’s also a third way, which is my favorite.

                                                                                                                                                      Greg Pfeil @sellout@2018-01-04T15:18:21.977Z
Eliminate `ContainerF`, and make your recursive structure `Fix[EnvT[Info, NodeF, ?]]`

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-04T15:18:43.873Z
in your second case, I'm actually having difficulty defining `Eq`

                                                                                                                                                      Greg Pfeil @sellout@2018-01-04T15:19:01.150Z
EnvT is basically a recursive tuple (which is what Cofree is – `type Cofree[F[_], A] = Fix[EnvT[A, F, ?]]`)

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-04T15:19:43.971Z
oh, let me look that into, tnx!

                                                                                                                                                      Greg Pfeil @sellout@2018-01-04T15:19:54.710Z
So you can annotate your structure with Info when you want it, and in other cases simply have `Fix[NodeF]` (or even treat the EnvT structure _as if_ it were `Fix[NodeF]` (ignoring the annotation without discarding it).

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-04T15:21:54.081Z
I had issues with diverging implicits (while defining `Eq` for `ContainerF`), but I just stumbled upon:

```scala
/** To avoid diverging implicits with fixed-point types, we need to defer the
  * lookup.
  */
trait Delay[F[_], G[_]] {
  def apply[A](fa: F[A]): F[G[A]]
}
```

                                                                                                                                                      Matija Folnovic @mfolnovic@2018-01-04T15:22:25.919Z
I'll play around both of those ideas and see which looks better in my case, thank you for your help, I really appreciate it! :blush: 

                                                                                                                                                      Greg Pfeil @sellout@2018-01-04T15:23:39.688Z
Yeah, `Delay` is definitely what you want for defining instances on functors. 👍🏼

                                                                                                                                                      Greg Pfeil @sellout@2018-01-04T15:23:46.488Z
No worries – glad to help.

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-04T19:32:24.567Z
I'm wondering if it's possible to compose multiple F-Algebras

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-04T19:33:08.026Z
Basically, imagine I have a bunch of rewrite rules like Algebra[F,Fix[F]] or something, and I want to chain them to one call of cata

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-04T19:34:01.244Z
like  someData.cata(alg1 compose alg2)

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-04T19:34:36.235Z
I haven't figured out how to do that yet (in such a way that it generalizes to an arbitrary amount of algebras)

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-04T19:34:39.945Z
Any tips?

                                                                                                                                                      Greg Pfeil @sellout@2018-01-04T19:39:43.118Z
@freskog Yep, definitely. The easiest way is if you can actually define one of the algebras as a natural transformation `F ~> F`. But even without that, you can do `alg2 . project . alg1` … but I also find sometimes it’s simpler to define a function `F[Fix[F]] -> F[Fix[F]]` (which Matryoshka calls a `Transform`) than an `Algebra` (by simpler, I mean that you are basically just doing `.embed` at the end of every case, so that you can just delete those and end up with a transform).  If you can do that, then you could do `alg2 . trans1` (where `trans1` is just `alg1` with all the trailing `.embed`s removed). Then you can also still use `.cata(embed . trans1)`, but you don’t end up with an invisible `project . embed` isomorphism in your algebra.

                                                                                                                                                      Greg Pfeil @sellout@2018-01-04T19:39:46.108Z
Does that make sense?

                                                                                                                                                      Fredrik Skogberg @freskog@2018-01-04T19:48:35.791Z
Yeah, I just tried the EndoTransform

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T16:07:50.901Z
Hi guys. I have an AST with a node of the form `AndThen[A](lhs: A, rhs: A)`. I want to write a fold that evaluates this AST but semantically I need the result of the evaluation of `lhs` to evaluate `rhs`, so `cata` doesn't seem to be a viable option. Is there a scheme that allows that ?

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T17:10:47.387Z
Reading the cheat-sheet, `histo` is said to carry "the previous answers it has given".  So I suppose it might be worth trying, but I'm not sure how to use it yet

                                                                                                                                                      Greg Pfeil @sellout@2018-01-06T20:24:34.274Z
@vil1 para might do you better than histo – you get a pair of the original subtree and the result for that node, so you can ignore the lhs subtree and re-evaluate the rhs subtree the way you want.

                                                                                                                                                      Greg Pfeil @sellout@2018-01-06T20:27:06.245Z
Alternatively, an attribute grammar, where you fold to A => A, then you return exactly `rhs <<< lhs` for that node.

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T20:43:13.557Z
what is an attribute grammar ?

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T20:43:54.957Z
(I do not understand your second line at all :worried: )

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T20:47:31.902Z
With para, when it comes to a `AndThen` node, I'll receive a `(result, original)` pair for both `lhs` and `rhs`,  but in order to use the result from `lhs` in the evaluation of `rhs`, won't I need to fold again on `rhs`'s ``original` ?

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T20:54:45.145Z
`rhs <<< lhs` (as you might have guessed) is really what I want to achieve here (but https://en.wikipedia.org/wiki/Attribute_grammar doesn't help much)

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T20:55:10.280Z
I'd say just use `cata` and put a function in your carrier

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T20:56:20.321Z
I don't think I can do that. I want to be able to (de)serialize my carrier

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T20:56:32.141Z
Why???

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T20:57:11.968Z
Why do I want to serialize or why can't I put a function in it ?

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T20:57:16.544Z
Is your tree distributed between machines?

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T20:57:56.710Z
it will be stored in a database

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T20:58:03.465Z
Right but your carrier is transient

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T20:58:09.846Z
When your cata is done you get a function

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T20:58:13.445Z
You feed it your "starting" state

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T20:58:16.809Z
Now it's not a function anymore

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T20:58:25.987Z
You can store it any way you wish

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T20:58:51.670Z
but I want to store "the function" 

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T20:59:40.379Z
You want to store the output of interpreting your tree

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T20:59:46.542Z
concretely, my carrier represents a form definition (and embedded in it, the way I need to validate input), but this definition is data in my domain

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T21:00:27.155Z
Your carrier represents a form definition? Doesn't your tree represent the form definition?

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T21:00:36.277Z
Can you show code?

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:01:07.752Z
I think I don't understand what you call carrier (> <)'

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T21:01:17.556Z
`F[A] => A`

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T21:01:19.875Z
`A` is your carrier

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:01:23.565Z
ahhh

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:01:27.428Z
my bad

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T21:01:37.522Z
Ah okay now I think we understand each other :)

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:01:58.794Z
and I think my mind has blown, again

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T21:02:14.558Z
:fire: 

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:02:24.764Z
lemme scroll up a few line and read that again with that new perspective

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:04:10.507Z
(and ponder for a while)

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T21:04:16.946Z
:thinking:

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:07:14.923Z
so what you're saying is that I should `cata`to produce, say, a `Map[String, String] => ValidationResult`

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T21:07:25.249Z
Sure, something like that

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:10:55.993Z
it's worth a try

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:12:05.773Z
awesome if it works, since it means I'd need to fold the definition only once, and apply the resulting function for each input

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:13:28.421Z
but in the case of validation errors, I'll want to generate a tree (form) decorated with the errors (so that I can send back some HTML to the client)

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:13:52.955Z
I'll sure won't go to bed early tonite ^^

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T21:14:19.655Z
Maybe you need some kind of "path" type which represents how you can drill down from the top of the tree to the "current" leaf that you can return with errors

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:14:41.654Z
yep, I already have something like that

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T21:15:12.146Z
Yeah, just represent the "current" path as state in your algebra (as both an input and an output to the function) and away you go

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:15:14.427Z
I basically `ana` to a `EnvT[Path, Form, ...]`

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T21:15:34.509Z
Could do that too

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:16:32.930Z
more precisely, I have a Coalgebra that does that, so my Algebra will get a proper EnvT as input

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:16:56.852Z
sounds like a plan then

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T21:17:01.963Z
Could also put it into your algebra and avoid the ana call, if you prefer, but yeah

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:18:50.540Z
I don't call ana but hylo

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T21:18:57.921Z
Ah right

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:19:28.819Z
the coalgebra decorates the tree with the path, and the algebra ... is now to rewrite XD

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T21:19:38.320Z
Right I see

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:26:43.665Z
> did you have fun last Saturday night ?


                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:27:03.179Z
> you bet ! I wrote an `Algebra[EnvT[Path, FormF, ?], DecodedForm => Either[T[EnvT[Option[Error], FormF, ?]], FormValue]]`

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:37:48.863Z
BTW and **for the record**, @edmundnoble, @sellout, I owe you both an <insert your favorite beverage> for the patience you've shown with my questions and the wise answer you gave me in 1+ year of me trying to make sense of all that recursion stuff and I'm a man of my words, so I hope we'll meet someday

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T21:38:24.113Z
Hope so too, that'd be cool :)

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:43:05.767Z
Funnily enough, I've been convinced to submit a "Practical applications of recursion schemes" workshop to LC2018, if it's accepted we might meet in Boulder

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-06T21:43:22.564Z
Very likely

                                                                                                                                                      Valentin Kasas @vil1@2018-01-06T21:49:39.015Z
^^

                                                                                                                                                      Greg Pfeil @sellout@2018-01-07T04:09:13.633Z
👍🏾

                                                                                                                                                      Greg Pfeil @sellout@2018-01-07T04:11:17.982Z
@vil1 Sorry – I was skiing earlier. But “put a function in your carrier” == “fold to `A => A`” == attribute grammar.

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-07T04:11:30.002Z
Oh that's what an attribute grammar is!

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-07T04:11:40.015Z
I didn't get anything from the wiki page either :P

                                                                                                                                                      Greg Pfeil @sellout@2018-01-07T04:16:07.647Z
@edmundnoble I’m not sure I really understand them. Someone was explaining them to me one day, and I was like “oh, I think you can do that with recursion schemes by folding to a function” and the next day they sent me a link to something that agreed with me, so I’m satisfied.

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-07T04:16:48.561Z
"The synthesized attributes are the result of the attribute evaluation rules, and may also use the values of the inherited attributes. The inherited attributes are passed down from parent nodes."

                                                                                                                                                      Edmund Noble @edmundnoble@2018-01-07T04:16:57.596Z
This certainly sounds like something I can do with `A => A`

                                                                                                                                                      Greg Pfeil @sellout@2018-01-07T04:20:40.516Z
Still trying to figure out Löb, though 😄
